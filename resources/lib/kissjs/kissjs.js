/**
 * 
 * KissJS stands for **K**eep **I**t **S**imple **S**tupid **J**ava**S**cript
 * 
 * It's a simple javascript library to build web applications.
 * 
 * It includes:
 * - out-of-the-box [UI components](../../index.html#ui=start&section=components)
 * - a [powerful datatable](../../index.html#ui=start&section=datatable)
 * - a [calendar view](../../index.html#ui=start&section=calendar)
 * - a [kanban board](../../index.html#ui=start&section=kanban)
 * - a [timeline view](../../index.html#ui=start&section=timeline)
 * - a chart view
 * - a dashboard view
 * 
 * All these components have high performances when the number of records is heavy (> 10 000)
 * 
 * Bonus stuff:
 * - **view manager**, if you want to use KissJS not only for its UI Components, but also to build a complete application with multiple views
 * - **client router** which works 100% offline (even with file:/// paths)
 * - **pubsub** which is at the heart of the components reactivity
 * - **NoSQL database wrapper** which allows to work in memory, offline, or online
 * - **NoSQL ORM** to manage Models, Collections, Records, and automate the updates when records have relationships
 * 
 * A few recommandations:
 * - don't try to explore the API documentation directly: it's boring and uninteresting
 * - you'd rather [jump to the guide](../../index.html#ui=landing-page) which contains a few easy step by step tutorials
 * 
 * Here is an overview of what it provides:
 * 
 * <img src="../../resources/doc/KissJS - Overview.png">
 * 
 * @namespace
 */
const kiss = {

    $KissJS: "KissJS - Keep It Simple Stupid Javascript",

    // Build number
    version: 4240,

    // Tell isomorphic code we're on the client side
    isClient: true,

    /**
     * Reserved namespaces for kiss modules
     * 
     * @ignore
     */
    db: {},
    ux: {},
    doc: {},
    app: {},
    acl: {},
    ajax: {},
    cache: {},
    tools: {},
    views: {},
    theme: {},
    global: {},
    fields: {},
    screen: {},
    router: {},
    loader: {},
    pubsub: {},
    plugins: {},
    context: {},
    session: {},
    formula: {},
    undoRedo: {},
    webfonts: {},
    language: {},
    directory: {},
    selection: {},
    templates: {},
    websocket: {},
    loadingSpinner: {},

    // Utility classes/functions that are defined in their own files
    lib: {
        formula: {},
    },

    /**
     * Add client/server shared methods to a specific kiss module
     * 
     * @param {string} moduleName
     * @param {object} methods 
     * 
     * @example
     * kiss.addToModule("tools", {
     *  sayHello: function() {
     *      console.log("Hello")
     *  },
     *  sayGoodbye: () => console.log("Goodbye!")
     * })
     * 
     * kiss.tools.sayHello() // "Hello"
     * kiss.tools.sayGoodbye() // "Goodbye"
     */
    addToModule(moduleName, methods) {
        // console.log("kiss - Loading module into kiss: " + moduleName)
        Object.assign(kiss[moduleName], methods)
    },

    /**
     * KissJS ui layer is the heart and the initial purpose of the library.
     * It provides built-in UI components, which consists of:
     * 
     * ### Containers
     * - [kiss.ui.Block](kiss.ui.Block.html): basic container
     * - [kiss.ui.Panel](kiss.ui.Panel.html): container with a header and other properties that allow to create standard draggable windows and modal windows
     * - [kiss.ui.WizardPanel](kiss.ui.WizardPanel.html): panel where items are displayed one at a time (each wizard page) with helper buttons (next, previous) to navigate through the pages
     * 
     * ### Elements
     * - [kiss.ui.Button](kiss.ui.Button.html): standard clickable button with an icon
     * - [kiss.ui.Dialog](kiss.ui.Dialog.html): modal dialog box
     * - [kiss.ui.Html](kiss.ui.Html.html): component to insert html
     * - [kiss.ui.Image](kiss.ui.Image.html): component to insert an image
     * - [kiss.ui.Menu](kiss.ui.Menu.html): menu of clickable items with icons
     * - [kiss.ui.Notification](kiss.ui.Notification.html): notification which disappears automatically (toast message)
     * - [kiss.ui.Spacer](kiss.ui.Spacer.html): simple empty element used as a spacer in the layout
     * - [kiss.ui.Tip](kiss.ui.Tip.html): tip that follows the mouse cursor
     * 
     * ### Data components
     * - [kiss.ui.Datatable](kiss.ui.Datatable.html): powerful datatable
     * - [kiss.ui.Calendar](kiss.ui.Calendar.html): simple calendar
     * - [kiss.ui.Kanban](kiss.ui.Kanban.html): nice kanban with standard view setup (sort, filter, group, fields)
     * - [kiss.ui.Timeline](kiss.ui.Timeline.html): powerful timeline with standard view setup (sort, filter, group, fields) + options like color, period, and more
     * - [kiss.ui.ChartView](kiss.ui.ChartView.html): chart view (with setup) embedding a chart component
     * - [kiss.ui.Dashboard](kiss.ui.Dashboard.html): dashboard of multiple charts
     * 
     * ### Fields
     * - [kiss.ui.Field](kiss.ui.Field.html): text, textarea, number, date or time fields
     * - [kiss.ui.Checkbox](kiss.ui.Checkbox.html): checkbox with multiple design options
     * - [kiss.ui.Select](kiss.ui.Select.html): highly flexible field to select one or more options into a dropdown list
     * - [kiss.ui.Attachment](kiss.ui.Attachment.html): widget to manage file attachments
     * - [kiss.ui.Color](kiss.ui.Color.html): field to select a color
     * - [kiss.ui.ColorPicker](kiss.ui.ColorPicker.html): widget to pick a color
     * - [kiss.ui.Icon](kiss.ui.Icon.html): field to select an icon
     * - [kiss.ui.IconPicker](kiss.ui.IconPicker.html): widget to pick an icon
     * - [kiss.ui.Slider](kiss.ui.Slider.html): slider widget to select a number value
     * - [kiss.ui.Rating](kiss.ui.Rating.html): widget used for ranking and notation
     * 
     * **The ui layer is a work in progress and might change rapidly according to new project requirements.**
     * 
     * @namespace
     */
    ui: {},

    /**
     * KissJS ux is a set of Ui eXtensions that are too specific to be in the core ui library.
     * It constantly evolves with new projects and requirements, and currently consists of:
     * 
     * ### Fields
     * - [kiss.ux.AiImage](kiss.ux.AiImage.html): an attachment field connected to OpenAI to generate Dall-E images
     * - [kiss.ux.AiTextarea](kiss.ux.AiTextarea.html): a paragraph field connected to OpenAI to generate content
     * - [kiss.ux.CodeEditor](kiss.ux.CodeEditor.html): a field to write code, embedding the famous Ace Editor
     * - [kiss.ux.MapField](kiss.ux.MapField.html): a map with a text field to enter an address or geo coordinates. Uses OpenLayers internally.
     * - [kiss.ux.RichTextField](kiss.ux.RichTextField.html): a rich text editor to manage formatted text. Uses Quill internally.
     * - [kiss.ux.Directory](kiss.ux.Directory.html): a field to select people from the address book | Used in pickaform project
     * - [kiss.ux.Link](kiss.ux.Link.html): a link to connect records together and build relations in a NoSQL context | Used in pickaform project
     * - [kiss.ux.SelectViewColumn](kiss.ux.SelectViewColumn.html): dropdown list that allows to select values extracted from a datatable column | Used in pickaform project
     * - [kiss.ux.SelectViewColumns](kiss.ux.SelectViewColumns.html): field the allows to select a record in a view, and assign values to multiple fields at once | Used in pickaform project
     * 
     * ### Elements
     * - [kiss.ux.Map](kiss.ux.Map.html): a component to display a Map using OpenLayers
     * - [kiss.ux.Chart](kiss.ux.Chart.html): a component to display a Chart using Chart.js
     * - [kiss.ux.QrCode](kiss.ux.QrCode.html): a component to display a QRCode
     * 
     * @namespace
     */
    ux: {},

    /**
     * KissJS data layer provides a way to manage data locally and to proxy data from a KissJS server (or a REST server). It consists of:
     * - [kiss.data.Model](kiss.data.Model.html): to define your models
     * - [kiss.data.Collection](kiss.data.Collection.html): to store data according to your models
     * - [kiss.data.Record](kiss.data.RecordFactory-Record.html): to manipulate instances
     * - [kiss.data.Transaction](kiss.data.Transaction.html): to perform batch updates over multiple collections and multiple records
     * 
     * **The data layer is a work in progress and might change rapidly according to new project requirements.**
     * 
     * @namespace
     */
    data: {
        /**
         * See [Model documentation](kiss.data.Model.html).
         * 
         * @ignore
         */
        Model: {},

        /**
         * See [Collection documentation](kiss.data.Collection.html).
         * 
         * @ignore
         */
        Collection: {},

        /**
         * See [Record documentation](kiss.data.RecordFactory-Record.html).
         * 
         * @ignore
         */
        Record: {},

        /**
         * See [Transaction documentation](kiss.data.Transaction.html).
         * 
         * @ignore
         */
        Transaction: {},

        /**
         * See [trash documentation](kiss.data.trash.html).
         * 
         * @ignore
         */
        trash: {},

        /**
         * Add a method to all models
         * 
         * This method is useful to plug a method to all records after they are already instanciated.
         * 
         * A typical use case is when a plugin needs to add a global feature to all records.
         * We can call this method in the plugin initialization.
         * 
         * @param {string} methodName 
         * @param {function} method
         * 
         * @example
         * kiss.data.addMethodToAllModels("getFields", function() {
         *  return Object.keys(this).join(", ")
         * })
         * 
         * console.log(myRecord.getFields()) // "firstName, lastName, birthDate"
         * 
         */
        addMethodToAllModels(methodName, method) {
            Object.values(kiss.data.Record).forEach(recordClass => {
                recordClass.prototype[methodName] = method
            })
        },

        /**
         * Add a property to all models
         * 
         * This method is useful to plug a property to all records after they are already instanciated.
         * 
         * A typical use case is when a plugin needs to add a global feature to all records.
         * We can call this method in the plugin initialization.
         * 
         * @param {string} propertyName 
         * @param {function} getter - The getter function, which receives the instanciated record as input parameter
         * 
         * @example
         * // To add a property
         * kiss.data.addPropertyToAllModels("WORKFLOW_STEP", function(record) {
         *  return kiss.global.workflowSteps[record["workflow-stepId"]]
         * })
         * 
         * console.log(myRecord.WORKFLOW_STEP) // "Analysis"
         * 
         * // To add a property which has methods
         * kiss.data.addPropertyToAllModels("workflow", function(record) {
         *  return {
         *      start: function() {
         *          console.log("STARTING WORKFLOW...")
         *      },
         *      vote: function(recordId, stepId, decisionId, comment, actors) {
         *          console.log("VOTE FOR..." + recordId)
         *      }
         *  }
         * })
         * 
         * // Usage
         * myRecord.workflow.start()
         */
        addPropertyToAllModels(propertyName, getter) {
            Object.values(kiss.data.Record).forEach(recordClass => {
                Object.defineProperty(recordClass.prototype, propertyName, {
                    get: function () {
                        try {
                            return getter(this)
                        } catch (err) {
                            log("kiss.data.Model - addPropertyToAllModels", 4, err)
                            return "Formula error"
                        }
                    },
                    set: function (value) {
                        try {
                            this.value = value
                            //this[propertyName] = value
                        } catch (err) {
                            log("kiss.data.Model - addPropertyToAllModels", 4, err)
                        }
                    },
                    configurable: true
                })
            })
        }
    },

    /**
     * Load some .js and .css into the page header.
     * This is mainly used in development mode, when the library is not yet bundled and minified
     * 
     * @namespace
     */
    loader: {

        // List of KissJS core modules
        core: {
            scripts: [
                "modules/dataTrash",
                "modules/ajax",
                "modules/context",
                "modules/session",
                "modules/fields",
                "modules/acl",
                "modules/undoRedo",
                "modules/directory",
                "modules/pubsub",
                "modules/websocket",
                "modules/router",
                "modules/views",
                "modules/theme",
                "modules/language",
                "modules/language.texts",
                "modules/plugins",
                "modules/selection",
                "modules/screen",
                "modules/webfonts"
            ]
        },

        // List of KissJS db modules
        db: {
            scripts: [
                "db/offline",
                "db/memory",
                "db/online",
                "db/faker"
            ]
        },

        // List of KissJS models
        models: {
            scripts: [
                "account",
                "apiClient",
                "file",
                "group",
                "link",
                "trash",
                "user",
                "view"
            ]
        },

        // List of KissJS ui components
        ui: {
            scripts: [
                // Containers
                "containers/block",
                "containers/panel",
                "containers/wizardPanel",

                // Data
                "data/datatable",
                "data/calendar",
                "data/kanban",
                "data/timeline",
                "data/chartview",
                "data/dashboard",

                // Elements
                "elements/spacer",
                "elements/html",
                "elements/image",
                "elements/button",
                "elements/menu",
                "elements/tip",
                "elements/notification",
                "elements/dialog",

                // Fields
                "fields/field",
                "fields/checkbox",
                "fields/rating",
                "fields/slider",
                "fields/select",
                "fields/icon",
                "fields/iconPicker",
                "fields/color",
                "fields/colorPicker",
                "fields/attachment",

                // Form
                "form/form",
                "form/formTabBar",
                "form/formActions",
                "form/formSideBar",
                "form/formContent",
                "form/formFeatureDescription",

                // Helpers
                "helpers/data/dataFilter",
                "helpers/data/dataFilterGroup",
                "helpers/data/dataFilterWindow",
                "helpers/data/dataSort",
                "helpers/data/dataSortWindow",
                "helpers/data/dataFieldsWindow",
                "helpers/data/recordSelectionWindow",
                "helpers/files/fileUploadLocal",
                "helpers/files/fileUploadLink",
                "helpers/files/fileUploadDropbox",
                "helpers/files/fileUploadBox",
                "helpers/files/fileUploadGoogleDrive",
                "helpers/files/fileUploadOneDrive",
                "helpers/files/fileUploadInstagram",
                "helpers/files/fileUploadTakePhoto",
                "helpers/files/fileUploadinstagramSession",
                "helpers/files/fileUploadBoxSession",
                "helpers/files/fileUploadWebSearch",
                "helpers/files/fileUploadWindow",
                "helpers/files/filePreviewWindow",

                // Views
                "views/common/matrix",
                "views/authentication/error",
                "views/authentication/invite",
                "views/authentication/login",
                "views/authentication/register",
                "views/authentication/resetPassword",
                "views/authentication/templates"
            ],
            styles: [
                // Base
                "styles/base",
                "styles/colors/light",
                "styles/geometry/default",
                "styles/animations/animate",

                // Components
                "abstract/component",
                "abstract/dataComponent",
                "containers/block",
                "containers/panel",
                "data/datatable",
                "data/calendar",
                "data/kanban",
                "data/timeline",
                "data/chartview",
                "data/dashboard",
                "elements/button",
                "elements/html",
                "elements/image",
                "elements/menu",
                "elements/tip",
                "elements/notification",
                "elements/dialog",
                "fields/field",
                "fields/checkbox",
                "fields/rating",
                "fields/slider",
                "fields/select",
                "fields/icon",
                "fields/iconPicker",
                "fields/color",
                "fields/colorPicker",
                "fields/attachment",
                "form/form",
                "helpers/data/dataSort",
                "helpers/data/dataFilter",
                "helpers/data/dataFilterGroup",
                "helpers/data/dataFieldsWindow",
                "helpers/files/fileUpload",
                "helpers/files/filePreviewWindow",
                "views/authentication/styles"
            ]
        },

        // List of KissJS ux components
        ux: {
            scripts: [
                "aiImage/aiImage",
                "aiTextarea/aiTextarea",
                "chart/chart",
                "codeEditor/codeEditor",
                "directory/directory",
                "link/link",
                "map/map",
                "mapField/mapField",
                "qrcode/qrcode",
                "richTextField/richTextField",
                "selectViewColumn/selectViewColumn",
                "selectViewColumns/selectViewColumns"
            ],
            styles: [
                "codeEditor/codeEditor",
                "directory/directory",
                "link/link",
                "map/map",
                "mapField/mapField",
                "richTextField/richTextField"
            ]
        },

        /**
         * Load a script file asynchronously into the page.
         * 
         * @param {string} path - Provide the path to the javascript file, without the extension .js
         * @param {object} [config] - Optional object configuration
         * @param {object} [config.options] - Optional object to pass any custom attributes to the script tag, like id, data-*, defer, async...
         * @param {string|boolean} [config.autoAddExtension='.js'] - The extension to auto append to the path url. Default is '.js'. Set to false to disable it.
         * 
         * @example
         * kiss.loader
         *  .loadScript("views/common/topbar")
         *  .then(() => {
         *      console.log("Javascript file loaded!")
         *  })
         * 
         * // With options. This is equivalent to:
         * // <script async type="text/javascript" src="https://www.dropbox.com/static/api/2/dropins.js" id="dropboxjs" data-app-key="2tkajpbphy1m8dj"></script>
         * kiss.loader.loadScript("https://www.dropbox.com/static/api/2/dropins.js", {
         *  id: "dropboxjs",
         *  "data-app-key": "2tkajpbphy1m8dj"
         * })
         * 
         */
        loadScript(path, config = {}) {
            return new Promise(function (resolve, reject) {
                const script = document.createElement("script")
                script.type = "text/javascript"
                script.async = true

                const autoAddExtension = (config.autoAddExtension === false) ? "" : ".js"
                script.src = path + autoAddExtension + "?build=" + kiss.version
                
                if (config.options) {
                    Object.keys(config.options).forEach(key => {
                        script.setAttribute(key, config.options[key])
                    })
                }
                const head = document.getElementsByTagName("head")[0]
                head.appendChild(script)
                script.onload = resolve
                script.onerror = reject
            })
        },

        /**
         * Load a CSS file asynchronously into the page
         * 
         * @param {string} path - Provide the path to the CSS files, without the extension .css
         * 
         * @example
         * kiss.loader
         *  .loadStyle("views/common/topbar")
         *  .then(() => {
         *      console.log("CSS file loaded!")
         *  })
         */
        loadStyle(path) {
            return new Promise(function (resolve, reject) {
                const style = document.createElement("link")
                style.rel = "stylesheet"
                style.type = "text/css"
                style.async = true
                style.href = path + ".css?build=" + kiss.version
                const head = document.getElementsByTagName("head")[0]
                head.appendChild(style)
                style.onload = resolve
                style.onerror = reject
            })
        },

        /**
         * Load many scripts asynchronously and resolve Promise when all scripts are loaded
         * 
         * @param {string[]} paths - Array of javascript file paths to load, without .js extension
         * 
         * @example
         * kiss.loader
         *  .loadScripts([
         *      "views/common/topbar",
         *      "views/common/logo",
         *      "views/common/buy"
         *  ]).then(() => {
         *      console.log("All javascript files are loaded!")
         *  })
         */
        async loadScripts(paths) {
            await Promise.allSettled(paths.map(kiss.loader.loadScript))
        },

        /**
         * Load many styles asynchronously and resolve Promise when all styles are loaded
         * 
         * @param {string[]} paths - Array of CSS file paths to load, without .cess extension
         * 
         * @example
         * kiss.loader
         *  .loadStyles([
         *      "views/common/topbar",
         *      "views/common/logo",
         *      "views/common/buy"
         *  ]).then(() => {
         *      console.log("All CSS files are loaded!")
         *  })
         */
        async loadStyles(paths) {
            await Promise.allSettled(paths.map(kiss.loader.loadStyle))
        },

        /**
         * Load KissJS library dynamically from all its source files.
         * 
         * - In development, KissJS is a collection of javascript and css files that must loaded separately
         * - Ui eXtensions (UX) always need to be loaded manually and separately
         * - In production, KissJS is bundled and doesn't require to load modules dynamically
         * 
         * Please note that dynamic loading of libraries is a bit tricky and hacky:
         * - Because a librariy can depend on another one, they must be loaded in the right order
         * - KissJS uses this technic because the native browser module system doesn't support file:// path (and KissJS does)
         * - We couldn't use external dependencies (like requirejs, systemjs...) which don't work with file path (file://)
         * 
         * @param {object} config
         * @param {object} config.libraryPath - The path to the library root folder
         * @param {object} config.useDb - If false, load the library without the db/data related scripts (default is true)
         * @param {object} config.useUx - If false, load the library without the ui extensions (default is true).
         * @async
         */
        async loadLibrary(config) {
            const useDb = (config.useDb === false) ? false : true
            const useUx = (config.useUx === false) ? false : true
            const libraryPath = config.libraryPath || ""

            // Load the main app module
            await kiss.loader.loadScript(libraryPath + "/client/core/modules/app")

            // Load the base classes first, because some classes inherit from them
            await kiss.loader.loadScript(libraryPath + "/client/ui/abstract/component")
            await kiss.loader.loadScript(libraryPath + "/client/ui/abstract/container")
            await kiss.loader.loadScript(libraryPath + "/client/ui/abstract/dataComponent")

            // Load the database wrapper
            if (useDb) {
                await kiss.loader.loadScript(libraryPath + "/client/core/db/nedb")
                await kiss.loader.loadScript(libraryPath + "/client/core/db/api")
            }

            // Load global tools
            await kiss.loader.loadScript(libraryPath + "/client/core/modules/logger")
            await kiss.loader.loadScript(libraryPath + "/client/core/modules/tools")
            await kiss.loader.loadScript(libraryPath + "/client/core/modules/loadingSpinner")

            // Shared modules
            await kiss.loader.loadScript(libraryPath + "/common/global")
            await kiss.loader.loadScript(libraryPath + "/common/prototypes")
            await kiss.loader.loadScript(libraryPath + "/common/formula")
            await kiss.loader.loadScript(libraryPath + "/common/formulaParser")
            await kiss.loader.loadScript(libraryPath + "/common/formulaParserOperators")
            await kiss.loader.loadScript(libraryPath + "/common/tools")

            if (useDb) {
                await kiss.loader.loadScript(libraryPath + "/common/dataModel")
                await kiss.loader.loadScript(libraryPath + "/common/dataRecord")
                await kiss.loader.loadScript(libraryPath + "/common/dataCollection")
                await kiss.loader.loadScript(libraryPath + "/common/dataRelations")
                await kiss.loader.loadScript(libraryPath + "/common/dataTransaction")
            }

            // Load everything else
            const dbScripts = (useDb) ? kiss.loader.db.scripts.map(path => libraryPath + "/client/core/" + path) : []
            const coreScripts = kiss.loader.core.scripts.map(path => libraryPath + "/client/core/" + path)
            const uiScripts = kiss.loader.ui.scripts.map(path => libraryPath + "/client/ui/" + path)
            const styles = kiss.loader.ui.styles.map(path => libraryPath + "/client/ui/" + path)
            const models = kiss.loader.models.scripts.map(path => libraryPath + "/common/models/" + path)

            try {
                await Promise.all([
                    kiss.loader.loadScripts(dbScripts),
                    kiss.loader.loadScripts(coreScripts),
                    kiss.loader.loadScripts(uiScripts),
                    kiss.loader.loadScripts(models),
                    kiss.loader.loadStyles(styles)
                ])

                // Load ux scripts and styles
                if (useUx) {
                    const uxScripts = kiss.loader.ux.scripts.map(path => libraryPath + "/client/ux/" + path)
                    const uxStyles = kiss.loader.ux.styles.map(path => libraryPath + "/client/ux/" + path)

                    await Promise.all([
                        kiss.loader.loadScripts(uxScripts),
                        kiss.loader.loadStyles(uxStyles)
                    ])
                }

                // Immediately init language because every translations depends on it
                kiss.language.init()
            }
            catch (err) {
                console.log("kiss.loader - loadLibrary", 4, err)
            }
        }
    },

    /**
     * KissJS service worker.
     * Mainly used for PWA at the moment.
     * 
     * @namespace
     */
    serviceWorker: {
        /**
         * Default service worker file
         * 
         * @ignore
         */
        serviceWorkerFile: "./serviceWorker.js",

        /**
         * Set the location of the service worker file.
         * Returns the service worker so that this method is chainable with the init method.
         * 
         * @param {string} path 
         * @returns {object} kiss.serviceWorker
         * 
         * @example
         * await kiss.serviceWorker.setFile("./myServiceWorkerFile.js").init()
         */
        setFile(path) {
            if (!path) return
            kiss.serviceWorker.serviceWorkerFile = path
            return kiss.serviceWorker
        },

        /**
         * Init the service worker
         * 
         * @async
         */
        async init() {
            if ("serviceWorker" in navigator) {
                try {
                    const registration = await navigator.serviceWorker.register(kiss.serviceWorker.serviceWorkerFile)
                    log("kiss.serviceWorker - Registered with scope", 1, registration.scope)
                }
                catch(err) {
                    log("kiss.serviceWorker - Registration failed", 3, err)
                }
            }
        }
    }
}

;/**
 * 
 * ## NoSQL database wrapper API
 * 
 * - built to work seamlessly in memory, offline, or online
 * - if connected to KissJS server:
 *      - online mode pushes updates dynamically over all connected clients through WebSocket
 *      - field updates handle relationships with foreign records, and compute the required updates to keep data coherent
 * 
 * @namespace
 * @param {object} kiss.db.memory - In-memory database wrapper
 * @param {object} kiss.db.offline - Offline database wrapper
 * @param {object} kiss.db.online - Online database wrapper
 * 
 */
kiss.db = {

    // Reserved namespaces for database
    memory: {},
    offline: {},
    online: {},
    faker: {},

    /**
     * Database mode:
     * - online: persist data on the server - requires a connection
     * - offline: persist data on the client - no connection required
     * - memory: no persistence at all - a browser refresh flushes the data
     */
    mode: "online",

    /**
     * Set the datatabase mode
     * 
     * @param {string} mode - memory | offline | online
     * 
     * @example
     * // Setting offline mode
     * kiss.db.setMode("offline")
     */
    setMode(mode) {
        if (!mode) return
        if (mode != "memory" && mode != "offline" && mode != "online") return

        kiss.db.mode = mode

        // Align models and collections with the database mode
        for (modelId in kiss.app.models) {
            const model = kiss.app.models[modelId]
            model.mode = mode
            model.db = kiss.db[mode]
        }

        for (modelId in kiss.app.collections) {
            const collection = kiss.app.collections[modelId]
            collection.mode = mode
            collection.db = kiss.db[mode]
        }
    },

    /**
     * Insert one record in a collection
     * 
     * @async
     * @param {string} modelId
     * @param {object} record - A single record
     * @returns {object} The inserted record data
     * 
     * @example
     * let newUser = await kiss.db.insertOne("user", {firstName: "Bob", lastName: "Wilson"})
     * console.log(newUser) // returns {firstName: "Bob", lastName: "Wilson"}
     */
    async insertOne(modelId, record) {
        return await kiss.db[this.mode].insertOne(modelId, record)
    },

    /**
     * Insert many records in a collection
     * 
     * @async
     * @param {string} modelId
     * @param {object[]} records - An array of records [{...}, {...}] for bulk insert
     * @returns {object[]} The array of inserted records data
     * 
     * @example
     * let newUsers = await kiss.db.insertMany("user", [
     *      {firstName: "Will", lastName: "Smith"},
     *      {firstName: "Joe", lastName: "Dalton"},
     *      {firstName: "Albert", lastName: "Einstein"}
     * ])
     */
    async insertMany(modelId, records) {
        return await kiss.db[this.mode].insertMany(modelId, records)
    },

    /**
     * Insert some fake records in a collection, for testing purpose.
     * 
     * See [db.faker](kiss.db.faker.html) documentation for more details.
     * 
     * @async
     * @param {string} modelId - The target collection
     * @param {object[]} fields - Array of fields that defines the model
     * @param {integer} numberOfRecords - Number of fake records to insert
     * @returns {object[]} The array of inserted records data
     * 
     * @example
     * // Insert 100 products into the collection
     * await kiss.db.insertFakeRecords("product", [
     *  {primary: true, label: "Title", type: "text"},
     *  {label: "Release date", type: "date"}
     *  {label: "Category", type: "select", multiple: true, options: [{value: "Adventure", color: "#00aaee"}, {value: "Action", color: "#00eeaa"}]}
     *  {label: "Life time", type: "integer", min: 0, max: 5}
     * ], 100)
     */
    async insertFakeRecords(modelId, fields, numberOfRecords) {
        let records = kiss.db.faker.generate(fields, numberOfRecords)
        return await kiss.db[this.mode].insertMany(modelId, records)
    },

    /**
     * Delete all the fake records inserted using the method insertFakeRecords.
     * Other records remain untouched.
     * 
     * @async
     * @param {string} modelId - The target collection
     * 
     * @example
     * await kiss.db.deleteFakeRecords()
     */
    async deleteFakeRecords(modelId) {
        return await kiss.db[this.mode].deleteMany(modelId, {
            isFake: true
        })
    },

    /**
     * Update a single record in a collection
     * 
     * @async
     * @param {string} modelId
     * @param {string} recordId
     * @param {object} update
     * @returns {object} The request's result
     * 
     * @example
     * let updatedUser = await kiss.db.updateOne("user", "f07xF008d", {lastName: "Smith"})
     * console.log(updatedUser) // returns {firstName: "Bob", lastName: "Smith"}
     */
    async updateOne(modelId, recordId, update) {
        return await kiss.db[this.mode].updateOne(modelId, recordId, update)
    },

    /**
     * Update a record then propagate the mutation to foreign records
     * 
     * @async
     * @param {string} modelId
     * @param {string} recordId
     * @param {string} [update] - If not specified, re-compute all the computed fields
     * @returns The request's result
     * 
     * @example
     * await kiss.db.updateOneDeep("company", "f07xF008d", {name: "pickaform"})
     */
    async updateOneDeep(modelId, recordId, update) {
        return await kiss.db[this.mode].updateOneDeep(modelId, recordId, update)
    },

    /**
     * Update the 2 records connected by a link
     * 
     * @param {object} link 
     * @returns The transaction result
     */    
    async updateLink(link) {
        return await kiss.db[this.mode].updateLink(link)
    },

    /**
     * Update many records in a single collection
     * 
     * @async
     * @param {string} modelId
     * @param {object} query
     * @param {object} update
     * @returns The request's result
     * 
     */
    async updateMany(modelId, query, update) {
        return await kiss.db[this.mode].updateMany(modelId, query, update)
    },

    /**
     * Update multiple records in multiple collections
     * 
     * @async
     * @param {object[]} operations - The list of updates to perform
     * @returns The request's result
     * 
     * @example
     * kiss.db.updateBulk(
     *  [{
     *		modelId: "project",
     *		recordId: "6ab2f4fd-e6f3-4fc3-998f-96629e7ef109",
     *		updates: {
     *			projectName: "Yet another Javascript project"
     *		}
     *	}, {
     *		modelId: "task",
     *		recordId: "5eb85fe3-2634-466c-839f-08423fc1cac1",
     *		updates: {
     *			taskName: "Task 1"
     *		}
     *	}, {
     *		modelId: "task",
     *		recordId: "5ae68056-f099-473b-8f5f-af9eeec9ddff",
     *		updates: {
     *			taskName: "Task 2",
                status: "done"
     *		}
     *	}, {
     *		modelId: "task",
     *		recordId: "1f7f9d6a-2cbc-42f1-80c4-8ad795141493",
     *		updates: {
     *			status: "pending"
     *		}
     *	}]
     * )
     */
    async updateBulk(operations = []) {
        if (operations.length == 0) return false
        return await kiss.db[this.mode].updateBulk(operations)
    },

    /**
     * Find a single record by id
     * 
     * @async
     * @param {string} modelId 
     * @param {string} recordId
     * @returns {object} The found record
     * 
     * @example
     * let Bob = await kiss.db.findOne("user", "fa7f9d6a-2cbc-42f1-80c4-dad795141eee")
     */
    async findOne(modelId, recordId) {
        return await kiss.db[this.mode].findOne(modelId, recordId)
    },

    /**
     * Find multiple records by id
     * 
     * @async
     * @param {string} modelId 
     * @param {string[]} ids - ids of the records to retrieve
     * @param {object[]|object} [sort] - Sort options, as a normalized array or a Mongo object. Normalized example: [{fieldA: "asc"}, {fieldB: "desc"}]. Mongo example: {fieldA: 1, fieldB: -1}
     * @param {string} [sortSyntax] - Sort syntax: "nomalized" | "mongo". Default is normalized
     * @returns {object[]} The found records
     * 
     * @example
     * let users = await kiss.db.findById("user", ["fa7f9d6a-2cbc-42f1-80c4-dad795141eee", "0e7f9d6a-2cbc-42f1-80c4-dad795141547"])
     * let sortedUsers = await kiss.db.findById("user", ["fa7f9d6a-2cbc-42f1-80c4-dad795141eee", "0e7f9d6a-2cbc-42f1-80c4-dad795141547"], [{lastName: "asc"}, {age: "desc"}])
     * let mongoSortedUsers = await kiss.db.findById("user", ["fa7f9d6a-2cbc-42f1-80c4-dad795141eee", "0e7f9d6a-2cbc-42f1-80c4-dad795141547"], {lastName: 1, age: -1}, "mongo")
     */
    async findById(modelId, ids, sort = [], sortSyntax = "normalized") {
        return await kiss.db[this.mode].findById(modelId, ids, sort, sortSyntax)
    },

    /**
     * Find records applying:
     * - filter
     * - sort
     * - group
     * - project
     * - skip
     * - limit
     * 
     * The query can be a normalized object, easier to serialize / deserialize.
     * 
     * Without a filter parameter, it returns all the records of the collection.
     * The filter can be a **group** of filters, where each **filter** can be:
     * - a field condition (example: country = "France")
     * - another group of filters. Check the example below.
     * 
     * Important: KissJS doesn't use server-side grouping and paging (using skip/limit) at the moment because:
     * - KissJS must work offline
     * - it's faster in memory for small / medium datasets
     * We'll see how it evolves in the future with the project requirements.
     * 
     * @async
     * @param {string} modelId
     * @param {object} [query] - Query object
     * @param {*} [query.filter] - The query
     * @param {string} [query.filterSyntax] - The query syntax. By default, passed as a normalized object
     * @param {*} [query.sort] - Sort fields
     * @param {string} [query.sortSyntax] - The sort syntax. By default, passed as a normalized array
     * @param {string[]} [query.group] - Array of fields to group by: ["country", "city"]
     * @param {boolean} [query.groupUnwind] - true to unwind the fields for records that belongs to multiple groups
     * @param {object} [query.projection] - {firstName: 1, lastName: 1, password: 0}
     * @param {object} [query.skip] - Number of records to skip
     * @param {object} [query.limit] - Number of records to return
     * @returns {object[]} An array containing the records data
     * 
     * @example
     * // Sample filter: "Get all people born in France within years 2000 and 2020, which last name is Dupont or Dupond"
     * const filter = {
     *  type: "group",
     *  operator: "and",
     *  filters: [
     *      {
     *          type: "group",
     *          operator: "and",
     *          filters: [
     *              {
     *                  type: "filter",
     *                  fieldId: "country",
     *                  operator: "=",
     *                  value: "France"
     *              },
     *              {
     *                  type: "filter",
     *                  fieldId: "birthDate",
     *                  operator: ">=",
     *                  value: "2000-01-01"
     *              },
     *              {
     *                  type: "filter",
     *                  fieldId: "birthDate",
     *                  operator: "<",
     *                  value: "2020-01-01"
     *              }
     *          ]
     *      },
     *      {
     *          type: "group",
     *          operator: "or",
     *          filters: [
     *              {
     *                  type: "filter",
     *                  fieldId: "lastName",
     *                  operator: "=",
     *                  value: "dupond"
     *              },
     *              {
     *                  type: "filter",
     *                  fieldId: "lastName",
     *                  operator: "=",
     *                  value: "dupont"
     *              }
     *          ]
     *      }
     *   ]
     * }
     * 
     * let users = await kiss.db.find("user", {
     *      filter: filter,
     *      sort: [{lastName: "asc"}, {birthDate: "desc"}],
     *      projection: {password: 0},
     *      skip: 100,
     *      limit: 50
     * })
     */
    async find(modelId, query) {
        if (!query) return await kiss.db[this.mode].find(modelId)

        // Sanitize the query
        let search = {
            operation: "search",
            filter: query.filter || {},
            filterSyntax: query.filterSyntax || "normalized",
            sort: query.sort || {},
            sortSyntax: query.sortSyntax || "normalized",
            group: query.group || [],
            projection: query.projection || {},
            skip: query.skip,
            limit: query.limit,
            groupUnwind: query.groupUnwind
        }
        return await kiss.db[this.mode].find(modelId, search)
    },

    /**
     * Delete a record from a collection
     * 
     * @async
     * @param {string} modelId
     * @param {string} recordId
     * @param {boolean} [sendToTrash] - If true, keeps the original record in a "trash" collection. Default = false
     * @returns The request's result
     * 
     * @example
     * await kiss.db.deleteOne("user", "007f9d6a-2cbc-42f1-80c4-dad7951414af")
     */
    async deleteOne(modelId, recordId, sendToTrash) {
        return await kiss.db[this.mode].deleteOne(modelId, recordId, sendToTrash)
    },

    /**
     * Delete many records from a collection
     * 
     * @async
     * @param {string} modelId 
     * @param {object} query
     * @param {boolean} [sendToTrash] - If true, keeps the original record in a "trash" collection
     * @returns The request's result
     */
    async deleteMany(modelId, query, sendToTrash) {
        return await kiss.db[this.mode].deleteMany(modelId, query, sendToTrash)
    },

    /**
     * Count the number of records that match a query
     * 
     * @async
     * @param {string} modelId
     * @param {object} query - Use same query format as for find() method
     * @returns {number} The number of records
     */
    async count(modelId, query) {
        return await kiss.db[this.mode].count(modelId, query)
    },

    /**
     * Helper functions to convert filter and sort options to MongoDb syntax
     * 
     * @namespace
     */
    mongo: {
        /**
         * Convert an array of sort options to Mongo style
         * 
         * @param {object[]} sortArray - The array to format to Mongo style
         * @returns {object} - A single object with sort options
         * 
         * @example
         * // input:
         * [{birthDate: "asc"}, {lastName: "desc"}]
         * 
         * // output:
         * {birthDate: 1, lastName: -1}
         */
        convertSort(sortArray) {
            let mongoSort = {}
            for (let i = 0, length = sortArray.length; i < length; i++) {
                let sortOption = sortArray[i]
                let sortField = Object.keys(sortOption)[0]
                let sortDirection = sortOption[sortField]
                mongoSort[sortField] = ((sortDirection == "asc") ? 1 : -1)
            }

            return mongoSort
        },

        /**
         * Convert a filter config into a Mongo query expression
         * 
         * @param {array} filter - The filter config to convert to Mongo syntax
         * @returns {object} The Mongo query expression
         * 
         * @example
         * // If the filter config is:
         * {
         *   type: "filter",
         *   fieldId: "firstName",
         *   operator: "contains",
         *   value: "wilson"
         * }
         * 
         * // It will return:
         * {firstName: /wilson/}
         * 
         */
        convertFilter(filterConfig) {
            let query = {}

            // Copy the filter config to not alter the original
            let filter = {}
            Object.assign(filter, filterConfig)

            // Convert dynamic values:
            let isUserTest
            if (filter.value == "$userId") {
                isUserTest = true
                filter.value = kiss.session.getACL() // Connected user

            } else if (filter.value == "$today") {
                filter.value = kiss.formula.TODAY()

            } else if (filter.fieldType == "date") {
                if (filter.dateOperator == "today") {
                    filter.value = kiss.formula.TODAY()
                }
                else if (filter.dateOperator == "days from now") {
                    const today = new Date()
                    const adjustedDate = kiss.formula.ADJUST_DATE(today, 0, 0, filter.value)
                    filter.value = adjustedDate
                }
                else if (filter.dateOperator == "days ago") {
                    const today = new Date()
                    const adjustedDate = kiss.formula.ADJUST_DATE(today, 0, 0, -filter.value)
                    filter.value = adjustedDate
                }                
            }

            switch (filter.operator) {
                case "=":
                    if (!isUserTest) {
                        query[filter.fieldId] = filter.value
                    } else {
                        query[filter.fieldId] = {
                            "$in": filter.value
                        }
                    }
                    break

                case "<>":
                    if (!isUserTest) {
                        query[filter.fieldId] = {
                            $ne: filter.value
                        }
                    } else {
                        query[filter.fieldId] = {
                            "$nin": filter.value
                        }
                    }
                    break

                case "<":
                    query[filter.fieldId] = {
                        $lt: filter.value
                    }
                    break

                case ">":
                    query[filter.fieldId] = {
                        $gt: filter.value
                    }
                    break

                case "<=":
                    query[filter.fieldId] = {
                        $lte: filter.value
                    }
                    break

                case ">=":
                    query[filter.fieldId] = {
                        $gte: filter.value
                    }
                    break

                case "contains":
                    if (!isUserTest) {
                        query[filter.fieldId] = new RegExp(filter.value, "i")
                    } else {
                        query[filter.fieldId] = {
                            "$in": filter.value
                        }
                    }
                    break

                case "does not contain":
                    if (!isUserTest) {
                        query = {
                            [filter.fieldId]: {
                                $not: new RegExp(filter.value, "i")
                            }
                        }
                    } else {
                        query[filter.fieldId] = {
                            "$nin": filter.value
                        }
                    }
                    break
    
                case "is empty":
                    query = {
                        $or: [{
                                [filter.fieldId]: ""
                            },
                            {
                                [filter.fieldId]: null
                            },                            
                            {
                                [filter.fieldId]: []
                            },
                            {
                                [filter.fieldId]: {
                                    $exists: false
                                }
                            }
                        ]
                    }
                    break

                case "is not empty":
                    query = {
                        $and: [{
                                [filter.fieldId]: {
                                    $ne: ""
                                }
                            },
                            {
                                [filter.fieldId]: {
                                    $ne: null
                                }
                            },
                            {
                                [filter.fieldId]: {
                                    $ne: []
                                }
                            },
                            {
                                [filter.fieldId]: {
                                    $exists: true
                                }
                            }
                        ]
                    }
                    break
            }

            return query
        },

        /**
         * Convert a filter config into a Mongo query expression
         * 
         * @param {array} filterGroup - The filter config to convert to Mongo syntax
         * @returns {object} The Mongo query expression
         * 
         * @example
         * // If the filter config is:
         * {
         *      type: "group",
         *      operator: "and",
         *      filters: [
         *          {
         *              type: "filter",
         *              fieldId: "firstName",
         *              operator: "contains",
         *              value: "wilson"
         *          },
         *          {
         *              type: "filter",
         *              fieldId: "birthDate",
         *              operator: ">",
         *              value: "2020-01-01"
         *          }
         *      ]
         * }
         * 
         * // It will return:
         * {$and: [
         *      {firstName: /wilson/},
         *      {birthDate: {$gt: "2000-01-01"}}
         * ]}
         */
        convertFilterGroup(filterGroup) {
            if (filterGroup.type != "group") return kiss.db.mongo.convertFilter(filterGroup)

            let filters = []

            filterGroup.filters.forEach(filter => {
                if (filter) {
                    if (filter.type == "group") {
                        // If it's a filter group, then we get the filters of the group recursively
                        filters.push(kiss.db.mongo.convertFilterGroup(filter))
                    } else {
                        // If it's a single filter, we directly get the filter values
                        filters.push(kiss.db.mongo.convertFilter(filter))
                    }
                }
            })

            let mongoFilter = {}
            mongoFilter["$" + filterGroup.operator] = filters
            return mongoFilter
        },

        /**
         * Get all the fields involved in a filter
         * 
         * @param {object} filter 
         * @returns {string[]} The list of field ids
         */
        getFilterFields(filter) {
            if (!filter) return []
            
            let fields = []
            if (filter.type == "filter") {
                fields.push(filter.fieldId)
            } else if (filter.type == "group") {
                filter.filters.forEach(filter => {
                    fields = fields.concat(kiss.db.mongo.getFilterFields(filter))
                })
            }
            return fields.unique()
        }
    }
}

;/**
 * 
 * ## Mockup tool to feed a database with fake random values
 * 
 * - The fake value is generated according to the field **label** property.
 * - A few common fields are recognized automatically
 * - If the **label** is undefined or not recognized, it tries to look at the field **type** property instead (text, number, date)
 * 
 * Recognized field labels are:
 * - name
 * - first name
 * - last name
 * - full name
 * - company name
 * - department
 * - email
 * - phone
 * - address
 * - address 1
 * - address 2
 * - zip code
 * - city
 * - country
 * - title
 * - description
 * - priority
 * - status
 * 
 * The fake values are generated one field at a time, so, to feed a complete record, you must loop over its list of fields.
 * ```
 * const userRecord = {}
 * userModel.getFields().forEach(field => userRecord[field.id] = kiss.db.faker(field))
 * ```
 * 
 * @namespace
 * @param {object|string} field - An object defining a label and a type | A simple string for the label ("First name") or the type ("number")
 * 
 * @example
 * kiss.db.faker({label: "First name"}) can return "Julia"
 * kiss.db.faker("First name") can return "Julia"
 * kiss.db.faker({label: "Full name"}) can return "Julia Giordini"
 * kiss.db.faker({label: "Amount", type: "number"}) can return 123
 * kiss.db.faker({label: "Workload", type: "float", min: 0, max: 100, precision: 2}) can return 42.42
 * kiss.db.faker({label: "Invoice date", type: "date", year: 2020}) can return "2020-05-27"
 * kiss.db.faker("date") can return "1984-05-31"
 * kiss.db.faker("priority") can return "high"
 * kiss.db.faker("status") can return "in progress"
 */
kiss.db.faker = function (field) {
    // Don't generate values for these special items
    if (["block", "panel", "link", "lookup", "summary", "attachment", "aiImage", "password", "selectViewColumn", "selectViewColumns"].indexOf(field.type) != -1) return null

    let sourceArray = []

    // Accept objects like {label: "First name", type: "text"} or simple strings like "First name"
    let mockupName = (typeof field === "object") ? field.label.toLowerCase() : field.toLowerCase()

    switch (mockupName) {
        /**
         * Generate *GENERIC* data according to field types
         */
        case "text":
            sourceArray = kiss.db.faker.text

            if (field.validationType == "url") return "https://en.pickaform.fr"
            if (field.validationType == "email") return kiss.db.faker("email")
            if (field.value == "unid") return kiss.tools.shortUid().toUpperCase()
            return sourceArray[Math.floor(Math.random() * sourceArray.length)]

        case "textarea":
        case "aitextarea":
        case "richtextfield":
            return kiss.db.faker("description")

        case "select":
            // Time field is a select with custom options
            if (field.template == "time") return ("0" + Math.round(Math.random() * 24)).slice(-2) + ":00"

            if (field.options) {
                sourceArray = field.options.map(option => option.value)
                return sourceArray[Math.floor(Math.random() * sourceArray.length)]
            }
            return ["A", "B", "C"]

        case "checkbox":
            let value = Math.random() * 100
            return (value > 50)

        case "date":
            let year = field.year || (1980 + Math.floor(Math.random() * 45))
            let month = field.month || (1 + Math.floor(Math.random() * 12))
            let day = field.day || (1 + Math.floor(Math.random() * 28))
            let date = year.toString() + "-" + ("0" + month.toString()).slice(-2) + "-" + ("0" + day.toString()).slice(-2)
            return date

        case "integer":
            return Math.floor(kiss.db.faker(Object.assign({}, field, {
                label: "float",
                precision: 0
            })))

        case "number":
        case "float":
            let min = field.min || 0
            let max = field.max || 100
            let precision = (field.precision === 0) ? 0 : 2
            let val = (min + Math.random() * (max - min)).toFixed(precision)
            if (mockupName == "number") return Math.floor(val)
            return val

        case "slider":
            return Math.floor((Math.random() * 100).toFixed(0))

        case "rating":
            let minRate = field.min || 0
            let maxRate = field.max || 10
            let rate = (minRate + Math.random() * (maxRate - minRate)).toFixed(0)
            return Math.floor(rate)
        
        case "directory":
            return kiss.session.getUserId()

        case "color":
        case "colorpicker":
            return "#" + kiss.global.palette[Math.round(Math.random() * 59)]

        case "icon":
        case "iconpicker":
            return kiss.webfonts.all[Math.round(Math.random() * 1040)]

        case "mapfield":
            return "-20.992914, 55.389535" // Enjoy!

        /**
         * Generate *SPECIFIC* data according to field ids
         */
        case "username":
        case "fullname":
        case "full name":
        case "nom complet":
        case "utilisateur":
            return kiss.db.faker({
                label: "first name"
            }) + " " + kiss.db.faker({
                label: "last name"
            })

        case "prénom":
            return kiss.db.faker({
                label: "first name"
            })

        case "nom":
            return kiss.db.faker({
                label: "last name"
            })

        case "email":
            return (kiss.db.faker({
                label: "first name"
            }) + "." + kiss.db.faker({
                label: "last name"
            }) + "@" + kiss.db.faker({
                label: "company name"
            }).toLowerCase() + "." + kiss.db.faker({
                label: "domain"
            })).toLowerCase()

        case "phone":
        case "mobile":
        case "mobile phone":
        case "téléphone":
        case "telephone":
            return kiss.db.faker({
                label: "integer",
                min: 1000000000,
                max: 9900000000
            })

        case "company":
        case "société":
            return kiss.db.faker({
                label: "company name"
            })

        case "address":
        case "adresse":
            return kiss.db.faker({
                    label: "address 1"
                }) +
                ", " + kiss.db.faker({
                    label: "address 2"
                }) +
                ", " + kiss.db.faker({
                    label: "zip code"
                }) +
                ", " + kiss.db.faker({
                    label: "city"
                }) +
                ", " + kiss.db.faker({
                    label: "country"
                })

        case "address 1":
        case "addresse 1":
            return kiss.db.faker({
                label: "company name"
            }) + " building"

        case "address 2":
        case "addresse 2":
            return kiss.db.faker({
                label: "integer",
                min: 1
            }) + " " + kiss.db.faker({
                label: "last name"
            }) + " " + kiss.db.faker({
                label: "street"
            })

        case "zip code":
        case "code postal":
            return kiss.db.faker({
                label: "integer",
                min: 1000,
                max: 90000
            })

        case "description":
            return "Lorem ipsum dolor sit amet. Vel animi quia aut deserunt quos qui quia quaerat ut internos ipsa."

            // !Funny text disabled
            // return "This is a " + kiss.db.faker({
            //         label: "description.adjectives"
            //     }) +
            //     " " + kiss.db.faker({
            //         label: "description.starts"
            //     }) +
            //     " about a " + kiss.db.faker({
            //         label: "description.adjectives"
            //     }) +
            //     " " + kiss.db.faker({
            //         label: "description.subjects"
            //     }) +
            //     " who " + kiss.db.faker({
            //         label: "description.auxiliaries"
            //     }) +
            //     " " + kiss.db.faker({
            //         label: "description.adverbs"
            //     }) +
            //     " " + kiss.db.faker({
            //         label: "description.verbs"
            //     }) +
            //     " a " + kiss.db.faker({
            //         label: "description.subjects"
            //     }) +
            //     ", which " + kiss.db.faker({
            //         label: "description.ends"
            //     }) + "."

        case "title":
        case "titre":
            return kiss.db.faker({
                    label: "description.adjectives"
                }).toTitleCase() +
                " " + kiss.db.faker({
                    label: "description.adjectives"
                }) +
                " " + kiss.db.faker({
                    label: "description.subjects"
                })

        default:
            if (typeof field === "object") {
                // Field was passed as a field configuration object

                // If the field is a "description", it's generated using a composition of multiple db.faker elements.
                // Otherwise, we try to get a specific field definition, depending the field label (example: "Last name")
                sourceArray = (field.label.indexOf("description") != -1) ? kiss.db.faker.description[field.label.split(".")[1]] : kiss.db.faker[mockupName]

                // If the field label couldn't be find amongst pre-defined field names, we use the field's type instead (text, number, date, ...)
                if (!sourceArray) {
                    return kiss.db.faker(Object.assign({}, field, {
                        label: field.type
                    }))
                }
            } else {
                // Field was passed as a simple field label
                sourceArray = kiss.db.faker[mockupName]
                if (!sourceArray) return kiss.db.faker("text")
            }

            // If the field label could be find, returns a random value of the source array
            return sourceArray[Math.floor(Math.random() * sourceArray.length)]
    }
}

// Define values to pick from...
kiss.db.faker["priority"] = ["1 - Critical", "2 - High", "3 - Normal", "4 - Low"]
kiss.db.faker["first name"] = ["Mihaela", "Johanna", "Julia", "Christian", "Brigitte", "Erwin", "Maurice", "Lydia", "Adrian", "Lucienne", "John", "Robert", "Bob", "Will", "Stephen", "Pavel", "Robin", "Gad", "Arnold", "Sylvester", "Dolph", "Robbie", "Flavien"]
kiss.db.faker["last name"] = ["Clinciu", "Giordini", "Cvejzek", "Ponzini", "Collat", "Romell", "Lanoix", "Mikevskaia", "Smith", "Dupont", "Romero", "De Rosa", "Wilson", "Smith", "King", "Yurgen", "Lundgren", "Al'Shadar", "Gad'Nayé", "Bouliama", "Legendre"]
kiss.db.faker["department"] = ["Head office", "Sales", "IT", "Support", "Marketing", "Communication", "Accounting", "Back office", "Human resources", "Quality"]
kiss.db.faker["company name"] = ["Google", "Amazon", "Facebook", "Apple", "IBM", "Microsoft", "Sony", "Nintendo", "SpaceX", "Toyota", "Ford", "Ferrari", "Renault", "Epic", "Ubisoft", "Quantic Dream", "Valve", "Stripe", "PickaForm", "Exauce", "The-Data-Box", "Infinity"]
kiss.db.faker["domain"] = ["net", "com", "org", "eu", "fr", "re"]
kiss.db.faker["city"] = ["Paris", "New York", "Tokyo", "London", "Ajaccio", "Saint-Denis", "Sydney", "Marseilles", "Lyon"]
kiss.db.faker["street"] = ["street", "avenue", "boulevard", "road"]
kiss.db.faker["country"] = ["Gaulle", "Germanistan", "Corsica", "Bhukistan", "Wessex", "Africanistan", "Americanistan", "Paradisistan"]
kiss.db.faker["text"] = ["Sample text", "This is an example", "Lorem ipsum"]
kiss.db.faker["description"] = {
    starts: ["example", "story", "book", "example", "use case", "case", "article"],
    adjectives: ["green", "blue", "red", "purple", "big", "small", "giant", "slick", "clever", "stupid", "wonderful", "serious", "shy", "dangerous", "hilarious", "not so serious", "really cool", "strange", "perfect", "moody"],
    subjects: ["man", "woman", "gorilla", "flying saucer", "donkey", "cat", "kiwi", "dog", "mouse", "wolf", "mammoth", "banana", "peanut", "zombie", "monster", "frog", "bird", "chair", "laptop", "planet"],
    auxiliaries: ["can", "can't", "could", "couldn't", "will", "won't", "did", "didn't", "may", "may not", "might", "might not", "shall"],
    verbs: ["talk to", "jump over", "sing with", "eat", "reprogram", "brain-wash", "help", "paint", "study", "invite"],
    adverbs: ["gracefully", "peacefully", "gently", "heavily", "slightly", "deeply", "silently", "carefully", "nicely", "easily", "electronically"],
    ends: ["is funny", "is a bit weird", "doesn't make any sense", "hurts a little bit", "should never happen", "remains to proof", "is nonsense", "might or might not be the truth", "makes me wonder", "invites to meditation"]
}

/**
 * Generate multiple fake records
 * 
 * @param {object[]} fields
 * @param {number} numberOfRecords
 * @returns {object[]} - An array of fake records
 */
kiss.db.faker.generate = function (fields, numberOfRecords) {
    let records = []
    let max = numberOfRecords || 50

    // Keep only the non-deleted fields
    let activeFields = fields.filter(field => field.deleted != true)

    for (let index = 0; index < max; index++) {
        let newRecord = {}
        activeFields.forEach(field => {
            if (field.primary == true) {
                // Primary fields: get field name + index
                newRecord[field.id] = field.label.toTitleCase() + " " + ("0000" + (index + 1)).slice(-5)
            } else if (field.label.toLowerCase() == "name") {
                // Name fields
                newRecord[field.id] = "Name " + ("0000" + (index + 1)).slice(-5)
            } else {
                // Other fields
                let generatedValue = kiss.db.faker(field)
                if (generatedValue !== "") newRecord[field.id] = generatedValue
            }
        })

        newRecord.id = uid()
        newRecord.isFake = true
        records.push(newRecord)
    }
    return records
}

;/**
 * 
 * ## In-memory database wrapper
 * 
 * It has the exact same api as [kiss.db.offline](kiss.db.offline.html) database, but it doesn't persist the records.
 * It means a browser refresh will flush the data.
 * 
 * @namespace
 * 
 */
kiss.db.memory = {
    mode: "memory",
    collections: {},
    deleteCollection: async (modelId) => await kiss.db.offline.deleteCollection(modelId, "memory"),
    insertOne: async (modelId, record) => await kiss.db.offline.insertOne(modelId, record, "memory"),
    insertMany: async (modelId, records) => await kiss.db.offline.insertMany(modelId, records, "memory"),
    updateOne: async(modelId, recordId, update) => await kiss.db.offline.updateOne(modelId, recordId, update, "memory"),
    updateOneDeep: async(modelId, recordId, update) => await kiss.db.offline.updateOneDeep(modelId, recordId, update, "memory"),
    updateLink: async(link) => await kiss.db.offline.updateLink(link, "memory"),    
    updateMany: async(modelId, query, update) => await kiss.db.offline.updateMany(modelId, query, update, "memory"),
    updateBulk: async(operations) => await kiss.db.offline.updateBulk(operations, "memory"),
    findOne: async (modelId, recordId) => await kiss.db.offline.findOne(modelId, recordId, "memory"),
    findById: async (modelId, ids, sort, sortSyntax) => await kiss.db.offline.findById(modelId, ids, sort, sortSyntax, "memory"),
    find: async (modelId, query = {}) => await kiss.db.offline.find(modelId, query, "memory"),
    deleteOne: async (modelId, recordId, sendToTrash) => await kiss.db.offline.deleteOne(modelId, recordId, sendToTrash, "memory"),
    deleteMany: async (modelId, query, sendToTrash) => await kiss.db.offline.deleteMany(modelId, query, sendToTrash, "memory"),
    count: async (modelId, query) => await kiss.db.offline.count(modelId, query, "memory")
}

;!function(t){if("function"==typeof bootstrap)bootstrap("nedb",t);else if("object"==typeof exports)module.exports=t();else if("function"==typeof define&&define.amd)define(t);else if("undefined"!=typeof ses){if(!ses.ok())return;ses.makeNedb=t}else"undefined"!=typeof window?window.Nedb=t():global.Nedb=t()}(function(){var t;return function(t,e,n){function r(n,o){if(!e[n]){if(!t[n]){var a="function"==typeof require&&require;if(!o&&a)return a(n,!0);if(i)return i(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=e[n]={exports:{}};t[n][0].call(u.exports,function(e){var i=t[n][1][e];return r(i?i:e)},u,u.exports)}return e[n].exports}for(var i="function"==typeof require&&require,o=0;o<n.length;o++)r(n[o]);return r}({1:[function(t,e,n){function r(t,e){if(t.indexOf)return t.indexOf(e);for(var n=0;n<t.length;n++)if(e===t[n])return n;return-1}var i=t("__browserify_process");i.EventEmitter||(i.EventEmitter=function(){});var o=n.EventEmitter=i.EventEmitter,a="function"==typeof Array.isArray?Array.isArray:function(t){return"[object Array]"===Object.prototype.toString.call(t)},u=10;o.prototype.setMaxListeners=function(t){this._events||(this._events={}),this._events.maxListeners=t},o.prototype.emit=function(t){if("error"===t&&(!this._events||!this._events.error||a(this._events.error)&&!this._events.error.length))throw arguments[1]instanceof Error?arguments[1]:new Error("Uncaught, unspecified 'error' event.");if(!this._events)return!1;var e=this._events[t];if(!e)return!1;if("function"==typeof e){switch(arguments.length){case 1:e.call(this);break;case 2:e.call(this,arguments[1]);break;case 3:e.call(this,arguments[1],arguments[2]);break;default:var n=Array.prototype.slice.call(arguments,1);e.apply(this,n)}return!0}if(a(e)){for(var n=Array.prototype.slice.call(arguments,1),r=e.slice(),i=0,o=r.length;o>i;i++)r[i].apply(this,n);return!0}return!1},o.prototype.addListener=function(t,e){if("function"!=typeof e)throw new Error("addListener only takes instances of Function");if(this._events||(this._events={}),this.emit("newListener",t,e),this._events[t])if(a(this._events[t])){if(!this._events[t].warned){var n;n=void 0!==this._events.maxListeners?this._events.maxListeners:u,n&&n>0&&this._events[t].length>n&&(this._events[t].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[t].length),console.trace())}this._events[t].push(e)}else this._events[t]=[this._events[t],e];else this._events[t]=e;return this},o.prototype.on=o.prototype.addListener,o.prototype.once=function(t,e){var n=this;return n.on(t,function r(){n.removeListener(t,r),e.apply(this,arguments)}),this},o.prototype.removeListener=function(t,e){if("function"!=typeof e)throw new Error("removeListener only takes instances of Function");if(!this._events||!this._events[t])return this;var n=this._events[t];if(a(n)){var i=r(n,e);if(0>i)return this;n.splice(i,1),0==n.length&&delete this._events[t]}else this._events[t]===e&&delete this._events[t];return this},o.prototype.removeAllListeners=function(t){return 0===arguments.length?(this._events={},this):(t&&this._events&&this._events[t]&&(this._events[t]=null),this)},o.prototype.listeners=function(t){return this._events||(this._events={}),this._events[t]||(this._events[t]=[]),a(this._events[t])||(this._events[t]=[this._events[t]]),this._events[t]},o.listenerCount=function(t,e){var n;return n=t._events&&t._events[e]?"function"==typeof t._events[e]?1:t._events[e].length:0}},{__browserify_process:4}],2:[function(t,e,n){function r(t,e){for(var n=[],r=0;r<t.length;r++)e(t[r],r,t)&&n.push(t[r]);return n}function i(t,e){for(var n=0,r=t.length;r>=0;r--){var i=t[r];"."==i?t.splice(r,1):".."===i?(t.splice(r,1),n++):n&&(t.splice(r,1),n--)}if(e)for(;n--;n)t.unshift("..");return t}var o=t("__browserify_process"),a=/^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;n.resolve=function(){for(var t="",e=!1,n=arguments.length;n>=-1&&!e;n--){var a=n>=0?arguments[n]:o.cwd();"string"==typeof a&&a&&(t=a+"/"+t,e="/"===a.charAt(0))}return t=i(r(t.split("/"),function(t){return!!t}),!e).join("/"),(e?"/":"")+t||"."},n.normalize=function(t){var e="/"===t.charAt(0),n="/"===t.slice(-1);return t=i(r(t.split("/"),function(t){return!!t}),!e).join("/"),t||e||(t="."),t&&n&&(t+="/"),(e?"/":"")+t},n.join=function(){var t=Array.prototype.slice.call(arguments,0);return n.normalize(r(t,function(t){return t&&"string"==typeof t}).join("/"))},n.dirname=function(t){var e=a.exec(t)[1]||"",n=!1;return e?1===e.length||n&&e.length<=3&&":"===e.charAt(1)?e:e.substring(0,e.length-1):"."},n.basename=function(t,e){var n=a.exec(t)[2]||"";return e&&n.substr(-1*e.length)===e&&(n=n.substr(0,n.length-e.length)),n},n.extname=function(t){return a.exec(t)[3]||""},n.relative=function(t,e){function r(t){for(var e=0;e<t.length&&""===t[e];e++);for(var n=t.length-1;n>=0&&""===t[n];n--);return e>n?[]:t.slice(e,n-e+1)}t=n.resolve(t).substr(1),e=n.resolve(e).substr(1);for(var i=r(t.split("/")),o=r(e.split("/")),a=Math.min(i.length,o.length),u=a,s=0;a>s;s++)if(i[s]!==o[s]){u=s;break}for(var c=[],s=u;s<i.length;s++)c.push("..");return c=c.concat(o.slice(u)),c.join("/")},n.sep="/"},{__browserify_process:4}],3:[function(t,e,n){function r(t){return Array.isArray(t)||"object"==typeof t&&"[object Array]"===Object.prototype.toString.call(t)}function i(t){"object"==typeof t&&"[object RegExp]"===Object.prototype.toString.call(t)}function o(t){return"object"==typeof t&&"[object Date]"===Object.prototype.toString.call(t)}t("events"),n.isArray=r,n.isDate=function(t){return"[object Date]"===Object.prototype.toString.call(t)},n.isRegExp=function(t){return"[object RegExp]"===Object.prototype.toString.call(t)},n.print=function(){},n.puts=function(){},n.debug=function(){},n.inspect=function(t,e,s,c){function f(t,s){if(t&&"function"==typeof t.inspect&&t!==n&&(!t.constructor||t.constructor.prototype!==t))return t.inspect(s);switch(typeof t){case"undefined":return h("undefined","undefined");case"string":var c="'"+JSON.stringify(t).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return h(c,"string");case"number":return h(""+t,"number");case"boolean":return h(""+t,"boolean")}if(null===t)return h("null","null");var p=a(t),d=e?u(t):p;if("function"==typeof t&&0===d.length){if(i(t))return h(""+t,"regexp");var y=t.name?": "+t.name:"";return h("[Function"+y+"]","special")}if(o(t)&&0===d.length)return h(t.toUTCString(),"date");var v,g,m;if(r(t)?(g="Array",m=["[","]"]):(g="Object",m=["{","}"]),"function"==typeof t){var b=t.name?": "+t.name:"";v=i(t)?" "+t:" [Function"+b+"]"}else v="";if(o(t)&&(v=" "+t.toUTCString()),0===d.length)return m[0]+v+m[1];if(0>s)return i(t)?h(""+t,"regexp"):h("[Object]","special");l.push(t);var w=d.map(function(e){var n,i;if(t.__lookupGetter__&&(t.__lookupGetter__(e)?i=t.__lookupSetter__(e)?h("[Getter/Setter]","special"):h("[Getter]","special"):t.__lookupSetter__(e)&&(i=h("[Setter]","special"))),p.indexOf(e)<0&&(n="["+e+"]"),i||(l.indexOf(t[e])<0?(i=null===s?f(t[e]):f(t[e],s-1),i.indexOf("\n")>-1&&(i=r(t)?i.split("\n").map(function(t){return"  "+t}).join("\n").substr(2):"\n"+i.split("\n").map(function(t){return"   "+t}).join("\n"))):i=h("[Circular]","special")),"undefined"==typeof n){if("Array"===g&&e.match(/^\d+$/))return i;n=JSON.stringify(""+e),n.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(n=n.substr(1,n.length-2),n=h(n,"name")):(n=n.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),n=h(n,"string"))}return n+": "+i});l.pop();var _=0,k=w.reduce(function(t,e){return _++,e.indexOf("\n")>=0&&_++,t+e.length+1},0);return w=k>50?m[0]+(""===v?"":v+"\n ")+" "+w.join(",\n  ")+" "+m[1]:m[0]+v+" "+w.join(", ")+" "+m[1]}var l=[],h=function(t,e){var n={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},r={special:"cyan",number:"blue","boolean":"yellow",undefined:"grey","null":"bold",string:"green",date:"magenta",regexp:"red"}[e];return r?"["+n[r][0]+"m"+t+"["+n[r][1]+"m":t};return c||(h=function(t){return t}),f(t,"undefined"==typeof s?2:s)},n.log=function(){},n.pump=null;var a=Object.keys||function(t){var e=[];for(var n in t)e.push(n);return e},u=Object.getOwnPropertyNames||function(t){var e=[];for(var n in t)Object.hasOwnProperty.call(t,n)&&e.push(n);return e},s=Object.create||function(t,e){var n;if(null===t)n={__proto__:null};else{if("object"!=typeof t)throw new TypeError("typeof prototype["+typeof t+"] != 'object'");var r=function(){};r.prototype=t,n=new r,n.__proto__=t}return"undefined"!=typeof e&&Object.defineProperties&&Object.defineProperties(n,e),n};n.inherits=function(t,e){t.super_=e,t.prototype=s(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}})};var c=/%[sdj%]/g;n.format=function(t){if("string"!=typeof t){for(var e=[],r=0;r<arguments.length;r++)e.push(n.inspect(arguments[r]));return e.join(" ")}for(var r=1,i=arguments,o=i.length,a=String(t).replace(c,function(t){if("%%"===t)return"%";if(r>=o)return t;switch(t){case"%s":return String(i[r++]);case"%d":return Number(i[r++]);case"%j":return JSON.stringify(i[r++]);default:return t}}),u=i[r];o>r;u=i[++r])a+=null===u||"object"!=typeof u?" "+u:" "+n.inspect(u);return a}},{events:1}],4:[function(t,e){var n=e.exports={};n.nextTick=function(){var t="undefined"!=typeof window&&window.setImmediate,e="undefined"!=typeof window&&window.postMessage&&window.addEventListener;if(t)return function(t){return window.setImmediate(t)};if(e){var n=[];return window.addEventListener("message",function(t){var e=t.source;if((e===window||null===e)&&"process-tick"===t.data&&(t.stopPropagation(),n.length>0)){var r=n.shift();r()}},!0),function(t){n.push(t),window.postMessage("process-tick","*")}}return function(t){setTimeout(t,0)}}(),n.title="browser",n.browser=!0,n.env={},n.argv=[],n.binding=function(){throw new Error("process.binding is not supported")},n.cwd=function(){return"/"},n.chdir=function(){throw new Error("process.chdir is not supported")}},{}],5:[function(t,e){function n(t,e,n){this.db=t,this.query=e||{},n&&(this.execFn=n)}var r=t("./model"),i=t("underscore");n.prototype.limit=function(t){return this._limit=t,this},n.prototype.skip=function(t){return this._skip=t,this},n.prototype.sort=function(t){return this._sort=t,this},n.prototype.projection=function(t){return this._projection=t,this},n.prototype.project=function(t){var e,n,o,a=[],u=this;return void 0===this._projection||0===Object.keys(this._projection).length?t:(e=0===this._projection._id?!1:!0,this._projection=i.omit(this._projection,"_id"),o=Object.keys(this._projection),o.forEach(function(t){if(void 0!==n&&u._projection[t]!==n)throw new Error("Can't both keep and omit fields except for _id");n=u._projection[t]}),t.forEach(function(t){var i;1===n?(i={$set:{}},o.forEach(function(e){i.$set[e]=r.getDotValue(t,e),void 0===i.$set[e]&&delete i.$set[e]}),i=r.modify({},i)):(i={$unset:{}},o.forEach(function(t){i.$unset[t]=!0}),i=r.modify(t,i)),e?i._id=t._id:delete i._id,a.push(i)}),a)},n.prototype._exec=function(t){function e(e,n){return c.execFn?c.execFn(e,n,t):t(e,n)}var n,i,o,a=[],u=0,s=0,c=this,f=null;this.db.getCandidates(this.query,function(t,l){if(t)return e(t);try{for(n=0;n<l.length;n+=1)if(r.match(l[n],c.query))if(c._sort)a.push(l[n]);else if(c._skip&&c._skip>s)s+=1;else if(a.push(l[n]),u+=1,c._limit&&c._limit<=u)break}catch(t){return e(t)}if(c._sort){i=Object.keys(c._sort);var h=[];for(n=0;n<i.length;n++)o=i[n],h.push({key:o,direction:c._sort[o]});a.sort(function(t,e){var n,i,o;for(o=0;o<h.length;o++)if(n=h[o],i=n.direction*r.compareThings(r.getDotValue(t,n.key),r.getDotValue(e,n.key),c.db.compareStrings),0!==i)return i;return 0});var p=c._limit||a.length,d=c._skip||0;a=a.slice(d,d+p)}try{a=c.project(a)}catch(y){f=y,a=void 0}return e(f,a)})},n.prototype.exec=function(){this.db.executor.push({"this":this,fn:this._exec,arguments:arguments})},e.exports=n},{"./model":10,underscore:19}],6:[function(t,e){function n(t){for(var e,e,n=new Array(t),r=0;t>r;r++)0==(3&r)&&(e=4294967296*Math.random()),n[r]=255&e>>>((3&r)<<3);return n}function r(t){function e(t){return o[63&t>>18]+o[63&t>>12]+o[63&t>>6]+o[63&t]}var n,r,i,o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a=t.length%3,u="";for(i=0,r=t.length-a;r>i;i+=3)n=(t[i]<<16)+(t[i+1]<<8)+t[i+2],u+=e(n);switch(a){case 1:n=t[t.length-1],u+=o[n>>2],u+=o[63&n<<4],u+="==";break;case 2:n=(t[t.length-2]<<8)+t[t.length-1],u+=o[n>>10],u+=o[63&n>>4],u+=o[63&n<<2],u+="="}return u}function i(t){return r(n(Math.ceil(Math.max(8,2*t)))).replace(/[+\/]/g,"").slice(0,t)}e.exports.uid=i},{}],7:[function(t,e){function n(t){var e;"string"==typeof t?(e=t,this.inMemoryOnly=!1):(t=t||{},e=t.filename,this.inMemoryOnly=t.inMemoryOnly||!1,this.autoload=t.autoload||!1,this.timestampData=t.timestampData||!1),e&&"string"==typeof e&&0!==e.length?this.filename=e:(this.filename=null,this.inMemoryOnly=!0),this.compareStrings=t.compareStrings,this.persistence=new f({db:this,nodeWebkitAppName:t.nodeWebkitAppName,afterSerialization:t.afterSerialization,beforeDeserialization:t.beforeDeserialization,corruptAlertThreshold:t.corruptAlertThreshold}),this.executor=new a,this.inMemoryOnly&&(this.executor.ready=!0),this.indexes={},this.indexes._id=new u({fieldName:"_id",unique:!0}),this.ttlIndexes={},this.autoload&&this.loadDatabase(t.onload||function(t){if(t)throw t})}var r=t("./customUtils"),i=t("./model"),o=t("async"),a=t("./executor"),u=t("./indexes"),s=t("util"),c=t("underscore"),f=t("./persistence"),l=t("./cursor");s.inherits(n,t("events").EventEmitter),n.prototype.loadDatabase=function(){this.executor.push({"this":this.persistence,fn:this.persistence.loadDatabase,arguments:arguments},!0)},n.prototype.getAllData=function(){return this.indexes._id.getAll()},n.prototype.resetIndexes=function(t){var e=this;Object.keys(this.indexes).forEach(function(n){e.indexes[n].reset(t)})},n.prototype.ensureIndex=function(t,e){var n,r=e||function(){};if(t=t||{},!t.fieldName)return n=new Error("Cannot create an index without a fieldName"),n.missingFieldName=!0,r(n);if(this.indexes[t.fieldName])return r(null);this.indexes[t.fieldName]=new u(t),void 0!==t.expireAfterSeconds&&(this.ttlIndexes[t.fieldName]=t.expireAfterSeconds);try{this.indexes[t.fieldName].insert(this.getAllData())}catch(i){return delete this.indexes[t.fieldName],r(i)}this.persistence.persistNewState([{$$indexCreated:t}],function(t){return t?r(t):r(null)})},n.prototype.removeIndex=function(t,e){var n=e||function(){};delete this.indexes[t],this.persistence.persistNewState([{$$indexRemoved:t}],function(t){return t?n(t):n(null)})},n.prototype.addToIndexes=function(t){var e,n,r,i=Object.keys(this.indexes);for(e=0;e<i.length;e+=1)try{this.indexes[i[e]].insert(t)}catch(o){n=e,r=o;break}if(r){for(e=0;n>e;e+=1)this.indexes[i[e]].remove(t);throw r}},n.prototype.removeFromIndexes=function(t){var e=this;Object.keys(this.indexes).forEach(function(n){e.indexes[n].remove(t)})},n.prototype.updateIndexes=function(t,e){var n,r,i,o=Object.keys(this.indexes);for(n=0;n<o.length;n+=1)try{this.indexes[o[n]].update(t,e)}catch(a){r=n,i=a;break}if(i){for(n=0;r>n;n+=1)this.indexes[o[n]].revertUpdate(t,e);throw i}},n.prototype.getCandidates=function(t,e,n){var r,i=Object.keys(this.indexes),a=this;"function"==typeof e&&(n=e,e=!1),o.waterfall([function(e){return r=[],Object.keys(t).forEach(function(e){("string"==typeof t[e]||"number"==typeof t[e]||"boolean"==typeof t[e]||s.isDate(t[e])||null===t[e])&&r.push(e)}),r=c.intersection(r,i),r.length>0?e(null,a.indexes[r[0]].getMatching(t[r[0]])):(r=[],Object.keys(t).forEach(function(e){t[e]&&t[e].hasOwnProperty("$in")&&r.push(e)}),r=c.intersection(r,i),r.length>0?e(null,a.indexes[r[0]].getMatching(t[r[0]].$in)):(r=[],Object.keys(t).forEach(function(e){t[e]&&(t[e].hasOwnProperty("$lt")||t[e].hasOwnProperty("$lte")||t[e].hasOwnProperty("$gt")||t[e].hasOwnProperty("$gte"))&&r.push(e)}),r=c.intersection(r,i),r.length>0?e(null,a.indexes[r[0]].getBetweenBounds(t[r[0]])):e(null,a.getAllData())))},function(t){if(e)return n(null,t);var r=[],i=[],u=Object.keys(a.ttlIndexes);t.forEach(function(t){var e=!0;u.forEach(function(n){void 0!==t[n]&&s.isDate(t[n])&&Date.now()>t[n].getTime()+1e3*a.ttlIndexes[n]&&(e=!1)}),e?i.push(t):r.push(t._id)}),o.eachSeries(r,function(t,e){a._remove({_id:t},{},function(t){return t?n(t):e()})},function(){return n(null,i)})}])},n.prototype._insert=function(t,e){var n,r=e||function(){};try{n=this.prepareDocumentForInsertion(t),this._insertInCache(n)}catch(o){return r(o)}this.persistence.persistNewState(s.isArray(n)?n:[n],function(t){return t?r(t):r(null,i.deepCopy(n))})},n.prototype.createNewId=function(){var t=r.uid(16);return this.indexes._id.getMatching(t).length>0&&(t=this.createNewId()),t},n.prototype.prepareDocumentForInsertion=function(t){var e,n=this;if(s.isArray(t))e=[],t.forEach(function(t){e.push(n.prepareDocumentForInsertion(t))});else{e=i.deepCopy(t),void 0===e._id&&(e._id=this.createNewId());var r=new Date;this.timestampData&&void 0===e.createdAt&&(e.createdAt=r),this.timestampData&&void 0===e.updatedAt&&(e.updatedAt=r),i.checkObject(e)}return e},n.prototype._insertInCache=function(t){s.isArray(t)?this._insertMultipleDocsInCache(t):this.addToIndexes(t)},n.prototype._insertMultipleDocsInCache=function(t){var e,n,r;for(e=0;e<t.length;e+=1)try{this.addToIndexes(t[e])}catch(i){r=i,n=e;break}if(r){for(e=0;n>e;e+=1)this.removeFromIndexes(t[e]);throw r}},n.prototype.insert=function(){this.executor.push({"this":this,fn:this._insert,arguments:arguments})},n.prototype.count=function(t,e){var n=new l(this,t,function(t,e,n){return t?n(t):n(null,e.length)});return"function"!=typeof e?n:(n.exec(e),void 0)},n.prototype.find=function(t,e,n){switch(arguments.length){case 1:e={};break;case 2:"function"==typeof e&&(n=e,e={})}var r=new l(this,t,function(t,e,n){var r,o=[];if(t)return n(t);for(r=0;r<e.length;r+=1)o.push(i.deepCopy(e[r]));return n(null,o)});return r.projection(e),"function"!=typeof n?r:(r.exec(n),void 0)},n.prototype.findOne=function(t,e,n){switch(arguments.length){case 1:e={};break;case 2:"function"==typeof e&&(n=e,e={})}var r=new l(this,t,function(t,e,n){return t?n(t):1===e.length?n(null,i.deepCopy(e[0])):n(null,null)});return r.projection(e).limit(1),"function"!=typeof n?r:(r.exec(n),void 0)},n.prototype._update=function(t,e,n,r){var a,u,s,f,h=this,p=0;"function"==typeof n&&(r=n,n={}),a=r||function(){},u=void 0!==n.multi?n.multi:!1,s=void 0!==n.upsert?n.upsert:!1,o.waterfall([function(n){if(!s)return n();var r=new l(h,t);r.limit(1)._exec(function(r,o){if(r)return a(r);if(1===o.length)return n();var u;try{i.checkObject(e),u=e}catch(s){try{u=i.modify(i.deepCopy(t,!0),e)}catch(r){return a(r)}}return h._insert(u,function(t,e){return t?a(t):a(null,1,e,!0)})})},function(){var r,o,s=[];h.getCandidates(t,function(l,d){if(l)return a(l);try{for(f=0;f<d.length;f+=1)i.match(d[f],t)&&(u||0===p)&&(p+=1,h.timestampData&&(o=d[f].createdAt),r=i.modify(d[f],e),h.timestampData&&(r.createdAt=o,r.updatedAt=new Date),s.push({oldDoc:d[f],newDoc:r}))}catch(l){return a(l)}try{h.updateIndexes(s)}catch(l){return a(l)}var y=c.pluck(s,"newDoc");h.persistence.persistNewState(y,function(t){if(t)return a(t);if(n.returnUpdatedDocs){var e=[];return y.forEach(function(t){e.push(i.deepCopy(t))}),u||(e=e[0]),a(null,p,e)}return a(null,p)})})}])},n.prototype.update=function(){this.executor.push({"this":this,fn:this._update,arguments:arguments})},n.prototype._remove=function(t,e,n){var r,o,a=this,u=0,s=[];"function"==typeof e&&(n=e,e={}),r=n||function(){},o=void 0!==e.multi?e.multi:!1,this.getCandidates(t,!0,function(e,n){if(e)return r(e);try{n.forEach(function(e){i.match(e,t)&&(o||0===u)&&(u+=1,s.push({$$deleted:!0,_id:e._id}),a.removeFromIndexes(e))})}catch(e){return r(e)}a.persistence.persistNewState(s,function(t){return t?r(t):r(null,u)})})},n.prototype.remove=function(){this.executor.push({"this":this,fn:this._remove,arguments:arguments})},e.exports=n},{"./cursor":5,"./customUtils":6,"./executor":8,"./indexes":9,"./model":10,"./persistence":11,async:13,events:1,underscore:19,util:3}],8:[function(t,e){function n(){this.buffer=[],this.ready=!1,this.queue=i.queue(function(t,e){for(var n=[],i=0;i<t.arguments.length;i+=1)n.push(t.arguments[i]);var o=t.arguments[t.arguments.length-1];"function"==typeof o?n[n.length-1]=function(){"function"==typeof setImmediate?setImmediate(e):r.nextTick(e),o.apply(null,arguments)}:o||0===t.arguments.length?n.push(function(){e()}):n[n.length-1]=function(){e()},t.fn.apply(t.this,n)},1)}var r=t("__browserify_process"),i=t("async");n.prototype.push=function(t,e){this.ready||e?this.queue.push(t):this.buffer.push(t)},n.prototype.processBuffer=function(){var t;for(this.ready=!0,t=0;t<this.buffer.length;t+=1)this.queue.push(this.buffer[t]);this.buffer=[]},e.exports=n},{__browserify_process:4,async:13}],9:[function(t,e){function n(t,e){return t===e}function r(t){return null===t?"$null":"string"==typeof t?"$string"+t:"boolean"==typeof t?"$boolean"+t:"number"==typeof t?"$number"+t:s.isArray(t)?"$date"+t.getTime():t}function i(t){this.fieldName=t.fieldName,this.unique=t.unique||!1,this.sparse=t.sparse||!1,this.treeOptions={unique:this.unique,compareKeys:a.compareThings,checkValueEquality:n},this.reset()}var o=t("binary-search-tree").AVLTree,a=t("./model"),u=t("underscore"),s=t("util");i.prototype.reset=function(t){this.tree=new o(this.treeOptions),t&&this.insert(t)},i.prototype.insert=function(t){var e,n,i,o,c;if(s.isArray(t))return this.insertMultipleDocs(t),void 0;if(e=a.getDotValue(t,this.fieldName),void 0!==e||!this.sparse)if(s.isArray(e)){for(n=u.uniq(e,r),i=0;i<n.length;i+=1)try{this.tree.insert(n[i],t)}catch(f){c=f,o=i;break}if(c){for(i=0;o>i;i+=1)this.tree.delete(n[i],t);throw c}}else this.tree.insert(e,t)},i.prototype.insertMultipleDocs=function(t){var e,n,r;for(e=0;e<t.length;e+=1)try{this.insert(t[e])}catch(i){n=i,r=e;break}if(n){for(e=0;r>e;e+=1)this.remove(t[e]);throw n}},i.prototype.remove=function(t){var e,n=this;return s.isArray(t)?(t.forEach(function(t){n.remove(t)}),void 0):(e=a.getDotValue(t,this.fieldName),void 0===e&&this.sparse||(s.isArray(e)?u.uniq(e,r).forEach(function(e){n.tree.delete(e,t)}):this.tree.delete(e,t)),void 0)},i.prototype.update=function(t,e){if(s.isArray(t))return this.updateMultipleDocs(t),void 0;this.remove(t);try{this.insert(e)}catch(n){throw this.insert(t),n}},i.prototype.updateMultipleDocs=function(t){var e,n,r;for(e=0;e<t.length;e+=1)this.remove(t[e].oldDoc);for(e=0;e<t.length;e+=1)try{this.insert(t[e].newDoc)}catch(i){r=i,n=e;break}if(r){for(e=0;n>e;e+=1)this.remove(t[e].newDoc);for(e=0;e<t.length;e+=1)this.insert(t[e].oldDoc);throw r}},i.prototype.revertUpdate=function(t,e){var n=[];s.isArray(t)?(t.forEach(function(t){n.push({oldDoc:t.newDoc,newDoc:t.oldDoc})}),this.update(n)):this.update(e,t)},i.prototype.getMatching=function(t){var e=this;if(s.isArray(t)){var n={},r=[];return t.forEach(function(t){e.getMatching(t).forEach(function(t){n[t._id]=t})}),Object.keys(n).forEach(function(t){r.push(n[t])}),r}return e.tree.search(t)},i.prototype.getBetweenBounds=function(t){return this.tree.betweenBounds(t)},i.prototype.getAll=function(){var t=[];return this.tree.executeOnEveryNode(function(e){var n;for(n=0;n<e.data.length;n+=1)t.push(e.data[n])}),t},e.exports=i},{"./model":10,"binary-search-tree":14,underscore:19,util:3}],10:[function(t,e){function n(t,e){if("number"==typeof t&&(t=t.toString()),!("$"!==t[0]||"$$date"===t&&"number"==typeof e||"$$deleted"===t&&e===!0||"$$indexCreated"===t||"$$indexRemoved"===t))throw new Error("Field names cannot begin with the $ character");if(-1!==t.indexOf("."))throw new Error("Field names cannot contain a .")}function r(t){m.isArray(t)&&t.forEach(function(t){r(t)}),"object"==typeof t&&null!==t&&Object.keys(t).forEach(function(e){n(e,t[e]),r(t[e])})}function i(t){var e;return e=JSON.stringify(t,function(t,e){return n(t,e),void 0===e?void 0:null===e?null:"function"==typeof this[t].getTime?{$$date:this[t].getTime()}:e})}function o(t){return JSON.parse(t,function(t,e){return"$$date"===t?new Date(e):"string"==typeof e||"number"==typeof e||"boolean"==typeof e||null===e?e:e&&e.$$date?e.$$date:e})}function a(t,e){var n;return"boolean"==typeof t||"number"==typeof t||"string"==typeof t||null===t||m.isDate(t)?t:m.isArray(t)?(n=[],t.forEach(function(t){n.push(a(t,e))}),n):"object"==typeof t?(n={},Object.keys(t).forEach(function(r){(!e||"$"!==r[0]&&-1===r.indexOf("."))&&(n[r]=a(t[r],e))}),n):void 0}function u(t){return"boolean"==typeof t||"number"==typeof t||"string"==typeof t||null===t||m.isDate(t)||m.isArray(t)}function s(t,e){return e>t?-1:t>e?1:0}function c(t,e){var n,r;for(n=0;n<Math.min(t.length,e.length);n+=1)if(r=f(t[n],e[n]),0!==r)return r;return s(t.length,e.length)}function f(t,e,n){var r,i,o,a,u=n||s;if(void 0===t)return void 0===e?0:-1;if(void 0===e)return void 0===t?0:1;if(null===t)return null===e?0:-1;if(null===e)return null===t?0:1;if("number"==typeof t)return"number"==typeof e?s(t,e):-1;if("number"==typeof e)return"number"==typeof t?s(t,e):1;if("string"==typeof t)return"string"==typeof e?u(t,e):-1;if("string"==typeof e)return"string"==typeof t?u(t,e):1;if("boolean"==typeof t)return"boolean"==typeof e?s(t,e):-1;if("boolean"==typeof e)return"boolean"==typeof t?s(t,e):1;if(m.isDate(t))return m.isDate(e)?s(t.getTime(),e.getTime()):-1;if(m.isDate(e))return m.isDate(t)?s(t.getTime(),e.getTime()):1;if(m.isArray(t))return m.isArray(e)?c(t,e):-1;if(m.isArray(e))return m.isArray(t)?c(t,e):1;for(r=Object.keys(t).sort(),i=Object.keys(e).sort(),a=0;a<Math.min(r.length,i.length);a+=1)if(o=f(t[r[a]],e[i[a]]),0!==o)return o;return s(r.length,i.length)}function l(t){return function(e,n,r){var i="string"==typeof n?n.split("."):n;if(1===i.length)_[t](e,n,r);else{if(void 0===e[i[0]]){if("$unset"===t)return;e[i[0]]={}}w[t](e[i[0]],i.slice(1),r)}}}function h(t,e){var n,i,o=Object.keys(e),u=b.map(o,function(t){return t[0]}),s=b.filter(u,function(t){return"$"===t});if(-1!==o.indexOf("_id")&&e._id!==t._id)throw new Error("You cannot change a document's _id");if(0!==s.length&&s.length!==u.length)throw new Error("You cannot mix modifiers and normal fields");if(0===s.length?(n=a(e),n._id=t._id):(i=b.uniq(o),n=a(t),i.forEach(function(t){var r;if(!w[t])throw new Error("Unknown modifier "+t);if("object"!=typeof e[t])throw new Error("Modifier "+t+"'s argument must be an object");r=Object.keys(e[t]),r.forEach(function(r){w[t](n,r,e[t][r])})})),r(n),t._id!==n._id)throw new Error("You can't change a document's _id");return n}function p(t,e){var n,r,i="string"==typeof e?e.split("."):e;if(!t)return void 0;if(0===i.length)return t;if(1===i.length)return t[i[0]];if(m.isArray(t[i[0]])){if(n=parseInt(i[1],10),"number"==typeof n&&!isNaN(n))return p(t[i[0]][n],i.slice(2));for(r=new Array,n=0;n<t[i[0]].length;n+=1)r.push(p(t[i[0]][n],i.slice(1)));return r}return p(t[i[0]],i.slice(1))}function d(t,e){var n,r,i;if(null===t||"string"==typeof t||"boolean"==typeof t||"number"==typeof t||null===e||"string"==typeof e||"boolean"==typeof e||"number"==typeof e)return t===e;if(m.isDate(t)||m.isDate(e))return m.isDate(t)&&m.isDate(e)&&t.getTime()===e.getTime();if((!m.isArray(t)||!m.isArray(e))&&(m.isArray(t)||m.isArray(e))||void 0===t||void 0===e)return!1;try{n=Object.keys(t),r=Object.keys(e)}catch(o){return!1}if(n.length!==r.length)return!1;for(i=0;i<n.length;i+=1){if(-1===r.indexOf(n[i]))return!1;if(!d(t[n[i]],e[n[i]]))return!1}return!0}function y(t,e){return"string"==typeof t||"number"==typeof t||m.isDate(t)||"string"==typeof e||"number"==typeof e||m.isDate(e)?typeof t!=typeof e?!1:!0:!1}function v(t,e){var n,r,i,o;if(u(t)||u(e))return g({needAKey:t},"needAKey",e);for(n=Object.keys(e),o=0;o<n.length;o+=1)if(r=n[o],i=e[r],"$"===r[0]){if(!x[r])throw new Error("Unknown logical operator "+r);if(!x[r](t,i))return!1}else if(!g(t,r,i))return!1;return!0}function g(t,e,n,r){var i,o,a,u,s=p(t,e);if(m.isArray(s)&&!r){if(m.isArray(n))return g(t,e,n,!0);if(null!==n&&"object"==typeof n&&!m.isRegExp(n))for(o=Object.keys(n),i=0;i<o.length;i+=1)if(E[o[i]])return g(t,e,n,!0);for(i=0;i<s.length;i+=1)if(g({k:s[i]},"k",n))return!0;return!1}if(null!==n&&"object"==typeof n&&!m.isRegExp(n)&&!m.isArray(n)){if(o=Object.keys(n),a=b.map(o,function(t){return t[0]}),u=b.filter(a,function(t){return"$"===t}),0!==u.length&&u.length!==a.length)throw new Error("You cannot mix operators and normal fields");if(u.length>0){for(i=0;i<o.length;i+=1){if(!k[o[i]])throw new Error("Unknown comparison function "+o[i]);if(!k[o[i]](s,n[o[i]]))return!1}return!0}}return m.isRegExp(n)?k.$regex(s,n):d(s,n)?!0:!1}var m=t("util"),b=t("underscore"),w={},_={},k={},x={},E={};_.$set=function(t,e,n){t[e]=n},_.$unset=function(t,e){delete t[e]},_.$push=function(t,e,n){if(t.hasOwnProperty(e)||(t[e]=[]),!m.isArray(t[e]))throw new Error("Can't $push an element on non-array values");if(null!==n&&"object"==typeof n&&n.$slice&&void 0===n.$each&&(n.$each=[]),null!==n&&"object"==typeof n&&n.$each){if(Object.keys(n).length>=3||2===Object.keys(n).length&&void 0===n.$slice)throw new Error("Can only use $slice in cunjunction with $each when $push to array");if(!m.isArray(n.$each))throw new Error("$each requires an array value");if(n.$each.forEach(function(n){t[e].push(n)}),void 0===n.$slice||"number"!=typeof n.$slice)return;if(0===n.$slice)t[e]=[];else{var r,i,o=t[e].length;n.$slice<0?(r=Math.max(0,o+n.$slice),i=o):n.$slice>0&&(r=0,i=Math.min(o,n.$slice)),t[e]=t[e].slice(r,i)}}else t[e].push(n)},_.$addToSet=function(t,e,n){var r=!0;if(t.hasOwnProperty(e)||(t[e]=[]),!m.isArray(t[e]))throw new Error("Can't $addToSet an element on non-array values");if(null!==n&&"object"==typeof n&&n.$each){if(Object.keys(n).length>1)throw new Error("Can't use another field in conjunction with $each");if(!m.isArray(n.$each))throw new Error("$each requires an array value");n.$each.forEach(function(n){_.$addToSet(t,e,n)})}else t[e].forEach(function(t){0===f(t,n)&&(r=!1)}),r&&t[e].push(n)},_.$pop=function(t,e,n){if(!m.isArray(t[e]))throw new Error("Can't $pop an element from non-array values");if("number"!=typeof n)throw new Error(n+" isn't an integer, can't use it with $pop");0!==n&&(t[e]=n>0?t[e].slice(0,t[e].length-1):t[e].slice(1))},_.$pull=function(t,e,n){var r,i;if(!m.isArray(t[e]))throw new Error("Can't $pull an element from non-array values");for(r=t[e],i=r.length-1;i>=0;i-=1)v(r[i],n)&&r.splice(i,1)},_.$inc=function(t,e,n){if("number"!=typeof n)throw new Error(n+" must be a number");if("number"!=typeof t[e]){if(b.has(t,e))throw new Error("Don't use the $inc modifier on non-number fields");t[e]=n}else t[e]+=n},_.$max=function(t,e,n){"undefined"==typeof t[e]?t[e]=n:n>t[e]&&(t[e]=n)},_.$min=function(t,e,n){"undefined"==typeof t[e]?t[e]=n:n<t[e]&&(t[e]=n)},Object.keys(_).forEach(function(t){w[t]=l(t)}),k.$lt=function(t,e){return y(t,e)&&e>t},k.$lte=function(t,e){return y(t,e)&&e>=t},k.$gt=function(t,e){return y(t,e)&&t>e},k.$gte=function(t,e){return y(t,e)&&t>=e},k.$ne=function(t,e){return void 0===t?!0:!d(t,e)},k.$in=function(t,e){var n;if(!m.isArray(e))throw new Error("$in operator called with a non-array");for(n=0;n<e.length;n+=1)if(d(t,e[n]))return!0;return!1},k.$nin=function(t,e){if(!m.isArray(e))throw new Error("$nin operator called with a non-array");return!k.$in(t,e)},k.$regex=function(t,e){if(!m.isRegExp(e))throw new Error("$regex operator called with non regular expression");return"string"!=typeof t?!1:e.test(t)},k.$exists=function(t,e){return e=e||""===e?!0:!1,void 0===t?!e:e},k.$size=function(t,e){if(!m.isArray(t))return!1;if(0!==e%1)throw new Error("$size operator called without an integer");return t.length==e},k.$elemMatch=function(t,e){if(!m.isArray(t))return!1;for(var n=t.length,r=!1;n--;)if(v(t[n],e)){r=!0;break}return r},E.$size=!0,E.$elemMatch=!0,x.$or=function(t,e){var n;if(!m.isArray(e))throw new Error("$or operator used without an array");for(n=0;n<e.length;n+=1)if(v(t,e[n]))return!0;return!1},x.$and=function(t,e){var n;if(!m.isArray(e))throw new Error("$and operator used without an array");
for(n=0;n<e.length;n+=1)if(!v(t,e[n]))return!1;return!0},x.$not=function(t,e){return!v(t,e)},x.$where=function(t,e){var n;if(!b.isFunction(e))throw new Error("$where operator used without a function");if(n=e.call(t),!b.isBoolean(n))throw new Error("$where function must return boolean");return n},e.exports.serialize=i,e.exports.deserialize=o,e.exports.deepCopy=a,e.exports.checkObject=r,e.exports.isPrimitiveType=u,e.exports.modify=h,e.exports.getDotValue=p,e.exports.match=v,e.exports.areThingsEqual=d,e.exports.compareThings=f},{underscore:19,util:3}],11:[function(t,e){function n(t){var e,r,i;if(this.db=t.db,this.inMemoryOnly=this.db.inMemoryOnly,this.filename=this.db.filename,this.corruptAlertThreshold=void 0!==t.corruptAlertThreshold?t.corruptAlertThreshold:.1,!this.inMemoryOnly&&this.filename&&"~"===this.filename.charAt(this.filename.length-1))throw new Error("The datafile name can't end with a ~, which is reserved for crash safe backup files");if(t.afterSerialization&&!t.beforeDeserialization)throw new Error("Serialization hook defined but deserialization hook undefined, cautiously refusing to start NeDB to prevent dataloss");if(!t.afterSerialization&&t.beforeDeserialization)throw new Error("Serialization hook undefined but deserialization hook defined, cautiously refusing to start NeDB to prevent dataloss");for(this.afterSerialization=t.afterSerialization||function(t){return t},this.beforeDeserialization=t.beforeDeserialization||function(t){return t},e=1;30>e;e+=1)for(r=0;10>r;r+=1)if(i=s.uid(e),this.beforeDeserialization(this.afterSerialization(i))!==i)throw new Error("beforeDeserialization is not the reverse of afterSerialization, cautiously refusing to start NeDB to prevent dataloss");this.filename&&t.nodeWebkitAppName&&(console.log("=================================================================="),console.log("WARNING: The nodeWebkitAppName option is deprecated"),console.log("To get the path to the directory where Node Webkit stores the data"),console.log("for your app, use the internal nw.gui module like this"),console.log("require('nw.gui').App.dataPath"),console.log("See https://github.com/rogerwang/node-webkit/issues/500"),console.log("=================================================================="),this.filename=n.getNWAppFilename(t.nodeWebkitAppName,this.filename))}var r=t("__browserify_process"),i=t("./storage"),o=t("path"),a=t("./model"),u=t("async"),s=t("./customUtils"),c=t("./indexes");n.ensureDirectoryExists=function(t,e){var n=e||function(){};i.mkdirp(t,function(t){return n(t)})},n.getNWAppFilename=function(t,e){var n;switch(r.platform){case"win32":case"win64":if(n=r.env.LOCALAPPDATA||r.env.APPDATA,!n)throw new Error("Couldn't find the base application data folder");n=o.join(n,t);break;case"darwin":if(n=r.env.HOME,!n)throw new Error("Couldn't find the base application data directory");n=o.join(n,"Library","Application Support",t);break;case"linux":if(n=r.env.HOME,!n)throw new Error("Couldn't find the base application data directory");n=o.join(n,".config",t);break;default:throw new Error("Can't use the Node Webkit relative path for platform "+r.platform)}return o.join(n,"nedb-data",e)},n.prototype.persistCachedDatabase=function(t){var e=t||function(){},n="",r=this;return this.inMemoryOnly?e(null):(this.db.getAllData().forEach(function(t){n+=r.afterSerialization(a.serialize(t))+"\n"}),Object.keys(this.db.indexes).forEach(function(t){"_id"!=t&&(n+=r.afterSerialization(a.serialize({$$indexCreated:{fieldName:t,unique:r.db.indexes[t].unique,sparse:r.db.indexes[t].sparse}}))+"\n")}),i.crashSafeWriteFile(this.filename,n,function(t){return t?e(t):(r.db.emit("compaction.done"),e(null))}),void 0)},n.prototype.compactDatafile=function(){this.db.executor.push({"this":this,fn:this.persistCachedDatabase,arguments:[]})},n.prototype.setAutocompactionInterval=function(t){var e=this,n=5e3,r=Math.max(t||0,n);this.stopAutocompaction(),this.autocompactionIntervalId=setInterval(function(){e.compactDatafile()},r)},n.prototype.stopAutocompaction=function(){this.autocompactionIntervalId&&clearInterval(this.autocompactionIntervalId)},n.prototype.persistNewState=function(t,e){var n=this,r="",o=e||function(){};return n.inMemoryOnly?o(null):(t.forEach(function(t){r+=n.afterSerialization(a.serialize(t))+"\n"}),0===r.length?o(null):(i.appendFile(n.filename,r,"utf8",function(t){return o(t)}),void 0))},n.prototype.treatRawData=function(t){var e,n=t.split("\n"),r={},i=[],o={},u=-1;for(e=0;e<n.length;e+=1){var s;try{s=a.deserialize(this.beforeDeserialization(n[e])),s._id?s.$$deleted===!0?delete r[s._id]:r[s._id]=s:s.$$indexCreated&&void 0!=s.$$indexCreated.fieldName?o[s.$$indexCreated.fieldName]=s.$$indexCreated:"string"==typeof s.$$indexRemoved&&delete o[s.$$indexRemoved]}catch(c){u+=1}}if(n.length>0&&u/n.length>this.corruptAlertThreshold)throw new Error("More than "+Math.floor(100*this.corruptAlertThreshold)+"% of the data file is corrupt, the wrong beforeDeserialization hook may be used. Cautiously refusing to start NeDB to prevent dataloss");return Object.keys(r).forEach(function(t){i.push(r[t])}),{data:i,indexes:o}},n.prototype.loadDatabase=function(t){var e=t||function(){},r=this;return r.db.resetIndexes(),r.inMemoryOnly?e(null):(u.waterfall([function(t){n.ensureDirectoryExists(o.dirname(r.filename),function(){i.ensureDatafileIntegrity(r.filename,function(){i.readFile(r.filename,"utf8",function(e,n){if(e)return t(e);try{var i=r.treatRawData(n)}catch(o){return t(o)}Object.keys(i.indexes).forEach(function(t){r.db.indexes[t]=new c(i.indexes[t])});try{r.db.resetIndexes(i.data)}catch(o){return r.db.resetIndexes(),t(o)}r.db.persistence.persistCachedDatabase(t)})})})}],function(t){return t?e(t):(r.db.executor.processBuffer(),e(null))}),void 0)},e.exports=n},{"./customUtils":6,"./indexes":9,"./model":10,"./storage":12,__browserify_process:4,async:13,path:2}],12:[function(t,e){function n(t,e){f.getItem(t,function(t,n){return null!==n?e(!0):e(!1)})}function r(t,e,n){f.getItem(t,function(r,i){null===i?f.removeItem(e,function(){return n()}):f.setItem(e,i,function(){f.removeItem(t,function(){return n()})})})}function i(t,e,n,r){"function"==typeof n&&(r=n),f.setItem(t,e,function(){return r()})}function o(t,e,n,r){"function"==typeof n&&(r=n),f.getItem(t,function(n,i){i=i||"",i+=e,f.setItem(t,i,function(){return r()})})}function a(t,e,n){"function"==typeof e&&(n=e),f.getItem(t,function(t,e){return n(null,e||"")})}function u(t,e){f.removeItem(t,function(){return e()})}function s(t,e){return e()}function c(t,e){return e(null)}var f=t("localforage");f.config({name:"NeDB",storeName:"nedbdata"}),e.exports.exists=n,e.exports.rename=r,e.exports.writeFile=i,e.exports.crashSafeWriteFile=i,e.exports.appendFile=o,e.exports.readFile=a,e.exports.unlink=u,e.exports.mkdirp=s,e.exports.ensureDatafileIntegrity=c},{localforage:18}],13:[function(e,n){var r=e("__browserify_process");!function(){function e(t){var e=!1;return function(){if(e)throw new Error("Callback was already called.");e=!0,t.apply(i,arguments)}}var i,o,a={};i=this,null!=i&&(o=i.async),a.noConflict=function(){return i.async=o,a};var u=function(t,e){if(t.forEach)return t.forEach(e);for(var n=0;n<t.length;n+=1)e(t[n],n,t)},s=function(t,e){if(t.map)return t.map(e);var n=[];return u(t,function(t,r,i){n.push(e(t,r,i))}),n},c=function(t,e,n){return t.reduce?t.reduce(e,n):(u(t,function(t,r,i){n=e(n,t,r,i)}),n)},f=function(t){if(Object.keys)return Object.keys(t);var e=[];for(var n in t)t.hasOwnProperty(n)&&e.push(n);return e};"undefined"!=typeof r&&r.nextTick?(a.nextTick=r.nextTick,a.setImmediate="undefined"!=typeof setImmediate?function(t){setImmediate(t)}:a.nextTick):"function"==typeof setImmediate?(a.nextTick=function(t){setImmediate(t)},a.setImmediate=a.nextTick):(a.nextTick=function(t){setTimeout(t,0)},a.setImmediate=a.nextTick),a.each=function(t,n,r){if(r=r||function(){},!t.length)return r();var i=0;u(t,function(o){n(o,e(function(e){e?(r(e),r=function(){}):(i+=1,i>=t.length&&r(null))}))})},a.forEach=a.each,a.eachSeries=function(t,e,n){if(n=n||function(){},!t.length)return n();var r=0,i=function(){e(t[r],function(e){e?(n(e),n=function(){}):(r+=1,r>=t.length?n(null):i())})};i()},a.forEachSeries=a.eachSeries,a.eachLimit=function(t,e,n,r){var i=l(e);i.apply(null,[t,n,r])},a.forEachLimit=a.eachLimit;var l=function(t){return function(e,n,r){if(r=r||function(){},!e.length||0>=t)return r();var i=0,o=0,a=0;!function u(){if(i>=e.length)return r();for(;t>a&&o<e.length;)o+=1,a+=1,n(e[o-1],function(t){t?(r(t),r=function(){}):(i+=1,a-=1,i>=e.length?r():u())})}()}},h=function(t){return function(){var e=Array.prototype.slice.call(arguments);return t.apply(null,[a.each].concat(e))}},p=function(t,e){return function(){var n=Array.prototype.slice.call(arguments);return e.apply(null,[l(t)].concat(n))}},d=function(t){return function(){var e=Array.prototype.slice.call(arguments);return t.apply(null,[a.eachSeries].concat(e))}},y=function(t,e,n,r){var i=[];e=s(e,function(t,e){return{index:e,value:t}}),t(e,function(t,e){n(t.value,function(n,r){i[t.index]=r,e(n)})},function(t){r(t,i)})};a.map=h(y),a.mapSeries=d(y),a.mapLimit=function(t,e,n,r){return v(e)(t,n,r)};var v=function(t){return p(t,y)};a.reduce=function(t,e,n,r){a.eachSeries(t,function(t,r){n(e,t,function(t,n){e=n,r(t)})},function(t){r(t,e)})},a.inject=a.reduce,a.foldl=a.reduce,a.reduceRight=function(t,e,n,r){var i=s(t,function(t){return t}).reverse();a.reduce(i,e,n,r)},a.foldr=a.reduceRight;var g=function(t,e,n,r){var i=[];e=s(e,function(t,e){return{index:e,value:t}}),t(e,function(t,e){n(t.value,function(n){n&&i.push(t),e()})},function(){r(s(i.sort(function(t,e){return t.index-e.index}),function(t){return t.value}))})};a.filter=h(g),a.filterSeries=d(g),a.select=a.filter,a.selectSeries=a.filterSeries;var m=function(t,e,n,r){var i=[];e=s(e,function(t,e){return{index:e,value:t}}),t(e,function(t,e){n(t.value,function(n){n||i.push(t),e()})},function(){r(s(i.sort(function(t,e){return t.index-e.index}),function(t){return t.value}))})};a.reject=h(m),a.rejectSeries=d(m);var b=function(t,e,n,r){t(e,function(t,e){n(t,function(n){n?(r(t),r=function(){}):e()})},function(){r()})};a.detect=h(b),a.detectSeries=d(b),a.some=function(t,e,n){a.each(t,function(t,r){e(t,function(t){t&&(n(!0),n=function(){}),r()})},function(){n(!1)})},a.any=a.some,a.every=function(t,e,n){a.each(t,function(t,r){e(t,function(t){t||(n(!1),n=function(){}),r()})},function(){n(!0)})},a.all=a.every,a.sortBy=function(t,e,n){a.map(t,function(t,n){e(t,function(e,r){e?n(e):n(null,{value:t,criteria:r})})},function(t,e){if(t)return n(t);var r=function(t,e){var n=t.criteria,r=e.criteria;return r>n?-1:n>r?1:0};n(null,s(e.sort(r),function(t){return t.value}))})},a.auto=function(t,e){e=e||function(){};var n=f(t);if(!n.length)return e(null);var r={},i=[],o=function(t){i.unshift(t)},s=function(t){for(var e=0;e<i.length;e+=1)if(i[e]===t)return i.splice(e,1),void 0},l=function(){u(i.slice(0),function(t){t()})};o(function(){f(r).length===n.length&&(e(null,r),e=function(){})}),u(n,function(n){var i=t[n]instanceof Function?[t[n]]:t[n],h=function(t){var i=Array.prototype.slice.call(arguments,1);if(i.length<=1&&(i=i[0]),t){var o={};u(f(r),function(t){o[t]=r[t]}),o[n]=i,e(t,o),e=function(){}}else r[n]=i,a.setImmediate(l)},p=i.slice(0,Math.abs(i.length-1))||[],d=function(){return c(p,function(t,e){return t&&r.hasOwnProperty(e)},!0)&&!r.hasOwnProperty(n)};if(d())i[i.length-1](h,r);else{var y=function(){d()&&(s(y),i[i.length-1](h,r))};o(y)}})},a.waterfall=function(t,e){if(e=e||function(){},t.constructor!==Array){var n=new Error("First argument to waterfall must be an array of functions");return e(n)}if(!t.length)return e();var r=function(t){return function(n){if(n)e.apply(null,arguments),e=function(){};else{var i=Array.prototype.slice.call(arguments,1),o=t.next();o?i.push(r(o)):i.push(e),a.setImmediate(function(){t.apply(null,i)})}}};r(a.iterator(t))()};var w=function(t,e,n){if(n=n||function(){},e.constructor===Array)t.map(e,function(t,e){t&&t(function(t){var n=Array.prototype.slice.call(arguments,1);n.length<=1&&(n=n[0]),e.call(null,t,n)})},n);else{var r={};t.each(f(e),function(t,n){e[t](function(e){var i=Array.prototype.slice.call(arguments,1);i.length<=1&&(i=i[0]),r[t]=i,n(e)})},function(t){n(t,r)})}};a.parallel=function(t,e){w({map:a.map,each:a.each},t,e)},a.parallelLimit=function(t,e,n){w({map:v(e),each:l(e)},t,n)},a.series=function(t,e){if(e=e||function(){},t.constructor===Array)a.mapSeries(t,function(t,e){t&&t(function(t){var n=Array.prototype.slice.call(arguments,1);n.length<=1&&(n=n[0]),e.call(null,t,n)})},e);else{var n={};a.eachSeries(f(t),function(e,r){t[e](function(t){var i=Array.prototype.slice.call(arguments,1);i.length<=1&&(i=i[0]),n[e]=i,r(t)})},function(t){e(t,n)})}},a.iterator=function(t){var e=function(n){var r=function(){return t.length&&t[n].apply(null,arguments),r.next()};return r.next=function(){return n<t.length-1?e(n+1):null},r};return e(0)},a.apply=function(t){var e=Array.prototype.slice.call(arguments,1);return function(){return t.apply(null,e.concat(Array.prototype.slice.call(arguments)))}};var _=function(t,e,n,r){var i=[];t(e,function(t,e){n(t,function(t,n){i=i.concat(n||[]),e(t)})},function(t){r(t,i)})};a.concat=h(_),a.concatSeries=d(_),a.whilst=function(t,e,n){t()?e(function(r){return r?n(r):(a.whilst(t,e,n),void 0)}):n()},a.doWhilst=function(t,e,n){t(function(r){return r?n(r):(e()?a.doWhilst(t,e,n):n(),void 0)})},a.until=function(t,e,n){t()?n():e(function(r){return r?n(r):(a.until(t,e,n),void 0)})},a.doUntil=function(t,e,n){t(function(r){return r?n(r):(e()?n():a.doUntil(t,e,n),void 0)})},a.queue=function(t,n){function r(t,e,r,i){e.constructor!==Array&&(e=[e]),u(e,function(e){var o={data:e,callback:"function"==typeof i?i:null};r?t.tasks.unshift(o):t.tasks.push(o),t.saturated&&t.tasks.length===n&&t.saturated(),a.setImmediate(t.process)})}void 0===n&&(n=1);var i=0,o={tasks:[],concurrency:n,saturated:null,empty:null,drain:null,push:function(t,e){r(o,t,!1,e)},unshift:function(t,e){r(o,t,!0,e)},process:function(){if(i<o.concurrency&&o.tasks.length){var n=o.tasks.shift();o.empty&&0===o.tasks.length&&o.empty(),i+=1;var r=function(){i-=1,n.callback&&n.callback.apply(n,arguments),o.drain&&0===o.tasks.length+i&&o.drain(),o.process()},a=e(r);t(n.data,a)}},length:function(){return o.tasks.length},running:function(){return i}};return o},a.cargo=function(t,e){var n=!1,r=[],i={tasks:r,payload:e,saturated:null,empty:null,drain:null,push:function(t,n){t.constructor!==Array&&(t=[t]),u(t,function(t){r.push({data:t,callback:"function"==typeof n?n:null}),i.saturated&&r.length===e&&i.saturated()}),a.setImmediate(i.process)},process:function o(){if(!n){if(0===r.length)return i.drain&&i.drain(),void 0;var a="number"==typeof e?r.splice(0,e):r.splice(0),c=s(a,function(t){return t.data});i.empty&&i.empty(),n=!0,t(c,function(){n=!1;var t=arguments;u(a,function(e){e.callback&&e.callback.apply(null,t)}),o()})}},length:function(){return r.length},running:function(){return n}};return i};var k=function(t){return function(e){var n=Array.prototype.slice.call(arguments,1);e.apply(null,n.concat([function(e){var n=Array.prototype.slice.call(arguments,1);"undefined"!=typeof console&&(e?console.error&&console.error(e):console[t]&&u(n,function(e){console[t](e)}))}]))}};a.log=k("log"),a.dir=k("dir"),a.memoize=function(t,e){var n={},r={};e=e||function(t){return t};var i=function(){var i=Array.prototype.slice.call(arguments),o=i.pop(),a=e.apply(null,i);a in n?o.apply(null,n[a]):a in r?r[a].push(o):(r[a]=[o],t.apply(null,i.concat([function(){n[a]=arguments;var t=r[a];delete r[a];for(var e=0,i=t.length;i>e;e++)t[e].apply(null,arguments)}])))};return i.memo=n,i.unmemoized=t,i},a.unmemoize=function(t){return function(){return(t.unmemoized||t).apply(null,arguments)}},a.times=function(t,e,n){for(var r=[],i=0;t>i;i++)r.push(i);return a.map(r,e,n)},a.timesSeries=function(t,e,n){for(var r=[],i=0;t>i;i++)r.push(i);return a.mapSeries(r,e,n)},a.compose=function(){var t=Array.prototype.reverse.call(arguments);return function(){var e=this,n=Array.prototype.slice.call(arguments),r=n.pop();a.reduce(t,n,function(t,n,r){n.apply(e,t.concat([function(){var t=arguments[0],e=Array.prototype.slice.call(arguments,1);r(t,e)}]))},function(t,n){r.apply(e,[t].concat(n))})}};var x=function(t,e){var n=function(){var n=this,r=Array.prototype.slice.call(arguments),i=r.pop();return t(e,function(t,e){t.apply(n,r.concat([e]))},i)};if(arguments.length>2){var r=Array.prototype.slice.call(arguments,2);return n.apply(this,r)}return n};a.applyEach=h(x),a.applyEachSeries=d(x),a.forever=function(t,e){function n(r){if(r){if(e)return e(r);throw r}t(n)}n()},"undefined"!=typeof t&&t.amd?t([],function(){return a}):"undefined"!=typeof n&&n.exports?n.exports=a:i.async=a}()},{__browserify_process:4}],14:[function(t,e){e.exports.BinarySearchTree=t("./server/bst"),e.exports.AVLTree=t("./server/avltree")},{"./server/avltree":15,"./server/bst":16}],15:[function(t,e){function n(t){this.tree=new r(t)}function r(t){t=t||{},this.left=null,this.right=null,this.parent=void 0!==t.parent?t.parent:null,t.hasOwnProperty("key")&&(this.key=t.key),this.data=t.hasOwnProperty("value")?[t.value]:[],this.unique=t.unique||!1,this.compareKeys=t.compareKeys||o.defaultCompareKeysFunction,this.checkValueEquality=t.checkValueEquality||o.defaultCheckValueEquality}var i=t("./bst"),o=t("./customUtils"),a=t("util");t("underscore"),a.inherits(r,i),n._AVLTree=r,r.prototype.checkHeightCorrect=function(){var t,e;if(this.hasOwnProperty("key")){if(this.left&&void 0===this.left.height)throw new Error("Undefined height for node "+this.left.key);if(this.right&&void 0===this.right.height)throw new Error("Undefined height for node "+this.right.key);if(void 0===this.height)throw new Error("Undefined height for node "+this.key);if(t=this.left?this.left.height:0,e=this.right?this.right.height:0,this.height!==1+Math.max(t,e))throw new Error("Height constraint failed for node "+this.key);this.left&&this.left.checkHeightCorrect(),this.right&&this.right.checkHeightCorrect()}},r.prototype.balanceFactor=function(){var t=this.left?this.left.height:0,e=this.right?this.right.height:0;return t-e},r.prototype.checkBalanceFactors=function(){if(Math.abs(this.balanceFactor())>1)throw new Error("Tree is unbalanced at node "+this.key);this.left&&this.left.checkBalanceFactors(),this.right&&this.right.checkBalanceFactors()},r.prototype.checkIsAVLT=function(){r.super_.prototype.checkIsBST.call(this),this.checkHeightCorrect(),this.checkBalanceFactors()},n.prototype.checkIsAVLT=function(){this.tree.checkIsAVLT()},r.prototype.rightRotation=function(){var t,e,n,r,i=this,o=this.left;return o?(t=o.right,i.parent?(o.parent=i.parent,i.parent.left===i?i.parent.left=o:i.parent.right=o):o.parent=null,o.right=i,i.parent=o,i.left=t,t&&(t.parent=i),e=o.left?o.left.height:0,n=t?t.height:0,r=i.right?i.right.height:0,i.height=Math.max(n,r)+1,o.height=Math.max(e,i.height)+1,o):this},r.prototype.leftRotation=function(){var t,e,n,r,i=this,o=this.right;return o?(t=o.left,i.parent?(o.parent=i.parent,i.parent.left===i?i.parent.left=o:i.parent.right=o):o.parent=null,o.left=i,i.parent=o,i.right=t,t&&(t.parent=i),e=i.left?i.left.height:0,n=t?t.height:0,r=o.right?o.right.height:0,i.height=Math.max(e,n)+1,o.height=Math.max(r,i.height)+1,o):this},r.prototype.rightTooSmall=function(){return this.balanceFactor()<=1?this:(this.left.balanceFactor()<0&&this.left.leftRotation(),this.rightRotation())},r.prototype.leftTooSmall=function(){return this.balanceFactor()>=-1?this:(this.right.balanceFactor()>0&&this.right.rightRotation(),this.leftRotation())},r.prototype.rebalanceAlongPath=function(t){var e,n,r=this;if(!this.hasOwnProperty("key"))return delete this.height,this;for(n=t.length-1;n>=0;n-=1)t[n].height=1+Math.max(t[n].left?t[n].left.height:0,t[n].right?t[n].right.height:0),t[n].balanceFactor()>1&&(e=t[n].rightTooSmall(),0===n&&(r=e)),t[n].balanceFactor()<-1&&(e=t[n].leftTooSmall(),0===n&&(r=e));return r},r.prototype.insert=function(t,e){var n=[],r=this;if(!this.hasOwnProperty("key"))return this.key=t,this.data.push(e),this.height=1,this;for(;;){if(0===r.compareKeys(r.key,t)){if(r.unique){var i=new Error("Can't insert key "+t+", it violates the unique constraint");throw i.key=t,i.errorType="uniqueViolated",i}return r.data.push(e),this}if(n.push(r),r.compareKeys(t,r.key)<0){if(!r.left){n.push(r.createLeftChild({key:t,value:e}));break}r=r.left}else{if(!r.right){n.push(r.createRightChild({key:t,value:e}));break}r=r.right}}return this.rebalanceAlongPath(n)},n.prototype.insert=function(t,e){var n=this.tree.insert(t,e);n&&(this.tree=n)},r.prototype.delete=function(t,e){var n,r=[],i=this,o=[];if(!this.hasOwnProperty("key"))return this;for(;;){if(0===i.compareKeys(t,i.key))break;if(o.push(i),i.compareKeys(t,i.key)<0){if(!i.left)return this;i=i.left}else{if(!i.right)return this;i=i.right}}if(i.data.length>1&&e)return i.data.forEach(function(t){i.checkValueEquality(t,e)||r.push(t)}),i.data=r,this;if(!i.left&&!i.right)return i===this?(delete i.key,i.data=[],delete i.height,this):(i.parent.left===i?i.parent.left=null:i.parent.right=null,this.rebalanceAlongPath(o));if(!i.left||!i.right)return n=i.left?i.left:i.right,i===this?(n.parent=null,n):(i.parent.left===i?(i.parent.left=n,n.parent=i.parent):(i.parent.right=n,n.parent=i.parent),this.rebalanceAlongPath(o));if(o.push(i),n=i.left,!n.right)return i.key=n.key,i.data=n.data,i.left=n.left,n.left&&(n.left.parent=i),this.rebalanceAlongPath(o);for(;;){if(!n.right)break;o.push(n),n=n.right}return i.key=n.key,i.data=n.data,n.parent.right=n.left,n.left&&(n.left.parent=n.parent),this.rebalanceAlongPath(o)},n.prototype.delete=function(t,e){var n=this.tree.delete(t,e);n&&(this.tree=n)},["getNumberOfKeys","search","betweenBounds","prettyPrint","executeOnEveryNode"].forEach(function(t){n.prototype[t]=function(){return this.tree[t].apply(this.tree,arguments)}}),e.exports=n},{"./bst":16,"./customUtils":17,underscore:19,util:3}],16:[function(t,e){function n(t){t=t||{},this.left=null,this.right=null,this.parent=void 0!==t.parent?t.parent:null,t.hasOwnProperty("key")&&(this.key=t.key),this.data=t.hasOwnProperty("value")?[t.value]:[],this.unique=t.unique||!1,this.compareKeys=t.compareKeys||i.defaultCompareKeysFunction,this.checkValueEquality=t.checkValueEquality||i.defaultCheckValueEquality}function r(t,e){var n;for(n=0;n<e.length;n+=1)t.push(e[n])}var i=t("./customUtils");n.prototype.getMaxKeyDescendant=function(){return this.right?this.right.getMaxKeyDescendant():this},n.prototype.getMaxKey=function(){return this.getMaxKeyDescendant().key},n.prototype.getMinKeyDescendant=function(){return this.left?this.left.getMinKeyDescendant():this},n.prototype.getMinKey=function(){return this.getMinKeyDescendant().key},n.prototype.checkAllNodesFullfillCondition=function(t){this.hasOwnProperty("key")&&(t(this.key,this.data),this.left&&this.left.checkAllNodesFullfillCondition(t),this.right&&this.right.checkAllNodesFullfillCondition(t))},n.prototype.checkNodeOrdering=function(){var t=this;this.hasOwnProperty("key")&&(this.left&&(this.left.checkAllNodesFullfillCondition(function(e){if(t.compareKeys(e,t.key)>=0)throw new Error("Tree with root "+t.key+" is not a binary search tree")}),this.left.checkNodeOrdering()),this.right&&(this.right.checkAllNodesFullfillCondition(function(e){if(t.compareKeys(e,t.key)<=0)throw new Error("Tree with root "+t.key+" is not a binary search tree")}),this.right.checkNodeOrdering()))},n.prototype.checkInternalPointers=function(){if(this.left){if(this.left.parent!==this)throw new Error("Parent pointer broken for key "+this.key);this.left.checkInternalPointers()}if(this.right){if(this.right.parent!==this)throw new Error("Parent pointer broken for key "+this.key);this.right.checkInternalPointers()}},n.prototype.checkIsBST=function(){if(this.checkNodeOrdering(),this.checkInternalPointers(),this.parent)throw new Error("The root shouldn't have a parent")},n.prototype.getNumberOfKeys=function(){var t;return this.hasOwnProperty("key")?(t=1,this.left&&(t+=this.left.getNumberOfKeys()),this.right&&(t+=this.right.getNumberOfKeys()),t):0},n.prototype.createSimilar=function(t){return t=t||{},t.unique=this.unique,t.compareKeys=this.compareKeys,t.checkValueEquality=this.checkValueEquality,new this.constructor(t)},n.prototype.createLeftChild=function(t){var e=this.createSimilar(t);return e.parent=this,this.left=e,e},n.prototype.createRightChild=function(t){var e=this.createSimilar(t);return e.parent=this,this.right=e,e},n.prototype.insert=function(t,e){if(!this.hasOwnProperty("key"))return this.key=t,this.data.push(e),void 0;if(0===this.compareKeys(this.key,t)){if(this.unique){var n=new Error("Can't insert key "+t+", it violates the unique constraint");throw n.key=t,n.errorType="uniqueViolated",n}return this.data.push(e),void 0}this.compareKeys(t,this.key)<0?this.left?this.left.insert(t,e):this.createLeftChild({key:t,value:e}):this.right?this.right.insert(t,e):this.createRightChild({key:t,value:e})},n.prototype.search=function(t){return this.hasOwnProperty("key")?0===this.compareKeys(this.key,t)?this.data:this.compareKeys(t,this.key)<0?this.left?this.left.search(t):[]:this.right?this.right.search(t):[]:[]},n.prototype.getLowerBoundMatcher=function(t){var e=this;return t.hasOwnProperty("$gt")||t.hasOwnProperty("$gte")?t.hasOwnProperty("$gt")&&t.hasOwnProperty("$gte")?0===e.compareKeys(t.$gte,t.$gt)?function(n){return e.compareKeys(n,t.$gt)>0}:e.compareKeys(t.$gte,t.$gt)>0?function(n){return e.compareKeys(n,t.$gte)>=0}:function(n){return e.compareKeys(n,t.$gt)>0}:t.hasOwnProperty("$gt")?function(n){return e.compareKeys(n,t.$gt)>0}:function(n){return e.compareKeys(n,t.$gte)>=0}:function(){return!0}},n.prototype.getUpperBoundMatcher=function(t){var e=this;return t.hasOwnProperty("$lt")||t.hasOwnProperty("$lte")?t.hasOwnProperty("$lt")&&t.hasOwnProperty("$lte")?0===e.compareKeys(t.$lte,t.$lt)?function(n){return e.compareKeys(n,t.$lt)<0}:e.compareKeys(t.$lte,t.$lt)<0?function(n){return e.compareKeys(n,t.$lte)<=0}:function(n){return e.compareKeys(n,t.$lt)<0}:t.hasOwnProperty("$lt")?function(n){return e.compareKeys(n,t.$lt)<0}:function(n){return e.compareKeys(n,t.$lte)<=0}:function(){return!0}},n.prototype.betweenBounds=function(t,e,n){var i=[];return this.hasOwnProperty("key")?(e=e||this.getLowerBoundMatcher(t),n=n||this.getUpperBoundMatcher(t),e(this.key)&&this.left&&r(i,this.left.betweenBounds(t,e,n)),e(this.key)&&n(this.key)&&r(i,this.data),n(this.key)&&this.right&&r(i,this.right.betweenBounds(t,e,n)),i):[]},n.prototype.deleteIfLeaf=function(){return this.left||this.right?!1:this.parent?(this.parent.left===this?this.parent.left=null:this.parent.right=null,!0):(delete this.key,this.data=[],!0)},n.prototype.deleteIfOnlyOneChild=function(){var t;return this.left&&!this.right&&(t=this.left),!this.left&&this.right&&(t=this.right),t?this.parent?(this.parent.left===this?(this.parent.left=t,t.parent=this.parent):(this.parent.right=t,t.parent=this.parent),!0):(this.key=t.key,this.data=t.data,this.left=null,t.left&&(this.left=t.left,t.left.parent=this),this.right=null,t.right&&(this.right=t.right,t.right.parent=this),!0):!1},n.prototype.delete=function(t,e){var n,r=[],i=this;if(this.hasOwnProperty("key")){if(this.compareKeys(t,this.key)<0)return this.left&&this.left.delete(t,e),void 0;if(this.compareKeys(t,this.key)>0)return this.right&&this.right.delete(t,e),void 0;if(0!==!this.compareKeys(t,this.key))return this.data.length>1&&void 0!==e?(this.data.forEach(function(t){i.checkValueEquality(t,e)||r.push(t)}),i.data=r,void 0):(this.deleteIfLeaf()||this.deleteIfOnlyOneChild()||(Math.random()>=.5?(n=this.left.getMaxKeyDescendant(),this.key=n.key,this.data=n.data,this===n.parent?(this.left=n.left,n.left&&(n.left.parent=n.parent)):(n.parent.right=n.left,n.left&&(n.left.parent=n.parent))):(n=this.right.getMinKeyDescendant(),this.key=n.key,this.data=n.data,this===n.parent?(this.right=n.right,n.right&&(n.right.parent=n.parent)):(n.parent.left=n.right,n.right&&(n.right.parent=n.parent)))),void 0)}},n.prototype.executeOnEveryNode=function(t){this.left&&this.left.executeOnEveryNode(t),t(this),this.right&&this.right.executeOnEveryNode(t)},n.prototype.prettyPrint=function(t,e){e=e||"",console.log(e+"* "+this.key),t&&console.log(e+"* "+this.data),(this.left||this.right)&&(this.left?this.left.prettyPrint(t,e+"  "):console.log(e+"  *"),this.right?this.right.prettyPrint(t,e+"  "):console.log(e+"  *"))},e.exports=n},{"./customUtils":17}],17:[function(t,e){function n(t){var e,r;return 0===t?[]:1===t?[0]:(e=n(t-1),r=Math.floor(Math.random()*t),e.splice(r,0,t-1),e)}function r(t,e){if(e>t)return-1;if(t>e)return 1;if(t===e)return 0;var n=new Error("Couldn't compare elements");throw n.a=t,n.b=e,n}function i(t,e){return t===e}e.exports.getRandomArray=n,e.exports.defaultCompareKeysFunction=r,e.exports.defaultCheckValueEquality=i},{}],18:[function(e,n,r){var i=e("__browserify_process"),o=self;!function(){var t,e,n,r;!function(){var i={},o={};t=function(t,e,n){i[t]={deps:e,callback:n}},r=n=e=function(t){function n(e){if("."!==e.charAt(0))return e;for(var n=e.split("/"),r=t.split("/").slice(0,-1),i=0,o=n.length;o>i;i++){var a=n[i];if(".."===a)r.pop();else{if("."===a)continue;r.push(a)}}return r.join("/")}if(r._eak_seen=i,o[t])return o[t];if(o[t]={},!i[t])throw new Error("Could not find module "+t);for(var a,u=i[t],s=u.deps,c=u.callback,f=[],l=0,h=s.length;h>l;l++)"exports"===s[l]?f.push(a={}):f.push(e(n(s[l])));var p=c.apply(this,f);return o[t]=a||p}}(),t("promise/all",["./utils","exports"],function(t,e){"use strict";function n(t){var e=this;if(!r(t))throw new TypeError("You must pass an array to all.");return new e(function(e,n){function r(t){return function(e){o(t,e)}}function o(t,n){u[t]=n,0===--s&&e(u)}var a,u=[],s=t.length;0===s&&e([]);for(var c=0;c<t.length;c++)a=t[c],a&&i(a.then)?a.then(r(c),n):o(c,a)})}var r=t.isArray,i=t.isFunction;e.all=n}),t("promise/asap",["exports"],function(t){"use strict";function e(){return function(){i.nextTick(a)}}function n(){var t=0,e=new f(a),n=document.createTextNode("");return e.observe(n,{characterData:!0}),function(){n.data=t=++t%2}}function r(){return function(){l.setTimeout(a,1)}}function a(){for(var t=0;t<h.length;t++){var e=h[t],n=e[0],r=e[1];n(r)}h=[]}function u(t,e){var n=h.push([t,e]);1===n&&s()}var s,c="undefined"!=typeof window?window:{},f=c.MutationObserver||c.WebKitMutationObserver,l="undefined"!=typeof o?o:void 0===this?window:this,h=[];s="undefined"!=typeof i&&"[object process]"==={}.toString.call(i)?e():f?n():r(),t.asap=u}),t("promise/config",["exports"],function(t){"use strict";function e(t,e){return 2!==arguments.length?n[t]:(n[t]=e,void 0)}var n={instrument:!1};t.config=n,t.configure=e}),t("promise/polyfill",["./promise","./utils","exports"],function(t,e,n){"use strict";function r(){var t;t="undefined"!=typeof o?o:"undefined"!=typeof window&&window.document?window:self;var e="Promise"in t&&"resolve"in t.Promise&&"reject"in t.Promise&&"all"in t.Promise&&"race"in t.Promise&&function(){var e;return new t.Promise(function(t){e=t}),a(e)}();e||(t.Promise=i)}var i=t.Promise,a=e.isFunction;n.polyfill=r}),t("promise/promise",["./config","./utils","./all","./race","./resolve","./reject","./asap","exports"],function(t,e,n,r,i,o,a,u){"use strict";function s(t){if(!_(t))throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");if(!(this instanceof s))throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");this._subscribers=[],c(t,this)}function c(t,e){function n(t){d(e,t)}function r(t){v(e,t)}try{t(n,r)}catch(i){r(i)}}function f(t,e,n,r){var i,o,a,u,s=_(n);if(s)try{i=n(r),a=!0}catch(c){u=!0,o=c}else i=r,a=!0;p(e,i)||(s&&a?d(e,i):u?v(e,o):t===I?d(e,i):t===$&&v(e,i))}function l(t,e,n,r){var i=t._subscribers,o=i.length;i[o]=e,i[o+I]=n,i[o+$]=r}function h(t,e){for(var n,r,i=t._subscribers,o=t._detail,a=0;a<i.length;a+=3)n=i[a],r=i[a+e],f(e,n,r,o);t._subscribers=null}function p(t,e){var n,r=null;try{if(t===e)throw new TypeError("A promises callback cannot return that same promise.");
if(w(e)&&(r=e.then,_(r)))return r.call(e,function(r){return n?!0:(n=!0,e!==r?d(t,r):y(t,r),void 0)},function(e){return n?!0:(n=!0,v(t,e),void 0)}),!0}catch(i){return n?!0:(v(t,i),!0)}return!1}function d(t,e){t===e?y(t,e):p(t,e)||y(t,e)}function y(t,e){t._state===S&&(t._state=j,t._detail=e,b.async(g,t))}function v(t,e){t._state===S&&(t._state=j,t._detail=e,b.async(m,t))}function g(t){h(t,t._state=I)}function m(t){h(t,t._state=$)}var b=t.config;t.configure;var w=e.objectOrFunction,_=e.isFunction;e.now;var k=n.all,x=r.race,E=i.resolve,A=o.reject,O=a.asap;b.async=O;var S=void 0,j=0,I=1,$=2;s.prototype={constructor:s,_state:void 0,_detail:void 0,_subscribers:void 0,then:function(t,e){var n=this,r=new this.constructor(function(){});if(this._state){var i=arguments;b.async(function(){f(n._state,r,i[n._state-1],n._detail)})}else l(this,r,t,e);return r},"catch":function(t){return this.then(null,t)}},s.all=k,s.race=x,s.resolve=E,s.reject=A,u.Promise=s}),t("promise/race",["./utils","exports"],function(t,e){"use strict";function n(t){var e=this;if(!r(t))throw new TypeError("You must pass an array to race.");return new e(function(e,n){for(var r,i=0;i<t.length;i++)r=t[i],r&&"function"==typeof r.then?r.then(e,n):e(r)})}var r=t.isArray;e.race=n}),t("promise/reject",["exports"],function(t){"use strict";function e(t){var e=this;return new e(function(e,n){n(t)})}t.reject=e}),t("promise/resolve",["exports"],function(t){"use strict";function e(t){if(t&&"object"==typeof t&&t.constructor===this)return t;var e=this;return new e(function(e){e(t)})}t.resolve=e}),t("promise/utils",["exports"],function(t){"use strict";function e(t){return n(t)||"object"==typeof t&&null!==t}function n(t){return"function"==typeof t}function r(t){return"[object Array]"===Object.prototype.toString.call(t)}var i=Date.now||function(){return(new Date).getTime()};t.objectOrFunction=e,t.isFunction=n,t.isArray=r,t.now=i}),e("promise/polyfill").polyfill()}(),function(e,i){"object"==typeof r&&"object"==typeof n?n.exports=i():"function"==typeof t&&t.amd?t([],i):"object"==typeof r?r.localforage=i():e.localforage=i()}(this,function(){return function(t){function e(r){if(n[r])return n[r].exports;var i=n[r]={exports:{},id:r,loaded:!1};return t[r].call(i.exports,i,i.exports,e),i.loaded=!0,i.exports}var n={};return e.m=t,e.c=n,e.p="",e(0)}([function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}e.__esModule=!0,function(){function t(t,e){t[e]=function(){var n=arguments;return t.ready().then(function(){return t[e].apply(t,n)})}}function i(){for(var t=1;t<arguments.length;t++){var e=arguments[t];if(e)for(var n in e)e.hasOwnProperty(n)&&(arguments[0][n]=h(e[n])?e[n].slice():e[n])}return arguments[0]}function o(t){for(var e in u)if(u.hasOwnProperty(e)&&u[e]===t)return!0;return!1}var a={},u={INDEXEDDB:"asyncStorage",LOCALSTORAGE:"localStorageWrapper",WEBSQL:"webSQLStorage"},s=[u.INDEXEDDB,u.WEBSQL,u.LOCALSTORAGE],c=["clear","getItem","iterate","key","keys","length","removeItem","setItem"],f={description:"",driver:s.slice(),name:"localforage",size:4980736,storeName:"keyvaluepairs",version:1},l=function(t){var e=e||t.indexedDB||t.webkitIndexedDB||t.mozIndexedDB||t.OIndexedDB||t.msIndexedDB,n={};return n[u.WEBSQL]=!!t.openDatabase,n[u.INDEXEDDB]=!!function(){if("undefined"!=typeof t.openDatabase&&t.navigator&&t.navigator.userAgent&&/Safari/.test(t.navigator.userAgent)&&!/Chrome/.test(t.navigator.userAgent))return!1;try{return e&&"function"==typeof e.open&&"undefined"!=typeof t.IDBKeyRange}catch(n){return!1}}(),n[u.LOCALSTORAGE]=!!function(){try{return t.localStorage&&"setItem"in t.localStorage&&t.localStorage.setItem}catch(e){return!1}}(),n}(this),h=Array.isArray||function(t){return"[object Array]"===Object.prototype.toString.call(t)},p=function(){function e(t){r(this,e),this.INDEXEDDB=u.INDEXEDDB,this.LOCALSTORAGE=u.LOCALSTORAGE,this.WEBSQL=u.WEBSQL,this._defaultConfig=i({},f),this._config=i({},this._defaultConfig,t),this._driverSet=null,this._initDriver=null,this._ready=!1,this._dbInfo=null,this._wrapLibraryMethodsWithReady(),this.setDriver(this._config.driver)}return e.prototype.config=function(t){if("object"==typeof t){if(this._ready)return new Error("Can't call config() after localforage has been used.");for(var e in t)"storeName"===e&&(t[e]=t[e].replace(/\W/g,"_")),this._config[e]=t[e];return"driver"in t&&t.driver&&this.setDriver(this._config.driver),!0}return"string"==typeof t?this._config[t]:this._config},e.prototype.defineDriver=function(t,e,n){var r=new Promise(function(e,n){try{var r=t._driver,i=new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver"),u=new Error("Custom driver name already in use: "+t._driver);if(!t._driver)return n(i),void 0;if(o(t._driver))return n(u),void 0;for(var s=c.concat("_initStorage"),f=0;f<s.length;f++){var h=s[f];if(!h||!t[h]||"function"!=typeof t[h])return n(i),void 0}var p=Promise.resolve(!0);"_support"in t&&(p=t._support&&"function"==typeof t._support?t._support():Promise.resolve(!!t._support)),p.then(function(n){l[r]=n,a[r]=t,e()},n)}catch(d){n(d)}});return r.then(e,n),r},e.prototype.driver=function(){return this._driver||null},e.prototype.getDriver=function(t,e,r){var i=this,u=function(){if(o(t))switch(t){case i.INDEXEDDB:return new Promise(function(t){t(n(1))});case i.LOCALSTORAGE:return new Promise(function(t){t(n(2))});case i.WEBSQL:return new Promise(function(t){t(n(4))})}else if(a[t])return Promise.resolve(a[t]);return Promise.reject(new Error("Driver not found."))}();return u.then(e,r),u},e.prototype.getSerializer=function(t){var e=new Promise(function(t){t(n(3))});return t&&"function"==typeof t&&e.then(function(e){t(e)}),e},e.prototype.ready=function(t){var e=this,n=e._driverSet.then(function(){return null===e._ready&&(e._ready=e._initDriver()),e._ready});return n.then(t,t),n},e.prototype.setDriver=function(t,e,n){function r(){o._config.driver=o.driver()}function i(t){return function(){function e(){for(;n<t.length;){var i=t[n];return n++,o._dbInfo=null,o._ready=null,o.getDriver(i).then(function(t){return o._extend(t),r(),o._ready=o._initStorage(o._config),o._ready})["catch"](e)}r();var a=new Error("No available storage method found.");return o._driverSet=Promise.reject(a),o._driverSet}var n=0;return e()}}var o=this;h(t)||(t=[t]);var a=this._getSupportedDrivers(t),u=null!==this._driverSet?this._driverSet["catch"](function(){return Promise.resolve()}):Promise.resolve();return this._driverSet=u.then(function(){var t=a[0];return o._dbInfo=null,o._ready=null,o.getDriver(t).then(function(t){o._driver=t._driver,r(),o._wrapLibraryMethodsWithReady(),o._initDriver=i(a)})})["catch"](function(){r();var t=new Error("No available storage method found.");return o._driverSet=Promise.reject(t),o._driverSet}),this._driverSet.then(e,n),this._driverSet},e.prototype.supports=function(t){return!!l[t]},e.prototype._extend=function(t){i(this,t)},e.prototype._getSupportedDrivers=function(t){for(var e=[],n=0,r=t.length;r>n;n++){var i=t[n];this.supports(i)&&e.push(i)}return e},e.prototype._wrapLibraryMethodsWithReady=function(){for(var e=0;e<c.length;e++)t(this,c[e])},e.prototype.createInstance=function(t){return new e(t)},e}(),d=new p;e["default"]=d}.call("undefined"!=typeof window?window:self),t.exports=e["default"]},function(t,e){"use strict";e.__esModule=!0,function(){function t(t,e){t=t||[],e=e||{};try{return new Blob(t,e)}catch(n){if("TypeError"!==n.name)throw n;for(var r=x.BlobBuilder||x.MSBlobBuilder||x.MozBlobBuilder||x.WebKitBlobBuilder,i=new r,o=0;o<t.length;o+=1)i.append(t[o]);return i.getBlob(e.type)}}function n(t){for(var e=t.length,n=new ArrayBuffer(e),r=new Uint8Array(n),i=0;e>i;i++)r[i]=t.charCodeAt(i);return n}function r(t){return new Promise(function(e,n){var r=new XMLHttpRequest;r.open("GET",t),r.withCredentials=!0,r.responseType="arraybuffer",r.onreadystatechange=function(){return 4===r.readyState?200===r.status?e({response:r.response,type:r.getResponseHeader("Content-Type")}):(n({status:r.status,response:r.response}),void 0):void 0},r.send()})}function i(e){return new Promise(function(n,i){var o=t([""],{type:"image/png"}),a=e.transaction([S],"readwrite");a.objectStore(S).put(o,"key"),a.oncomplete=function(){var t=e.transaction([S],"readwrite"),o=t.objectStore(S).get("key");o.onerror=i,o.onsuccess=function(t){var e=t.target.result,i=URL.createObjectURL(e);r(i).then(function(t){n(!(!t||"image/png"!==t.type))},function(){n(!1)}).then(function(){URL.revokeObjectURL(i)})}}})["catch"](function(){return!1})}function o(t){return"boolean"==typeof A?Promise.resolve(A):i(t).then(function(t){return A=t})}function a(t){return new Promise(function(e,n){var r=new FileReader;r.onerror=n,r.onloadend=function(n){var r=btoa(n.target.result||"");e({__local_forage_encoded_blob:!0,data:r,type:t.type})},r.readAsBinaryString(t)})}function u(e){var r=n(atob(e.data));return t([r],{type:e.type})}function s(t){return t&&t.__local_forage_encoded_blob}function c(t){function e(){return Promise.resolve()}var n=this,r={db:null};if(t)for(var i in t)r[i]=t[i];O||(O={});var o=O[r.name];o||(o={forages:[],db:null},O[r.name]=o),o.forages.push(this);for(var a=[],u=0;u<o.forages.length;u++){var s=o.forages[u];s!==this&&a.push(s.ready()["catch"](e))}var c=o.forages.slice(0);return Promise.all(a).then(function(){return r.db=o.db,f(r)}).then(function(t){return r.db=t,p(r,n._defaultConfig.version)?l(r):t}).then(function(t){r.db=o.db=t,n._dbInfo=r;for(var e in c){var i=c[e];i!==n&&(i._dbInfo.db=r.db,i._dbInfo.version=r.version)}})}function f(t){return h(t,!1)}function l(t){return h(t,!0)}function h(t,e){return new Promise(function(n,r){if(t.db){if(!e)return n(t.db);t.db.close()}var i=[t.name];e&&i.push(t.version);var o=E.open.apply(E,i);e&&(o.onupgradeneeded=function(e){var n=o.result;try{n.createObjectStore(t.storeName),e.oldVersion<=1&&n.createObjectStore(S)}catch(r){if("ConstraintError"!==r.name)throw r;x.console.warn('The database "'+t.name+'"'+" has been upgraded from version "+e.oldVersion+" to version "+e.newVersion+', but the storage "'+t.storeName+'" already exists.')}}),o.onerror=function(){r(o.error)},o.onsuccess=function(){n(o.result)}})}function p(t,e){if(!t.db)return!0;var n=!t.db.objectStoreNames.contains(t.storeName),r=t.version<t.db.version,i=t.version>t.db.version;if(r&&(t.version!==e&&x.console.warn('The database "'+t.name+'"'+" can't be downgraded from version "+t.db.version+" to version "+t.version+"."),t.version=t.db.version),i||n){if(n){var o=t.db.version+1;o>t.version&&(t.version=o)}return!0}return!1}function d(t,e){var n=this;"string"!=typeof t&&(x.console.warn(t+" used as a key, but it is not a string."),t=String(t));var r=new Promise(function(e,r){n.ready().then(function(){var i=n._dbInfo,o=i.db.transaction(i.storeName,"readonly").objectStore(i.storeName),a=o.get(t);a.onsuccess=function(){var t=a.result;void 0===t&&(t=null),s(t)&&(t=u(t)),e(t)},a.onerror=function(){r(a.error)}})["catch"](r)});return k(r,e),r}function y(t,e){var n=this,r=new Promise(function(e,r){n.ready().then(function(){var i=n._dbInfo,o=i.db.transaction(i.storeName,"readonly").objectStore(i.storeName),a=o.openCursor(),c=1;a.onsuccess=function(){var n=a.result;if(n){var r=n.value;s(r)&&(r=u(r));var i=t(r,n.key,c++);void 0!==i?e(i):n["continue"]()}else e()},a.onerror=function(){r(a.error)}})["catch"](r)});return k(r,e),r}function v(t,e,n){var r=this;"string"!=typeof t&&(x.console.warn(t+" used as a key, but it is not a string."),t=String(t));var i=new Promise(function(n,i){var u;r.ready().then(function(){return u=r._dbInfo,o(u.db)}).then(function(t){return!t&&e instanceof Blob?a(e):e}).then(function(e){var r=u.db.transaction(u.storeName,"readwrite"),o=r.objectStore(u.storeName);null===e&&(e=void 0);var a=o.put(e,t);r.oncomplete=function(){void 0===e&&(e=null),n(e)},r.onabort=r.onerror=function(){var t=a.error?a.error:a.transaction.error;i(t)}})["catch"](i)});return k(i,n),i}function g(t,e){var n=this;"string"!=typeof t&&(x.console.warn(t+" used as a key, but it is not a string."),t=String(t));var r=new Promise(function(e,r){n.ready().then(function(){var i=n._dbInfo,o=i.db.transaction(i.storeName,"readwrite"),a=o.objectStore(i.storeName),u=a["delete"](t);o.oncomplete=function(){e()},o.onerror=function(){r(u.error)},o.onabort=function(){var t=u.error?u.error:u.transaction.error;r(t)}})["catch"](r)});return k(r,e),r}function m(t){var e=this,n=new Promise(function(t,n){e.ready().then(function(){var r=e._dbInfo,i=r.db.transaction(r.storeName,"readwrite"),o=i.objectStore(r.storeName),a=o.clear();i.oncomplete=function(){t()},i.onabort=i.onerror=function(){var t=a.error?a.error:a.transaction.error;n(t)}})["catch"](n)});return k(n,t),n}function b(t){var e=this,n=new Promise(function(t,n){e.ready().then(function(){var r=e._dbInfo,i=r.db.transaction(r.storeName,"readonly").objectStore(r.storeName),o=i.count();o.onsuccess=function(){t(o.result)},o.onerror=function(){n(o.error)}})["catch"](n)});return k(n,t),n}function w(t,e){var n=this,r=new Promise(function(e,r){return 0>t?(e(null),void 0):(n.ready().then(function(){var i=n._dbInfo,o=i.db.transaction(i.storeName,"readonly").objectStore(i.storeName),a=!1,u=o.openCursor();u.onsuccess=function(){var n=u.result;return n?(0===t?e(n.key):a?e(n.key):(a=!0,n.advance(t)),void 0):(e(null),void 0)},u.onerror=function(){r(u.error)}})["catch"](r),void 0)});return k(r,e),r}function _(t){var e=this,n=new Promise(function(t,n){e.ready().then(function(){var r=e._dbInfo,i=r.db.transaction(r.storeName,"readonly").objectStore(r.storeName),o=i.openCursor(),a=[];o.onsuccess=function(){var e=o.result;return e?(a.push(e.key),e["continue"](),void 0):(t(a),void 0)},o.onerror=function(){n(o.error)}})["catch"](n)});return k(n,t),n}function k(t,e){e&&t.then(function(t){e(null,t)},function(t){e(t)})}var x=this,E=E||this.indexedDB||this.webkitIndexedDB||this.mozIndexedDB||this.OIndexedDB||this.msIndexedDB;if(E){var A,O,S="local-forage-detect-blob-support",j={_driver:"asyncStorage",_initStorage:c,iterate:y,getItem:d,setItem:v,removeItem:g,clear:m,length:b,key:w,keys:_};e["default"]=j}}.call("undefined"!=typeof window?window:self),t.exports=e["default"]},function(t,e,n){"use strict";e.__esModule=!0,function(){function t(t){var e=this,r={};if(t)for(var i in t)r[i]=t[i];return r.keyPrefix=r.name+"/",r.storeName!==e._defaultConfig.storeName&&(r.keyPrefix+=r.storeName+"/"),e._dbInfo=r,new Promise(function(t){t(n(3))}).then(function(t){return r.serializer=t,Promise.resolve()})}function r(t){var e=this,n=e.ready().then(function(){for(var t=e._dbInfo.keyPrefix,n=p.length-1;n>=0;n--){var r=p.key(n);0===r.indexOf(t)&&p.removeItem(r)}});return l(n,t),n}function i(t,e){var n=this;"string"!=typeof t&&(h.console.warn(t+" used as a key, but it is not a string."),t=String(t));var r=n.ready().then(function(){var e=n._dbInfo,r=p.getItem(e.keyPrefix+t);return r&&(r=e.serializer.deserialize(r)),r});return l(r,e),r}function o(t,e){var n=this,r=n.ready().then(function(){for(var e=n._dbInfo,r=e.keyPrefix,i=r.length,o=p.length,a=1,u=0;o>u;u++){var s=p.key(u);if(0===s.indexOf(r)){var c=p.getItem(s);if(c&&(c=e.serializer.deserialize(c)),c=t(c,s.substring(i),a++),void 0!==c)return c}}});return l(r,e),r}function a(t,e){var n=this,r=n.ready().then(function(){var e,r=n._dbInfo;try{e=p.key(t)}catch(i){e=null}return e&&(e=e.substring(r.keyPrefix.length)),e});return l(r,e),r}function u(t){var e=this,n=e.ready().then(function(){for(var t=e._dbInfo,n=p.length,r=[],i=0;n>i;i++)0===p.key(i).indexOf(t.keyPrefix)&&r.push(p.key(i).substring(t.keyPrefix.length));return r});return l(n,t),n}function s(t){var e=this,n=e.keys().then(function(t){return t.length});return l(n,t),n}function c(t,e){var n=this;"string"!=typeof t&&(h.console.warn(t+" used as a key, but it is not a string."),t=String(t));var r=n.ready().then(function(){var e=n._dbInfo;p.removeItem(e.keyPrefix+t)});return l(r,e),r}function f(t,e,n){var r=this;"string"!=typeof t&&(h.console.warn(t+" used as a key, but it is not a string."),t=String(t));var i=r.ready().then(function(){void 0===e&&(e=null);var n=e;return new Promise(function(i,o){var a=r._dbInfo;a.serializer.serialize(e,function(e,r){if(r)o(r);else try{p.setItem(a.keyPrefix+t,e),i(n)}catch(u){("QuotaExceededError"===u.name||"NS_ERROR_DOM_QUOTA_REACHED"===u.name)&&o(u),o(u)}})})});return l(i,n),i}function l(t,e){e&&t.then(function(t){e(null,t)},function(t){e(t)})}var h=this,p=null;try{if(!(this.localStorage&&"setItem"in this.localStorage))return;p=this.localStorage}catch(d){return}var y={_driver:"localStorageWrapper",_initStorage:t,iterate:o,getItem:i,setItem:f,removeItem:c,clear:r,length:s,key:a,keys:u};e["default"]=y}.call("undefined"!=typeof window?window:self),t.exports=e["default"]},function(t,e){"use strict";e.__esModule=!0,function(){function t(t,e){t=t||[],e=e||{};try{return new Blob(t,e)}catch(n){if("TypeError"!==n.name)throw n;for(var r=x.BlobBuilder||x.MSBlobBuilder||x.MozBlobBuilder||x.WebKitBlobBuilder,i=new r,o=0;o<t.length;o+=1)i.append(t[o]);return i.getBlob(e.type)}}function n(t,e){var n="";if(t&&(n=t.toString()),t&&("[object ArrayBuffer]"===t.toString()||t.buffer&&"[object ArrayBuffer]"===t.buffer.toString())){var r,i=c;t instanceof ArrayBuffer?(r=t,i+=l):(r=t.buffer,"[object Int8Array]"===n?i+=p:"[object Uint8Array]"===n?i+=d:"[object Uint8ClampedArray]"===n?i+=y:"[object Int16Array]"===n?i+=v:"[object Uint16Array]"===n?i+=m:"[object Int32Array]"===n?i+=g:"[object Uint32Array]"===n?i+=b:"[object Float32Array]"===n?i+=w:"[object Float64Array]"===n?i+=_:e(new Error("Failed to get type for BinaryArray"))),e(i+o(r))}else if("[object Blob]"===n){var a=new FileReader;a.onload=function(){var n=u+t.type+"~"+o(this.result);e(c+h+n)},a.readAsArrayBuffer(t)}else try{e(JSON.stringify(t))}catch(s){console.error("Couldn't convert value into a JSON string: ",t),e(null,s)}}function r(e){if(e.substring(0,f)!==c)return JSON.parse(e);var n,r=e.substring(k),o=e.substring(f,k);if(o===h&&s.test(r)){var a=r.match(s);n=a[1],r=r.substring(a[0].length)}var u=i(r);switch(o){case l:return u;case h:return t([u],{type:n});case p:return new Int8Array(u);case d:return new Uint8Array(u);case y:return new Uint8ClampedArray(u);case v:return new Int16Array(u);case m:return new Uint16Array(u);case g:return new Int32Array(u);case b:return new Uint32Array(u);case w:return new Float32Array(u);case _:return new Float64Array(u);default:throw new Error("Unkown type: "+o)}}function i(t){var e,n,r,i,o,u=.75*t.length,s=t.length,c=0;"="===t[t.length-1]&&(u--,"="===t[t.length-2]&&u--);var f=new ArrayBuffer(u),l=new Uint8Array(f);for(e=0;s>e;e+=4)n=a.indexOf(t[e]),r=a.indexOf(t[e+1]),i=a.indexOf(t[e+2]),o=a.indexOf(t[e+3]),l[c++]=n<<2|r>>4,l[c++]=(15&r)<<4|i>>2,l[c++]=(3&i)<<6|63&o;return f}function o(t){var e,n=new Uint8Array(t),r="";for(e=0;e<n.length;e+=3)r+=a[n[e]>>2],r+=a[(3&n[e])<<4|n[e+1]>>4],r+=a[(15&n[e+1])<<2|n[e+2]>>6],r+=a[63&n[e+2]];return 2===n.length%3?r=r.substring(0,r.length-1)+"=":1===n.length%3&&(r=r.substring(0,r.length-2)+"=="),r}var a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",u="~~local_forage_type~",s=/^~~local_forage_type~([^~]+)~/,c="__lfsc__:",f=c.length,l="arbf",h="blob",p="si08",d="ui08",y="uic8",v="si16",g="si32",m="ur16",b="ui32",w="fl32",_="fl64",k=f+l.length,x=this,E={serialize:n,deserialize:r,stringToBuffer:i,bufferToString:o};e["default"]=E}.call("undefined"!=typeof window?window:self),t.exports=e["default"]},function(t,e,n){"use strict";e.__esModule=!0,function(){function t(t){var e=this,r={db:null};if(t)for(var i in t)r[i]="string"!=typeof t[i]?t[i].toString():t[i];var o=new Promise(function(n,i){try{r.db=p(r.name,String(r.version),r.description,r.size)}catch(o){return e.setDriver(e.LOCALSTORAGE).then(function(){return e._initStorage(t)}).then(n)["catch"](i)}r.db.transaction(function(t){t.executeSql("CREATE TABLE IF NOT EXISTS "+r.storeName+" (id INTEGER PRIMARY KEY, key unique, value)",[],function(){e._dbInfo=r,n()},function(t,e){i(e)})})});return new Promise(function(t){t(n(3))}).then(function(t){return r.serializer=t,o})}function r(t,e){var n=this;"string"!=typeof t&&(h.console.warn(t+" used as a key, but it is not a string."),t=String(t));var r=new Promise(function(e,r){n.ready().then(function(){var i=n._dbInfo;i.db.transaction(function(n){n.executeSql("SELECT * FROM "+i.storeName+" WHERE key = ? LIMIT 1",[t],function(t,n){var r=n.rows.length?n.rows.item(0).value:null;r&&(r=i.serializer.deserialize(r)),e(r)},function(t,e){r(e)})})})["catch"](r)});return l(r,e),r}function i(t,e){var n=this,r=new Promise(function(e,r){n.ready().then(function(){var i=n._dbInfo;i.db.transaction(function(n){n.executeSql("SELECT * FROM "+i.storeName,[],function(n,r){for(var o=r.rows,a=o.length,u=0;a>u;u++){var s=o.item(u),c=s.value;if(c&&(c=i.serializer.deserialize(c)),c=t(c,s.key,u+1),void 0!==c)return e(c),void 0}e()},function(t,e){r(e)})})})["catch"](r)});return l(r,e),r}function o(t,e,n){var r=this;"string"!=typeof t&&(h.console.warn(t+" used as a key, but it is not a string."),t=String(t));var i=new Promise(function(n,i){r.ready().then(function(){void 0===e&&(e=null);var o=e,a=r._dbInfo;a.serializer.serialize(e,function(e,r){r?i(r):a.db.transaction(function(r){r.executeSql("INSERT OR REPLACE INTO "+a.storeName+" (key, value) VALUES (?, ?)",[t,e],function(){n(o)},function(t,e){i(e)})},function(t){t.code===t.QUOTA_ERR&&i(t)})})})["catch"](i)});return l(i,n),i}function a(t,e){var n=this;"string"!=typeof t&&(h.console.warn(t+" used as a key, but it is not a string."),t=String(t));var r=new Promise(function(e,r){n.ready().then(function(){var i=n._dbInfo;i.db.transaction(function(n){n.executeSql("DELETE FROM "+i.storeName+" WHERE key = ?",[t],function(){e()},function(t,e){r(e)})})})["catch"](r)});return l(r,e),r}function u(t){var e=this,n=new Promise(function(t,n){e.ready().then(function(){var r=e._dbInfo;r.db.transaction(function(e){e.executeSql("DELETE FROM "+r.storeName,[],function(){t()},function(t,e){n(e)})})})["catch"](n)});return l(n,t),n}function s(t){var e=this,n=new Promise(function(t,n){e.ready().then(function(){var r=e._dbInfo;r.db.transaction(function(e){e.executeSql("SELECT COUNT(key) as c FROM "+r.storeName,[],function(e,n){var r=n.rows.item(0).c;t(r)},function(t,e){n(e)})})})["catch"](n)});return l(n,t),n}function c(t,e){var n=this,r=new Promise(function(e,r){n.ready().then(function(){var i=n._dbInfo;i.db.transaction(function(n){n.executeSql("SELECT key FROM "+i.storeName+" WHERE id = ? LIMIT 1",[t+1],function(t,n){var r=n.rows.length?n.rows.item(0).key:null;e(r)},function(t,e){r(e)})})})["catch"](r)});return l(r,e),r}function f(t){var e=this,n=new Promise(function(t,n){e.ready().then(function(){var r=e._dbInfo;r.db.transaction(function(e){e.executeSql("SELECT key FROM "+r.storeName,[],function(e,n){for(var r=[],i=0;i<n.rows.length;i++)r.push(n.rows.item(i).key);t(r)},function(t,e){n(e)})})})["catch"](n)});return l(n,t),n}function l(t,e){e&&t.then(function(t){e(null,t)},function(t){e(t)})}var h=this,p=this.openDatabase;if(p){var d={_driver:"webSQLStorage",_initStorage:t,iterate:i,getItem:r,setItem:o,removeItem:a,clear:u,length:s,key:c,keys:f};e["default"]=d}}.call("undefined"!=typeof window?window:self),t.exports=e["default"]}])})},{__browserify_process:4}],19:[function(t,e,n){!function(){var t=this,r=t._,i={},o=Array.prototype,a=Object.prototype,u=Function.prototype,s=o.push,c=o.slice,f=o.concat,l=a.toString,h=a.hasOwnProperty,p=o.forEach,d=o.map,y=o.reduce,v=o.reduceRight,g=o.filter,m=o.every,b=o.some,w=o.indexOf,_=o.lastIndexOf,k=Array.isArray,x=Object.keys,E=u.bind,A=function(t){return t instanceof A?t:this instanceof A?(this._wrapped=t,void 0):new A(t)};"undefined"!=typeof n?("undefined"!=typeof e&&e.exports&&(n=e.exports=A),n._=A):t._=A,A.VERSION="1.4.4";var O=A.each=A.forEach=function(t,e,n){if(null!=t)if(p&&t.forEach===p)t.forEach(e,n);else if(t.length===+t.length){for(var r=0,o=t.length;o>r;r++)if(e.call(n,t[r],r,t)===i)return}else for(var a in t)if(A.has(t,a)&&e.call(n,t[a],a,t)===i)return};A.map=A.collect=function(t,e,n){var r=[];return null==t?r:d&&t.map===d?t.map(e,n):(O(t,function(t,i,o){r[r.length]=e.call(n,t,i,o)}),r)};var S="Reduce of empty array with no initial value";A.reduce=A.foldl=A.inject=function(t,e,n,r){var i=arguments.length>2;if(null==t&&(t=[]),y&&t.reduce===y)return r&&(e=A.bind(e,r)),i?t.reduce(e,n):t.reduce(e);if(O(t,function(t,o,a){i?n=e.call(r,n,t,o,a):(n=t,i=!0)}),!i)throw new TypeError(S);return n},A.reduceRight=A.foldr=function(t,e,n,r){var i=arguments.length>2;if(null==t&&(t=[]),v&&t.reduceRight===v)return r&&(e=A.bind(e,r)),i?t.reduceRight(e,n):t.reduceRight(e);var o=t.length;if(o!==+o){var a=A.keys(t);o=a.length}if(O(t,function(u,s,c){s=a?a[--o]:--o,i?n=e.call(r,n,t[s],s,c):(n=t[s],i=!0)}),!i)throw new TypeError(S);return n},A.find=A.detect=function(t,e,n){var r;return j(t,function(t,i,o){return e.call(n,t,i,o)?(r=t,!0):void 0}),r},A.filter=A.select=function(t,e,n){var r=[];return null==t?r:g&&t.filter===g?t.filter(e,n):(O(t,function(t,i,o){e.call(n,t,i,o)&&(r[r.length]=t)}),r)},A.reject=function(t,e,n){return A.filter(t,function(t,r,i){return!e.call(n,t,r,i)},n)},A.every=A.all=function(t,e,n){e||(e=A.identity);var r=!0;return null==t?r:m&&t.every===m?t.every(e,n):(O(t,function(t,o,a){return(r=r&&e.call(n,t,o,a))?void 0:i}),!!r)};var j=A.some=A.any=function(t,e,n){e||(e=A.identity);var r=!1;return null==t?r:b&&t.some===b?t.some(e,n):(O(t,function(t,o,a){return r||(r=e.call(n,t,o,a))?i:void 0}),!!r)};A.contains=A.include=function(t,e){return null==t?!1:w&&t.indexOf===w?-1!=t.indexOf(e):j(t,function(t){return t===e})},A.invoke=function(t,e){var n=c.call(arguments,2),r=A.isFunction(e);return A.map(t,function(t){return(r?e:t[e]).apply(t,n)})},A.pluck=function(t,e){return A.map(t,function(t){return t[e]})},A.where=function(t,e,n){return A.isEmpty(e)?n?null:[]:A[n?"find":"filter"](t,function(t){for(var n in e)if(e[n]!==t[n])return!1;return!0})},A.findWhere=function(t,e){return A.where(t,e,!0)},A.max=function(t,e,n){if(!e&&A.isArray(t)&&t[0]===+t[0]&&t.length<65535)return Math.max.apply(Math,t);if(!e&&A.isEmpty(t))return-1/0;var r={computed:-1/0,value:-1/0};return O(t,function(t,i,o){var a=e?e.call(n,t,i,o):t;a>=r.computed&&(r={value:t,computed:a})}),r.value},A.min=function(t,e,n){if(!e&&A.isArray(t)&&t[0]===+t[0]&&t.length<65535)return Math.min.apply(Math,t);if(!e&&A.isEmpty(t))return 1/0;var r={computed:1/0,value:1/0};return O(t,function(t,i,o){var a=e?e.call(n,t,i,o):t;a<r.computed&&(r={value:t,computed:a})}),r.value},A.shuffle=function(t){var e,n=0,r=[];return O(t,function(t){e=A.random(n++),r[n-1]=r[e],r[e]=t}),r};var I=function(t){return A.isFunction(t)?t:function(e){return e[t]}};A.sortBy=function(t,e,n){var r=I(e);return A.pluck(A.map(t,function(t,e,i){return{value:t,index:e,criteria:r.call(n,t,e,i)}}).sort(function(t,e){var n=t.criteria,r=e.criteria;if(n!==r){if(n>r||void 0===n)return 1;if(r>n||void 0===r)return-1}return t.index<e.index?-1:1}),"value")};var $=function(t,e,n,r){var i={},o=I(e||A.identity);return O(t,function(e,a){var u=o.call(n,e,a,t);r(i,u,e)}),i};A.groupBy=function(t,e,n){return $(t,e,n,function(t,e,n){(A.has(t,e)?t[e]:t[e]=[]).push(n)})},A.countBy=function(t,e,n){return $(t,e,n,function(t,e){A.has(t,e)||(t[e]=0),t[e]++})},A.sortedIndex=function(t,e,n,r){n=null==n?A.identity:I(n);for(var i=n.call(r,e),o=0,a=t.length;a>o;){var u=o+a>>>1;n.call(r,t[u])<i?o=u+1:a=u}return o},A.toArray=function(t){return t?A.isArray(t)?c.call(t):t.length===+t.length?A.map(t,A.identity):A.values(t):[]},A.size=function(t){return null==t?0:t.length===+t.length?t.length:A.keys(t).length},A.first=A.head=A.take=function(t,e,n){return null==t?void 0:null==e||n?t[0]:c.call(t,0,e)},A.initial=function(t,e,n){return c.call(t,0,t.length-(null==e||n?1:e))},A.last=function(t,e,n){return null==t?void 0:null==e||n?t[t.length-1]:c.call(t,Math.max(t.length-e,0))},A.rest=A.tail=A.drop=function(t,e,n){return c.call(t,null==e||n?1:e)},A.compact=function(t){return A.filter(t,A.identity)};var D=function(t,e,n){return O(t,function(t){A.isArray(t)?e?s.apply(n,t):D(t,e,n):n.push(t)}),n};A.flatten=function(t,e){return D(t,e,[])},A.without=function(t){return A.difference(t,c.call(arguments,1))},A.uniq=A.unique=function(t,e,n,r){A.isFunction(e)&&(r=n,n=e,e=!1);var i=n?A.map(t,n,r):t,o=[],a=[];return O(i,function(n,r){(e?r&&a[a.length-1]===n:A.contains(a,n))||(a.push(n),o.push(t[r]))}),o},A.union=function(){return A.uniq(f.apply(o,arguments))},A.intersection=function(t){var e=c.call(arguments,1);return A.filter(A.uniq(t),function(t){return A.every(e,function(e){return A.indexOf(e,t)>=0})})},A.difference=function(t){var e=f.apply(o,c.call(arguments,1));return A.filter(t,function(t){return!A.contains(e,t)})},A.zip=function(){for(var t=c.call(arguments),e=A.max(A.pluck(t,"length")),n=new Array(e),r=0;e>r;r++)n[r]=A.pluck(t,""+r);return n},A.object=function(t,e){if(null==t)return{};for(var n={},r=0,i=t.length;i>r;r++)e?n[t[r]]=e[r]:n[t[r][0]]=t[r][1];return n},A.indexOf=function(t,e,n){if(null==t)return-1;var r=0,i=t.length;if(n){if("number"!=typeof n)return r=A.sortedIndex(t,e),t[r]===e?r:-1;r=0>n?Math.max(0,i+n):n}if(w&&t.indexOf===w)return t.indexOf(e,n);for(;i>r;r++)if(t[r]===e)return r;return-1},A.lastIndexOf=function(t,e,n){if(null==t)return-1;var r=null!=n;if(_&&t.lastIndexOf===_)return r?t.lastIndexOf(e,n):t.lastIndexOf(e);for(var i=r?n:t.length;i--;)if(t[i]===e)return i;return-1},A.range=function(t,e,n){arguments.length<=1&&(e=t||0,t=0),n=arguments[2]||1;for(var r=Math.max(Math.ceil((e-t)/n),0),i=0,o=new Array(r);r>i;)o[i++]=t,t+=n;return o},A.bind=function(t,e){if(t.bind===E&&E)return E.apply(t,c.call(arguments,1));var n=c.call(arguments,2);return function(){return t.apply(e,n.concat(c.call(arguments)))}},A.partial=function(t){var e=c.call(arguments,1);return function(){return t.apply(this,e.concat(c.call(arguments)))}},A.bindAll=function(t){var e=c.call(arguments,1);return 0===e.length&&(e=A.functions(t)),O(e,function(e){t[e]=A.bind(t[e],t)}),t},A.memoize=function(t,e){var n={};return e||(e=A.identity),function(){var r=e.apply(this,arguments);return A.has(n,r)?n[r]:n[r]=t.apply(this,arguments)}},A.delay=function(t,e){var n=c.call(arguments,2);return setTimeout(function(){return t.apply(null,n)},e)},A.defer=function(t){return A.delay.apply(A,[t,1].concat(c.call(arguments,1)))},A.throttle=function(t,e){var n,r,i,o,a=0,u=function(){a=new Date,i=null,o=t.apply(n,r)};return function(){var s=new Date,c=e-(s-a);return n=this,r=arguments,0>=c?(clearTimeout(i),i=null,a=s,o=t.apply(n,r)):i||(i=setTimeout(u,c)),o}},A.debounce=function(t,e,n){var r,i;return function(){var o=this,a=arguments,u=function(){r=null,n||(i=t.apply(o,a))},s=n&&!r;return clearTimeout(r),r=setTimeout(u,e),s&&(i=t.apply(o,a)),i}},A.once=function(t){var e,n=!1;return function(){return n?e:(n=!0,e=t.apply(this,arguments),t=null,e)}},A.wrap=function(t,e){return function(){var n=[t];return s.apply(n,arguments),e.apply(this,n)}},A.compose=function(){var t=arguments;return function(){for(var e=arguments,n=t.length-1;n>=0;n--)e=[t[n].apply(this,e)];return e[0]}},A.after=function(t,e){return 0>=t?e():function(){return--t<1?e.apply(this,arguments):void 0}},A.keys=x||function(t){if(t!==Object(t))throw new TypeError("Invalid object");var e=[];for(var n in t)A.has(t,n)&&(e[e.length]=n);return e},A.values=function(t){var e=[];for(var n in t)A.has(t,n)&&e.push(t[n]);return e},A.pairs=function(t){var e=[];for(var n in t)A.has(t,n)&&e.push([n,t[n]]);return e},A.invert=function(t){var e={};for(var n in t)A.has(t,n)&&(e[t[n]]=n);return e},A.functions=A.methods=function(t){var e=[];for(var n in t)A.isFunction(t[n])&&e.push(n);return e.sort()},A.extend=function(t){return O(c.call(arguments,1),function(e){if(e)for(var n in e)t[n]=e[n]}),t},A.pick=function(t){var e={},n=f.apply(o,c.call(arguments,1));return O(n,function(n){n in t&&(e[n]=t[n])}),e},A.omit=function(t){var e={},n=f.apply(o,c.call(arguments,1));for(var r in t)A.contains(n,r)||(e[r]=t[r]);return e},A.defaults=function(t){return O(c.call(arguments,1),function(e){if(e)for(var n in e)null==t[n]&&(t[n]=e[n])
}),t},A.clone=function(t){return A.isObject(t)?A.isArray(t)?t.slice():A.extend({},t):t},A.tap=function(t,e){return e(t),t};var N=function(t,e,n,r){if(t===e)return 0!==t||1/t==1/e;if(null==t||null==e)return t===e;t instanceof A&&(t=t._wrapped),e instanceof A&&(e=e._wrapped);var i=l.call(t);if(i!=l.call(e))return!1;switch(i){case"[object String]":return t==String(e);case"[object Number]":return t!=+t?e!=+e:0==t?1/t==1/e:t==+e;case"[object Date]":case"[object Boolean]":return+t==+e;case"[object RegExp]":return t.source==e.source&&t.global==e.global&&t.multiline==e.multiline&&t.ignoreCase==e.ignoreCase}if("object"!=typeof t||"object"!=typeof e)return!1;for(var o=n.length;o--;)if(n[o]==t)return r[o]==e;n.push(t),r.push(e);var a=0,u=!0;if("[object Array]"==i){if(a=t.length,u=a==e.length)for(;a--&&(u=N(t[a],e[a],n,r)););}else{var s=t.constructor,c=e.constructor;if(s!==c&&!(A.isFunction(s)&&s instanceof s&&A.isFunction(c)&&c instanceof c))return!1;for(var f in t)if(A.has(t,f)&&(a++,!(u=A.has(e,f)&&N(t[f],e[f],n,r))))break;if(u){for(f in e)if(A.has(e,f)&&!a--)break;u=!a}}return n.pop(),r.pop(),u};A.isEqual=function(t,e){return N(t,e,[],[])},A.isEmpty=function(t){if(null==t)return!0;if(A.isArray(t)||A.isString(t))return 0===t.length;for(var e in t)if(A.has(t,e))return!1;return!0},A.isElement=function(t){return!(!t||1!==t.nodeType)},A.isArray=k||function(t){return"[object Array]"==l.call(t)},A.isObject=function(t){return t===Object(t)},O(["Arguments","Function","String","Number","Date","RegExp"],function(t){A["is"+t]=function(e){return l.call(e)=="[object "+t+"]"}}),A.isArguments(arguments)||(A.isArguments=function(t){return!(!t||!A.has(t,"callee"))}),"function"!=typeof/./&&(A.isFunction=function(t){return"function"==typeof t}),A.isFinite=function(t){return isFinite(t)&&!isNaN(parseFloat(t))},A.isNaN=function(t){return A.isNumber(t)&&t!=+t},A.isBoolean=function(t){return t===!0||t===!1||"[object Boolean]"==l.call(t)},A.isNull=function(t){return null===t},A.isUndefined=function(t){return void 0===t},A.has=function(t,e){return h.call(t,e)},A.noConflict=function(){return t._=r,this},A.identity=function(t){return t},A.times=function(t,e,n){for(var r=Array(t),i=0;t>i;i++)r[i]=e.call(n,i);return r},A.random=function(t,e){return null==e&&(e=t,t=0),t+Math.floor(Math.random()*(e-t+1))};var P={escape:{"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","/":"&#x2F;"}};P.unescape=A.invert(P.escape);var T={escape:new RegExp("["+A.keys(P.escape).join("")+"]","g"),unescape:new RegExp("("+A.keys(P.unescape).join("|")+")","g")};A.each(["escape","unescape"],function(t){A[t]=function(e){return null==e?"":(""+e).replace(T[t],function(e){return P[t][e]})}}),A.result=function(t,e){if(null==t)return null;var n=t[e];return A.isFunction(n)?n.call(t):n},A.mixin=function(t){O(A.functions(t),function(e){var n=A[e]=t[e];A.prototype[e]=function(){var t=[this._wrapped];return s.apply(t,arguments),R.call(this,n.apply(A,t))}})};var C=0;A.uniqueId=function(t){var e=++C+"";return t?t+e:e},A.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g};var M=/(.)^/,B={"'":"'","\\":"\\","\r":"r","\n":"n","	":"t","\u2028":"u2028","\u2029":"u2029"},F=/\\|'|\r|\n|\t|\u2028|\u2029/g;A.template=function(t,e,n){var r;n=A.defaults({},n,A.templateSettings);var i=new RegExp([(n.escape||M).source,(n.interpolate||M).source,(n.evaluate||M).source].join("|")+"|$","g"),o=0,a="__p+='";t.replace(i,function(e,n,r,i,u){return a+=t.slice(o,u).replace(F,function(t){return"\\"+B[t]}),n&&(a+="'+\n((__t=("+n+"))==null?'':_.escape(__t))+\n'"),r&&(a+="'+\n((__t=("+r+"))==null?'':__t)+\n'"),i&&(a+="';\n"+i+"\n__p+='"),o=u+e.length,e}),a+="';\n",n.variable||(a="with(obj||{}){\n"+a+"}\n"),a="var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n"+a+"return __p;\n";try{r=new Function(n.variable||"obj","_",a)}catch(u){throw u.source=a,u}if(e)return r(e,A);var s=function(t){return r.call(this,t,A)};return s.source="function("+(n.variable||"obj")+"){\n"+a+"}",s},A.chain=function(t){return A(t).chain()};var R=function(t){return this._chain?A(t).chain():t};A.mixin(A),O(["pop","push","reverse","shift","sort","splice","unshift"],function(t){var e=o[t];A.prototype[t]=function(){var n=this._wrapped;return e.apply(n,arguments),"shift"!=t&&"splice"!=t||0!==n.length||delete n[0],R.call(this,n)}}),O(["concat","join","slice"],function(t){var e=o[t];A.prototype[t]=function(){return R.call(this,e.apply(this._wrapped,arguments))}}),A.extend(A.prototype,{chain:function(){return this._chain=!0,this},value:function(){return this._wrapped}})}.call(this)},{}]},{},[7])(7)})

;/**
 * 
 * ## Offline database wrapper with Nedb
 * 
 * @namespace
 * 
 */
kiss.db.offline = {
    mode: "offline",

    // Store the various offline collections
    collections: {},

    // Convert id to _id
    toId(record) {
        record.id = record._id
        delete record._id
        return record
    },

    toIds(records) {
        records.forEach(record => {
            record.id = record._id
            delete record._id
        })
        return records
    },

    toMongoId(record) {
        record._id = record.id
        delete record.id
        return record
    },

    toMongoIds(records) {
        records.forEach(record => {
            record._id = record.id
            delete record.id
        })
        return records
    },

    /**
     * Creates a new collection
     * 
     * Does not do anything if the collection already exists.
     * This method should not be called directly: collections are created automatically by requesting them.
     * 
     * @ignore
     * @async
     * @param {string} modelId
     * @param {string} [dbMode] - Use "memory" to work with an in-memory collection
     * @returns {promise} Promise to have a collection created if it doesn't exist yet
     */
    async createCollection(modelId, dbMode = "offline") {
        log(`kiss.db.offline - createCollection <${modelId}> in mode <${(dbMode == "memory") ? "memory" : "offline"}>`)

        const newCollection = new Nedb({
            filename: modelId,
            autoload: true,
            timestampData: true,
            inMemoryOnly: (dbMode === "memory")
        })

        const collection = this.collections[modelId] = this.nedbWrapper.fromInstance(newCollection)
        await collection.loadDatabase()

        return collection
    },

    /**
     * Get a collection
     * 
     * This method should not be called directly: NeDb collections are retrieved automatically when requesting them.
     * 
     * @ignore
     * @async
     * @param {string} modelId
     * @param {string} [dbMode] - Use "memory" to work with an in-memory collection
     * @returns {promise} Promise to have a collection
     */
    async getCollection(modelId, dbMode = "offline") {
        if (!this.collections[modelId]) await this.createCollection(modelId, dbMode)
        return this.collections[modelId]
    },

    /**
     * Delete the local NeDb collection (memory or offline)
     * 
     * @async
     * @param {string} modelId
     * @returns {promise} Promise to have a the collection deleted
     */
    async deleteCollection(modelId) {
        const collection = this.collections[modelId]
        if (!collection) return

        collection.remove({}, {
            multi: true
        }, function (err, numRemoved) {
            if (err) {
                log("kiss.db.offline - deleteCollection - Error:", 4, err)
            } else {
                log("kiss.db.offline - deleteCollection - Num removed: " + numRemoved, 2)
            }
        })

        this.collections[modelId] = null
    },

    /**
     * Create an index for a collection
     * 
     * According to NeDb, this can give a significant performance boost when reading data.
     * 
     * @async
     * @param {string} modelId 
     * @param {string} fieldName
     * @param {string} [dbMode] - Use "memory" to work with an in-memory collection
     * @returns {promise} Promise to have a collection index created
     * 
     * @example
     * await db.offline.createCollectionIndex("users", {fieldName: "firstName"})
     */
    async createCollectionIndex(modelId, fieldName, dbMode = "offline") {
        const collection = await this.getCollection(modelId, dbMode)
        collection.ensureIndex({
            fieldName: fieldName
        })
    },

    /**
     * Insert one record in a collection. See [db.insertOne](kiss.db.html#.insertOne)
     * 
     * @async
     * @param {string} modelId
     * @param {object} record - A single record
     * @param {string} [dbMode] - Use "memory" to work with an in-memory collection
     * @returns {object} The inserted record data
     */
    async insertOne(modelId, record, dbMode = "offline") {
        log("kiss.db - " + dbMode + " - insertOne - Model " + modelId, 0, record)

        const collection = await this.getCollection(modelId, dbMode)
        record.createdBy = kiss.session.getUserId()

        this.toMongoId(record)
        const insertedRecord = await collection.insert(record)
        this.toId(record)

        // Broadcast
        const channel = "EVT_DB_INSERT:" + modelId.toUpperCase()
        kiss.pubsub.publish(channel, {
            channel,
            dbMode,
            accountId: kiss.session.getCurrentAccountId(),
            userId: kiss.session.getUserId(),
            modelId,
            id: record.id,
            data: record
        })

        return insertedRecord
    },

    /**
     * Insert many records in a collection. See [db.insertMany](kiss.db.html#.insertMany)
     * 
     * @async
     * @param {string} modelId
     * @param {object[]} records - An array of records [{...}, {...}] for bulk insert
     * @param {string} [dbMode] - Use "memory" to work with an in-memory collection
     * @returns {object[]} The array of inserted records data
     */
    async insertMany(modelId, records, dbMode = "offline") {
        log("kiss.db - " + dbMode + " - insertMany - Model" + modelId + " / " + records.length + " record(s)", 0, records)

        const collection = await this.getCollection(modelId, dbMode)
        const createdBy = kiss.session.getUserId()
        records.forEach(record => record.createdBy = createdBy)

        this.toMongoIds(records)
        const insertedRecords = await collection.insert(records)
        this.toIds(records)

        // Broadcast
        const channel = "EVT_DB_INSERT_MANY:" + modelId.toUpperCase()
        kiss.pubsub.publish(channel, {
            channel,
            dbMode,
            accountId: kiss.session.getCurrentAccountId(),
            userId: kiss.session.getUserId(),
            modelId,
            data: records
        })

        return insertedRecords
    },

    /**
     * Update a record then propagate the mutation to foreign records.
     * Note: it will generate a transaction processed with kiss.db.updateBulk
     * 
     * @async
     * @param {string} modelId
     * @param {string} recordId
     * @param {string} [update] - If not specified, re-compute all the computed fields
     * @param {string} [dbMode] - Use "memory" to work with an in-memory collection
     * @returns {boolean} true if the update is successful
     * 
     * @example
     * await kiss.db.updateOneDeep("company", "f07xF008d", {"name": "pickaform"})
     */    
    async updateOneDeep(modelId, recordId, update, dbMode = "offline") {
        log("kiss.db - " + dbMode + " - updateOneDeep - Model " + modelId + " / Record " + recordId, 0, update)

        const model = kiss.app.models[modelId]
        const record = await model.collection.findOne(recordId)

        return await kiss.data.relations.updateOneDeep(model, record, update)
    },

    /**
     * Update the 2 records connected by a link
     * 
     * @param {object} linkRecord
     * @returns The transaction result
     */    
     async updateLink(linkRecord) {
        log("kiss.db - offline - updateLink: ", 0, linkRecord)

        return await kiss.data.relations.updateLink(linkRecord)
    },

    /**
     * Update a single record in a collection. See [db.updateOne](kiss.db.html#.update)
     * 
     * @async
     * @param {string} modelId
     * @param {string} recordId
     * @param {string} update - Specifies how the record should be updated
     * @param {string} [dbMode] - Use "memory" to work with an in-memory collection
     * @returns {object} The updated record
     */
    async updateOne(modelId, recordId, update, dbMode = "offline") {
        log("kiss.db - " + dbMode + " - updateOne - Model " + modelId + " / Record " + recordId, 0, update)

        const collection = await this.getCollection(modelId, dbMode)
        update.updatedBy = kiss.session.getUserId()

        const response = await collection.update({
            _id: recordId
        }, {
            $set: update
        }, {
            upsert: false
        })

        // Broadcast
        const channel = "EVT_DB_UPDATE:" + modelId.toUpperCase()
        kiss.pubsub.publish(channel, {
            channel,
            dbMode,
            accountId: kiss.session.getCurrentAccountId(),
            userId: kiss.session.getUserId(),
            modelId,
            id: recordId,
            data: update
        })

        return response
    },

    /**
     * Update many records in a single collection. See [db.updateMany](kiss.db.html#.updateMany)
     * 
     * @async
     * @param {string} modelId
     * @param {object} query
     * @param {object} update
     * @param {string} [dbMode] - Use "memory" to work with an in-memory collection
     * 
     * TODO: NOT USED / NOT TESTED YET
     */
    async updateMany(modelId, query, update, dbMode = "offline") {
        log("kiss.db - " + dbMode + " - updateMany - Model " + modelId, 0, update)

        const collection = await this.getCollection(modelId, dbMode)
        update.updatedBy = kiss.session.getUserId()

        const response = await collection.update(query, {
            $set: update
        }, {
            multi: true
        })

        // Broadcast
        const channel = "EVT_DB_UPDATE_MANY:" + modelId.toUpperCase()
        kiss.pubsub.publish(channel, {
            channel,
            dbMode,
            accountId: kiss.session.getCurrentAccountId(),
            userId: kiss.session.getUserId(),
            modelId,
            data: update
        })

        return response
    },

    /**
     * Update many records in multiple collections. See [db.updateBulk](kiss.db.html#.updateBulk)
     * TODO: group operations by collection to avoid reseting the collection in the loop
     * TODO: use PromiseAll to parallelize update operations
     * 
     * @async
     * @param {object[]} operations - The list of updates to perform
     * @param {string} [dbMode] - Use "memory" to work with an in-memory collection
     * @returns {object} response - Empty object for offline/memory database
     */
    async updateBulk(operations, dbMode = "offline") {
        log("kiss.db - " + dbMode + " - updateBulk", 0, operations)

        const updatedBy = kiss.session.getUserId()

        for (let operation of operations) {

            const collection = await this.getCollection(operation.modelId, dbMode)
            operation.updates.updatedBy = updatedBy

            await collection.update({
                _id: operation.recordId
            }, {
                $set: operation.updates
            }, {
                upsert: false
            })
        }

        // Broadcast
        const channel = "EVT_DB_UPDATE_BULK"
        kiss.pubsub.publish(channel, {
            channel,
            dbMode,
            accountId: kiss.session.getCurrentAccountId(),
            userId: kiss.session.getUserId(),
            data: operations
        })

        return {}
    },

    /**
     * Find a single record in a collection. See [db.findOne](kiss.db.html#.findOne)
     * 
     * @async
     * @param {string} modelId 
     * @param {string} recordId
     * @param {string} [dbMode] - Use "memory" to work with an in-memory collection
     * @returns {object} The found record
     */
    async findOne(modelId, recordId, dbMode = "offline") {
        log("kiss.db - " + dbMode + " - findOne - Model " + modelId + " / Record " + recordId)

        const collection = await this.getCollection(modelId, dbMode)
        const record = await collection.findOne({
            _id: recordId
        })

        if (record) this.toId(record)
        return record
    },

    /**
     * Find multiple records by id
     * 
     * @async
     * @param {string} modelId 
     * @param {string[]} ids - ids of the records to retrieve
     * @param {object[]|object} [sort] - Sort options, as a normalized array or a Mongo object. Normalized example: [{fieldA: "asc"}, {fieldB: "desc"}]. Mongo example: {fieldA: 1, fieldB: -1}
     * @param {string} [sortSyntax] - Sort syntax: "nomalized" | "mongo". Default is normalized
     * @param {string} [dbMode] - Use "memory" to work with an in-memory collection
     * @returns {object[]} The found records
     */
    async findById(modelId, ids, sort = [], sortSyntax = "normalized", dbMode = "offline") {
        log("kiss.db - " + dbMode + " - findById - Model " + modelId + " / Records: " + ids.join())

        const collection = await this.getCollection(modelId, dbMode)
        let records

        if (sortSyntax.length == 0) {
            records = await collection.find({
                _id: {
                    "$in": ids
                }
            })
        }
        else {
            const sortObject = (sortSyntax == "normalized") ? kiss.db.mongo.convertSort(sort) : sort
            records = await collection.cfind({
                _id: {
                    "$in": ids
                }
            }).sort(sortObject).exec()
        }

        return this.toIds(records)
    },

    /**
     * Find documents in a collection. See [db.find](kiss.db.html#.find)
     * 
     * @async
     * @param {string} modelId
     * @param {object} [query] - Query object
     * @param {*} [query.filter] - The query
     * @param {string} [query.filterSyntax] - The query syntax. By default, passed as a normalized object
     * @param {*} [query.sort] - Sort fields
     * @param {string} [query.sortSyntax] - The sort syntax. By default, passed as a normalized array
     * @param {string[]} [query.group] - Array of fields to group by: ["country", "city"]
     * @param {boolean} [query.groupUnwind] - true to unwind the fields for records that belongs to multiple groups
     * @param {object} [query.projection] - {firstName: 1, lastName: 1, password: 0}
     * @param {object} [query.skip] - Number of records to skip
     * @param {object} [query.limit] - Number of records to return
     * @param {string} [dbMode] - Use "memory" to work with an in-memory collection
     * @returns {object[]} An array containing the records data
     */
    async find(modelId, query, dbMode = "offline") {
        log("kiss.db - " + dbMode + " - find - Model " + modelId + " / Query:", 0, query)

        let records
        const collection = await this.getCollection(modelId, dbMode)

        if (!query) {
            records = await collection.find({})
            return this.toIds(records)
        }

        // Sanitize the query
        const search = {
            operation: "search",
            filter: query.filter || {},
            filterSyntax: query.filterSyntax || "normalized",
            sort: query.sort || {},
            sortSyntax: query.sortSyntax || "normalized",
            group: query.group || [],
            projection: query.projection || {},
            skip: query.skip,
            limit: query.limit,
            groupUnwind: query.groupUnwind
        }

        // If sort or filter are normalized, we convert them to mongo syntax beforing sending request to database
        if (search.filterSyntax == "normalized") {
            search.filter = kiss.db.mongo.convertFilterGroup(search.filter)
        }

        if (search.sortSyntax == "normalized") {
            search.sort = kiss.db.mongo.convertSort(search.sort)
        }

        if (search.limit && search.limit > 0) {
            records = await collection.cfind(search.filter, search.projection).limit(search.limit).sort(search.sort).exec()
        }
        else {
            records = await collection.cfind(search.filter, search.projection).sort(search.sort).exec()
        }
        
        return this.toIds(records)
    },

    /**
     * Delete an element from a collection. See [db.delete](kiss.db.html#.delete)
     * 
     * @async
     * @param {string} modelId
     * @param {string} recordId
     * @param {boolean} [sendToTrash] - If true, keeps the original record in a "trash" collection
     * @param {string} [dbMode] - Use "memory" to work with an in-memory collection
     * @returns {object} {success: true} if the deletion is successful
     */
    async deleteOne(modelId, recordId, sendToTrash, dbMode = "offline") {
        log("kiss.db - " + dbMode + " - deleteOne - Model " + modelId + " / Record " + recordId)

        const collection = await this.getCollection(modelId, dbMode)

        // Copying record to trash collection prior to deletion
        if (sendToTrash) {
            await this.copyOneToTrash(modelId, recordId, dbMode)
        }

        await collection.remove({
            _id: recordId
        })

        // Broadcast
        const channel = "EVT_DB_DELETE:" + modelId.toUpperCase()
        kiss.pubsub.publish(channel, {
            channel,
            dbMode,
            accountId: kiss.session.getCurrentAccountId(),
            userId: kiss.session.getUserId(),
            modelId,
            id: recordId
        })

        // Deleting a dynamic record can trigger updates on its relations
        if (kiss.tools.isUid(modelId)) {
            const operations = await kiss.data.relations.updateForeignRecords(modelId, recordId)
            
            if (operations.length > 0) {
                const channel = "EVT_DB_UPDATE_BULK"
                kiss.pubsub.publish(channel, {
                    channel,
                    dbMode,
                    accountId: kiss.session.getAccountId(),
                    userId: kiss.session.getUserId(),
                    data: operations
                })				
            }
        }
        else if (modelId.startsWith("file")) {
            // TODO: remove file from local drive or Amazon S3
            
        }

        return true
    },

    /**
     * Delete many records from a collection
     * 
     * @param {string} modelId 
     * @param {object} query
     * @param {boolean} [sendToTrash] - If true, keeps the original records in a "trash" collection
     * @param {string} [dbMode] - Use "memory" to work with an in-memory collection
     * 
     * TODO: NOT TESTED YET
     */
    async deleteMany(modelId, query, sendToTrash, dbMode = "offline") {
        log("kiss.db - " + dbMode + " - deleteMany - Model " + modelId, 0, query)

        const collection = await this.getCollection(modelId, dbMode)

        // Copying records to trash collection prior to deletion
        if (sendToTrash) {
            await this.copyManyToTrash(modelId, query, dbMode)
        }

        const response = await collection.remove(
            query, {
                multi: true
            }
        )

        // Broadcast
        const channel = "EVT_DB_DELETE_MANY:" + modelId.toUpperCase()
        kiss.pubsub.publish(channel, {
            channel,
            dbMode,
            accountId: kiss.session.getCurrentAccountId(),
            userId: kiss.session.getUserId(),
            modelId,
            data: query
        })

        return response
    },

    /**
     * Count the number of records that match a query.
     * 
     * @async
     * @param {string} modelId
     * @param {object} query - Use same query format as for find() method
     * @param {string} [dbMode] - Use "memory" to work with an in-memory collection
     * @returns {number} The number of records
     */
    async count(modelId, query, dbMode) {
        log("kiss.db - " + dbMode + " - count - Model " + modelId, 0, query)

        const collection = await this.getCollection(modelId, dbMode)
        return await collection.count(query)
    },

    /**
     * Copy a record to the "trash" collection (recycle bin)
     * 
     * This is useful if you want to implement soft deletion
     * 
     * @async
     * @param {string} modelId 
     * @param {string} recordId 
     * @param {string} [dbMode] - Use "memory" to work with an in-memory collection 
     * @returns {object} The record copied to the trash with extra informations
     */
    async copyOneToTrash(modelId, recordId, dbMode = "offline") {
        // Get the record to move
        const record = await this.findOne(modelId, recordId, dbMode)

        // The record is associated to the account
        record.accountId = "anonymous"

        // Set the source collection to be able to restore at the right place later
        record.sourceModelId = modelId

        // Timestamp the deletion
        record.deletedAt = new Date().toISOString()
        record.deletedBy = "anonymous"

        await this.insertOne("trash", record, dbMode)
        return record
    },

    /**
     * Copy many records to the "trash" collection (recycle bin)
     * 
     * This is useful if you want to implement soft deletion
     * 
     * @async
     * @param {string} modelId 
     * @param {string} query 
     * @param {string} [dbMode] - Use "memory" to work with an in-memory collection 
     * @returns {object} The records copied to the trash with extra informations
     */
    async copyManyToTrash(modelId, query, dbMode = "offline") {
        // Get the records to move
        const records = await this.find(modelId, query, dbMode)
        const data = []

        for (record of records) {
            // The record is associated to the account
            record.accountId = "anonymous"

            // Set the source collection to be able to restore at the right place later
            record.sourceModelId = modelId

            // Timestamp the deletion
            record.deletedAt = new Date().toISOString()
            record.deletedBy = "anonymous"

            data.push(record)
        }

        await this.insertMany("trash", data, dbMode)

        return records
    },

    /**
     * 
     * Node.js Embedded Database (Nedb) wrapper
     * 
     * Nedb is a local / offline database developped by Louis Chatriot, both in-memory and persistent with IndexedDb or WebSQL or localStorage (or file-based storage for Node).
     * Nedb is the only accepted dependency for KissJS, because Nedb code is absolutely brilliant.
     * 
     * Nedb has the fastest and easiest api compared to:
     * - PouchDb: problems => can't update fields, but have to update full records + versioning high complexity
     * - Dixie: problems => boring static schema and schema versionning system
     * - LokiJS: problems => the localCollection must be integraly serialized to persist (ouch!)
     * 
     * The only small inconvenient of Nedb is that it only uses callbacks, hence, this wrapper to use it with Promises :)
     * 
     * @ignore
     */
    nedbWrapper: {

        /**
         * Transform a Nedb instance into a promisified (aka "thenified") version
         * 
         * @param {*} nedbInstance 
         */
        fromInstance(nedbInstance) {
            const newCollection = {
                nedb: nedbInstance // Keep the original Nedb in case we still want callbacks in some situations
            }

            // Convert main methods
            const methods = ['loadDatabase', 'insert', 'find', 'findOne', 'count', 'update', 'remove', 'ensureIndex', 'removeIndex']
            for (let i = 0; i < methods.length; ++i) {
                const method = methods[i]
                newCollection[method] = kiss.db.offline.nedbWrapper.thenify(nedbInstance[method].bind(nedbInstance))
            }

            // Convert cursor find
            newCollection.cfind = function (query, projections) {
                const cursor = nedbInstance.find(query, projections)
                cursor.exec = kiss.db.offline.nedbWrapper.thenify(cursor.exec.bind(cursor))
                return cursor
            }

            // Convert cursor findOne
            newCollection.cfindOne = function (query, projections) {
                const cursor = nedbInstance.findOne(query, projections)
                cursor.exec = kiss.db.offline.nedbWrapper.thenify(cursor.exec.bind(cursor))
                return cursor
            }

            // Convert cursor count
            newCollection.ccount = function (query) {
                const cursor = nedbInstance.count(query)
                cursor.exec = kiss.db.offline.nedbWrapper.thenify(cursor.exec.bind(cursor))
                return cursor
            }

            return newCollection
        },

        /**
         * Create the wrapper to transform a function with callbaks into a Promise.
         * 
         * @param {string} name - Method name
         * @param {object} options - {withCallback: true|false, multiArgs: true|false}
         * @returns {string} - The string representation of the "thenified" function, ready to be evaluated
         */
        create: function (name, options) {
            name = (name || '').replace(/\s|bound(?!$)/g, '')
            options = options || {}

            var multiArgs = options.multiArgs !== undefined ? options.multiArgs : true
            multiArgs = 'var multiArgs = ' + JSON.stringify(multiArgs) + '\n'

            var withCallback = options.withCallback ?
                'var lastType = typeof arguments[len - 1]\n' +
                'if (lastType === "function") return $$__fn__$$.apply(self, arguments)\n' :
                ''

            return '(function ' + name + '() {\n' +
                'var self = this\n' +
                'var len = arguments.length\n' +
                multiArgs +
                withCallback +
                'var args = new Array(len + 1)\n' +
                'for (var i = 0; i < len; ++i) args[i] = arguments[i]\n' +
                'var lastIndex = i\n' +
                'return new Promise(function (resolve, reject) {\n' +
                'args[lastIndex] = kiss.db.offline.nedbWrapper.createCallback(resolve, reject, multiArgs)\n' +
                '$$__fn__$$.apply(self, args)\n' +
                '})\n' +
                '})'
        },

        /**
         * Turn async functions into promises
         *
         * @param {function} $$__fn__$$ - Function to thenify
         * @param {object} options - {withCallback: true|false, multiArgs: true|false}
         * @returns {function} - The wrapped function
         */
        thenify: function ($$__fn__$$, options) {
            return eval(this.create($$__fn__$$.name, options))
        },

        /**
         * Generates the callback for the "thenified" function
         * 
         * @param {function} resolve 
         * @param {function} reject 
         * @param {boolean} multiArgs
         */
        createCallback: function (resolve, reject, multiArgs) {
            return function (err, value) {
                if (err) return reject(err)
                const length = arguments.length

                if (length <= 2 || !multiArgs) return resolve(value)

                if (Array.isArray(multiArgs)) {
                    let values = {}
                    for (let i = 1; i < length; i++) values[multiArgs[i - 1]] = arguments[i]
                    return resolve(values)
                }

                let values = new Array(length - 1)
                for (let i = 1; i < length; ++i) values[i - 1] = arguments[i]
                resolve(values)
            }
        }
    }
};

/**
 * Turn async functions into promises and backward compatible with callback
 *
 * @param {function} $$__fn__$$ - Function to thenify
 * @param {object} options - {withCallback: true|false, multiArgs: true|false}
 * @returns {function} - The wrapped function
 */
kiss.db.offline.nedbWrapper.thenify.withCallback = function ($$__fn__$$, options) {
    options = options || {}
    options.withCallback = true
    if (options.multiArgs === undefined) options.multiArgs = true
    return eval(kiss.db.offline.nedbWrapper.create($$__fn__$$.name, options))
}

;/**
 * 
 * ## Online database wrapper for KissJS server
 * 
 * Standard REST requests are performed for basic CRUD operations, except for:
 * - find(modelId, query)
 * - findById(modelId, ids, sort, sortSyntax)
 * - updateOneDeep(modelId, recordId, update)
 * - updateBulk(operations)
 * - deleteOne(modelId, recordId, sendToTrash)
 * - deleteMany(modelId, query, sendToTrash)
 * 
 * **Remember: these custom methods are design for KissJS server, and will not behave the same if used on another REST endpoint.**
 * 
 * The **find** method provides a rich and expressive way of querying the database with a **query** parameter.
 * The query can be an object with complex filters (multi-level AND / OR) and multi-field sorting, so, we need a way to send that (eventually big) object to the server.
 * As the HTTP GET method has some limitations about the amount of data that can be sent, KissJS uses a POST instead (despite it's a READ operation).
 * 
 * The **updateOneDeep** method performs a deep update of the record and its relationships.
 * This is the main method used to perform the updates of foreign records in a NoSQL environment.
 * 
 * The **updateBulk** method offers a convenient way to perform multiple updates in multiple collections at once.
 * The operations parameter is an array of operations, where each operation contains:
 * - the target modelId
 * - the target recordId
 * - the updates to apply to the target record
 * 
 * The **deleteOne** and **deleteMany** operations have an extra "sendToTrash" parameter which is useful to implement soft-deletion.
 * 
 * Below is a table of correspondance between the API and how it is converted to HTTP requests:
 *  
 * kiss.db.online | HTTP | HTTP body
 * --- | --- | ---
 * insertOne(modelId, record) | POST /modelId | record
 * insertMany(modelId, records) | POST /modelId | records
 * updateOne(modelId, recordId, update) | PATCH /modelId/recordId | update
 * updateOneDeep(modelId, recordId, update) | PATCH /modelId/recordId | {operation: "updateOneDeep", update} => update the record and its relationships
 * updateMany(modelId, query, update) | PATCH /modelId | query+update
 * updateBulk(operations) | PATCH /data | operations
 * findOne(modelId, recordId) | GET /modelId/recordId | <none>
 * findById(modelId, ids, sort, sortSyntax) | POST /modelId | Array of ids
 * find(modelId) | GET /modelId | <none>
 * find(modelId, query) | POST /modelId | query
 * deleteOne(modelId, recordId, sendToTrash) | DELETE /modelId/recordId | {sendToTrash: true/false}
 * deleteMany(modelId, query, sendToTrash) | POST /modelId | {operation: "delete", sendToTrash: true/false}
 * 
 * @namespace kiss.db.online
 * 
 */
kiss.db.online = {
    // Database endpoint, which defaults to the server root path url
    url: "",

    /**
     * Insert one record in a collection. See [db.insertOne](kiss.db.html#.insertOne)
     * 
     * @async
     * @param {string} modelId
     * @param {object} record - A single record
     * @returns {object} The server response
     */
    async insertOne(modelId, record) {
        log("kiss.db - online - insertOne - Model " + modelId, 0, record)

        const response = await kiss.ajax.request({
            url: "/" + modelId,
            method: "post",
            body: JSON.stringify(record)
        })

        // Broadcast
        const channel = "EVT_DB_INSERT:" + modelId.toUpperCase()
        kiss.pubsub.publish(channel, {
            channel,
            dbMode: "online",
            accountId: kiss.session.getCurrentAccountId(),
            userId: kiss.session.getUserId(),
            modelId,
            id: record.id,
            data: record
        })

        return response
    },

    /**
     * Insert many records in a collection. See [db.insertMany](kiss.db.html#.insertMany)
     * 
     * @async
     * @param {string} modelId
     * @param {object[]} records - An array of records [{...}, {...}] for bulk insert
     * @returns {object} The server response
     */
    async insertMany(modelId, records) {
        log("kiss.db - online - insertMany - Model " + modelId + " / " + records.length + " record(s)", 0, records)

        const response = await kiss.ajax.request({
            url: "/" + modelId,
            method: "post",
            body: JSON.stringify(records)
        })

        // Broadcast
        const channel = "EVT_DB_INSERT_MANY:" + modelId.toUpperCase()
        kiss.pubsub.publish(channel, {
            channel,
            dbMode: "online",
            accountId: kiss.session.getCurrentAccountId(),
            userId: kiss.session.getUserId(),
            modelId,
            data: records
        })

        return response
    },

    /**
     * Update a record in a collection. See [db.updateOne](kiss.db.html#.update)
     * 
     * @async
     * @param {string} modelId
     * @param {string} recordId
     * @param {string} update - Update to apply to the record. Ex: {firstName: "Bob"}
     * @returns {object} The server response
     */
    async updateOne(modelId, recordId, update) {
        log("kiss.db - online - updateOne - Model " + modelId + " / Record " + recordId, 0, update)

        const response = await kiss.ajax.request({
            url: "/" + modelId + "/" + recordId,
            method: "patch",
            body: JSON.stringify(update)
        })

        // Broadcast
        const channel = "EVT_DB_UPDATE:" + modelId.toUpperCase()
        kiss.pubsub.publish(channel, {
            channel,
            dbMode: "online",
            accountId: kiss.session.getCurrentAccountId(),
            userId: kiss.session.getUserId(),
            modelId,
            id: recordId,
            data: update
        })

        return response
    },

    /**
     * Update many records in a single collection. See [db.updateMany](kiss.db.html#.updateMany)
     * 
     * @async
     * @param {string} modelId
     * @param {object} query
     * @param {object} update
     * @returns {object} The server response
     * 
     * TODO: NOT TESTED YET
     */
    async updateMany(modelId, query, update) {
        log("kiss.db - online - updateMany - Model " + modelId, 0, update)

        const response = await kiss.ajax.request({
            url: "/" + modelId,
            method: "patch",
            body: JSON.stringify({
                query: query,
                update: update
            })
        })

        // Broadcast
        const channel = "EVT_DB_UPDATE_MANY:" + modelId.toUpperCase()
        kiss.pubsub.publish(channel, {
            channel,
            dbMode: "online",
            accountId: kiss.session.getCurrentAccountId(),
            userId: kiss.session.getUserId(),
            modelId,
            data: update
        })

        return response
    },

    /**
     * Update a single field of a record then propagate the triggered mutations to foreign records
     * 
     * IMPORTANT: this method does not broadcast to the active user because
     * all relationships computations are done server-side
     * 
     * @async
     * @param {string} modelId
     * @param {string} recordId
     * @param {string} [update] - If not specified, re-compute all the computed fields
     * @returns {boolean} true if the update is successful
     * 
     * @example
     * await kiss.db.updateOneDeep("company", "f07xF008d", {"name": "pickaform"})
     */
    async updateOneDeep(modelId, recordId, update) {
        log("kiss.db - online - updateOneDeep - Model " + modelId + " / Record " + recordId, 0, update)

        const response = await kiss.ajax.request({
            url: "/" + modelId + "/" + recordId,
            method: "patch",
            body: JSON.stringify({
                operation: "updateOneDeep",
                update
            })
        })

        // Broadcast
        const channel = "EVT_DB_UPDATE_ONE_DEEP:" + modelId.toUpperCase()
        kiss.pubsub.publish(channel, {
            channel,
            dbMode: "online",
            accountId: kiss.session.getCurrentAccountId(),
            userId: kiss.session.getUserId(),
            modelId,
            id: recordId,
            data: update
        })

        return response
    },

    /**
     * Update the 2 records connected by a link
     * 
     * @param {object} link 
     * @returns The transaction result
     */
    async updateLink(link) {
        log("kiss.db - online - updateLink: ", 0, link)

        const response = await kiss.ajax.request({
            url: "/updateLink",
            method: "post",
            body: JSON.stringify(link)
        })

        return response
    },

    /**
     * Update multiple records in multiple collections. See [db.updateBulk](kiss.db.html#.updateBulk)
     * 
     * @async
     * @param {object[]} operations - The list of updates to perform
     * @returns {object} The server response
     */
    async updateBulk(operations) {
        log("kiss.db - online - updateBulk", 0, operations)

        const response = await kiss.ajax.request({
            url: "/bulk",
            method: "patch",
            body: JSON.stringify(operations)
        })

        // Broadcast
        const channel = "EVT_DB_UPDATE_BULK"
        kiss.pubsub.publish(channel, {
            channel,
            dbMode: "online",
            accountId: kiss.session.getCurrentAccountId(),
            userId: kiss.session.getUserId(),
            data: operations
        })

        return response
    },

    /**
     * Find a single record by id. See [db.findOne](kiss.db.html#.findOne)
     * 
     * @async
     * @param {string} modelId 
     * @param {string} recordId
     * @returns {object} The server response
     */
    async findOne(modelId, recordId) {
        log("kiss.db - online - findOne - Model " + modelId + " / Record " + recordId)

        return await kiss.ajax.request({
            url: "/" + modelId + "/" + recordId,
            method: "get"
        })
    },

    /**
     * Find multiple records by id
     * 
     * @async
     * @param {string} modelId 
     * @param {string[]} ids - ids of the records to retrieve
     * @param {object[]|object} [sort] - Sort options, as a normalized array or a Mongo object. Normalized example: [{fieldA: "asc"}, {fieldB: "desc"}]. Mongo example: {fieldA: 1, fieldB: -1}
     * @param {string} [sortSyntax] - Sort syntax: "nomalized" | "mongo". Default is normalized
     * @returns {object[]} The found records
     */
     async findById(modelId, ids, sort = [], sortSyntax = "normalized") {
        log("kiss.db - online - findById - Model " + modelId + " / Records: " + ids.join())

        const search = {
            operation: "search",
            ids,
            sort,
            sortSyntax
        }

        return await kiss.ajax.request({
            url: "/" + modelId,
            method: "post",
            body: JSON.stringify(search)
        })
    },

    /**
     * Find documents in a collection. See [db.find](kiss.db.html#.find)
     * 
     * Important:
     * - without query params, it uses standard GET
     * - with query params, the only way is to "POST" the request to the server
     * In effet, the HTTP GET query parameters are limited in size, which is blocking to handle complex queries.
     * 
     * @async
     * @param {string} modelId
     * @param {object} [query] - Optional query object
     * @returns {object[]} An array containing the records data
     */
    async find(modelId, query) {
        log("kiss.db - online - find - Model " + modelId + " / Query:", 0, query)

        // No query: we return all records with a find()
        if (!query) {
            return await kiss.ajax.request({
                url: "/" + modelId,
                method: "get"
            })
        }

        // Sanitize the query
        const search = {
            operation: "search",
            filter: query.filter || {},
            filterSyntax: query.filterSyntax || "normalized",
            sort: query.sort || {},
            sortSyntax: query.sortSyntax || "normalized",
            group: query.group || [],
            projection: query.projection || {},
            skip: query.skip,
            limit: query.limit,
            groupUnwind: query.groupUnwind
        }

        return await kiss.ajax.request({
            url: "/" + modelId,
            method: "post", // Only way to post the query object properly
            body: JSON.stringify(search)
        })
    },

    /**
     * Delete an element from a collection. See [db.delete](kiss.db.html#.delete)
     * 
     * @async
     * @param {string} modelId
     * @param {string} recordId
     * @param {boolean} [sendToTrash] - If true, keeps the original record in a "trash" collection
     * @returns {boolean}
     */
    async deleteOne(modelId, recordId, sendToTrash) {
        log("kiss.db - online - deleteOne - Model " + modelId + " / Record " + recordId)

        const response = await kiss.ajax.request({
            url: "/" + modelId + "/" + recordId,
            method: "delete",
            body: JSON.stringify({
                sendToTrash: !!sendToTrash
            })
        })

        // Broadcast
        const channel = "EVT_DB_DELETE:" + modelId.toUpperCase()
        kiss.pubsub.publish(channel, {
            channel,
            dbMode: "online",
            accountId: kiss.session.getCurrentAccountId(),
            userId: kiss.session.getUserId(),
            modelId,
            id: recordId
        })

        return response
    },

    /**
     * Delete many records from a collection
     * 
     * Note: REST doesn't have any standard way to perform a bulk delete.
     * For this, we use a custom POST operation, as suggested in the Google API Design Guide
     * 
     * @param {string} modelId 
     * @param {object} query
     * @param {boolean} [sendToTrash] - If true, keeps the original record in a "trash" collection
     * @returns {object} The server response
     */
    async deleteMany(modelId, query, sendToTrash) {
        log("kiss.db - online - deleteMany - Model " + modelId, 0, query)

        const params = {
            operation: "delete",
            filter: query || {},
            sendToTrash: !!sendToTrash
        }

        const response = await kiss.ajax.request({
            url: "/" + modelId,
            method: "post", // Only way to post the query object properly
            body: JSON.stringify(params),
            showLoading: true
        })

        // Broadcast
        const channel = "EVT_DB_DELETE_MANY:" + modelId.toUpperCase()
        kiss.pubsub.publish(channel, {
            channel,
            dbMode: "online",
            accountId: kiss.session.getCurrentAccountId(),
            userId: kiss.session.getUserId(),
            modelId,
            data: query
        })

        return response
    },

    /**
     * Count the number of records that match a query
     * 
     * @async
     * @param {string} modelId
     * @param {object} query - Use same query format as for find() method
     * @returns {number} The number of records
     */
    count(modelId, query) {
        log("kiss.db - online - count - Model " + modelId, 0, query)

        // TODO
        return 42
    }
}

;/**
 * 
 * ## A simple ACL manager
 * 
 * This small module provides an isomorphic record-based ACL.
 * 
 * The ACL ensures that a user has the PERMISSION to perform an ACTION.
 * To check this, the ACL configuration consists of RULES and VALIDATOR functions (aka "validators"):
 * 
 * ```
 *    acl: {
 *       permissions: {
 *           create: [
 *               { isOwner: true } // <= RULE
 *           ],
 *           read: [
 *               { authenticatedCanRead: true }, // RULE 1
 *               { isReader: true } // RULE 2 (evaluated only if RULE 1 is false)
 *           ],
 *           update: [
 *               { isOwner: true, isBanned: false }, // <= RULE with 2 conditions to fulfill
 *               { isDesigner: true }
 *           ],
 *           delete: [
 *               { isOwner: true }
 *           ],
 *           paintCar: [ // <= any arbitrary ACTION can be evaluated, not only CRUD operations
 *               { isOwner : true}
 *           ]
 *       },
 *   
 *       validators: {
 *           async isOwner({req}) { // <= VALIDATOR function
 *               if (kiss.isClient) return kiss.session.isOwner // <= ACL can be checked on the client or the server
 *               else return req.token.isOwner
 *           },
 *   
 *           async isDesigner({userACL, record}) {
 *               return kiss.tools.intersects(userACL, record.accessUpdate)
 *           },
 *   
 *           async authenticatedCanRead({record}) {
 *               return !!record.authenticatedCanRead
 *           },
 *   
 *           async isReader({userACL, record}) {
 *               if (record.accessRead && kiss.tools.intersects(userACL, record.accessRead)) return true
 *           },
 * 
 *           async isBanned({userACL, record}) {
 *               return (userACL.indexOf("banned") != -1)
 *           }
 *       }
 *    }
 * ```
 * 
 * This way, it's very straightforward to read the permissions, even with complex business cases.
 * 
 * In the example above, the PERMISSION to UPDATE requires the user:
 * - to be an owner AND not to be banned
 * OR
 * - to be a designer
 * 
 * The validator functions are called to evaluate those rules.
 * 
 * The rules are evaluated sequentially, and it stops if a rule is fulfilled.
 * A single rule can have multiple validators, for example:
 * { isOwner: false, isDesigner: true }
 * 
 * All the validators of a rule must pass to consider the rule fulfilled.
 * 
 * Inside a validator, we can use kiss.isClient and kiss.isServer to check where the code is executed.
 * This allows to have specific code depending on the execution context.
 * 
 * Validator functions used for creation and mutations (create, patch, delete) receive an object with 4 properties:
 * - req: the server request object
 * - userACL: an array of string containing all the names that identify a user, including groups.
 * - record: the database record we're trying to access
 * - model: the record's model
 * 
 * A validator function used for the "read" action receives an object with 3 properties:
 * - req: the server request object
 * - userACL
 * - record: the database record to evaluate. The validator returns true if the record matches the requirements.
 * 
 * For the "read" operation, the validators are evaluated against **each** record to filter data according to the user's permissions.
 * 
 * When executed on the CLIENT, the req property is not sent (the request doesn't exist here).
 * Validators are asynchronous because they sometimes need to retrieve database objects.
 * 
 * @namespace
 * 
 */
kiss.acl = {
    /**
     * Check a permission to perform an action on a record
     * 
     * @async
     * @param {object} config
     * @param {string} config.action - Ex: "create", "update", "read", "paintCar", "setCharacterName"
     * @param {object} config.record - CLIENT ONLY - record which we want to check the access rights
     * @param {object} config.req - SERVER ONLY - Server request object
     * @returns {boolean} true if permission is granted
     * 
     * @example
     * const record = await kiss.db.findOne("opportunity", {
     *  _id: "01890143-81ba-71bb-a1e9-155872656bdf"
     * })
     * 
     * const canUpdate = await kiss.acl.check({
     *  action: "update",
     *  record
     * })
     * console.log(canUpdate) // true or false
     */
    async check({action, record}) {
        const userACL = kiss.session.getACL()
        let model = record.model

        try {
            const acl = (kiss.tools.isUid(model.id)) ? kiss.app.models.dynamicModel.acl : model.acl
            
            // No acl defined = everyone has access
            if (!acl) return true

            // No permissions defined = everyone has access
            const permissions = acl.permissions
            if (!permissions) return true
    
            const permissionRules = permissions[action]
            if (!permissionRules) return true

            // Check every rule
            for (let rule of permissionRules) {
    
                let hasPermission = true
                const validators = Object.keys(rule)
    
                for (let validator of validators) {
                    const ruleTestValue = rule[validator]
                    const ruleFunction = acl.validators[validator]

                    if (ruleFunction) {
                        const permissionCheck = await ruleFunction({
                            userACL,
                            model,
                            record
                        })
                        
                        // Flag if a condition fails
                        if (permissionCheck != ruleTestValue) hasPermission = false
                        
                        log(`kiss.acl - check (client) - ${action} - Model: ${model.name} ${record.id.slice(0, 7)}... Permission: ${validator} = ${permissionCheck} - Access ${(hasPermission) ? "granted" :  "denied"}`, (hasPermission) ? 2 : 4)
                    }
                    else {
                        log(`kiss.acl - check (client) - Error: validator function <${validator}> is not defined for model ${model.id}`, 4)
                    }
                }
    
                // All conditions passed
                if (hasPermission) return true
            }
    
            return false

        } catch(err) {
            log(`kiss.acl - check (client) - Validator error - Model: ${model.id}`, 4, err)
            return false
        }
    },

    /**
     * Filter records for "read"" operations (find, findAndSort)
     * 
     * The rules defined in the "read" configuration of the acl object are evaluated against **each** record.
     * For this reason, this ACL system should be applied only to small sets of records (ex: workspaces, applications...)
     * but not on big sets of records (like dynamic tables with thousands of records).
     * 
     * For big sets of records, the ACL should not be record-based (per record), but model-based (per table/collection)
     * 
     * @async
     * @param {object} config
     * @param {object[]} config.records - records to filter
     * @param {object} config.req - SERVER ONLY - Server request
     * @returns {object[]} filtered records
     * 
     * @example
     * // Inside a NodeJS controller
     * const records = await kiss.db.find("opportunity", {}) // Retrieve all the opportunities
     * 
     * const authorizedRecords = await kiss.acl.filter({
     *  records,
     *  req
     * })
     * console.log(authorizedRecords) // Show only the records where the user has a read access
     * 
     */
    async filter({records}) {
        const userACL = kiss.session.getACL()
        const firstRecord = records[0]
        const model = firstRecord.model

        try {
            // No acl defined = everyone has access
            const acl = model.acl
            if (!acl) return true

            // No permissions defined = everyone has access
            const permissions = acl.permissions
            if (!permissions) return true

            const permissionRules = permissions.read
            if (!permissionRules) return true

            let hasPermission
            let result = []

            for (record of records) {

                // Check every rule
                for (let rule of permissionRules) {
                    const validators = Object.keys(rule)
                    hasPermission = true

                    // Check every validator of the rule
                    // The must ALL be fulfilled to validate the rule
                    for (let validator of validators) {
                        const ruleTestValue = rule[validator]
                        const ruleFunction = acl.validators[validator]

                        if (ruleFunction) {
                            const permissionCheck = await ruleFunction({
                                userACL,
                                record
                            })
                            
                            log("kiss.acl - filter (client) - Permission: " + validator + " / " + permissionCheck, (permissionCheck) ? 2 : 4)

                            // If a validator fails, the rule is not fulfilled => we skip to the next rule
                            if (permissionCheck != ruleTestValue) {
                                hasPermission = false
                                break
                            }
                        }
                    }

                    if (hasPermission) break
                }

                // All conditions passed
                if (hasPermission) result.push(record)
            }

            return result

        } catch (err) {
            log(`kiss.acl - filter (client) - Validator error - Model: ${model.id} / Validator: ${validator}`, 4, err)
            return false
        }
    }
}

;/**
 * 
 * ## Ajax operations
 * 
 * Just syntax sugar over the standard **fetch** API.
 * 
 * @namespace
 * 
 */
kiss.ajax = {
    timeout: 60000,

    // Default headers
    headers: {
        "Accept": "application/json",
        "Content-Type": "application/json; charset=UTF-8"
    },

    // If the host is set, it will be prepended to each request URL
    host: "",

    /**
     * Set the host for the requests.
     * You can use this method to set the base URL for the requests.
     * 
     * @param {string} host
     * 
     * @example
     * kiss.ajax.setHost("https://api.example.com:3000")
     */
    setHost(host = "") {
        kiss.ajax.host = host
    },

    /**
     * Set the request headers
     * 
     * @param {object} headers
     * 
     * @example
     * kiss.ajax.setHeaders({
     *  "Accept": "application/json",
     *  "Content-Type": "application/json; charset=UTF-8"
     * })
     */
    setHeaders(headers) {
        kiss.ajax.headers = headers
    },

    /**
     * Encapsulate the Fetch API to automate:
     * - Content-Type header
     * - Authorization header (Bearer) using the Json Web Token provided by kiss.session
     * - Body parsing
     * - Timeout management (default to 60000 ms)
     * - Automatically sets the "boundary" parameter for multipart/form-data content
     * - Process HTTP error codes:
     *      . 401 redirects to login page
     *      . 403 (forbidden) sends a notification
     *      . 498 (token expired) tries to get a new token using the refresh token, and redirects to login if failed
     * 
     * @async
     * @param {object} params - A single object containing the following:
     * @param {string} [params.host] - Optional host to prepend to the URL in replacement of the default host
     * @param {string} params.url - Url to request
     * @param {string} params.method - get, post, put, patch, delete, options - Default to get
     * @param {object} params.accept - Accept header
     * @param {object} params.contentType - Content Type header - Default to application/json; charset=UTF-8
     * @param {object} params.authorization - Authorization header
     * @param {object} params.accessControlAllowOrigin - Access Control Allow Origin
     * @param {object} params.accessControlAllowHeaders - Access Control Allow Headers
     * @param {object|string} params.body - body for post, put and patch requests
     * @param {number} params.timeout - in milliseconds. Throw an error in timeout exceeded.
     * @param {boolean} params.showLoading - If true, show the loading spinner while loading - Default to false
     * @returns Request's result, or false if it failed
     * 
     * @example
     * // Posting with simple JSON:
     * kiss.ajax.request({
     *      url: "https://www.your_url.com/api/endpoint",
     *      method: "post",
     *      accept: "application/json",
     *      contentType: "application/json; charset=UTF-8",
     *      body: JSON.stringify({
     *          foo: "bar",
     *          hello: "world"
     *      }),
     *      timeout: 60000 // 60 seconds
     * })
     * .then(data => {
     *      console.log(data)
     * })
     * .catch(err => {
     *      console.log(err)
     * })
     * 
     * // Posting with basic authentication and application/x-www-form-urlencoded:
     * kiss.ajax.request({
     *      url: "https://www.your_url.com/api/endpoint",
     *      method: "post",
     *      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
     *      authorization: "Basic " + btoa(YOUR_LOGIN + ":" + YOUR_PASSWORD),
     *      body: "foo=bar&hello=world"
     * })
     */
    async request(params) {
        log(`kiss.ajax - request - ${params.method || "GET"}: ${params.url}`)

        let options = {
            method: params?.method?.toUpperCase() || "GET",
            headers: kiss.ajax.headers
        }

        // Inject authorization header with the active token
        // kissjs keeps the token in the localStorage until a logout is triggered
        const token = kiss.session.getToken()
        if (token) options.headers["Authorization"] = "Bearer " + token

        if (params.accept) options.headers["Accept"] = params.accept
        if (params.authorization) options.headers["Authorization"] = params.authorization
        if (params.accessControlAllowOrigin) options.headers["Access-Control-Allow-Origin"] = params.accessControlAllowOrigin
        if (params.accessControlAllowHeaders) options.headers["Access-Control-Allow-Headers"] = params.accessControlAllowHeaders
        if (params.body) options.body = params.body

        // Adjust content type
        if (params.contentType) {
            if (params.contentType == "multipart/form-data") {
                // For multipart/form-data, we delete the content type to force the browser
                // to infer the content type and set the "boundary" paramater automatically
                delete options.headers["Content-Type"]
            } else {
                options.headers["Content-Type"] = params.contentType
            }
        } else {
            // Default to application/json and UTF-8 encoding
            options.headers["Content-Type"] = "application/json; charset=UTF-8"
        }

        // Manage timeout
        const timeout = params.timeout || kiss.ajax.timeout
        const abortController = new AbortController()
        options.signal = abortController.signal
        setTimeout(() => abortController.abort(), timeout)

        let loadingId
        if (params.showLoading) {
            loadingId = kiss.loadingSpinner.show()
        }

        // Build url using default host or the one provided in the params
        // Having a default host will point every request to the same server
        const url = (params.host || params.host === "") ? params.host + params.url : kiss.ajax.host + params.url

        return fetch(url, options)
            .then(async response => {

                if (params.showLoading) {
                    kiss.loadingSpinner.hide(loadingId)
                }
        
                switch (response.status) {
                    case 401:
                        // Unauthorized requests are redirected to the login page
                        kiss.session.showLogin()
                        return false

                    case 498:
                        // Prevent loops for invalid tokens
                        if (kiss.global.ajaxRetries >= kiss.global.ajaxMaxRetries) {
                            kiss.global.ajaxRetries = 0
                            return false
                        }
                        kiss.global.ajaxRetries++

                        // Means the token to request the server is expired.
                        // Sends a request to refresh the token
                        const newToken = await kiss.session.getNewToken()

                        if (newToken) {
                            // Retry the original request
                            return await kiss.ajax.request(params)
                        }
                        break

                    case 403:
                        // Means the access to the resource is forbidden
                        const data = await response.json()
                        if (data.error) {
                            createNotification(txtTitleCase(data.error))
                        }
                        else {
                            createNotification(txtTitleCase("#not authorized"))
                        }

                    default:
                        return response.json().then(data => {
                            return data
                        }).catch(err => {
                            // The response is not JSON
                            return response
                        })
                }
            })
            .catch(err => {
                if (err.name == "AbortError") {
                    log("kiss.ajax - request - Timeout!", 4, err)
                    createNotification(txtTitleCase("#error slow connection"))
                } else {
                    log("kiss.ajax - request - Error:", 4, err)
                    log("kiss.ajax - The original request was:", 4, params)
                }

                if (params.showLoading) {
                    loadingId = kiss.loadingSpinner.hide(loadingId)
                }
                                
                return false
            })
    },

    /**
     * Adjust the request timeout
     * 
     * @param {number} timeout - in milliseconds
     */
    setTimeout(timeout) {
        if (typeof timeout === "number") kiss.ajax.timeout = timeout
    }
}

;/**
 * 
 * ## Kiss application manager
 * 
 * This module allows to:
 * - define and access **models**
 * - define and access **collections**
 * - define **views**
 * - define **view controllers**
 * - **init** the application using kiss.app.init()
 * 
 * Once the models and collections are defined, they are stored in the **app** object.
 * ```
 * // Getting models and collections
 * const appModels = kiss.app.models
 * const appCollections = kiss.app.collections
 * 
 * // Getting a model definition or a collection
 * const userModel = appModels.user
 * const userCollection = appCollections.user
 * 
 * // Using the model
 * const Bob = userModel.create({firstName: "Bob", lastName: "Wilson"})
 * await Bob.save()
 * 
 * // Using the collection if you're not sure it's loaded in memory (async method)
 * const John = await userCollection.findOne("123")
 * 
 * // Using the collection if it's already loaded in memory (sync method)
 * const Will = userCollection.getRecord("456")
 * ```
 * 
 * @namespace
 */
kiss.app = {

    // Reserved namespace for form templates
    formTemplates: {},

    // Reserved namespace for view templates
    viewTemplates: {},

    /**
     * Store the application models.
     * [More about models here.](kiss.data.Model.html)
     * 
     * @example
     * const userModel = kiss.app.models.user
     */
    models: {},

    /**
     * Store the application collections.
     * [More about collections here.](kiss.data.Collection.html)
     * 
     * @example
     * const userCollection = kiss.app.collections.user
     */
    collections: {},

    /**
     * Define all the application texts that can be translated.
     * Each text will be used as an English text if it doesn't have any english translation.
     * 
     * @param {object} texts
     * 
     * @example
     * kiss.app.defineTexts({
     *  "hello": {
     *      fr: "bonjour"
     *  },
     *  "#thank": {
     *      en: "thank you",
     *      fr: "merci"
     *  }
     * })
     */
    defineTexts(texts) {
        if (texts) {
            Object.assign(kiss.language.texts, texts)
            log.info(`kiss.language - Loaded ${Object.keys(texts).length} translated texts`)
        }
    },

    /**
     * Define a new model in the application
     * 
     * This automatically:
     * - references the model in **kiss.app.models**
     * - references a new collection for the model in **kiss.app.collections**
     * - references a new record class to instanciate the model
     * - generates the basic api for the record class (create, save, update, delete)
     * - generates getters/setters for record's computed fields (= virtual fields)
     * 
     * Check the class [Model documentation](kiss.data.Model.html) for more informations about models.
     * 
     * @param {object} model - The model configuration object
     * @returns {Model} The newly defined model
     */
    defineModel(model) {
        if (kiss.app.models[model.id]) return kiss.app.models[model.id]
        return new kiss.data.Model(model)
    },

    /**
     * Define the model relationships
     * 
     * This methods explores all the application models and finds automatically the relationships between the models.
     * When exploring the models, specific field types are generating the relationships:
     * - **link**: field used to link one or many foreign records
     * - **lookup**: field that looks up a field in a foreign record
     * - **summary**: field that looks up and summarizes data from multiple foreign records
     * 
     * @example
     * kiss.app.defineModelRelationships()
     */
    defineModelRelationships() {
        Object.values(kiss.app.models).forEach(model => model._defineRelationships())
    },

    /**
     * Get a Model by id or by name
     * 
     * Note: if the model is not found, the methods tries to find the model by its name
     * 
     * @param {string} modelId - id or name (case insensitive) of the model
     * @returns {object} Model
     */
    getModel(modelId) {
        const model = kiss.app.models[modelId]
        if (model) return model
        return kiss.app.getModelByName(modelId)
    },

    /**
     * Get a Model by name
     * 
     * Models are normally retrieved by id like this:
     * ```
     * const projectModel = kiss.app.models[modelId]
     * const projectRecord = projectModel.create({projectName: "foo"})
     * ```
     * 
     * In some situation, we just know the model name and have to use this method:
     * ```
     * const projectModel = kiss.app.getModelByName("Project")
     * const projectRecord = projectModel.create({projectName: "foo"})
     * ```
     * 
     * @param {string} modelName - The name of the model (case insensitive)
     * @returns {object} Model
     */
    getModelByName(modelName) {
        const model = Object.values(kiss.app.models).find(model => (model.name.toLowerCase() == modelName.toLowerCase()))
        return model
    },

    /**
     * Get a Collection by its model's name
     * 
     * Collections are normally retrieved by id like this:
     * ```
     * const projectCollection = kiss.app.collections[collectionId]
     * const projects = await projectCollection.find()
     * ```
     * 
     * In some situation, we just know the name of the collection's model, so we have to use this method:
     * ```
     * const projectCollection = kiss.app.getCollectionByModelName("Project")
     * const projects = await projectCollection.find()
     * ```
     * 
     * @param {string} modelName - The name of the collection's model (case insensitive)
     * @returns {object} Collection
     */
    getCollectionByModelName(modelName) {
        return Object.values(kiss.app.collections).find(collection => (collection.model.name.toLowerCase() == modelName.toLowerCase()))
    },

    /**
     * List all the application collections.
     * Give their name and number of records.
     */
    listCollections() {
        Object.values(kiss.app.collections).forEach(collection => {
            console.log(`id: ${collection.id}, name: ${collection.model.name}, records: ${collection.records.length}`)
        })
    },

    /**
     * Define a view by storing its renderer function into the list of view renderers.
     * It does NOT store a view, but instead stores a view 'renderer' function that will generate the view later, when needed.
     * 
     * @param {object} config
     * @param {string} config.id - The id of the view to add
     * @param {function} config.renderer - The function that will render the view when needed
     * @param {object} config.meta - Meta informations injected in the HTML header. Can be localized or not. See examples in kiss.views module.
     * 
     * @example
     * kiss.app.defineView({
     *  id: "home",
     *  renderer: function (id, target) {
     *      // ... build your view here
     *      return createPanel({
     * 
     *          id, // Very important. Can't work without it.
     *          target, // Optional insertion point in the DOM. You can omit if you don't need it.
     * 
     *          title: "My first panel",
     * 
     *          // A few panel properties
     *          draggable: true,
     *          closable: true,
     *          width: 300,
     *          height: 200,
     *          boxShadow: "5px 5px 10px #cccccc",
     *      
     *          // Panel content
     *          items: [
     *              {
     *                  type: "html",
     *                  html: "<center>Hello world?</center>",
     *              
     *                  // W3C events attached to the html element
     *                  // It works only if you've attached the "hello" viewController (see below)
     *                  events: {
     *                      onclick: function() {
     *                          $(id).hello()
     *                      }
     *                  }
     *              }
     *          ]
     *      })
     *  }
     * })
     */
    defineView({
        id,
        renderer,
        meta
    }) {
        kiss.views.addView({
            id,
            renderer,
            meta
        })
    },

    /**
     * Define a controller for a specific view
     * 
     * The view controller must have the same name as the controlled view.
     * They will be paired automatically.
     * 
     * @param {string} id 
     * @param {object} viewController - Object containing all the controller methods
     * 
     * @example
     * // This controller has 4 methods, hello(), world(), foo() and bar()
     * kiss.app.defineViewController("home", {
     *          
     *      hello: function() {
     *          createNotification({
     *              message: "Hello!",
     *              duration: 2000
     *          })
     *      },
     * 
     *      // ... or using an arrow function:
     *      world: () => console.log("World!"),
     * 
     *      // ... or class member notation:
     *      foo() {
     *          console.log("Foo!")
     *      },
     * 
     *      // Methods can be async, too:
     *      async bar() {
     *          return await 42
     *      }
     * })
     */
    defineViewController(id, viewController) {
        kiss.views.addViewController(id, viewController)
    },

    /**
     * Add a plugin definition to the application
     * 
     * @param {object} plugin 
     */
    definePlugin(plugin) {
        kiss.plugins.add(plugin)
    },

    /**
     * Init KissJS application
     * 
     * @async
     * @param {object} config - The application configuration object
     * @param {string} [config.name] - Optional application name (will be stored in kiss.app.name)
     * @param {string} [config.logo] - Optional application logo (will be stored in kiss.app.logo and use in login screens)
     * @param {string} [config.mode] - "online", "offline", "memory". Default is "online". Don't use "online" for local projects.
     * @param {string} [config.host] - The host for online requests. Can be localhost in developement.
     * @param {boolean} [config.https] - Set to false if the application doesn't use https. Default is true. Ignored for "memory" or "offline" modes.
     * @param {string[]} [config.loginMethods] - The list of login methods to use. Default is ["internal", "google", "microsoft365"]
     * @param {string|object} [config.startRoute] - The route to start with. Can be a string (= viewId) or an object (check router documentation).
     * @param {string[]} [config.publicRoutes] - The list of public routes which doesn't require authentication
     * @param {object} [config.undoRedo] - The undo/redo configuration object
     * @param {function} [config.loader] - The async function used to load your custom resources at startup. Must *absolutely* return a boolean to indicate success.
     * @param {boolean} [config.useDirectory] - Set to true if your app uses KissJS directory to manage users, groups and apiClients. Default is false.
     * @param {boolean} [config.useDynamicModels] - Set to true if your app needs dynamic models. Default is false.
     * @param {boolean} [config.useFormPlugins] - Set to true if your app needs form plugins. Default is false.
     * @param {object} [config.theme] - The theme to use. Ex: {color: "light", geometry: "sharp"}
     * @param {string} [config.language] - "en", "fr" or "es". Default is "en" or the last language used by the user.
     * @param {boolean} [config.debug] - Enable debug mode if true (default is false)
     * 
     * @example
     * await kiss.app.init({
     *  debug: true,
     *  name: "pickaform",
     *  language: "fr",
     *  logo: "./resources/img/logo 256x128.png",
     *  mode: "online",
     *  https: true,
     *  useDirectory: true,
     *  useDynamicModels: true,
     *  useFormPlugins: true,
     *  startRoute: "home-start",
     *  publicRoutes: [
     *      "form-public"
     *  ],
     *  undoRedo: {
     *      async undo() {
     *          // Undo code here
     *      },
     *      async redo() {
     *          // Redo code here
     *      }
     *  },
     *  theme: {
     *      color: "light",
     *      geometry: "sharp"
     *  },
     *  loader: async function() {
     *    // Load your resources here
     *    return true // IMPORTANT: return true if everything is loaded correctly, false otherwise
     *  }
     * })
     */
    async init(config) {
        if (!config) return false

        kiss.app.name = config.name
        kiss.app.logo = config.logo
        kiss.app.useDirectory = !!config.useDirectory
        kiss.app.useDynamicModels = !!config.useDirectory
        kiss.app.useFormPlugins = !!config.useFormPlugins
        kiss.app.loader = config.loader
        kiss.language.current = config.language || kiss.language.get() || "en"

        // Init global mode and database mode:
        // - the mode automatically switch depending on the html file used to start the application
        // - by default, starting with **index.html** will work online
        // - demo.html is used to show application templates in memory (no server resource consumption)
        // - memory.html is to test the application locally without saving anything: a browser refresh will wipe data
        // - offline.html is to save the data inside the browser
        const location = window.location.pathname
        if (location.includes("demo")) {
            kiss.global.mode = "demo"
            kiss.db.setMode("memory")
        } else if (location.includes("memory")) {
            kiss.global.mode = "memory"
            kiss.db.setMode("memory")
        } else if (location.includes("offline")) {
            kiss.global.mode = "offline"
            kiss.db.setMode("offline")
        } else {
            kiss.global.mode = config.mode || "online"
            kiss.db.setMode(kiss.global.mode)
        }

        // Init KissJS logger
        let categories = ["😘"]
        if (config.debug) {
            categories = categories.concat([
                "*",
                // "kiss.ajax",
                // "kiss.session",
                // "kiss.websocket",
                // "kiss.pubsub",
                // "kiss.db",
                // "kiss.data.Model",
                // "kiss.data.Record",
                // "kiss.data.Collection",
                // "kiss.data.Transaction",
                // "kiss.data.trash",
                // "kiss.acl",
                // "kiss.ui",
                // "kiss.views",
                // "kiss.language",
                // "kiss.plugins"
            ])
        }

        kiss.logger.init({
            data: true,
            types: [0, 1, 2, 3, 4],
            categories
        })

        // Init undo/redo
        if (config.undoRedo) kiss.undoRedo.init(config.undoRedo)

        // Init the theme
        if (config.theme) kiss.theme.set(config.theme)
        kiss.theme.init()

        // Init screen size listener
        kiss.screen.init()

        // Init the application router
        kiss.router.init()

        if (config.publicRoutes) {
            if (Array.isArray(config.publicRoutes) && config.publicRoutes.length > 0) {
                kiss.router.addPublicRoutes(config.publicRoutes)
            }
        }

        if (config.routerGuards) {
            if (Array.isArray(config.routerGuards) && config.routerGuards.length > 0) {
                kiss.router.addRoutingGuards(config.routerGuards)
            }
        }

        if (config.routerActions) {
            if (Array.isArray(config.routerActions) && config.routerActions.length > 0) {
                kiss.router.addRoutingActions(config.routerActions)
            }
        }

        // Get the requested route
        if (config.startRoute) {
            let route = config.startRoute
            if (typeof route === "string") {
                route = {
                    ui: config.startRoute
                }
            }
            kiss.router.updateUrlHash(route, true)
        }
        const newRoute = kiss.router.getRoute()

        // Init host
        if (config.host) {
            let host = config.host
            // Session host
            if (typeof host === "string") {
                host = {
                    host: config.host
                }
            }
            kiss.session.setHost(host)

            // Ajax host
            kiss.session.secure = (config.https === false) ? false : true
            let ajaxHost = kiss.session.getHttpHost()
            kiss.ajax.setHost(ajaxHost)
        }

        if (config.loginMethods) {
            if (Array.isArray(config.loginMethods) && config.loginMethods.length > 0) {
                kiss.session.setLoginMethods(config.loginMethods)
            }
        }
        
        if (!kiss.router.isPublicRoute()) await kiss.session.restore()

        // Jump to the first route
        kiss.router.navigateTo(newRoute)

        // Remove the splash screen, if any
        if ($("splash")) $("splash").remove()

        // Welcome message
        console.log("😘 Powered with ❤ by KissJS, Keep It Simple Stupid Javascript")
    },

    /**
     * Load core application data:
     * - load the directory
     * - load dynamic models
     * - define model relationships
     * - load links between records
     * - load form plugins
     * 
     * @returns {boolean} - True if the core application data could be loaded properly, false otherwise
     */
    async load() {
        // Load the directory
        if (kiss.app.useDirectory) {
            let success = await kiss.app.loadDirectory()
            if (!success) return false
        }

        // Load dynamic models
        if (kiss.app.useDynamicModels) {
            let success = await kiss.app.loadDynamicModels()
            if (!success) return false
        }

        // Discover model relationships dynamically
        kiss.app.defineModelRelationships()

        // Load links between records
        await kiss.app.collections.link.find()

        // Load the form plugins
        if (kiss.app.useFormPlugins) {
            // (we don't await it because it can be loaded in the background)
            kiss.plugins.init()
        }

        return true
    },

    /**
     * Load the application directory (users, groups, apiClients)
     * @returns {boolean} - True if the directory is loaded, false otherwise
     */
    async loadDirectory() {
        return await kiss.directory.init()
    },

    /**
     * Load the dynamic models.
     * Dynamic models are created by the users and have an unpredictable schema.
     * 
     * @returns {boolean} - True if the dynamic models are loaded, false otherwise
     */
    async loadDynamicModels() {
        if (!await kiss.app.collections.model) return true

        const models = await kiss.app.collections.model.find()

        // Exit if error (meaning the user is not properly logged in)
        if (!models) return false

        models.forEach(model => {
            if (model.items) kiss.app.defineModel(model)
        })

        // React to the creation of new models
        kiss.pubsub.subscribe("EVT_DB_INSERT:MODEL", msgData => {
            kiss.app.defineModel(msgData.data)
        })

        return true
    }
}


;/**
 * 
 * ## Manage application **context**
 * 
 * The application context is mainly (but not only) driven by the client router, which observes the url hash and converts it to a context.
 * It can also be used as a global variable to store application states.
 * 
 * With KissJS, the url hash **must** contain the following parameter:
 * - ui: it stands for "user interface" and is used to display the main view
 * 
 * The url hash **may** contain other informations depending on your application.
 * For example, at PickaForm, we use:
 * - applicationId: the active application id
 * - modelId: the active model id
 * - viewType: the active view type (datatable|calendar|kanban|gallery|...)
 * - viewId: the active view id
 * - recordId: the active record id (when displayed in a form)
 * - themeColor: the current application CSS theme color
 * - themeGeometry: the current application CSS theme geometry
 * - etc...
 * 
 * @namespace
 * 
 */
kiss.context = {

    /**
     * Context history
     * 
     * Keep the history of visited routes
     * 
     * @example
     * console.log(kiss.context.history)
     * 
     * // Output:
     * [
     *  {ui: "tutorial", chapterId: "1", sectionId: "2"},
     *  {ui: "tutorial", chapterId: "1", sectionId: "7"},
     *  {ui: "tutorial", chapterId: "2", sectionId: "3"}
     * // ...
     * ]
     */
    history: [],

    /**
     * Last context
     * 
     * @example
     * console.log(kiss.context.lastContext)
     * 
     * // Output:
     * {ui: "tutorial", chapterId: "2", sectionId: "3"}
     */
    lastContext: {},

    /**
     * Last context changes
     * 
     * @example
     * console.log(kiss.context.changes)
     * 
     * // Output:
     * {ui: false, chapterId: false, sectionId: true}
     */
    changes: {},

    /**
     * Update the application context:
     * - you can use this as a global way to save some of your application states
     * - the whole context history is saved in kiss.context.history
     * 
     * @param {object} newContext
     * 
     * @example
     * kiss.context.update({
     *  applicationId: "c393b159-2dd2-41e0-9d68-17c40f7088ab",
     *  viewId: "56b64b39-e932-49ae-86f2-30058345d9c8",
     *  language: "fr"
     * })
     */
    update(newContext) {
        let {
            history,
            ...currentContext
        } = kiss.tools.snapshot(kiss.context)

        kiss.context.lastContext = currentContext
        kiss.context.history.push(currentContext)
        Object.assign(kiss.context, newContext)
    },

    /**
     * Allow to check how the context has changed during the last routing event
     * 
     * @param {string} [propertyName] - The property to check. If not provided, it returns all the property changes.
     * @returns {object} Where each property value is a boolean (true means "has changed")
     * 
     * @example
     * console.log(kiss.context.hasChanged())
     * // Output:
     * {
     *  ui: false,
     *  viewId: true,
     *  themeColor: false
     * }
     * 
     * console.log(kiss.context.hasChanged("ui")) // Output: false
     */
    hasChanged(contextName) {
        let isNew = (this.history.length <= 1)
        let propertiesToCheck = Object.keys(kiss.tools.snapshot(this))
        let lastContext = kiss.context.history[kiss.context.history.length - 1]

        propertiesToCheck.forEach(property => {
            if (property != "history") this.changes[property] = (isNew) ? false : (kiss.context[property] != lastContext[property])
        })

        if (contextName) return this.changes[contextName]
        return this.changes
    }
}

;/**
 * 
 * ## Trash / Recycle bin
 * 
 * This module manage the deletion and restoration of records.
 * It provides a default UI (a datatable) to see the deleted records and restore them.
 * 
 * @namespace
 * 
 */
kiss.data.trash = {
    /**
     * Get the records that have been sent to trash
     * 
     * @param {string} [modelId] - Optional modelId to filter the deleted records of a single model
     * @returns {object[]} The deleted records
     */
    async getRecords(modelId) {
        const query = {
            sort: [{
                deleteAt: "desc"
            }]
        }

        if (modelId) {
            query.filter = {
                sourceModelId: this.modelId
            }
            query.filterSyntax = "mongo"
        }

        return await kiss.app.collections.trash.find(query, true)
    },

    /**
     * Show the deleted records for a given model
     * 
     * @param {object} config
     * @param {string} config.modelId - Mandatory model id
     * @param {object} [config.filter] - Optional filter
     * @param {object} [config.filterSyntax] - "mongo" (default) | "normalized"
     * @param {object} [config.sort] - Optional sort
     * @param {object} [config.sortSyntax] - "mongo" | "normalized" (default)
     */
    async showRecords(config) {
        // Build the panel to show the datatable
        if (!config || !config.modelId) return
        const model = kiss.app.models[config.modelId]
        if (!model) return

        const temporaryCollection = new kiss.data.Collection({
            id: "temp_" + uid(),
            model: kiss.app.models.trash
        })

        Object.assign(temporaryCollection, {
            filter: config.filter || {
                type: "filter",
                fieldId: "sourceModelId",
                operator: "=",
                value: config.modelId
            },
            sort: config.sort || [{
                deletedAt: "desc"
            }],

            filterSyntax: config.filterSyntax || "normalized",
            sortSyntax: config.sortSyntax || "normalized"
        })
        
        // Force the table to display the deletion event
        const columns = [{
            id: "deletedAt",
            title: txtTitleCase("#deletedAt"),
            type: "date"
        },
        {
            id: "deletedBy",
            title: txtTitleCase("#deletedBy"),
            type: "directory"
        }]

        //model.getFieldsAsColumns().slice(0, 10)
        const tempPanelId = kiss.tools.shortUid()

        const datatable = createDatatable({
            type: "datatable",
            model: model,
            collection: temporaryCollection,
            columns,
            canFilter: false,
            canGroup: false,

            // Options
            color: model.color,
            showHeader: true,
            showToolbar: true,
            showActions: false,
            canSelect: false,
            canEdit: false,
            canAddField: false,
            canEditField: false,
            canCreateRecord: false,
            iconAction: "fas fa-recycle",

            buttons: [
                {
                    position: 1,
                    text: txtTitleCase("empty the trash"),
                    icon: "fas fa-trash",
                    iconColor: "var(--red)",
                    action: async () => {
                        if (temporaryCollection.records.length == 0) {
                            return createNotification(txtTitleCase("#warning trash empty"))
                        }
                        
                        const firstRecord = temporaryCollection.records[0]
                        const canDelete = await kiss.acl.check({
                            action: "delete",
                            record: firstRecord
                        })
                        
                        if (!canDelete) {
                            return createNotification(txtTitleCase("#not authorized"))
                        }

                        kiss.data.trash.empty(model.id)
                    }
                }
            ],

            subscriptions: {
                "EVT_DB_DELETE_MANY:TRASH": function() {
                    this.reload()
                }
            },

            methods: {
                selectRecord: async (record) => {
                    createDialog({
                        title: txtTitleCase("#restore"),
                        icon: "fas fa-recycle",
                        message: txtTitleCase("#restore confirm"),
                        action: async () => {
                            const response = await kiss.data.trash.restoreRecord(record.id)
                            if (!response.success) createNotification(txtTitleCase("#not authorized"))

                            $(tempPanelId).close()
                        }
                    })
                }
            }
        })

        createPanel({
            id: tempPanelId,
            modal: true,
            draggable: true,
            closable: true,
            expandable: true,

            // Header
            title: txtTitleCase("#deleted records") + " <b>" + model.namePlural + "</b>",
            icon: model.icon,
            headerBackgroundColor: model.color,

            // Size and layout
            display: "flex",
            layout: "vertical",
            width: () => kiss.screen.current.width - 200,
            height: () => kiss.screen.current.height - 200,
            align: "center",
            verticalAlign: "center",
            autoSize: true,
            padding: 0,
            items: [{
                flex: 1,
                layout: "vertical",
                items: [datatable]
            }],

            // When closing the panel, we must destroy the datatable temporary source collection
            events: {
                onclose: () => temporaryCollection.destroy()
            }
        }).render()
    },

    /**
     * Restore a given record to its original collection
     * 
     * @param {string} recordId 
     * @returns {boolean} true if the record could be restored
     */
    async restoreRecord(recordId) {
        log("kiss.data.trash - Restore record " + recordId)

        const record = await kiss.app.collections.trash.findOne(recordId, true)
        const canDelete = await kiss.acl.check({
            action: "delete",
            record
        })

        if (!canDelete) {
            return {
                success: false
            }
        }

        const recordData = record.getRawData()
        const model = kiss.app.models[recordData.sourceModelId]

        // Re-creates the record in the collection
        delete recordData.sourceModelId
        const newRecord = model.create(recordData)
        const success = await newRecord.save()

        // Delete the record from the trash collection
        if (success) {
            await record.delete()
            return {
                success: true
            }
        }
        
        return {
            success: false
        }
    },

    /**
     * Empty the trash
     * 
     * @param {string} modelId 
     */
    empty(modelId) {
        createDialog({
            type: "danger",
            title: txtTitleCase("empty the trash"),
            message: txtTitleCase("#warning empty trash"),
            buttonOKPosition: "left",
            action: async () => {
                await kiss.app.collections.trash.deleteMany({
                    sourceModelId: modelId
                })
            }
        })
    }
}

;/**
 * 
 * ## Directory to handle users and groups
 * 
 * @namespace
 * 
 */
kiss.directory = {
    users: [],
    groups: [],
    collaborators: [],
    apiClients: [],
    roles: {},
    index: {},
    colors: {},

    /**
     * Init the address book
     * 
     * @returns {Promise<boolean>} false if users or groups could not be loaded properly
     */
    async init() {
        this._initRoles()

        if (kiss.session.isOnline()) {
            const success = await this._initUsersAndGroups()
            if (!success) return false

            this._initSubscriptions()
        }
        else {
            this._initOfflineUsersAndGroups()
        }
        return true
    },

    /**
     * Init or reset the address book
     * 
     * @private
     * @ignore
     * @return {boolean} false if users, groups, collaborators or API clients could not be loaded properly
     */
    async _initUsersAndGroups() {
        this.users = []
        this.groups = []
        this.collaborators = []
        this.apiClients = []

        await this._loadUsers()
        if (!this.users) return false
        
        await this._loadGroups()
        if (!this.groups) return false

        await this._loadCollaborators()
        if (!this.collaborators) return false

        await this._loadApiClients()
        if (!this.apiClients) return false

        this._buildIndex()
        return true
    },

    /**
     * Init or reset the address book for offline use
     * 
     * @private
     * @ignore
     */
    _initOfflineUsersAndGroups() {
        this.users = [{
            id: kiss.tools.uid(),
            email: "contact@pickaform.com",
            firstName: "Contact",
            lastName: "Pickaform",
            invitedBy: [],
            isCollaboratorOf: [],
            isInvite: false,
            active: true
        }]

        this.groups = [{
            id: kiss.tools.uid(),
            icon: "fas fa-users",
            color: "#00aaee",
            name: "Managers",
            users: ["contact@pickaform.com"]
        }]

        this._buildIndex()
    },

    /**
     * Build a directory index for instant entry search
     * 
     * @private
     * @ignore
     */
    _buildIndex() {
        this.index = {}
        this.users.forEach(user => this.index[user.email] = user)
        this.groups.forEach(group => this.index[group.id] = group)
        this.apiClients.forEach(client => this.index[client.id] = client)

        // this.directory = []
        // this.directory = this.users.concat(this.groups)
    },

    /**
     * Init special directory roles
     * 
     * @private
     * @ignore
     */
    _initRoles() {
        kiss.directory.roles.everyone = {
            type: "role",
            label: txtTitleCase("#everyone"),
            value: "*"
        }

        kiss.directory.roles.authenticated = {
            type: "role",
            label: txtTitleCase("authenticated users"),
            value: "$authenticated"
        }

        kiss.directory.roles.creator = {
            type: "role",
            label: txtTitleCase("the creator of the record"),
            value: "$creator"
        }

        kiss.directory.roles.userId = {
            type: "role",
            label: txtTitleCase("connected user"),
            value: "$userId"
        }

        kiss.directory.roles.nobody = {
            type: "role",
            label: txtTitleCase("#nobody"),
            value: "$nobody"
        }
    },

    /**
     * Subscribe the directory to react to changes
     * 
     * @private
     * @ignore
     */
    _initSubscriptions() {
        if (this.subscriptions) return

        this.subscriptions = [
            // USERS
            subscribe("EVT_DB_INSERT:USER", (msgData) => {
                this.addUser(msgData.data)
                this._buildIndex()
            }),

            subscribe("EVT_DB_UPDATE:USER", (msgData) => {
                this.updateUser(msgData.id, msgData.data)
            }),

            subscribe("EVT_DB_DELETE:USER", (msgData) => {
                this.deleteUser(msgData.id)
                this._buildIndex()
            }),

            // GROUPS
            subscribe("EVT_DB_INSERT:GROUP", (msgData) => {
                this.addGroup(msgData.data)
                this._buildIndex()
            }),

            subscribe("EVT_DB_UPDATE:GROUP", (msgData) => {
                this.updateGroup(msgData.id, msgData.data)
            }),

            subscribe("EVT_DB_DELETE:GROUP", (msgData) => {
                this.deleteGroup(msgData.id)
                this._buildIndex()
            }),

            // API CLIENT
            subscribe("EVT_DB_INSERT:APICLIENT", (msgData) => {
                this.addApiClient(msgData.data)
                this._buildIndex()
            }),

            subscribe("EVT_DB_UPDATE:APICLIENT", (msgData) => {
                this.updateApiClient(msgData.id, msgData.data)
            }),

            subscribe("EVT_DB_DELETE:APICLIENT", (msgData) => {
                this.deleteApiClient(msgData.id)
                this._buildIndex()
            }),

            // COLLABORATION PROCESS
            subscribe("EVT_COLLABORATION:SENT", async () => {
                await this._initUsersAndGroups()
                kiss.pubsub.publish("EVT_DIRECTORY_UPDATED")
            }),

            subscribe("EVT_COLLABORATION:RECEIVED", async () => {
                kiss.pubsub.publish("EVT_DIRECTORY_UPDATED")
            }),

            subscribe("EVT_COLLABORATION:ACCEPTED", async () => {
                await this._initUsersAndGroups()
                kiss.pubsub.publish("EVT_DIRECTORY_UPDATED")
            }),

            subscribe("EVT_COLLABORATION:REJECTED", async () => {
                await this._initUsersAndGroups()
                kiss.pubsub.publish("EVT_DIRECTORY_UPDATED")
            }),            
            
            subscribe("EVT_COLLABORATION:STOPPED", async () => {
                await this._initUsersAndGroups()
                kiss.pubsub.publish("EVT_DIRECTORY_UPDATED")
            })
        ]
    },

    /**
     * Add a user
     * 
     * @param {object} user 
     */
    addUser(user) {
        const hasUser = kiss.directory.users.find(existingUser => existingUser.id == user.id)
        if (hasUser) return
        kiss.directory.users.push(user)
    },

    /**
     * Update a user
     * 
     * @param {string} userId
     * @param {object} update 
     */
    updateUser(userId, update) {
        let user = kiss.directory.users.get(userId)
        Object.assign(user, update)
    },

    /**
     * Delete a user
     * 
     * @param {string} userId
     */
    deleteUser(userId) {
        this.users = this.users.filter(user => user.id != userId)
    },    

    /**
     * Add a group
     * 
     * @param {object} group
     */
    addGroup(group) {
        const hasGroup = kiss.directory.groups.find(existingGroup => existingGroup.id == group.id)
        if (hasGroup) return
        kiss.directory.groups.push(group)
    },    

    /**
     * Update a group
     * 
     * @param {string} groupId 
     * @param {object} update 
     */
    updateGroup(groupId, update) {
        let group = kiss.directory.groups.get(groupId)
        Object.assign(group, update)
    },

    /**
     * Delete a group
     * 
     * @param {string} groupId 
     */
    deleteGroup(groupId) {
        this.groups = this.groups.filter(group => group.id != groupId)
    },

    /**
     * Add an API client
     * 
     * @param {object} client 
     */
    addApiClient(client) {
        const hasClient = kiss.directory.apiClients.find(existingClient => existingClient.id == client.id)
        if (hasClient) return
        kiss.directory.apiClients.push(client)
    },

    /**
     * Update an API client
     * 
     * @param {string} clientId
     * @param {object} update 
     */
    updateApiClient(clientId, update) {
        let client = kiss.directory.apiClients.get(clientId)
        Object.assign(client, update)
    },

    /**
     * Delete an API client
     * 
     * @param {string} clientId
     */
    deleteApiClient(clientId) {
        this.apiClients = this.apiClients.filter(client => client.id != clientId)
    },

    /**
     * Load active account users
     * 
     * @private
     * @async
     * @returns {object[]} Array of users or false
     */
    async _loadUsers() {
        this.users = await kiss.ajax.request({
            url: "/getUsers"
        })
        return this.users
    },

    /**
     * Load account groups
     * 
     * @private
     * @async
     * @returns {object[]} Array of groups or false
     */
    async _loadGroups() {
        this.groups = await kiss.app.collections.group.find()
        return this.groups
    },

    /**
     * Load account collaborators
     * 
     * @private
     * @async
     * @returns {object[]} Array of collaborators or false
     */
    async _loadCollaborators() {
        this.collaborators = await kiss.ajax.request({
            url: "/getCollaborators"
        })
        return this.collaborators
    },

    /**
     * Load API clients
     * 
     * @private
     * @async
     * @returns {object[]} Array of API clients or false
     */
    async _loadApiClients() {
        this.apiClients = await kiss.ajax.request({
            url: "/getApiClients"
        })
        return this.apiClients
    },

    /**
     * Get a user or a group, given its email (for users) or id (for groups)
     * 
     * @param {string} entryId
     * @returns {}
     */
    getEntry(entryId) {
        return this.index[entryId]
    },

    /**
     * Get a list of users and groups, given their ids
     * 
     * @param {string[]} entryId - Array of ids
     * @returns {object[]} Array of entries
     */
    getEntries(entryIds) {
        return entryIds.map(id => kiss.directory.index[id]).filter(entry => !!entry)
    },

    /**
     * Returns the user name
     * 
     * @param {string} userId 
     * @returns {string}
     */
    getEntryName(userId) {
        const entry = kiss.directory.getEntry(userId)

        if (!entry) return userId

        if (entry.firstName && entry.lastName) {
            // It's a user
            return entry.firstName + " " + entry.lastName
            
        } else {
            // It's a group
            if (entry.users) {
                return entry.name
            }
            else if (entry.name) {
                // It's an API client
                return entry.name
            }

            return entry.email
        }
    },

    /**
     * Get a list of user and group names, given their ids
     * 
     * @param {string[]} entryId - Array of ids
     * @returns {string[]} Array of entry names
     */
    getEntryNames(entryIds) {
        entryIds = [].concat(entryIds)
        return entryIds.map(this.getEntryName)
    },

    /**
     * Returns all the names by which the user can be recognized into ACL lists.
     * 
     * @param {string} userId 
     * @returns {string[]}
     */
    getUserACL(userId) {
        let userACL = ["*"]

        if (kiss.session.isOnline()) {
            // Online
            userACL = userACL.concat(userId)
            if (kiss.session.isAuthenticated()) userACL = userACL.concat("$authenticated")
        }
        else {
            // Offline
            userACL = userACL.concat("$authenticated", "anonymous")
        }

        this.groups.forEach(group => {
            if (group.users.includes(userId)) userACL.push(group.id)
        })
        return userACL
    },

    /**
     * Get the user initials
     * 
     * @param {object} user 
     * @returns {string} The initials
     * 
     * @example
     * const initials = kiss.directory.getUserInitials("david.grossi@pickaform.com")
     * console.log(initials) // "DG"
     */
    getUserInitials(user) {
        if (!user.firstName || !user.lastName) return "??"
        return (user.firstName[0] + user.lastName[0]).toUpperCase()
    },

    /**
     * Get the entry color (randomly assigned at startup)
     * 
     * @param {string} userId 
     * @returns {string} The hex color code
     * 
     * @example
     * const userColor = kiss.directory.getEntryColor("david.grossi@pickaform.com")
     * console.log(userColor) // "#00aaee"
     * 
     */
    getEntryColor(userId) {
        let userColor = kiss.directory.colors[userId]
        if (userColor) return userColor

        userColor = kiss.tools.getRandomColor(0, 20)
        kiss.directory.colors[userId] = userColor
        return userColor
    },

    /**
     * Get users
     * 
     * @param {object} config
     * @param {string} config.sortBy - "firstName" | "lastName" (default)
     * @param {string} config.nameOrder - "firstName" | "lastName" (default)
     * @param {string} config.sortOrder - "asc" (default) | "desc"
     * @param {boolean} config.onlyActiveUsers - true to filter out inactive users
     * @returns {object[]} Array of users
     */
    getUsers(config = {
        sortBy: "lastName",
        nameOrder: "lastName",
        sortOrder: "asc",
        onlyActiveUsers: false
    }) {
        const compareFunction = (config.sortBy == "firstName") ? this._sortByFirstName : this._sortByLastName

        const users = kiss.directory.users
            .filter(user => {
                if (config.onlyActiveUsers == false) return true
                return user.active !== false
            })
            .map(user => {
                return {
                    type: "user",
                    id: user.email,
                    isInvite: user.isInvite,
                    isOwner: user.isOwner,
                    firstName: user.firstName || "",
                    lastName: user.lastName || "",
                    email: user.email,
                    name: (user.firstName && user.lastName) ?
                        ((config.nameOrder == "firstName") ?
                            (user.firstName + " " + user.lastName) :
                            (user.lastName + " " + user.firstName)) : user.email
                }
            })
            .sort(compareFunction)

        if (config.sortOrder == "desc") return users.reverse()
        return users
    },

    /**
     * Get groups
     * 
     * @param {string} sortOrder - "asc" (default) | "desc"
     * @returns {object[]} Array of groups
     */
    getGroups(sortOrder = "asc") {
        const groups = kiss.directory.groups
            .map(group => {
                return {
                    type: "group",
                    id: group.id,
                    name: group.name
                }
            })
            .sort(this._sortByName)

        if (sortOrder == "desc") return groups.reverse()
        return groups
    },

    /**
     * Get API clients
     * 
     * @returns {object[]} Array of API clients
     */
    getApiClients() {
        const apiClients = kiss.directory.apiClients
            .map(client => {
                return {
                    type: "api",
                    id: client.id,
                    name: client.name
                }
            })
            .sort(this._sortByName)

        return apiClients
    },    

    /**
     * Sort by user firstName
     * 
     * @private
     * @ignore
     */
    _sortByFirstName(a, b) {
        if (a.firstName.toLowerCase() < b.firstName.toLowerCase()) return -1
        if (a.firstName.toLowerCase() > b.firstName.toLowerCase()) return 1
        return 0
    },

    /**
     * Sort by user lastName
     * 
     * @private
     * @ignore
     */
    _sortByLastName(a, b) {
        if (a.lastName.toLowerCase() < b.lastName.toLowerCase()) return -1
        if (a.lastName.toLowerCase() > b.lastName.toLowerCase()) return 1
        return 0
    },

    /**
     * Sort by group name
     * 
     * @private
     * @ignore
     */
    _sortByName(a, b) {
        if (a.name.toLowerCase() < b.name.toLowerCase()) return -1
        if (a.name.toLowerCase() > b.name.toLowerCase()) return 1
        return 0
    },

    /**
     * Dialog to change the user first name and last name
     * 
     * @param {string} userId 
     */
    async editUsername(userId) {
        const user = await kiss.app.collections.user.findOne(userId)
        const initialFirstName = user.firstName
        const initialLastName = user.lastName

        createPanel({
            id: "edit-user-infos",
            title: txtTitleCase("#title edit name"),
            icon: "fas fa-edit",
            layout: "vertical",
            align: "center",
            verticalAlign: "center",
            modal: true,
            closable: true,
            draggable: true,

            defaultConfig: {
                width: 350,
                labelWidth: 150,
                fieldWidth: 200
            },

            items: [
                {
                    id: "edit-firstName",
                    type: "text",
                    label: txtTitleCase("first name"),
                    value: user.firstName,
                    required: true,
                    min: 2,
                    max: 50
                },
                {
                    id: "edit-lastName",
                    type: "text",
                    label: txtTitleCase("last name"),
                    value: user.lastName,
                    required: true,
                    min: 2,
                    max: 50
                },
                {
                    type: "button",
                    text: txtTitleCase("#button edit name"),
                    icon: "fas fa-check",
                    height: 40,
                    margin: "20px 0px 10px 0px",

                    action: () => {
                        const success = $("edit-user-infos").validate()
                        if (!success) return

                        const firstName = $("edit-firstName").getValue()
                        const lastName = $("edit-lastName").getValue()
                        
                        // No change: exit
                        if (initialFirstName == firstName && initialLastName == lastName) {
                            $("edit-user-infos").close()
                            return true
                        }

                        // Change: confirm
                        createDialog({
                            type: "danger",
                            title: txtTitleCase("#title edit name"),
                            buttonOKPosition: "left",
                            message: txtTitleCase("#confirm edit name", null, {
                                firstName,
                                lastName
                            }),
                            action: async () => {
                                $("edit-user-infos").close()
                                await user.update({
                                    firstName,
                                    lastName
                                })

                                // Update session informations
                                localStorage.setItem("session-firstName", firstName)
                                localStorage.setItem("session-lastName", lastName)
                                kiss.pubsub.publish("EVT_USERNAME_UPDATED")
                            }
                        })
                    }
                }
            ]
        }).render()
    }
}

;/**
 * 
 * ## kiss.fields
 * 
 * This module is used internally by KissJS and should not be used directly in your code.
 * It's dedicated to performance optimizations when rendering fields inside data components like datatable, kanban...
 * In data components, we need to render a lot of fields and we want to do it as fast as possible.
 * This module serves as a cache for all field renderers.
 * 
 * Each renderer function receives the following parameters:
 * - `value`: the value to render
 * - `record`: the record object
 * - `config`: a custom field configuration object, which can be used to pass additional parameters to the renderer
 * 
 * Only the `value` parameter is required. The other parameters are optional and can be used if needed in the renderer.
 * 
 * @ignore
 * 
 */
kiss.fields = {
    renderers: {},
    cachedOptionsForSelectFields: new Map(),

    /**
     * Returns the "real" type of a field
     * When a field is a "lookup" or a "summary", we need to get the type of the source field
     * 
     * @param {object} field 
     * @returns {string} type
     */
    getFieldType(field) {
        let type = field.type
        if (type == "lookup") return field.lookup.type || field.type
        if (type == "summary") return field.summary.type || field.type
        return type
    },

    /**
     * Defines the HTML renderer for a field.
     * 
     * Each renderer is specific to a field type and returns a function that takes a value as parameter and returns the HTML to display.
     * Renderers are stored in cache for a faster access when rendering data components like datatable, kanban...
     * 
     * TODO: centralize invariant renderers (like the default one) in a single place to save memory
     * 
     * @param {object} model 
     * @param {object} field
     */
    setRenderer(model, field) {
        kiss.fields.renderers[model.id] = kiss.fields.renderers[model.id] || {}

        if (field.valueRenderer) {
            kiss.fields.renderers[model.id][field.id] = field.valueRenderer
            return
        }
        
        let renderer
        const type = this.getFieldType(field)

        switch (type) {
            case "number":
                renderer = this._setRendererForNumber(field)
                break
            case "date":
                renderer = this._setRendererForDate(field)
                break
            case "textarea":
            case "aiTextarea":
                renderer = this._setRendererForTextarea()
                break
            case "richTextField":
                renderer = this._setRendererForRichText()
                break
            case "select":
                renderer = this._setRendererForSelect(field)
                break
            case "directory":
                renderer = this._setRendererForDirectory()
                break
            case "checkbox":
                renderer = this._setRendererForCheckbox(model, field)
                break
            case "slider":
                renderer = this._setRendererForSlider(field)
                break                
            case "rating":
                renderer = this._setRendererForRating(model, field)
                break
            case "color":
                renderer = this._setRendererForColor()
                break
            case "icon":
                renderer = this._setRendererForIcon()
                break
            case "selectViewColumn":
                renderer = this._setRendererForSelectViewColumn()
                break
            case "attachment":
            case "aiImage":
                renderer = this._setRendererForAttachments()
                break
            case "password":
                renderer = this._setRendererForPassword()
                break
            case "link":
                renderer = this._setRendererForLink(field)
                break
            default:
                renderer = this.defaultRenderer
                break
        }

        kiss.fields.renderers[model.id][field.id] = renderer
    },

    /**
     * Default renderer
     * Escape HTML characters for safe rendering
     */    
    defaultRenderer({value}) {
        return ((value || "") + "").escapeHtml()
    },

    /**
     * Renderer for "Number" fields
     */
    _setRendererForNumber(field) {
        const precision = (field) ? field.precision : 2 // Default precision = 2
        const unit = (field.unit) ? " " + field.unit : ""

        return function({value, config = {}}) {
            if (value === undefined) return ""
            return Number(value).format(precision) + ((config.unit != false) ? unit : "")
        }
    },

    /**
     * Renderer for "Date" fields
     * Todo: Add support for different date formats
     */      
    _setRendererForDate(field) {
        // const dateFormat = (field) ? field.dateFormat : "YYYY-MM-AA"
        return function({value}) {
            if (!value) return ""
            return new Date(value).toLocaleDateString()
        }
    },

    /**
     * Renderer for "Textarea" fields
     */
    _setRendererForTextarea() {
        return function({value, config}) {
            if (!value) return ""
            if (config && config.nobr) return value
            return value.replaceAll("\n", "<br>")
        }
    },

    /**
     * Renderer for "Rich text" fields
     */    
    _setRendererForRichText() {
        return function({value, config}) {
            if (!value) return ""
            value = kiss.tools.convertHtmlToPlainText(value)
            if (config && config.nobr) return value
            return value.replaceAll("\n", "<br>")
        } 
    },    

    /**
     * Renderer for "Select" fields
     */     
    _setRendererForSelect(field) {
        // If the <Select> field has its own specific renderer, we use it
        if (field.valueRenderer) return field.valueRenderer

        // Define options
        let options = (typeof field.options == "function") ? field.options() : field.options
        options = options || []

        // Special case for "time" fields
        if (field.template == "time") {
            options = kiss.ui.Select.prototype._generateTimes(field.min || 0, field.max || 24, field.interval || 60, true)
        }

        // If no options, returns default layout
        if (!options) {
            return function({value}) {
                return [].concat(value).map(val => {
                    if (!val) return ""
                    return `<span class="field-select-value">${val}</span>`
                }).join("")
            }
        }

        // Cache options
        let mapOptions = {}
        options.forEach(option => {
            mapOptions[option.value.toLowerCase()] = {
                value: option.label || option.value,
                color: option.color
            }
        })        

        // If options, returns values with the right option colors
        return function({value}) {
            return [].concat(value).map(val => {
                if (!val) return ""

                let option = mapOptions[("" + val).toLowerCase()]

                if (!option) option = {
                    value: val
                }

                if (!option.value || option.value == " ") return ""

                return `<span class="field-select-value" ${(option.color) ? `style="color: #ffffff; background-color: ${option.color}"` : ""}>${option.value}</span>`
            }).join("")
        }
    },

    /**
     * Renderer for "Directory" fields
     */
    _setRendererForDirectory() {
        return function({value}) {
            return [].concat(value).map(val => {
                if (!val) return ""

                let name
                switch (val) {
                    case "*":
                        name = kiss.directory.roles.everyone.label
                        break
                    case "$authenticated":
                        name = kiss.directory.roles.authenticated.label
                        break
                    case "$creator":
                        name = kiss.directory.roles.creator.label
                        break
                    case "$nobody":
                        name = kiss.directory.roles.nobody.label
                        break
                    default:
                        name = kiss.directory.getEntryName(val)
                }

                return (name) ? `<span class="field-select-value">${name}</span>` : ""
            }).join("")
        }
    },

    /**
     * Renderer for "Checkbox" fields
     */    
    _setRendererForCheckbox(model, field) {
        let shape = field.shape || "square"
        let iconColorOn = field.iconColorOn || "#000000"

        try {
            if (field.type == "lookup") {
                const linkId = field.lookup.linkId
                const linkField = model.getField(linkId)
                const foreignModelId = linkField.link.modelId
                const foreignModel = kiss.app.models[foreignModelId]
                const sourceField = foreignModel.getField(field.lookup.fieldId)
                shape = sourceField.shape
                iconColorOn = sourceField.iconColorOn
            }
        } catch (err) {
            log("kiss.fields - Couldn't generate renderer for field " + model.name  + "/" + field.label)
            return function({value}) {
                return value
            }
        }

        const iconClasses = kiss.ui.Checkbox.prototype.getIconClasses()
        const defaultIconOn = iconClasses[shape]["on"]
        const defaultIconOff = iconClasses[shape]["off"]

        return function({value}) {
            return `<span ${(value === true) ? `style="color: ${iconColorOn}"` : ""} class=\"${(value === true) ? defaultIconOn + " data-type-checkbox-checked" : defaultIconOff + " data-type-checkbox-unchecked"}\"></span>`
        }
    },

    /**
     * Renderer for "Slider" fields
     */    
    _setRendererForSlider(field) {
        const min = field.min || 0
        const max = field.max || 100
        const step = field.step || 5
        const unit = field.unit || ""

        return function({value, config = {}}) {
            return /*html*/ `<span class="field-slider-container">
                <input class="field-slider" type="range" value="${value || 0}" min="${min}" max="${max}" step="${step}" style="pointer-events: none;">
                <span class="field-slider-value">${value || 0} ${(config.unit != false) ? unit : ""}</span>
            </span>`
        }
    },    

    /**
     * Renderer for "Rating" fields
     */
    _setRendererForRating(model, field) {
        let shape = field.shape || "star"
        let iconColorOn = field.iconColorOn || "#ffd139"
        let iconColorOff = field.iconColorOff || "#dddddd"

        try {
            if (field.type == "lookup") {
                const linkId = field.lookup.linkId
                const linkField = model.getField(linkId)
                const foreignModelId = linkField.link.modelId
                const foreignModel = kiss.app.models[foreignModelId]
                const sourceField = foreignModel.getField(field.lookup.fieldId)
                shape = sourceField.shape
                iconColorOn = sourceField.iconColorOn
                iconColorOff = sourceField.iconColorOff
            }
        } catch (err) {
            log("kiss.fields - Couldn't generate renderer for field " + model.name  + "/" + field.label)
            return function({value}) {
                return value
            }
        }

        const iconClasses = kiss.ui.Rating.prototype.getIconClasses()
        const icon = iconClasses[shape]
        const max = field.max || 5

        return function({value}) {
            let html = ""
            for (let i = 0; i < max; i++) {
                const color = (i < value) ? iconColorOn : iconColorOff
                html += /*html*/ `<span class="rating ${icon}" style="color: ${color}" index=${i}></span>`
            }
            return html
        }
    },
    
    /**
     * Renderer for "Color" fields
     */    
    _setRendererForColor() {
        return function({value}) {
            if (!value) return ""
            return `<span class="data-type-color" style="background: ${value}"></span>`
        }
    },

    /**
     * Renderer for "Icon" fields
     */ 
    _setRendererForIcon() {
        return function({value}) {
            if (!value) return ""
            return `<span class="data-type-icon ${value}"/>`
        }
    },

    /**
     * Renderer for "SelectViewColumn" fields
     */    
    _setRendererForSelectViewColumn() {
        return function({value}) {
            return [].concat(value).map(val => {
                if (!val) return ""
                return `<span class="field-select-value">${val}</span>`
            }).join("")
        }
    },

    /**
     * Renderer for "Attachment" fields
     */     
    _setRendererForAttachments() {
        return function({value, config = {}}) {
            if ((!value) || (value == " ") || !Array.isArray(value)) return ""

            let attachmentItems = value.map((file, i) => {
                if (!file.path) return ""

                let preview
                let filePath = kiss.tools.createFileURL(file, config.thumbSize || "s")
                const fileExtension = file.path.split(".").pop().toLowerCase()

                if (["jpg", "jpeg", "png", "gif", "webp"].indexOf(fileExtension) != -1) {
                    // Image
                    preview = `<img id="${file.id}" fieldId="${this.id}" class="data-type-attachment-image data-thumbnail" src="${filePath}" loading="lazy"></img>`
                } else {
                    // Other
                    const {
                        icon,
                        color
                    } = kiss.tools.fileToIcon(fileExtension)
                    preview = `<span id="${file.id}" fieldId="${this.id}" style="color: ${color}" class="fas ${icon} data-type-attachment-icon data-thumbnail"></span>`
                }

                return preview
            }).join("")

            return attachmentItems
        }
    },

    /**
     * Renderer for "Password" fields
     */    
    _setRendererForPassword() {
        return function() {
            return "***"
        }
    },

    /**
     * Renderer for "Link" fields
     */  
    _setRendererForLink(field) {
        if (!field || !field.link) return () => ""

        const linkModelId = field.link.modelId
        if (!linkModelId) return () => ""

        const linkModel = kiss.app.models[linkModelId]
        if (!linkModel) return () => ""

        return function() {
            return `<span class="field-link-value-cell" modelId="${linkModelId}">
                        ${(field.multiple)
                            ? linkModel.namePlural + "&nbsp; <span class='fas fa-sitemap'></span>"
                            : linkModel.name + "&nbsp; <span class='fas fa-link'></span>"}
                    </span>`.removeExtraSpaces()
        }
    }    
}

;/**
 * 
 * ## Simple translation management
 * 
 * Provides 4 functions to translate the texts:
 * - txt
 * - txtTitleCase
 * - txtUpperCase
 * - txtLowerCase
 * 
 * Note:
 * - You can also merge data directly into the translated text using a "merge" object (see below).
 * - Any translation which is not found will fallback to the text passed to the function.
 * - Any unfound text will be automatically stored into the "missingTexts" variable to ease the debug phase
 * 
 * @namespace
 * 
 */
kiss.language = {
    // Active language
    current: "en",

    // Store all the localized texts
    texts: {},

    // Store missing texts while browsing the application views
    missingTexts: [],

    // Available languages
    // If the navigator's default language is not included in the available languages, it defaults to "en"
    available: [{
            code: "en",
            name: "English"
        },
        {
            code: "fr",
            name: "Français"
        },
        {
            code: "es",
            name: "Español"
        }
    ],

    /**
     * Set the available languages
     * 
     * @param {object[]} languages - Passeed as an array of objects with a "code" and a "name" property
     * @returns this
     * 
     * @example
     * kiss.language.setAvailable([
     *  {
     *      code: "en",
     *      name: "English"
     *  },
     *  {
     *      code: "fr",
     *      name: "Français"
     *  },
     *  {
     *      code: "es",
     *      name: "Español"
     *  }
     * ])
     */
    setAvailable(languages) {
        kiss.language.available = languages
        return this
    },

    /**
     * - 1) Set the language from the browser settings, or system locales, or localStorage
     * - 2) Consolidate the library's texts and the specific application's texts into a single object to lookup
     */
    init() {
        // 1 - Set the language
        kiss.language.get()

        // 2 - Generate a hash for each text
        //this.initHash()
    },

    /**
     * Generate a hash for each localized text
     * 
     * @ignore
     */
    initHash() {
        kiss.language.hash = {}
        Object.keys(kiss.language.texts).forEach(key => {
            kiss.language.hash[key.hashCode()] = key
        })
    },

    /**
     * Get the current language
     * 
     * - first check the url parameter "language" (for example: &language=fr)
     * - if no parameter, tries to get the browser language
     * - defaults to "en" (English)
     * 
     * @returns {string} The current language. Examples: "en", "fr", "de", "it"...
     */
    get() {
        const urlLanguage = kiss.router.getRoute().language
        if (urlLanguage) {
            if (!kiss.language.available.find(lang => lang.code == urlLanguage)) urlLanguage = "en"
            kiss.language.current = urlLanguage
        } else {
            const navigatorLanguage = (navigator.languages ? navigator.languages[0] : navigator.language).substring(0, 2)
            const storedLanguage = localStorage.getItem("config-language")
            kiss.language.current = storedLanguage || navigatorLanguage || "en"

            // Restrict to languages which are available
            if (!kiss.language.available.find(lang => lang.code == kiss.language.current)) kiss.language.current = "en"
        }
        return kiss.language.current
    },

    /**
     * Return a localized text from a key, or a fallback text
     * If a translation is missing, the text key is stored into the "kiss.language.missingTexts" array, in order to ease the debug phase.
     * When a merge object is passed as a parameter, the values are merged into the final string.
     * 
     * @param {string} key - The text key, which should be in lowercase by convention (txtTitleCase, txtUpperCase, and txtLowerCase handle the case)
     * @param {object} [customSourceTexts] - Custom source texts. Must be provided in the same format as default source texts. See example.
     * @param {object} merge - Contextual data that must be merged into the text
     * @returns {string} - The localized text, or the key passed to the function if not found
     * 
     * @example
     * txt("hello") // bonjour
     * txtTitleCase("hello") // Bonjour
     * txt("hello %firstName %lastName", null, {firstName: "Bob", lastName: "Wilson"}) // bonjour Bob Wilson
     * txt("Devil number: %num%num%num", null, {num: 6}) // Devil number: 666
     * 
     * let customSource = {
     *      "apple": {
     *          fr: "pomme"
     *      },
     *      "banana": {
     *          fr: "banana"
     *      },
     *      "fruits": {
     *          en: "choose between those fruits...",
     *          fr: "choisissez parmi ces fruits..."
     *      }
     * }
     * 
     * kiss.language.set("en")
     * txtTitleCase("apple", customSource) // Apple
     * txtUpperCase("banana", customSource) // BANANA
     * txtTitleCase("fruits", customSource) // Choose between those fruits...
     * 
     * kiss.language.set("fr")
     * txtUpperCase("fruits", customSource) // CHOISISSEZ PARMI CES FRUITS...
     */
    translate(key, customSourceTexts, merge) {
        // Get static text
        let translationKey = (customSourceTexts) ? customSourceTexts[key] : kiss.language.texts[key]
        let translation = (translationKey) ? translationKey[kiss.language.current] : null

        // If there is no English text, then the text is the key itself
        let isMissing = false
        if (!translation) {
            translation = key
            isMissing = true
        }

        // Merge dynamic text
        if (merge) {
            Object.keys(merge).forEach(key => {
                let tag = new RegExp("%" + key, "g")
                translation = translation.replace(tag, merge[key])
            })
        }

        if (isMissing && kiss.language.missingTexts.indexOf(key) == -1) {
            kiss.language.missingTexts.push(key)
            log(`kiss.language - Missing [${kiss.language.current}] translation for [${key}]`, 4)
        }

        // On-the-fly translation, not ready yet because of the possibility of merging text into translated strings
        // return `<span class="translation" id="${key.hashCode()}">${translation}</span>`
        return translation
    },

    /**
     * Switch to another language
     * 
     * @param {*} newLanguage 
     */
    set(newLanguage) {
        kiss.language.current = newLanguage
        localStorage.setItem("config-language", newLanguage)
        document.location.reload()
    },

    /**
     * Show all missing texts in the console
     * @returns {string} - All the missing texts
     */
    showMissingTexts() {
        let i = 0
        kiss.language.missingTexts.forEach(text => {
            console.log(text)
            i++
        })
        console.log(`kiss.language - Result: ${i} missing texts for language ${kiss.language.current}`)
    },

    /**
     * Show a window to translate texts without translation
     */
    showTranslationWindow() {
        const containerId = kiss.tools.uid()

        const items = kiss.language.missingTexts.map(text => {
            return {
                type: "text",
                label: text,
                labelPosition: "top",
                width: "100%",
                events: {
                    onchange: () => $(containerId).update()
                }
            }
        })

        createPanel({
            title: "Quick translation for " + kiss.language.current.toUpperCase(),
            width: () => kiss.screen.current.width - 100,
            height: () => kiss.screen.current.height - 100,
            align: "center",
            verticalAlign: "center",
            modal: true,
            draggable: true,
            closable: true,
            layout: "horizontal",
            overflowY: "auto",

            defaultConfig: {
                margin: 10,
                borderRadius: 10,
                boxShadow: "var(--shadow-4)"
            },
            items: [{
                    id: containerId,
                    layout: "vertical",
                    flex: 1,
                    overflowY: "auto",
                    padding: 10,
                    items: items,

                    methods: {
                        update: function () {
                            const translationFields = $(containerId).items
                            const translations = {}
                            translationFields.forEach(field => {
                                const translation = field.getValue()
                                if (translation) {
                                    const translationKey = field.getLabel()
                                    translations[translationKey] = {
                                        [kiss.language.current]: translation
                                    }
                                }
                            })
                            $("export").setValue(JSON.stringify(translations, null, 4))
                        }
                    }
                },
                {
                    id: "export",
                    type: "textarea",
                    label: "Export",
                    labelPosition: "top",
                    flex: 1,
                    fieldHeight: "100%"
                }
            ]
        }).render()
    },

    /**
     * Open a window to switch the language
     */
    select() {
        if ($("language-window")) return
        const isMobile = kiss.screen.isMobile
    
        if (isMobile) {
            responsiveOptions = {
                top: () => 0,
                left: () => 0,
                width: "100%",
                height: "100%",
                borderRadius: "0 0 0 0",
                draggable: false,
            }
        }
        else {
            responsiveOptions = {
                verticalAlign: "center",
                draggable: true
            }
        }
    
        const languageButtons = kiss.language.available.map(language => {
            return {
                text: language.name,
                icon: "fas fa-chevron-right",
                action: () => kiss.language.set(language.code)
            }
        })
    
        return createPanel({
            id: "language-window",
            icon: "fas fa-globe",
            title: txtTitleCase("pick a language"),
            modal: true,
            closable: true,
            display: "block",
            position: "absolute",
            align: "center",
            overflowY: "auto",
    
            ...responsiveOptions,
    
            defaultConfig: {
                type: "button",
                flex: 1,
                width:(isMobile) ? "calc(100% - 2rem)" : "15rem",
                height: "5rem",
                margin: "1rem",
                iconSize: "2.4rem",
                fontSize: "1.6rem",
                textAlign: "left",
                boxShadow: "var(--shadow-1)",
                boxShadowHover: "var(--shadow-4)"
            },
    
            items: languageButtons
        }).render()
    }
};

// Shortcuts to uppercase, lowercase, titlecase
const txt = kiss.language.translate
const txtUpperCase = (key, customSourceTexts, merge) => txt(key, customSourceTexts, merge).toUpperCase()
const txtLowerCase = (key, customSourceTexts, merge) => txt(key, customSourceTexts, merge).toLowerCase()
const txtTitleCase = (key, customSourceTexts, merge) => txt(key, customSourceTexts, merge).toTitleCase()

;/**
 * 
 * All the static texts used in the UI components
 * 
 */
kiss.language.texts = {
    /**
     * General
     */
    "data": {
        fr: "données",
        es: "datos"
    },
    "untitled": {
        fr: "sans titre",
        es: "sin título"
    },
    "yes": {
        fr: "oui",
        es: "sí"
    },
    "no": {
        fr: "non",
        es: "no"
    },
    "or": {
        fr: "ou",
        es: "o"
    },
    "and": {
        fr: "et",
        es: "y"
    },    
    "new": {
        fr: "nouveau",
        es: "nuevo"
    },
    "edit": {
        fr: "modifier",
        es: "editar"
    },
    "validate": {
        fr: "valider",
        es: "validar"
    },
    "cancel": {
        fr: "annuler",
        es: "cancelar"
    },
    "delete": {
        fr: "supprimer",
        es: "eliminar"
    },
    "update": {
        fr: "mettre à jour",
        es: "actualizar"
    },
    "back": {
        fr: "retour",
        es: "regresar"
    },
    "save": {
        fr: "sauver",
        es: "guardar"
    },
    "save changes": {
        fr: "sauver les modifications",
        es: "guardar cambios"
    },
    "exit": {
        fr: "sortir",
        es: "salir"
    },
    "save and exit": {
        fr: "sauver et sortir",
        es: "guardar y salir"
    },
    "refresh": {
        fr: "mettre à jour",
        es: "actualizar"
    },
    "#not authorized": {
        en: "you are not authorized to perform this operation",
        fr: "vous n'êtes pas autorisé à effectuer cette opération",
        es: "no estás autorizado para realizar esta operación"
    },
    "#error general": {
        en: "sorry, we could not perform this operation",
        fr: "désolé, nous n'avons pas pu effectuer cette opération",
        es: "lo sentimos, no pudimos realizar esta operación"
    },
    "color": {
        fr: "couleur",
        es: "color"
    },
    "geometry": {
        fr: "géométrie",
        es: "geometría"
    },
    "contains": {
        fr: "contient",
        es: "contiene"
    },
    "does not contain": {
        fr: "ne contient pas",
        es: "no contiene"
    },
    "is empty": {
        fr: "est vide",
        es: "está vacío"
    },
    "is not empty": {
        fr: "n'est pas vide",
        es: "no está vacío"
    },
    "Unable to download this file.": {
        fr: "Impossible de télécharger ce fichier.",
        es: "No es posible descargar este archivo."
    },
    "search": {
        fr: "rechercher",
        es: "buscar"
    },
    "#createdAt": {
        en: "created at",
        fr: "créé le",
        es: "creado el"
    },
    "#createdBy": {
        en: "created by",
        fr: "créé par",
        es: "creado por"
    },
    "#updatedAt": {
        en: "updated at",
        fr: "modifié le",
        es: "modificado el"
    },
    "#updatedBy": {
        en: "updated by",
        fr: "modifié par",
        es: "modificado por"
    },
    "#deletedAt": {
        en: "deleted at",
        fr: "supprimé le",
        es: "eliminado el"
    },
    "#deletedBy": {
        en: "deleted by",
        fr: "supprimé par",
        es: "eliminado por"
    },
    "copy to clipboard": {
        fr: "copier dans le presse-papier",
        es: "copiar al portapapeles"
    },
    "copied to clipboard": {
        fr: "copié dans le presse-papier",
        es: "copiado al portapapeles"
    },
    "#update done": {
        en: "update done",
        fr: "mise à jour effectuée",
        es: "actualización realizada"
    },
    "nothing to undo": {
        fr: "rien à annuler",
        es: "nada que deshacer"
    },
    "nothing to redo": {
        fr: "rien à refaire",
        es: "nada que rehacer"
    },
    "undo": {
        en: "undo last change",
        fr: "annuler la dernière modification",
        es: "deshacer la última modificación"
    },
    "redo": {
        en: "redo last change",
        fr: "refaire la dernière modification",
        es: "rehacer la última modificación"
    },

    /**
     * Authentication & Registration
     */
    "name": {
        fr: "nom",
        es: "nombre"
    },
    "first name": {
        fr: "prénom",
        es: "nombre"
    },
    "last name": {
        fr: "nom",
        es: "apellido"
    },
    "email": {
        fr: "email",
        es: "correo electrónico"
    },
    "password": {
        fr: "mot de passe",
        es: "contraseña"
    },
    "login": {
        fr: "se connecter",
        es: "iniciar sesión"
    },
    "login with": {
        fr: "se connecter avec",
        es: "iniciar sesión con"
    },
    "#no account": {
        en: "don't have an account? Sign up",
        fr: "pas de compte ? Enregistrez-vous",
        es: "¿No tienes cuenta? Regístrate"
    },
    "#already an account": {
        en: "already have an account? Sign in",
        fr: "vous avez un compte ? Connectez-vous",
        es: "¿Ya tienes cuenta? Inicia sesión"
    },
    "authentication-error": {
        en: "sorry, we could not authenticate you properly with third party service...",
        fr: "désolé, nous n'avons pas pu vous authentifier correctement auprès du service externe",
        es: "lo sentimos, no pudimos autenticarte correctamente con el servicio externo..."
    },
    "register": {
        fr: "s'enregistrer",
        es: "registrarse"
    },
    "register with": {
        fr: "s'enregistrer avec",
        es: "registrarse con"
    },
    "register to": {
        fr: "s'enregistrer à",
        es: "registrarse en"
    },
    "#thanks for registration": {
        en: "thank you! You will soon receive an email containing a link to activate your account...",
        fr: "merci ! Vous allez bientôt recevoir un email contenant un lien pour activer votre compte...",
        es: "¡Gracias! Pronto recibirás un correo electrónico con un enlace para activar tu cuenta..."
    },
    "UserAlreadyExists": {
        en: "this email is already registered",
        fr: "cet email est déjà enregistré",
        es: "este correo electrónico ya está registrado"
    },

    /**
     * Password change
     */
    "forgot password?": {
        fr: "mot de passe oublié ?",
        es: "¿Olvidaste tu contraseña?"
    },
    "change password": {
        fr: "changer le mot de passe",
        es: "cambiar la contraseña"
    },
    "password confirmation": {
        fr: "confirmation du mot de passe",
        es: "confirmación de contraseña"
    },
    "new password": {
        fr: "nouveau mot de passe",
        es: "nueva contraseña"
    },
    "new password confirmation": {
        fr: "confirmation du nouveau mot de passe",
        es: "confirmación de la nueva contraseña"
    },
    "#password don't match": {
        en: "Your 2 passwords don't match",
        fr: "Vos 2 mots de passe ne correspondent pas",
        es: "Tus 2 contraseñas no coinciden"
    },
    "please, enter your email": {
        fr: "entrez votre email SVP",
        es: "por favor, ingresa tu correo electrónico"
    },
    "#email missing": {
        en: "please, enter your email",
        fr: "merci de préciser votre email",
        es: "por favor, ingresa tu correo electrónico"
    },
    "password reset": {
        fr: "réinitialisation du mot de passe",
        es: "restablecimiento de contraseña"
    },
    "#password reset request": {
        en: "We've just sent you an email to reset your password.\nDon't forget to check your spam folder!",
        fr: "Nous venons de vous envoyer un email pour réinitialiser votre mot de passe.\nN'oubliez pas de vérifier votre dossier spam !",
        es: "Acabamos de enviarte un correo electrónico para restablecer tu contraseña.\n¡No olvides revisar tu carpeta de spam!"
    },

    /**
     * Directory
     */
    "user": {
        fr: "utilisateur",
        es: "usuario"
    },
    "users": {
        fr: "utilisateurs",
        es: "usuarios"
    },
    "collaborations": {
        fr: "collaborations",
        es: "colaboraciones"
    },
    "accounts": {
        fr: "comptes",
        es: "cuentas"
    },
    "groups": {
        fr: "groupes",
        es: "grupos"
    },

    /**
     * Network
     */
    "websocket disconnected": {
        en: "sorry, it seems you've been disconnected. Trying to reconnect...",
        fr: "désolé, il semble que vous ayez été déconnecté. Essai de reconnexion...",
        es: "lo siento, parece que has sido desconectado. Intentando reconectar..."
    },
    "websocket connection lost": {
        en: "sorry, the connection has been lost. Try to reload the page...\n\nIt is also possible that your profile is connected to another tab or browser.\nIt's not possible to be logged in twice with the same profile.",
        fr: "désolé, la connexion a été perdue. Essayez de recharger la page...\n\nIl est possible aussi que votre profil se soit connecté sur un autre onglet ou navigateur.\nIl n'est pas possible d'être connecté deux fois avec le même profil.",
        es: "lo siento, la conexión se ha perdido. Intenta recargar la página...\n\nTambién es posible que tu perfil esté conectado en otra pestaña o navegador.\nNo es posible iniciar sesión dos veces con el mismo perfil."
    },
    "#error slow connection": {
        en: "sorry, your connection is too slow to load data properly",
        fr: "désolé, votre connexion est trop lente pour charger les données correctement",
        es: "lo sentimos, tu conexión es demasiado lenta para cargar los datos correctamente"
    },

    /**
     * Features
     */
    "#coming soon": {
        en: "coming soon",
        fr: "bientôt disponible",
        es: "próximamente"
    },
    "#not available yet": {
        en: "this feature is not available yet but we're working on it!",
        fr: "cette fonctionnalité n'est pas encore disponible mais nous travaillons dessus !",
        es: "esta función aún no está disponible, ¡pero estamos trabajando en ello!"
    },

    /**
     * Main menu
     */
    "switch language": {
        fr: "changer de langue",
        es: "cambiar idioma"
    },
    "pick a language": {
        fr: "choisir une langue",
        es: "seleccionar un idioma"
    },
    "select a theme": {
        fr: "choisir un thème",
        es: "seleccionar un tema"
    },
    "open the map": {
        fr: "ouvrir la carte",
        es: "abrir el mapa"
    },
    "logout": {
        fr: "se déconnecter",
        es: "cerrar sesión"
    },
    "#auto logout": {
        en: "auto logout",
        fr: "déconnexion automatique",
        es: "cerrar sesión automáticamente",
    },
    "#auto logout help": {
        en: "determine the idle time (in hours) before auto logout",
        fr: "déterminez le temps d'inactivité (en heures) avant la déconnexion automatique",
        es: "determina el tiempo de inactividad (en horas) antes de cerrar sesión automáticamente"
    },

    /**
     * Fields
     */
    "text": {
        fr: "texte",
        es: "texto"
    },
    "paragraph": {
        fr: "paragraphe",
        es: "párrafo"
    },
    "rich text": {
        fr: "texte riche",
        es: "texto enriquecido"
    },
    "static text": {
        fr: "texte statique",
        es: "texto estático"
    },    
    "number": {
        fr: "nombre",
        es: "número"
    },
    "date": {
        fr: "date",
        es: "fecha"
    },
    "time": {
        fr: "heure",
        es: "hora"
    },
    "#select": {
        en: "dropdown list (static)",
        fr: "liste déroulante (statique)",
        es: "lista desplegable (estática)"
    },
    "#select view column": {
        en: "dropdown list (1 view column)",
        fr: "liste déroulante (1 colonne de vue)",
        es: "lista desplegable (1 columna de vista)"
    },
    "#select view columns": {
        en: "select from a view",
        fr: "sélection dans une vue",
        es: "selección desde una vista"
    },
    "#select view": {
        en: "select the data source view",
        fr: "sélectionnez la vue source des données",
        es: "selecciona la vista de la fuente de datos"
    },
    "checkbox": {
        fr: "case à cocher",
        es: "casilla de verificación"
    },
    "slider": {
        en: "progress bar",
        fr: "barre de progression",
        es: "barra de progreso"
    },
    "slider step": {
        en: "step",
        fr: "incrément",
        es: "incremento"
    },
    "rating": {
        fr: "notation",
        es: "calificación"
    },
    "attachment": {
        fr: "fichiers attachés",
        es: "archivos adjuntos"
    },
    "attachments": {
        fr: "fichiers attachés",
        es: "archivos adjuntos"
    },
    "collaborators": {
        fr: "collaborateurs",
        es: "colaboradores"
    },
    "color picker": {
        fr: "palette de couleur",
        es: "selector de color"
    },
    "icon picker": {
        fr: "palette d'icônes",
        es: "selector de iconos"
    },
    "map field": {
        en: "map",
        fr: "carte",
        es: "mapa"
    },
    "map ratio": {
        en: "map ratio (width/height)",
        fr: "ratio de la carte (largeur/hauteur)",
        es: "relación del mapa (ancho/alto)"
    },
    "map zoom": {
        fr: "zoom de la carte",
        es: "zoom del mapa"
    },
    "from": {
        fr: "de",
        es: "de"
    },
    "to": {
        fr: "à",
        es: "a"
    },
    "cc": {
        fr: "copie à",
        es: "cc"
    },
    "subject": {
        fr: "sujet",
        es: "asunto"
    },
    "#updating ACL": {
        en: "the security of this file changed to",
        fr: "la sécurité de ce fichier a changé en",
        es: "la seguridad de este archivo cambió a"
    },
    "#update file ACL": {
        en: "put this file %access in",
        fr: "mettre ce fichier en accès %access",
        es: "poner este archivo %access en"
    },
    "public": {
        fr: "public",
        es: "público"
    },
    "private": {
        fr: "privé",
        es: "privado"
    },
    "field style": {
        fr: "style du champ",
        es: "estilo del campo"
    },
    "#style no labels": {
        en: "without field labels",
        fr: "sans les libellés de champs",
        es: "sin etiquetas de campos"
    },
    "#style compact": {
        en: "compact",
        fr: "compact",
        es: "compacto"
    },
    "#fields incorrect value": {
        en: "some fields have an incorrect value",
        fr: "certains champs ont une valeur incorrecte",
        es: "algunos campos tienen un valor incorrecto"
    },
    "#not available offline": {
        en: "sorry, this feature is not available offline",
        fr: "désolé, cette fonctionnalité n'est pas disponible hors ligne",
        es: "lo siento, esta función no está disponible sin conexión"
    },
    "#not available in demo": {
        en: "sorry, this feature is not available in the demonstration",
        fr: "désolé, cette fonctionnalité n'est pas disponible dans la démonstration",
        es: "lo siento, esta función no está disponible en la demostración"
    },

    /**
     * AI image
     */
    "AI image": {
        fr: "image IA",
        es: "imagen IA"
    },
    "#image generator": {
        en: "your AI image generator assistant",
        fr: "votre assistant IA pour générer des images",
        es: "tu asistente generador de imágenes IA"
    },
    "image format": {
        fr: "format de l'image",
        es: "formato de la imagen"
    },
    "#AI image instructions": {
        en: "give your instructions to the AI image generator",
        fr: "donnez vos instructions à l'IA pour générer l'image",
        es: "da tus instrucciones al generador de imágenes IA"
    },
    "generate image...": {
        fr: "générer l'image...",
        es: "generar imagen..."
    },
    "generate an image": {
        fr: "générer une image",
        es: "generar una imagen"
    },
    "portrait": {
        fr: "portrait",
        es: "retrato"
    },
    "landscape": {
        fr: "paysage",
        es: "paisaje"
    },
    "square": {
        fr: "carré",
        es: "cuadrado"
    },

    /**
     * AI paragraph
     */
    "AI paragraph": {
        fr: "paragraphe IA",
        es: "párrafo de IA"
    },
    "your AI assistant": {
        fr: "votre assistant IA",
        es: "tu asistente de IA"
    },
    "response max length": {
        fr: "longueur maximale de la réponse",
        es: "longitud máxima de la respuesta"
    },
    "#AI prompt instructions": {
        en: "give your instructions to the AI",
        fr: "donnez vos instructions à l'IA",
        es: "da tus instrucciones a la IA"
    },
    "generate content...": {
        fr: "générer le contenu...",
        es: "generar contenido..."
    },
    "are you sure you want to cancel your input?": {
        fr: "êtes-vous sûr de vouloir annuler votre saisie ?",
        es: "¿Estás seguro de querer cancelar tu entrada?"
    },
    "creativity": {
        fr: "créativité",
        es: "creatividad"
    },

    // AI profiles
    "AI profile": {
        fr: "profil de l'IA",
        es: "perfil de la IA"
    },
    "no profile": {
        fr: "pas de profil",
        es: "sin perfil"
    },
    "sales rep": {
        fr: "commercial",
        es: "comercial"
    },
    "HR manager": {
        fr: "manager RH",
        es: "gerente de RRHH"
    },
    "marketing manager": {
        fr: "manager marketing",
        es: "gerente de marketing"
    },
    "product manager": {
        fr: "responsable produit",
        es: "gerente de producto"
    },
    // Tasks
    "task": {
        fr: "tâche",
        es: "tarea"
    },
    "free": {
        fr: "libre",
        es: "libre"
    },
    "draft a blog post": {
        fr: "écrire un brouillon de post de blog",
        es: "escribir un borrador de entrada de blog"
    },
    "summup a text": {
        fr: "résumer un texte",
        es: "resumir un texto"
    },
    "convert to Tweet": {
        fr: "convertir en Tweet",
        es: "convertir a Tweet"
    },
    "write an email": {
        fr: "écrire un email",
        es: "escribir un correo electrónico"
    },
    "create user persona": {
        fr: "créer un persona",
        es: "crear un persona"
    },
    "create job description": {
        fr: "créer une description d'emploi",
        es: "crear una descripción de empleo"
    },
    // Tones
    "tone to use": {
        fr: "ton à utiliser",
        es: "tono a usar"
    },
    "casual": {
        fr: "décontracté",
        es: "informal"
    },
    "formal": {
        fr: "formel",
        es: "formal"
    },
    "humour": {
        fr: "humour",
        es: "humor"
    },
    "ironic": {
        fr: "ironique",
        es: "irónico"
    },
    // Goals
    "goal": {
        fr: "objectif",
        es: "objetivo"
    },
    "none": {
        fr: "aucun",
        es: "ninguno"
    },
    "inform": {
        fr: "informer",
        es: "informar"
    },
    "persuade": {
        fr: "persuader",
        es: "persuadir"
    },
    "inspire": {
        fr: "inspirer",
        es: "inspirar"
    },

    /**
     * Views
     */
    "#pick a view type": {
        en: "pick a view type to display your data",
        fr: "choisissez un type de vue pour afficher vos données",
        es: "elige un tipo de vista para mostrar tus datos"
    },
    "datatable": {
        fr: "grille de données",
        es: "tabla de datos"
    },
    "datatable view": {
        en: "create a grid view to manage your data as easily as in a spreadsheet",
        fr: "créez une vue table pour gérer vos données aussi facilement que dans un tableur",
        es: "crea una vista de cuadrícula para gestionar tus datos tan fácilmente como en una hoja de cálculo"
    },
    "calendar": {
        fr: "calendrier",
        es: "calendario"
    },
    "calendar view": {
        en: "visualize your data in a calendar according to the date fields of your forms",
        fr: "visualisez vos données dans un agenda en fonction des champs date de vos formulaires",
        es: "visualiza tus datos en un calendario según los campos de fecha de tus formularios"
    },
    "gallery": {
        fr: "gallerie",
        es: "galería"
    },
    "gallery view": {
        en: "display your data by highlighting attached images in your forms",
        fr: "affichez vos données en mettant en évidence les images jointes à vos formulaires",
        es: "muestra tus datos destacando las imágenes adjuntas en tus formularios"
    },
    "kanban view": {
        en: "follow your tasks or activity pipelines on a kanban board",
        fr: "suivez vos tâches ou pipelines d'activités sur un tableau kanban",
        es: "sigue tus tareas o tuberías de actividad en un tablero kanban"
    },
    "timeline": {
        fr: "ligne de temps",
        es: "línea de tiempo"
    },
    "timeline view": {
        en: "follow your tasks or activity pipelines on a timeline",
        fr: "suivez vos tâches ou pipelines d'activités sur une ligne de temps",
        es: "sigue tus tareas o tuberías de actividad en una línea de tiempo"
    },
    "chart": {
        fr: "graphique",
        es: "gráfico"
    },
    "chart view": {
        en: "visualize your data in a chart",
        fr: "visualisez les données dans un graphique",
        es: "visualiza los datos en un gráfico"
    },

    /**
     * Dashboard
     */
    "dashboard": {
        fr: "tableau de bord",
        es: "tablero de control"
    },
    "dashboard view": {
        en: "create a dashboard with multiple charts to follow your key indicators",
        fr: "créez un tableau de bord de plusieurs graphiques pour suivre vos indicateurs clés",
        es: "crea un tablero de control con varios gráficos para seguir tus indicadores clave"
    },
    "#help setup chart": {
        en: "click here to setup this chart",
        fr: "cliquez ici pour paramétrer ce graphique",
        es: "haz clic aquí para configurar este gráfico"
    },    
    "#help add chart": {
        en: "click here to add another chart on this row",
        fr: "cliquez ici pour ajouter un autre graphique sur cette ligne",
        es: "haz clic aquí para añadir otro gráfico a este tablero"
    },
    "add chart": {
        fr: "ajouter un graphique",
        es: "añadir un gráfico"
    },
    "this row is full": {
        fr: "cette ligne est pleine",
        es: "esta fila está llena"
    },
    "move up": {
        fr: "déplacer vers le haut",
        es: "mover hacia arriba"
    },
    "move down": {
        fr: "déplacer vers le bas",
        es: "mover hacia abajo"
    },
    "row height": {
        fr: "hauteur de la ligne",
        es: "altura de la fila"
    },
    "add row": {
        fr: "ajouter une ligne",
        es: "añadir una fila"
    },
    "delete this row": {
        fr: "supprimer cette ligne",
        es: "eliminar esta fila"
    },
    "#delete row": {
        en: "are you sure you want to delete this row?",
        fr: "êtes-vous sûr de vouloir supprimer cette ligne ?",
        es: "¿estás seguro de querer eliminar esta fila?"
    },

    /**
     * Attachment field
     */
    "attach files": {
        fr: "attacher des fichiers",
        es: "adjuntar archivos"
    },
    "select files to upload": {
        fr: "sélectionner les fichiers à télécharger",
        es: "seleccionar archivos para subir"
    },
    "choose your upload method": {
        fr: "choisissez votre méthode de téléchargement",
        es: "elige tu método de carga"
    },
    "my device": {
        fr: "mon ordinateur",
        es: "mi dispositivo"
    },
    "#upload local help": {
        en: "drag and drop some files here, or click on the button below to browse your disk...",
        fr: "glissez déposez des fichiers ici, ou cliquez sur le bouton ci-dessous pour rechercher sur votre disque",
        es: "arrastra y suelta algunos archivos aquí, o haz clic en el botón de abajo para explorar tu disco..."
    },
    "#upload local help mobile": {
        en: "click on the button below to browse your device...",
        fr: "cliquez sur le bouton ci-dessous pour rechercher sur votre appareil...",
        es: "haz clic en el botón de abajo para explorar tu dispositivo..."
    },
    "#upload security mode": {
        en: "public / private",
        fr: "public / privé",
        es: "público / privado"
    },
    "link (URL)": {
        fr: "hyperlien (URL)",
        es: "enlace (URL)"
    },
    "add file from URL": {
        fr: "ajouter le fichier depuis l'URL",
        es: "añadir archivo desde URL"
    },
    "enter an URL here": {
        fr: "entez une URL ici",
        es: "ingresa una URL aquí"
    },
    "#upload link help": {
        en: "copy/paste the URL of a file in the field below, click Add file from URL then Upload...",
        fr: "copiez/collez l'URL d'un fichier dans le champ ci-dessous, cliquez sur Ajouter le fichier depuis l'URL, puis Télécharger",
        es: "copia/pega la URL de un archivo en el campo de abajo, haz clic en Añadir archivo desde URL y luego en Subir..."
    },
    "web search": {
        fr: "recherche web",
        es: "búsqueda web"
    },
    "take photo": {
        fr: "prendre une photo",
        es: "tomar una foto"
    },
    "#upload webcam help": {
        en: "please click on Open Webcam button to capture an image...",
        fr: "merci de cliquer sur Ouvrir la Webcam pour capturer une image...",
        es: "por favor haz clic en el botón de Abrir Webcam para capturar una imagen..."
    },
    "open webcam": {
        fr: "Ouvrir la webcam",
        es: "abrir la webcam"
    },
    "#take photo": {
        en: "click Take photo to add image",
        fr: "cliquez sur Prendre une photo pour ajouter une image",
        es: "haz clic en Tomar foto para añadir una imagen"
    },
    "#upload web search help": {
        en: "search images on the web using the search field below",
        fr: "recherchez des images sur le web via le champ de recherche ci-dessous",
        es: "busca imágenes en la web usando el campo de búsqueda de abajo"
    },
    "enter your search term and press Enter": {
        fr: "entrez votre recherche et pressez Enter",
        es: "ingresa tu término de búsqueda y presiona Enter"
    },
    "add images from Web search": {
        fr: "ajouter les images trouvées",
        es: "añadir imágenes encontradas"
    },
    "upload": {
        fr: "télécharger les fichiers",
        es: "subir archivos"
    },
    "upload %n file(s)": {
        fr: "télécharger %n fichier(s)",
        es: "subir %n archivo(s)"
    },
    "#upload drive help": {
        en: "select files from your %drive account then click on Upload...",
        fr: "sélectionnez des fichiers depuis votre compte %drive puis cliquez sur Télécharger",
        es: "selecciona archivos desde tu cuenta de %drive y luego haz clic en Subir..."
    },
    "connect to your %drive account": {
        fr: "connectez-vous à votre compte %drive",
        es: "conéctate a tu cuenta de %drive"
    },
    "#no preview": {
        en: "sorry, we can't preview this file type:",
        fr: "désolé, le navigateur ne peut pas prévisualiser ce type de fichier :",
        es: "lo siento, no podemos previsualizar este tipo de archivo:"
    },
    "deleting a file": {
        fr: "effacer un fichier",
        es: "eliminar un archivo"
    },
    "#warning delete file": {
        en: "do you really want to delete this file?",
        fr: "voulez-vous vraiment effacer ce fichier ?",
        es: "¿realmente quieres eliminar este archivo?"
    },
    "#warning file size": {
        en: "the total size of files should not exceed",
        fr: "la taille totale des fichiers ne doit pas dépasser",
        es: "el tamaño total de los archivos no debe exceder"
    },
    "#preview mode": {
        en: "side / center view",
        fr: "affichage latéral / central",
        es: "vista lateral / central"
    },

    /**
     * Link field
     */
    "link to another table": {
        fr: "liaison vers une autre table",
        es: "enlace a otra tabla"
    },
    "#select link": {
        en: "select",
        fr: "sélectionner",
        es: "seleccionar"
    },
    "delete a link": {
        fr: "effacer une liaison",
        es: "eliminar un enlace"
    },
    "#delete link": {
        en: "this will delete the link between the records. Do you want to do that?",
        fr: "cela va supprimer la liaison entre les fiches. Voulez-vous bien faire cela ?",
        es: "esto eliminará el enlace entre los registros. ¿Quieres hacer eso?"
    },
    "#connect records": {
        en: "connecting 2 records",
        fr: "connecter 2 données",
        es: "conectar 2 registros"
    },
    "#connect confirmation": {
        en: "are you sure you want to link this record?",
        fr: "êtes-vous sûr de vouloir connecter cette donnée ?",
        es: "¿estás seguro de que quieres enlazar este registro?"
    },
    "#link to": {
        en: "link to a record from the table:",
        fr: "lier à une donnée de la table :",
        es: "enlazar con un registro de la tabla:"
    },
    "#record already linked": {
        en: "this record is already linked",
        fr: "cette fiche est déjà liée",
        es: "este registro ya está vinculado"
    },
    "#only one link": {
        en: "you can only link a single element",
        fr: "vous ne pouvez lier qu'un seul élément",
        es: "solo puedes enlazar un único elemento"
    },
    "display as table": {
        fr: "afficher en table",
        es: "mostrar como tabla"
    },

    /**
     * Datatable
     */
    "add a table": {
        fr: "ajouter une table",
        es: "añadir una tabla"
    },
    "select your fields": {
        fr: "Choisissez vos champs",
        es: "elige tus campos"
    },
    "cells": {
        fr: "cellules",
        es: "células"
    },
    "rows": {
        fr: "lignes",
        es: "filas"
    },
    "columns": {
        fr: "colonnes",
        es: "columnas"
    },
    "#display fields": {
        en: "select fields",
        fr: "sélectionner les champs",
        es: "seleccionar campos"
    },
    "add a column": {
        fr: "ajouter une colonne",
        es: "añadir una columna"
    },
    "column color": {
        fr: "couleur de la colonne",
        es: "color de la columna"
    },
    "remove color": {
        fr: "enlever la couleur",
        es: "eliminar el color"
    },
    "sort your data": {
        fr: "triez vos données",
        es: "ordena tus datos",
    },
    "to sort": {
        en: "sort",
        fr: "trier",
        es: "ordenar"
    },
    "sort by": {
        fr: "trier par",
        es: "ordenar por"
    },
    "then by": {
        fr: "puis par",
        es: "luego por"
    },
    "inverse order": {
        fr: "ordre inverse",
        es: "orden inverso"
    },
    "select a field to sort by": {
        fr: "Sélectionner le champ à trier",
        es: "selecciona un campo por el cual ordenar"
    },
    "add a subgroup": {
        fr: "ajouter un sous-groupe",
        es: "añadir un subgrupo"
    },
    "filter your data": {
        fr: "Filtrez vos données",
        es: "filtra tus datos"
    },
    "where field": {
        fr: "Où le champ",
        es: "donde el campo"
    },
    "operator": {
        fr: "Opérateur",
        es: "operador"
    },
    "comparison": {
        fr: "comparaison",
        es: "comparación"
    },
    "today": {
        fr: "aujourd'hui",
        es: "hoy"
    },
    "exact date": {
        fr: "date exacte",
        es: "fecha exacta"
    },
    "days ago": {
        fr: "il y a N jours",
        es: "hace N días"
    },
    "days from now": {
        fr: "dans N jours",
        es: "en N días"
    },
    "days": {
        fr: "jours",
        es: "días"
    },
    "value": {
        fr: "valeur",
        es: "valor"
    },
    "add a filter": {
        fr: "ajouter un filtre",
        es: "añadir un filtro"
    },
    "to filter": {
        en: "filter",
        fr: "filtrer",
        es: "filtrar"
    },
    "actions": {
        fr: "actions",
        es: "acciones"
    },
    "hide all": {
        fr: "tout cacher",
        es: "ocultar todo"
    },
    "show all": {
        fr: "tout afficher",
        es: "mostrar todo"
    },
    "expand all": {
        fr: "tout déployer",
        es: "expandir todo"
    },
    "collapse all": {
        fr: "tout condenser",
        es: "colapsar todo"
    },
    "group by": {
        fr: "grouper par",
        es: "agrupar por"
    },
    "#ftsearch title": {
        en: "current search term",
        fr: "recherche actuelle",
        es: "término de búsqueda actual"
    },
    "seriously": {
        en: "6 groups",
        fr: "6 groupes",
        es: "6 grupos"
    },
    "#too many groups": {
        en: "sorry, it's not possible to group on more than 6 fields",
        fr: "désolé, il n'est pas possible de grouper sur plus de 6 champs",
        es: "lo siento, no es posible agrupar en más de 6 campos"
    },
    "#understood": {
        en: "ok, roger that!",
        fr: "ok, compris !",
        es: "¡ok, entendido!"
    },
    "show group hierarchy": {
        fr: "afficher la hiérarchie des groupes",
        es: "mostrar la jerarquía de grupos"
    },
    "download file": {
        fr: "télécharger le fichier",
        es: "descargar archivo"
    },
    "#no links": {
        en: "this record has no links to %table",
        fr: "cette donnée n'a pas de liens vers %table",
        es: "este registro no tiene enlaces a %table"
    },
    "#summary": {
        en: "summary",
        fr: "aggrégation",
        es: "resumen"
    },
    "sum": {
        fr: "somme",
        es: "suma"
    },
    "#sum": {
        en: "sum",
        fr: "som.",
        es: "sum."
    },
    "average": {
        fr: "moyenne",
        es: "promedio"
    },
    "#avg": {
        en: "avg.",
        fr: "moy.",
        es: "prom."
    },
    "#summary sum": {
        en: "display sum",
        fr: "afficher les sommes",
        es: "mostrar sumas"
    },
    "#summary avg": {
        en: "display average",
        fr: "afficher les moyennes",
        es: "mostrar promedios"
    },
    "#no summary": {
        en: "no summary",
        fr: "pas de calculs",
        es: "sin resumen"
    },
    "sort ascending": {
        fr: "trier dans l'ordre croissant",
        es: "ordenar de forma ascendente"
    },
    "sort descending": {
        fr: "trier dans l'ordre décroissant",
        es: "ordenar de forma descendente"
    },
    "#reset view params": {
        en: "reset view",
        fr: "réinitialiser la vue",
        es: "restablecer vista"
    },
    "layout": {
        fr: "mise en page",
        es: "diseño"
    },
    "cell size": {
        fr: "taille des cellules",
        es: "tamaño de las células"
    },
    "compact": {
        fr: "compact",
        es: "compacto"
    },
    "normal": {
        fr: "normal",
        es: "normal"
    },
    "extra small": {
        fr: "très petit",
        es: "extra pequeño"
    },
    "small": {
        fr: "petit",
        es: "pequeño"
    },
    "medium": {
        fr: "moyen",
        es: "mediano"
    },
    "large": {
        fr: "grand",
        es: "grande"
    },
    "extra large": {
        fr: "très grand",
        es: "extra grande"
    },
    "tall": {
        fr: "grand",
        es: "alto"
    },
    "very tall": {
        fr: "très grand",
        es: "muy alto"
    },
    "top": {
        fr: "haut",
        es: "arriba"
    },
    "middle": {
        fr: "milieu",
        es: "medio"
    },
    "bottom": {
        fr: "bas",
        es: "abajo"
    },
    "#realtime sync": {
        en: `<b>Real time update</b>
        <br>Warning: if you enable this feature, the view will be updated each time it is modified by you or another user`,
        fr: `<b>Mise à jour en temps réel</b>
        <br>Attention: si vous activez cette fonctionnalité, la vue sera mise à jour à chaque modification faite par vous ou un autre utilisateur`,
        es: `<b>Actualización en tiempo real</b>
        <br>Advertencia: si habilitas esta característica, la vista se actualizará cada vez que sea modificada por ti o por otro usuario`
    },
    "#quick tips": {
        en: "quick start",
        fr: "démarrage rapide",
        es: "inicio rápido"
    },
    "#replay tips": {
        en: "do you want to review these tips?",
        fr: "voulez-vous revoir ces conseils ?",
        es: "¿quieres revisar estos consejos?"
    },
    "#open link": {
        en: "open link in new tab",
        fr: "ouvrir le lien dans un nouvel onglet",
        es: "abrir enlace en nueva pestaña"
    },
    "#copy selection": {
        en: "copy selection to clipboard",
        fr: "copier la sélection dans le presse-papier",
        es: "copiar la selección en el portapapeles"
    },

    /**
     * Calendar
     */
    "january": {
        fr: "janvier",
        es: "enero"
    },
    "february": {
        fr: "février",
        es: "febrero"
    },
    "march": {
        fr: "mars",
        es: "marzo"
    },
    "april": {
        fr: "avril",
        es: "abril"
    },
    "may": {
        fr: "mai",
        es: "mayo"
    },
    "june": {
        fr: "juin",
        es: "junio"
    },
    "july": {
        fr: "juillet",
        es: "julio"
    },
    "august": {
        fr: "août",
        es: "agosto"
    },
    "september": {
        fr: "septembre",
        es: "septiembre"
    },
    "october": {
        fr: "octobre",
        es: "octubre"
    },
    "november": {
        fr: "novembre",
        es: "noviembre"
    },
    "december": {
        fr: "décembre",
        es: "diciembre"
    },
    "sunday": {
        fr: "dimanche",
        es: "domingo"
    },
    "monday": {
        fr: "lundi",
        es: "lunes"
    },
    "tuesday": {
        fr: "mardi",
        es: "martes"
    },
    "wednesday": {
        fr: "mercredi",
        es: "miércoles"
    },
    "thursday": {
        fr: "jeudi",
        es: "jueves"
    },
    "friday": {
        fr: "vendredi",
        es: "viernes"
    },
    "saturday": {
        fr: "samedi",
        es: "sábado"
    },
    "today": {
        fr: "aujourd'hui",
        es: "hoy"
    },
    "date field used": {
        fr: "champ Date utilisé",
        es: "campo Fecha usado"
    },
    "time field used": {
        fr: "champ Heure utilisé",
        es: "campo Hora usado"
    },
    "default period": {
        fr: "période par défaut",
        es: "período predeterminado"
    },
    "setup the calendar": {
        fr: "paramétrer le calendrier",
        es: "configurar el calendario"
    },
    "weeks start on monday": {
        fr: "les semaines démarrent le lundi",
        es: "las semanas comienzan el lunes"
    },
    "show week-ends": {
        fr: "afficher les week-ends",
        es: "mostrar los fines de semana"
    },
    "month": {
        fr: "mois",
        es: "mes"
    },
    "months": {
        fr: "mois",
        es: "meses"
    },
    "year": {
        fr: "année",
        es: "año"
    },
    "years": {
        fr: "années",
        es: "años"
    },
    "weeks": {
        fr: "semaines",
        es: "semanas"
    },
    "week": {
        fr: "semaine",
        es: "semana"
    },
    "details": {
        fr: "détails",
        es: "detalles"
    },

    /**
     * Kanban
     */
    "#move card": {
        en: "move to column",
        fr: "déplacer vers la colonne",
        es: "mover a la columna"
    },
    "#kanban help": {
        en: "select a field in the 'Group by' list to create the columns of your Kanban",
        fr: "choisissez un champ dans la liste 'Grouper par' pour créer les colonnes de votre Kanban",
        es: "seleccione un campo en la lista 'Agrupar por' para crear las columnas de su Kanban"
    },
    "#no category": {
        en: "without category",
        fr: "sans catégorie",
        es: "sin categoría"
    },
    "#move card": {
        en: "move to...",
        fr: "déplacer vers...",
        es: "mover a..."
    },
    "#card moved": {
        en: "card moved successfully to column",
        fr: "carte déplacée avec succès vers la colonne",
        es: "tarjeta movida exitosamente a la columna"
    },

    /**
     * Timeline
     */
    "setup the timeline": {
        fr: "paramétrer la ligne de temps",
        es: "configurar la línea de tiempo"
    },
    "#timeline start date": {
        en: "field used as the start date",
        fr: "champ pour la date de début",
        es: "campo usado como fecha de inicio"
    },
    "#timeline end date": {
        en: "field used as the end date",
        fr: "champ pour la date de fin",
        es: "campo usado como fecha de finalización"
    },
    "#timeline title field": {
        en: "field used as the title in the left column",
        fr: "champ pour le titre de la colonne de gauche",
        es: "campo usado como el título en la columna izquierda"
    },
    "#timeline period": {
        en: "default period displayed",
        fr: "période affichée par défaut",
        es: "período predeterminado mostrado"
    },
    "#timeline color field": {
        en: "field used as the color of the bars",
        fr: "champ pour la couleur des barres",
        es: "campo utilizado como color de las barras"
    },

    /**
     * Chart
     */
    "#chart help": {
        en: "click on the settings icon to configure the chart",
        fr: "cliquez sur le menu du graphique pour le configurer",
        es: "haz clic en el menú del gráfico para configurarlo"
    },
    "#chart wrong params": {
        en: "you didn't setup the chart correctly",
        fr: "vous n'avez pas configuré le graphique correctement",
        es: "no has configurado el gráfico correctamente"
    },
    "setup the chart": {
        fr: "paramétrer le graphique",
        es: "configurar el gráfico"
    },
    "#chart type": {
        en: "type of chart",
        fr: "type de graphique",
        es: "tipo de gráfico"
    },
    "#bar chart": {
        en: "display a comparison or a trend over time, with many categories",
        fr: "afficher une comparaison ou une tendance dans le temps, avec beaucoup de catégories",
        es: "mostrar una comparación o una tendencia en el tiempo, con muchas categorías"
    },
    "#line chart": {
        en: "display a trend over time or a relationship between 2 variables",
        fr: "afficher une tendance dans le temps ou une relation entre 2 variables",
        es: "mostrar una tendencia en el tiempo o una relación entre 2 variables"
    },
    "#pie chart": {
        en: "display a comparison, with few categories",
        fr: "afficher une comparaison, avec peu de catégories",
        es: "mostrar una comparación, con pocas categorías"
    },
    "#number chart": {
        en: "display a number representing a summary",
        fr: "afficher un nombre représentant une synthèse",
        es: "mostrar un número que representa un resumen"
    },
    "legend": {
        fr: "légende",
        es: "leyenda"
    },
    "#time series": {
        en: "show a time series",
        fr: "montrer une évolution temporelle",
        es: "mostrar una evolución temporal"
    },
    "#count data": {
        en: "count data",
        fr: "compter les données",
        es: "contar los datos"
    },
    "#summarize data": {
        en: "summarize data",
        fr: "aggréger les données",
        es: "resumir los datos"
    },
    "X-axis": {
        fr: "axe X",
        es: "eje X"
    },
    "Y-axis": {
        fr: "axe Y",
        es: "eje Y"
    },
    "time axis": {
        fr: "axe temporel",
        es: "eje temporal"
    },
    "chart values": {
        fr: "valeurs du graphique",
        es: "valores del gráfico",
    },
    "#category field": {
        en: "field used as the categories",
        fr: "champ pour les catégories",
        es: "campo para las categorías"
    },
    "#summary field": {
        en: "field to summarize",
        fr: "champ à agréger",
        es: "campo a resumir"
    },
    "start at zero": {
        fr: "démarrer à zéro",
        es: "comenzar en cero"
    },
    "download chart": {
        fr: "télécharger le graphique",
        es: "descargar gráfico"
    },
    "show legend": {
        fr: "afficher la légende",
        es: "mostrar leyenda"
    },
    "show values on chart": {
        fr: "afficher les valeurs sur le graphique",
        es: "mostrar valores en el gráfico"
    },
    "show labels on chart": {
        fr: "afficher les libellés sur le graphique",
        es: "mostrar etiquetas en el gráfico"
    },
    "#center labels": {
        en: "center labels",
        fr: "centrer les libellés",
        es: "centrar etiquetas"
    },
    "legend position": {
        fr: "position de la légende",
        es: "posición de la leyenda"
    },
    "download image": {
        fr: "télécharger l'image",
        es: "descargar imagen"
    },

    /**
     * Messages to notify database mutations
     */
    "#msg insert": {
        en: "user <b> %user </b> created <b> %object </b>",
        fr: "l'utilisateur <b> %user </b> a créé <b> %object </b>",
        es: "el usuario <b> %user </b> creó <b> %object </b>"
    },
    "#msg update": {
        en: "user <b> %user </b> updated <b> %object </b>",
        fr: "l'utilisateur <b> %user </b> a mis à jour <b> %object </b>",
        es: "el usuario <b> %user </b> actualizó <b> %object </b>"
    },
    "#msg delete": {
        en: "user <b> %user </b> deleted <b> %object </b>",
        fr: "l'utilisateur <b> %user </b> a supprimé <b> %object </b>",
        es: "el usuario <b> %user </b> eliminó <b> %object </b>"
    },
    "#a record": {
        en: "a record",
        fr: "une donnée",
        es: "un registro"
    },
    "#a view": {
        en: "a view",
        fr: "une vue",
        es: "una vista"
    },
    "#a model": {
        en: "a form / table",
        fr: "un formulaire / une table",
        es: "un formulario / una tabla"
    },
    "#some data": {
        en: "some data",
        fr: "des données",
        es: "algunos datos"
    },

    /**
     * Themes
     */
    "dark": {
        fr: "sombre",
        es: "oscuro"
    },
    "light": {
        fr: "clair",
        es: "claro"
    },
    "custom": {
        fr: "personnel",
        es: "personalizado"
    },
    "default": {
        fr: "par défaut",
        es: "predeterminado"
    },
    "sharp": {
        fr: "anguleux",
        es: "anguloso"
    },
    "round": {
        fr: "arrondi",
        es: "redondeado"
    },
    "theme builder": {
        en: "CSS theme creation",
        fr: "création de thème CSS",
        es: "creación de tema CSS"
    },
    "#download theme": {
        en: "download the theme",
        fr: "télécharger le thème",
        es: "descargar el tema personalizado"
    },
    "#load theme": {
        en: "load a theme",
        fr: "charger un thème",
        es: "cargar un tema"
    },
    "#theme name": {
        en: "theme name",
        fr: "nom du thème",
        es: "nombre del tema"
    },
    "#theme name help": {
        en: "give a name to your theme",
        fr: "donnez un nom à votre thème",
        es: "da un nombre a tu tema"
    },
    "body": {
        fr: "corps",
        es: "cuerpo"
    },
    "basic colors": {
        fr: "couleurs de base",
        es: "colores básicos"
    },
    "special backgrounds": {
        fr: "arrière-plans spéciaux",
        es: "fondos especiales"
    },
    "shadows": {
        fr: "ombres",
        es: "sombras"
    },
    "scrollbars": {
        fr: "barres de défilement",
        es: "barras de desplazamiento"
    },
    "data components": {
        fr: "composants de données",
        es: "componentes de datos"
    },
    "tabs": {
        fr: "onglets",
        es: "pestañas"
    },
    "loading": {
        fr: "chargement",
        es: "carga"
    },
    "home page": {
        fr: "page d'accueil",
        es: "página de inicio"
    },
    "fields": {
        fr: "champs",
        es: "campos"
    },
    "select fields": {
        fr: "listes déroulantes",
        es: "listas desplegables"
    },
    "panels": {
        fr: "panneaux",
        es: "paneles"
    },
    "menus": {
        fr: "menus",
        es: "menús"
    },
    "buttons": {
        fr: "boutons",
        es: "botones"
    }
}

;/**
 * 
 * ## Simple module to handle a global loading spinner.
 * 
 * When multiple components needs to lock the UI while they are loading, it can be tricky to know when to show and hide the loading screen.
 * This module solves the problem by mutualizing the loading screen between components.
 * 
 * @namespace
 * 
 */
kiss.loadingSpinner = {

    // Used to track components which are in loading state
    components: [],

    /**
     * Check the loading state
     * 
     * @private
     * @ignore
     * @returns {boolean} true if the loading spinner is displayed
     */
    _isLoading() {
        return (this.components.length != 0)
    },

    /**
     * Build the DOM element that will hold the loading spinner
     * 
     * @private
     * @ignore
     */
    _init() {
        this.loadingLayer = document.createElement("div")
        this.loadingLayer.setAttribute("id", "loading-layer")
        this.loadingLayer.style.display = "fixed"
        this.loadingLayer.style.width = "100%"
        this.loadingLayer.style.height = "100%"
        document.body.append(this.loadingLayer)
    },

    /**
     * Show the loading spinner.
     * 
     * @returns {string} A unique id used later to hide the loading spinner
     * 
     * @example
     * 
     * // To show the loading spinner
     * const loadingId = kiss.loadingSpinner.show()
     * 
     * // To hide the loading spinner
     * kiss.loadingSpinner.hide(loadingId)
     * 
     * // With multiple components loading in parallel:
     * const loadingComponent1 = kiss.loadingSpinner.show()
     * const loadingComponent2 = kiss.loadingSpinner.show()
     * 
     * kiss.loadingSpinner.hide(loadingComponent1) // This will not hide the spinner because component 2 is still loading
     * kiss.loadingSpinner.hide(loadingComponent2) // This will hide the spinner because there are no more components loading
     * 
     */
    show() {
        if (!this.loadingLayer) this._init()
        this.loadingId = kiss.tools.shortUid()
        this.components.push(this.loadingId)

        this.loadingLayer.showLoading({
            fullscreen: true,
            spinnerSize: "12.8rem",
            mask: false
        })
        return this.loadingId
    },

    /**
     * Hide the loading spinner.
     * 
     * Note: it will hide the loading spinner only if there is no more loading components in the buffer.
     * 
     * @param {string} loadingId - The unique id given by the kiss.loadingSpinner.show() method
     */
    hide(loadingId) {
        this.components = this.components.filter(componentId => componentId != loadingId)
        if (this.components.length == 0 && this.loadingLayer) this.loadingLayer.hideLoading()
    }
}

;/**
 * 
 * ## Simple client logger
 * 
 * @namespace
 * 
 */
kiss.logger = {
    /**
     * History of all logged messages
     */
    history: [],

    /**
     * Maximum length of the history
     * (used to limit memory consumption)
     */
    maxLength: 200,

    /**
     * Message types:
     * - "*" means all accepted (default behavior)
     * - 0: messages
     * - 1: informations
     * - 2: acknowledges
     * - 3: warnings
     * - 4: errors
     */
    types: ["*"],

    /**
     * Message accepted categories.
     * Default to "none" (meaning no message is logged).
     * 
     * The logger will only log the messages of the accepted categories.
     * The category of the message is its first word, and can be anything.
     * It's up to you to decide your logging strategy.
     * Check init() method for examples.
     */
    categories: ["none"],

    /**
     * Defines if the logger logs data too.
     * false: only messages. true: messages and data
     */
    data: true,

    /**
     * Initialize the logger
     * 
     * @param {object} config
     * @param {boolean} [config.data] - false: only messages. true: messages and data (default)
     * @param {array} [config.types] - Log only the messages of these types, for example: [3,4]. Default to ["*"] (meaning everything is logged).
     * @param {string[]} [config.categories] - Log only the messages of these types, for example: ["db", "socket"]. Default to ["*"] (meaning everything is logged).
     * @param {number} [config.maxLength] - Maximum number of messages kept into logger's history
     * 
     * @example
     * // Will log the messages starting with the word "database" or the word "socket", like "db - find()", or "socket connected!"
     * kiss.logger.init({
     *  types: [0, 3, 4],
     *  categories: ["database", "socket"],
     *  maxLength: 20
     * })
     * 
     * // The category of this message is "database", and it will be logged.
     * // The error will be display too.
     * log("database access denied", 4, err)
     * 
     * // The category of this message is "database", but it will not be logged because of type 2:
     * log("database successfuly updated", 2)
     *
     * // The type of this message is 0 (default), but it will not be logged because its category is "view":
     * log("view - Sent to cache")
     */
    init(config) {
        kiss.logger.maxLength = config.maxLength || 200
        kiss.logger.types = config.types || []
        kiss.logger.categories = config.categories || []
        if (config.data === false) kiss.logger.data = false
    },

    /**
     * console.log wrapper
     * 
     * Sends a colored message in the console, and keeps the history in kiss.logger.history.
     * 
     * @param {string} msg - The msg to log
     * @param {integer} [type] - (default) 0=message (black), 1=info (blue), 2=acknowledge (green), 3=warning (orange), 4=error (red)
     * @param {*} [data] - Optional data to show in the console
     * 
     * @example
     * // Simple log
     * log("database - Trying to update...")
     * 
     * // Write the message in green (type 2) and also show the data:
     * const update = {lastName: "Wilson"}
     * log("database updated successfuly", 2, update)
     */
    log(msg, type = 0, data) {
        if (typeof msg != "string") return console.log(msg)
        
        const msgCategory = msg.split(" ")[0]
        if (!kiss.logger.categories.includes(msgCategory) && !kiss.logger.categories.includes("*")) return
        if (!kiss.logger.types.includes(type) && !kiss.logger.types.includes("*")) return

        let style
        switch (type) {
            case 0:
                // MESSAGE
                style = "color: black"
                break
            case 1:
                // INFO
                style = "color: blue"
                break
            case 2:
                // ACKNOWLEDGE (success, true, ok...)
                style = "color: green"
                break
            case 3:
                // WARNING
                style = "color: orange"
                break
            case 4:
                // ERROR
                style = "color: red"
                break
        }

        console.log("%c%s", style, msg)
        if (data && kiss.logger.data) console.log(data)

        kiss.logger.history.push({
            msg,
            type
        })

        if (kiss.logger.history.length > kiss.logger.maxLength) kiss.logger.history.splice(0, 1)
    },

    /**
     * Show the history of all logged messages
     */
    show() {
        console.log(kiss.logger.history)
    },

    /**
     * Replay the log history
     * 
     * @param {integer} count - Number of messages to replay
     */
    replay(count = 0) {
        if (!count) {
            kiss.logger.history.forEach(event => log(event.msg, event.type))
        }
        else {
            kiss.logger.history.slice(-count).forEach(event => log(event.msg, event.type))
        }
    }
}

// Shorthand
const log = kiss.logger.log
log.info = (msg, data) => log(msg, 1, data)
log.ack = (msg, data) => log(msg, 2, data)
log.warn = (msg, data) => log(msg, 3, data)
log.err = (msg, data) => log(msg, 4, data)


;/**
 * 
 * ## Plugin manager
 * 
 * Allow to add / get plugins.
 * Plugins are used to add features to the application.
 * Check the example for further details.
 * 
 * @namespace
 */
kiss.plugins = {

    /**
     * Array of loaded plugins
     */
    plugins: [],

    /**
     * Adds a plugin to the list
     * 
     * @param {object} plugin
     * 
     * @example
     * 
     * // Defines the plugin which adds the form feature: "See JSON data"
     * kiss.plugins.add({
     *     // Plugin id
     *     id: "form-feature-show-json",
     * 
     *     // The plugin has an icon to recognize it
     *     icon: "fab fa-node-js",
     * 
     *     // A plugin must support multi-language texts
     *     texts: {
     *         // A plugin must at least have name and a description
     *         "name": {
     *             en: "see data as JSON",
     *             fr: "Voir les données JSON"
     *         },
     *         "description": {
     *             en: "this plugin displays the record data as JSON",
     *             fr: "ce plugin affiche les données JSON du document"
     *         }
     *     },
     * 
     *     // A plugin is an array of features because a single plugin can add multiple features at the same time.
     *     features: [{
     *         // The plugin "type" tells the application WHERE to integrate the plugin.
     *         // There are many places where a feature can be plugged into pickaform.
     *         // The most common one is "form-section", which adds a... form section, of course.
     *         type: "form-section",
     * 
     *         // The "renderer" is the function that will render the plugin into the page.
     *         // In the case of a form section, the function will receive the form itself as input parameter.
     *         // There are only 2 rules to follow to build the renderer:
     *         // - the function **must** return an HTMLElement.
     *         // - the HTMLElement **must** have a class with the plugin id. The class will be used as a selector when showing/hiding the plugin.
     *         renderer: function (form) {
     *             const record = form.record
     * 
     *             // Return your UI: can be any HTMLElement or KissJS component. The example below is a KissJS component:
     *             return createHtml({
     *                 class: "form-feature-show-json",
     * 
     *                 collections: [
     *                     kiss.app.collections[record.model.id]
     *                 ],
     * 
     *                 methods: {
     *                     async load() {
     *                         let recordDataToHtml = JSON.stringify(record.getRawData(), null, 4)
     *                         recordDataToHtml = recordDataToHtml.replaceAll("\n", "<br>")
     *                         recordDataToHtml = recordDataToHtml.replaceAll(" ", "&nbsp;")
     *                         this.setInnerHtml(recordDataToHtml)
     *                     }
     *                 }
     *             })
     *         }
     *     }]
     * });
     */
    add(plugin) {
        try {
            // Get the current language
            kiss.language.get()

            // Translate main properties into the right language
            plugin.name = txtTitleCase("name", plugin.texts)
            plugin.description = txtTitleCase("description", plugin.texts)
            plugin.instructions = txtTitleCase("instructions", plugin.texts)

            // Add the plugin
            log("kiss.plugins - Adding plugin <" + plugin.name + ">", 1, plugin)
            kiss.plugins.plugins.push(plugin)

        } catch (err) {
            log("kiss.plugins - The plugin " + plugin.id + " is not well formatted", 4, plugin)
        }
    },

    /**
     * Get one or all the plugin definitions
     * 
     * @param {string} [pluginId] - If provided, returns only the specified plugin. Otherwise, return all plugins.
     * @returns {*} The array of all plugins, or only the specified plugin
     */
    get(pluginId) {
        if (!pluginId) return kiss.plugins.plugins.sortBy("order")
        return kiss.plugins.plugins.find(plugin => plugin.id == pluginId)
    },

    /**
     * Get the texts of the plugin
     * 
     * @param {string} pluginId
     * @returns {object} Plugin texts
     */
    getTexts(pluginId) {
        const plugin = kiss.plugins.get(pluginId)
        return plugin.texts
    },    

    /**
     * Init all the plugins at once
     */
    async init() {
        for (let plugin of kiss.plugins.plugins) {
            if (plugin.init) await plugin.init()
        }
    }
}

;/**
 * 
 * ## A simple PubSub
 * 
 * 1. subscribe a function to a channel:
 * ```
 * let subscriptionId = kiss.pubsub.subscribe("MY_CHANNEL_NAME", (messageData) => { console.log(messageData) })
 * ```
 * 
 * 2. publish a message on a channel:
 * ```
 * kiss.pubsub.publish("MY_CHANNEL_NAME", {foo: "bar"})
 * ```
 * 
 * 3. unsubscribe a function:
 * ```
 * kiss.pubsub.unsubscribe(subscriptionId)
 * ```
 * 
 * 4. list all active subscriptions
 * ```
 * kiss.pubsub.list()
 * ```
 * 
 * @namespace
 * 
 */
kiss.pubsub = {
    subscriptions: {},

    channelsNotLogged: ["EVT_ROUTE_UPDATED", "EVT_CONTAINERS_RESIZED"],

    /**
     * Publish a message on a specific channel
     * 
     * @param {string} channel - The channel name
     * @param {object} [messageData] - The data published into the channel
     */
    publish(channel, messageData) {
        let targetChannel = kiss.pubsub.subscriptions[channel]
        if (!targetChannel) return

        if (!kiss.pubsub.channelsNotLogged.includes(channel.toUpperCase())) {
            log("kiss.pubsub - publish on channel: " + channel, 1, messageData)
        }
        
        // Browse all the subscriptions of kiss.pubsub channel
        Object.keys(targetChannel).forEach(subscriptionId => {
            // Get the function to execute
            let fn = targetChannel[subscriptionId]
            
            try {
                // Pass the message data to the function
                fn(messageData)
            }
            catch(err) {
                log("kiss.pubsub - publish - Error with subscription id: " + subscriptionId, 4, err)
            }
        })
    },

    /**
     * Subscribe a function to a channel
     * 
     * @param {string} channel - The channel name
     * @param {function} fn - The function to subscribe to the channel
     * @param {string} [description] - Optional description of the subscription
     * @returns {string} The subscription id
     */
    subscribe(channel, fn, description) {
        let subscriptionId = kiss.tools.shortUid()

        // If the channel doesn't exist yet, we create it
        if (!kiss.pubsub.subscriptions[channel]) kiss.pubsub.subscriptions[channel] = {}

        // Subscribe the function to the channel
        kiss.pubsub.subscriptions[channel][subscriptionId] = fn
        kiss.pubsub.subscriptions[channel][subscriptionId].description = description

        // Return the subscription id so we can use it to unsubscribe the function later
        return subscriptionId
    },

    /**
     * Unsubscribe a function from the pubsub
     * 
     * @param {string} subscriptionId - The id of the subscription to remove
     */
    unsubscribe(subscriptionId) {
        // Scan all the channels
        Object.keys(kiss.pubsub.subscriptions).forEach(channel => {
            let channelSubscriptions = kiss.pubsub.subscriptions[channel]

            // For each channel, scan all the subscriptions
            Object.keys(channelSubscriptions).forEach(channelSubscriptionId => {
                // If the subscription is found, we delete it
                if (channelSubscriptionId == subscriptionId) {
                    delete kiss.pubsub.subscriptions[channel][subscriptionId]
                    return
                }
            })
        })
    },

    /**
     * Return the number of subscriptions.
     * 
     * Mainly used for debugging (useful to track memory leaks).
     * 
     * @returns {number}
     */
    getCount() {
        let count = 0
        Object.keys(kiss.pubsub.subscriptions).forEach(channel => {
            let channelSubscriptions = kiss.pubsub.subscriptions[channel]
            Object.keys(channelSubscriptions).forEach(() => count++)
        })
        return count
    },

    /**
     * Get a subscription by id.
     * 
     * Mainly used for debug purpose, when you need to check which function is registered in the pubsub.
     * 
     * @param {string} subscriptionId - The id of the subscription to retrieve
     * @return {function} The subscribed function
     */
    get(subscriptionId) {
        let subscription

        // Scan all the channels
        Object.keys(kiss.pubsub.subscriptions).forEach(channel => {
            let channelSubscriptions = kiss.pubsub.subscriptions[channel]

            // For each channel, scan all the subscriptions
            Object.keys(channelSubscriptions).forEach(channelSubscriptionId => {
                // If the subscription is found, we return it
                if (channelSubscriptionId == subscriptionId) {
                    subscription = kiss.pubsub.subscriptions[channel][subscriptionId]
                }
            })
        })
        return subscription
    },

    /**
     * List all the subscriptions in the console.
     * 
     * Mainly used for debug purpose, when you need an overview of subscriptions.
     * 
     * @param {boolean} [showFunction] - If true, show the subscribed function
     */    
    list(showFunction) {
        let counter = 0

        // Scan all the channels
        Object.keys(kiss.pubsub.subscriptions).forEach(channel => {
            let channelSubscriptions = kiss.pubsub.subscriptions[channel]

            // For each channel, scan all the subscriptions
            Object.keys(channelSubscriptions).forEach(channelSubscriptionId => {
                let subscription = kiss.pubsub.subscriptions[channel][channelSubscriptionId]
                let description = kiss.pubsub.subscriptions[channel][channelSubscriptionId].description

                log("-----------------------------------------------------------------")
                log("Subscription " + counter.pad(5) + " - subscription id: " + channelSubscriptionId, 1)
                if (description) log("Description: ", 2, description)
                if (showFunction) log("Function: ", 2, subscription)
                counter++
            })
        })
        log("Total number of subscriptions: " + counter)  
    }
};

// Shortcuts
const publish = kiss.pubsub.publish
const subscribe = kiss.pubsub.subscribe
const unsubscribe = kiss.pubsub.unsubscribe;/**
 * 
 * ## A simple client router
 * 
 * The router allows to navigate between different views in a single-page application.
 * It also works with local files paths (file:///)
 * 
 * The router is based on the url hash, for example:
 * ```
 * /index.html#ui=homepage
 * ```
 * 
 * The "ui" parameter is mandatory and represents the main view to display.
 * Other parameters can be added to the url hash to manage deeper navigation:
 * ```
 * /index.html#ui=homepage&applicationId=123&viewId=456
 * ```
 * 
 * If you need to display multiple views simultaneously, you can use multiple parameters starting with "ui":
 * ```
 * /index.html#ui=homepage&ui1=map&ui2=account
 * ```
 * 
 * To use the router:
 * ```
 * kiss.router.navigateTo(newRoute)
 * ```
 * 
 * You can pass a single string if you just want to change the main view:
 * ```
 * kiss.router.navigateTo("homepage")
 * ```
 * 
 * This is equivalent to:
 * ```
 * kiss.router.navigateTo({ui: "homepage"})
 * ```
 * 
 * If you need deeper navigation, you can pass an object:
 * ```
 * kiss.router.navigateTo({ui: "homepage", applicationId: "123", viewId: "456"})
 * ```
 * 
 * The router observes url hash changes and automatically triggers new routes accordingly.
 * 
 * When initializing the router, you can optionally define public routes:
 * 
 * ```
 * // Init your app router:
 * kiss.router.init({
 *  publicRoutes: ["login", "register"]
 * })
 * 
 * // Setting public routes after initialization:
 * kiss.router.setPublicRoutes(["login", "register"])
 * 
 * // Adding routing guards, to check if a route is valid before routing:
 * kiss.router.addRoutingGuards([
 *  async function(newRoute) {
 *      return await app.api.checkViewAuthorization(newRoute)
 *  }
 * ])
 * 
 * // Adding routing actions, to perform some actions after routing:
 * kiss.router.addRoutingActions([
 *  async function() {
 *      // Do something after routing
 *  }
 * ])
 * 
 * // Navigating to a new route:
 * kiss.router.navigateTo({ui: "homepage", applicationId: "123", viewId: "456"})
 * 
 * // Get the current application route by reading the url hash:
 * const currentApplicationRoute = kiss.router.getRoute() // {ui: "homepage", applicationId: "123", viewId: "456"}
 * ```
 * 
 * @namespace
 * 
 */
kiss.router = {
    /**
     * Default list of public routes which doesn't require authentication.
     * 
     * Add custom public routes using addPublicRoutes([...]) method.
     * 
     * By default, the following routes are public:
     * - authentication-login
     * - authentication-register
     * - authentication-reset-password
     * - authentication-error
     */
    publicRoutes: [
        "authentication-login",
        "authentication-register",
        "authentication-reset-password",
        "authentication-error"
    ],

    /**
     * Init the router
     * 
     * It will observe any url hash change, which will:
     * - perform a custom action before triggering the new route
     * - perform a custom action after the routing
     * 
     * @param {object} config - The router config, containing the 2 methods:
     * @param {string[]} [config.publicRoutes] - Define public routes (skip login)
     */
    init(config = {}) {
        // Set public routes
        if (config.publicRoutes && Array.isArray(config.publicRoutes)) {
            kiss.router.publicRoutes = config.publicRoutes
        }

        // Observe hash changes
        window.onhashchange = async function () {
            // Update the application context
            const newRoute = kiss.router.getRoute()

            // Perform verifications before routing
            const doRoute = await kiss.router._beforeRouting(newRoute)
            if (!doRoute) return
            
            kiss.context.update(newRoute)

            // Execute router actions after routing
            await kiss.router._afterRouting()
        }
    },

    /**
     * Set the public routes
     *  
     * @param {string[]} publicRoutes
     */
    setPublicRoutes(publicRoutes) {
        kiss.router.publicRoutes = publicRoutes
    },

    /**
     * Add some public routes
     *  
     * @param {string[]} publicRoutes
     */
    addPublicRoutes(publicRoutes) {
        kiss.router.publicRoutes = kiss.router.publicRoutes.concat(publicRoutes).unique()
    },

    /**
     * Add routing guards
     * 
     * Guards are used to check if a route is valid **before** routing.
     * Must be an array of async functions where each function must return a boolean.
     * The route is accepted if all guards return true.
     * 
     * @param {function[]} guards
     */
    addRoutingGuards(guards) {
        if (guards && Array.isArray(guards)) {
            kiss.router.beforeRoutingGuards = kiss.router.beforeRoutingGuards.concat(guards)
        }
    },

    /**
     * Add routing actions
     * 
     * Actions are used to perform some actions **after** routing.
     * Must be an array of async functions to execute sequentially.
     * 
     * @param {function[]} actions
     */
    addRoutingActions(actions) {
        if (actions && Array.isArray(actions)) {
            kiss.router.afterRoutingActions = kiss.router.afterRoutingActions.concat(actions)
        }
    },

    /**
     * Check if the current route (given by the ui parameter) is public
     * 
     * @returns {boolean}
     */
    isPublicRoute() {
        const currentRoute = kiss.router.getRoute().ui
        if (!currentRoute) return false
        return kiss.router.publicRoutes.includes(currentRoute)
    },

    /**
     * Navigate to a new hash
     * It indirectly triggers the new route by dispatching the window's *hashchange* event.
     * 
     * @param {object|string} newRoute
     * @param {boolean} [reset] - Set to true to reset the previous route before routing to a new one
     * 
     * @example
     * // Using an object
     * const newRoute = {ui: "homepage", applicationId: "123", viewId: "456"}
     * kiss.router.navigateTo(newRoute)
     * 
     * // Using a string
     * kiss.router.navigateTo("home-start") // Is equivalent to: kiss.router.navigateTo({ui: "home-start"})
     */
    async navigateTo(newRoute, reset) {
        if (typeof newRoute === "string") newRoute = {
            ui: newRoute
        }
        kiss.router.updateUrlHash(newRoute, reset)

        // Perform verifications before routing
        // The routing can be interrupted if the method beforeRouting returns false


        // const doRoute = await kiss.router._beforeRouting(newRoute)
        // if (!doRoute) return

        // Propagate the hash change
        window.dispatchEvent(new HashChangeEvent("hashchange"))
    },

    /**
     * Get the current application route from the url hash.
     * 
     * For example:
     * - if current url is: http://.../...#ui=homepage&applicationId=123&viewId=456
     * - the output is: {ui: "homepage", applicationId: "123", viewId: "456"}
     * 
     * @returns {object}
     */
    getRoute() {
        return kiss.router._toRoute(window.location.hash.slice(1))
    },

    /**
     * Update URL hash according to new route params.
     * 
     * @param {object} newRoute 
     * @param {boolean} [reset] - True to reset the current hash
     * 
     * @example
     * kiss.router.updateUrlHash({chapter: 10, section: 2}, true)
     */
    updateUrlHash(newRoute, reset) {
        const currentRoute = kiss.router.getRoute()
        const toRoute = (reset) ? newRoute : Object.assign(currentRoute, newRoute)
        const newHash = "#" + kiss.router._toHash(toRoute)
        window.history.pushState(toRoute, toRoute.ui, newHash)
    },

    /**
     * Convert a url hash into an application route object.
     * 
     * For example:
     * input: http://.../...#ui=homepage&applicationId=123&viewId=456
     * output: {ui: "homepage", applicationId: "123", viewId: "456"}
     * 
     * @private
     * @ignore
     * @param {string} hash
     * 
     * @returns {object} Object containing the application route
     */
    _toRoute(hash) {
        const route = {}
        hash.split("&").forEach(param => {
            const paramName = param.split("=")[0]
            if (paramName) route[paramName] = param.split("=")[1]
        })
        return route
    },

    /**
     * Convert an application route into an url hash
     * 
     * @private
     * @ignore
     * @param {object} newRoute - The application route
     * @returns {string} An url hash
     * 
     * @example
     * kiss.router._toHash({ui: "homepage", applicationId: "123", viewId: "456"})
     * // URL hash will be: ui=homepage&applicationId=123&viewId=456
     */
    _toHash(newRoute) {
        const hash = []
        Object.keys(newRoute).forEach(key => (newRoute[key]) ? hash.push(key + "=" + newRoute[key]) : "")
        return hash.join("&")
    },

    /**
     * Perform some validations before routing.
     * 
     * Validations are defined in kiss.router.validators and can be customized at initialization.
     * Standard validation process is:
     * - check if the new route is the login page (always accepted)
     * - check if the new route is a public route (accepted if true)
     * - check if the application is properly loaded (routing accepted if true)
     * 
     * @private
     * @ignore
     * @param {object} newRoute - Intended application route
     * @returns {promise} Resolve to false if the routing must be interrupted for any reason
     */
    async _beforeRouting(newRoute) {
        // Always accept the login page
        if (kiss.router._isLoginPage(newRoute)) return true

        // Accept public routes
        if (kiss.router._isPublicRoute(newRoute)) return true

        // Check if the application is properly loaded
        const appLoaded = await kiss.router._isAppLoaded()
        if (!appLoaded) return false

        // Check if the route is authorized
        for (let guardFunction of kiss.router.beforeRoutingGuards) {
            const guardResult = await guardFunction(newRoute)
            if (!guardResult) return false
        }

        return true
    },

    /**
     * Perform some actions *after* routing.
     * 
     * Actions are defined in kiss.router.actions and can be customized at initialization.
     * 
     * @private
     * @ignore
     */
    async _afterRouting() {
        for (let actionFunction of kiss.router.afterRoutingActions) {
            await actionFunction()
        }
    },

    /**
     * Check if the new route is the login page
     * 
     * @private
     * @ignore
     * @param {object} newRoute 
     * @returns {boolean} True if the new route is the login page
     * 
     * @example
     * kiss.router.validators.isLoginPage({ui: "homepage", applicationId: "123", viewId: "456"}) // false
     * kiss.router.validators.isLoginPage({ui: "authentication-login"}) // true
     */
    _isLoginPage(newRoute) {
        if (newRoute.ui == kiss.session.defaultViews.login) return true
        return false
    },

    /**
     * Check if the new route is a public route
     * 
     * @private
     * @ignore
     * @param {object} newRoute
     * @returns {boolean} True if the new route is a public route
     * 
     * @example
     * kiss.router.validators.isPublicRoute({ui: "homepage", applicationId: "123", viewId: "456"}) // false
     * kiss.router.validators.isPublicRoute({ui: "authentication-login"}) // true
     */
    _isPublicRoute(newRoute) {
        if (kiss.router.publicRoutes.indexOf(newRoute.ui) != -1) return true
        return false
    },

    /**
     * Check if the application is properly loaded.
     * 
     * "Properly" means:
     * - required core data is loaded
     * - custom application data is loaded (depends on the use case)
     * 
     * Custom data is loaded using a "loader" function defined at initialization with kiss.app.init({...}).
     * The loader:
     * - is a function that must be fully completed before the routing can occur
     * - will be waited for completion if it's async
     * - must return a boolean to indicate if the required elements are properly loaded
     * 
     * Once loaded, kiss.app.isLoaded is flagged and the routing can occur.
     * 
     * @private
     * @ignore
     * @returns {boolean} True if the application is properly loaded
     * 
     * @example
     * kiss.router.validators.isAppLoaded() // true
     */
    async _isAppLoaded() {
        if (!kiss.app.isLoaded) {
            // Load core data
            let success = await kiss.app.load()
            if (!success) return false

            // Optionally Load custom data defined when initializing the app, using kiss.app.init({...})
            if (kiss.app.loader && typeof kiss.app.loader === "function") {
                success = await kiss.app.loader()
                if (!success) return false
            }

            kiss.app.isLoaded = true
        }

        return true
    },

    /**
     * Optional validations to perform before routing:
     * - It's an array of async functions where each function must return a boolean.
     * - Must be set up at initialization.
     * - The route is accepted if all validators return true.
     * - Can be extended at runtime using kiss.router.addRoutingGuards([...])
     * 
     * @private
     * @ignore
     */
    beforeRoutingGuards: [],

    /**
     * Default actions to perform after routing.
     * 
     * Can be extended with new actions, using kiss.router.addActions([...])
     * 
     * @private
     * @ignore
     */
    afterRoutingActions: [
        /**
         * Default action performed *after* routing.
         * By default, it checks the new application route and displays a new view according to the *ui* parameter.
         * It can display multiple views simultaneously, using multiple parameters starting with "ui".
         * 
         * @private
         * @ignore
         */
        async function () {
            const newRoute = kiss.router.getRoute()

            // Display a new main view if there is a *ui* parameter
            // (the main view is "exclusive" to other views in the same container)
            if (newRoute.ui) await kiss.views.show(newRoute.ui, null, true)

            // Display other views using all parameters starting with "ui" (ui1, ui2, uiMap, uiAccount, etc...)
            // This allows, for example, to open secondary windows / popup / information messages...
            for (let route of Object.keys(newRoute)) {
                if (route.startsWith("ui") && route != "ui") await kiss.views.show(newRoute[route])
            }

            // Publish the new route
            kiss.pubsub.publish("EVT_ROUTE_UPDATED", newRoute)
        }
    ]
}

;/**
 * 
 * ## A simple screen size manager
 * 
 * - keeps track of screen size and ratio changes
 * - helper to compute a component dimensions based on other components: getHeightMinus(...), getWidthMinus(...)
 * - observe screen size changes and publish them to the PubSub on the EVT_WINDOW_RESIZED channel
 * - observe when container components (Block, Panel) are resized to propagate the change on children
 * 
 * @namespace
 * 
 */
kiss.screen = {
    isMobile: false,

    /**
     * Check if a screen is horizontal (= landscape)
     * 
     * @returns {boolean}
     */
    isHorizontal: () => kiss.screen.current.width > kiss.screen.current.height,

    /**
     * Check if a screen is vertical (= portrait)
     * 
     * @returns {boolean}
     */
    isVertical: () => kiss.screen.current.width < kiss.screen.current.height,

    /**
     * Check if a screen is a touch screen
     * 
     * @returns {boolean}
     */
    isTouch: () => 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0,

    /**
     * Store the last click position on the screen
     */
    lastClick: {
        x: 0,
        y: 0
    },

    /**
     * Previous dimensions and ratio
     * 
     * @example
     * kiss.screen.previous.height
     * kiss.screen.previous.ratio
     */
    previous: {
        width: window.innerWidth,
        height: window.innerHeight,
        ratio: window.innerWidth / window.innerHeight
    },

    /**
     * Current dimensions and ratio
     * 
     * @example
     * kiss.screen.current.width
     * kiss.screen.current.ratio
     */
    current: {
        width: window.innerWidth,
        height: window.innerHeight,
        ratio: window.innerWidth / window.innerHeight
    },

    /**
     * Init the screen size observer
     */
    init() {
        // Startup test to check if it's a mobile environment
        if (kiss.tools.isMobile()) kiss.screen.isMobile = true

        // Init screen size listener
        kiss.screen.observe()
    },

    /**
     * Update the current screen size and cache the previous one
     * 
     * @private
     * @ignore
     */
    _update() {
        kiss.screen.previous = kiss.screen.current
        kiss.screen.current = {
            width: window.innerWidth,
            height: window.innerHeight,
            ratio: window.innerWidth / window.innerHeight
        }
    },

    /**
     * Compute the delta between previous and new screen size
     * 
     * @private
     * @ignore
     * @returns {object} For example: {width: 100, height: 50}
     */
    _delta() {
        let deltaWidth = kiss.screen.current.width - kiss.screen.previous.width
        let deltaHeight = kiss.screen.current.height - kiss.screen.previous.height
        let delta = {
            width: deltaWidth,
            height: deltaHeight
        }
        return delta
    },

    /**
     * Compute the remaining window's height in pixels (= window's height minus a computed delta)
     * 
     * @param {...*} something - Either a number, or a CSS height in pixels, or an array of ids of the items to consider while computing the remaining height
     * @returns {number} The remaining height, in pixels
     * 
     * @example
     * // With number:
     * kiss.screen.getHeightMinus(60)
     * 
     * // With a CSS size:
     * kiss.screen.getHeightMinus("60px")
     * 
     * // With a component id:
     * kiss.screen.getHeightMinus("top-bar")
     * 
     * // With multiple component ids:
     * kiss.screen.getHeightMinus("top-bar", "button-bar")
     * 
     * // With multiple numbers:
     * kiss.screen.getHeightMinus(60, 20, $("top-bar").offsetHeight)
     * 
     * // Mixed stuff:
     * kiss.screen.getHeightMinus("top-bar", 20, "60px")
     */
    getHeightMinus(...something) {
        let delta = 0
        something.forEach(function (item) {
            // Item given as a number: 60
            if (typeof item == "number") {
                delta += item
            } else {
                // Item given as CSS size: "60px"
                if (item.indexOf("px") != -1) {
                    delta += Number(item.substring(0, item.indexOf("px")))
                }
                // Item given as a DOM Element id
                else {
                    let node = $(item)
                    if (node) {
                        if (!node.offsetHeight) node = node.firstElementChild
                        delta += node.offsetHeight
                    }
                }
            }
        })

        return (window.innerHeight - delta)
    },

    /**
     * Compute the remaining window's width in pixels (= window's width minus a computed delta)
     * 
     * @param {...*} something - Either a number, or a CSS height in pixels, or an array of ids of the items to consider while computing the remaining width
     * @returns {number} The remaining height, in pixels
     * 
     * @example
     * // With number:
     * kiss.screen.getWidthMinus(60)
     * 
     * // With a CSS size:
     * kiss.screen.getWidthMinus("60px")
     * 
     * // With a component id:
     * kiss.screen.getWidthMinus("left-nav")
     * 
     * // With multiple component ids:
     * kiss.screen.getWidthMinus("left-nav", "left-nav-margin")
     * 
     * // With multiple numbers:
     * kiss.screen.getWidthMinus(60, 20, $("left-nav").offsetWidth)
     * 
     * // Mixed stuff:
     * kiss.screen.getWidthMinus("left-nav", 20, "60px")
     */
    getWidthMinus(...something) {
        let delta = 0
        something.forEach(function (item) {
            // Item given as a number: 60
            if (typeof item == "number") {
                delta += item
            } else {
                // Item given as CSS size: "60px"
                if (item.indexOf("px") != -1) {
                    delta += Number(item.substring(0, item.indexOf("px")))
                }
                // Item given as a DOM Element id
                else {
                    let node = $(item)
                    if (node) {
                        if (!node.offsetWidth) node = node.firstElementChild
                        delta += node.offsetWidth
                    }
                }
            }
        })

        return (window.innerWidth - delta)
    },

    /**
     * Get the screen orientation
     * 
     * @returns {string} "vertical" or "horizontal"
     */
    getOrientation() {
        return (kiss.screen.current.height > kiss.screen.current.width) ? "vertical" : "horizontal"
    },

    /**
     * Debounce a function which occurs at a high frequency, and force it to occur at a specific interval (in milliseconds)
     * 
     * @private
     * @ignore
     * @param {integer} interval - Interval in milliseconds used to call the debounced function
     * @param {function} fn - The function to debounce
     * @returns {function} A function calling the function to debounce, passing it the {event} that occured.
     * 
     * @example
     * window.addEventListener("resize", kiss.screen._debounce(function(event) { console.log(event) })
     */
    _debounce(interval, fn) {
        let timer
        return function (event) {
            if (timer) clearTimeout(timer)
            timer = setTimeout(fn, interval, event)
        }
    },

    /**
     * Observe the window resize event, and publish the changes in the EVT_WINDOW_RESIZED pubsub channel.
     * 
     * @example
     * kiss.screen.observe()
     */
    observe() {
        window.addEventListener("resize", kiss.screen._debounce(100, function () {
            kiss.screen._update()
            kiss.pubsub.publish("EVT_WINDOW_RESIZED", {
                previous: kiss.screen.previous,
                current: kiss.screen.current,
                delta: kiss.screen._delta()
            })
        }))

        // Observe the mouse position
        window.addEventListener("mousemove", (evt) => {
            kiss.screen.mousePosition = {
                x: evt.clientX,
                y: evt.clientY
            }
        })
    },

    /**
     * Observe when container components (Block, Panel) are resized.
     * Propagate the event EVT_CONTAINERS_RESIZED with the list of ids of the resized containers
     * 
     * @ignore
     * @param {function} callback to execute when the observer is triggered
     */
    getResizeObserver() {
        if (kiss.screen.resize) return kiss.screen.resize

        kiss.screen.resize = new ResizeObserver(kiss.screen._debounce(100, function (entries) {
            let elements = Array.from(entries)
                .filter(entry => entry.borderBoxSize[0].blockSize != 0)
                .map(entry => entry.target.id)

            // Propagate the list of container ids
            if (elements.length > 0) kiss.pubsub.publish("EVT_CONTAINERS_RESIZED", elements)
        }))

        return kiss.screen.resize
    }
}

;/**
 * 
 * ## A simple selection manager
 * 
 * - keeps track of selected records for a specific view
 * - allow simple operations like add/delete/get/reset
 * - store in a localStorage object, which key is the viewId
 * - works in combination with datatables or other data components with selection capabilities
 * 
 * @namespace
 * 
 */
kiss.selection = {
    /**
     * Insert one record into the view selection
     * 
     * @param {string} viewId 
     * @param {string} recordId 
     */
    insertOne(viewId, recordId) {
        let selection = localStorage.getItem("config-selection-" + viewId)
        if (!selection) {
            localStorage.setItem("config-selection-" + viewId, recordId)
            return
        }

        let records = selection.split(",")
        if (records.indexOf(recordId) != -1) return

        localStorage.setItem("config-selection-" + viewId, selection + "," + recordId)
    },

    /**
     * Insert many records into the view selection
     * 
     * @param {string} viewId 
     * @param {string[]} recordIds
     */    
    insertMany(viewId, recordIds) {
        let selection = localStorage.getItem("config-selection-" + viewId)
        if (!selection) {
            localStorage.setItem("config-selection-" + viewId, recordIds.join(","))
            return
        }

        let ids = selection.split(",")
        ids = ids.concat(recordIds).unique()

        localStorage.setItem("config-selection-" + viewId, ids.join(","))
    },

    /**
     * Delete a record from the view selection
     * 
     * @param {string} viewId 
     * @param {string} recordId 
     */    
    delete(viewId, recordId) {
        let selection = localStorage.getItem("config-selection-" + viewId)
        if (!selection) return

        let records = selection.split(",").remove(recordId)
        records = records.filter(recordId => recordId != "")
        localStorage.setItem("config-selection-" + viewId, records.join(","))
    },

    /**
     * Reset the selection of a view
     * 
     * @param {string} viewId 
     */       
    reset(viewId) {
        let selection = localStorage.getItem("config-selection-" + viewId)
        if (!selection) return

        localStorage.removeItem("config-selection-" + viewId)
    },    

    /**
     * Get the current selection for a view
     * 
     * @param {string} viewId
     * @returns {string[]} The list of ids of the selected records
     */    
    get(viewId) {
        let selection = localStorage.getItem("config-selection-" + viewId)
        if (!selection) return []

        return selection.split(",")
    },

    /**
     * Get the current selection for the active view
     * 
     * @param {string} viewId
     * @returns {string[]} The list of ids of the selected records
     */    
    getFromActiveView() {
        const viewId = kiss.context.viewId
        if (!viewId) return []
        let selection = localStorage.getItem("config-selection-" + viewId)
        if (!selection) return []

        return selection.split(",")
    },    

    /**
     * Get the selected records in a view
     * 
     * @param {string} viewId
     * @returns {object[]} The list of selected records
     */      
    async getRecords(viewId) {
        const recordIds = kiss.selection.get(viewId)
        const viewCollection = $(viewId).collection
        return await viewCollection.findById(recordIds)
    },

    /**
     * Get the selected records in the active view
     * 
     * @returns {object[]} The list of selected records
     */
    async getRecordsFromActiveView() {
        const viewId = kiss.context.viewId
        return await kiss.selection.getRecords(viewId)
    },

    /**
     * Opens a window to batch update the selected records
     */
    updateSelectedRecords() {
        const ids = kiss.selection.getFromActiveView()
        if (ids.length == 0) return createNotification(txtTitleCase("#no selection"))

        const model = kiss.app.models[kiss.context.modelId]
        if (!model) return

        const fields = model.getBatchableFields()

        createPanel({
            id: "selection-batch-update",
            title: txtTitleCase("update selected documents"),
            modal: true,
            closable: true,
            draggable: true,
            icon: "fas fa-bolt",
            align: "center",
            verticalAlign: "center",
            layout: "vertical",
            width: 400,


            items: [
                // Field to update
                {
                    id: "batch-field",
                    type: "select",
                    label: txtTitleCase("field to update"),
                    labelPosition: "top",
                    width: "100%",
                    options: fields.map(field => {
                        return {
                            value: field.id,
                            label: field.label
                        }
                    }),
                    events: {
                        change: function() {
                            const fieldId = this.getValue()
                            $("selection-batch-update").updateInput(fieldId)
                        }
                    }
                },
                // Value to set (will be replaced by the input field)
                {
                    id: "batch-value-container",
                },
                // Button to update the records
                {
                    hidden: true,
                    id: "batch-update-button",
                    type: "button",
                    text: txtTitleCase("update"),
                    icon: "fas fa-bolt",
                    iconColor: "var(--yellow)",
                    margin: "5px 5px 0 5px",
                    action: () => $("selection-batch-update").updateRecords(ids)
                }
            ],

            methods: {
                updateRecords(ids) {
                    // Warn the user that the operation is irreversible
                    createDialog({
                        title: txtTitleCase("update selected documents"),
                        type: "danger",
                        buttonOKPosition: "left",
                        message: txtTitleCase("#warning update docs", null, {
                            n: ids.length
                        }),
                        action: async () => {
                            const fieldId = $("batch-field").getValue()
                            const value = $("batch-value").getValue()

                            if (value == "") {
                                // Warn the user that the value is empty
                                createDialog({
                                    title: txtTitleCase("empty value"),
                                    type: "danger",
                                    buttonOKPosition: "left",
                                    message: txtTitleCase("#warning empty value"),
                                    action: async () => {
                                        await kiss.selection._updateRecords(fieldId, value)
                                        $("selection-batch-update").close()

                                        const viewId = kiss.context.viewId
                                        $(viewId).deselectAll()
                                    }
                                })
                            }
                            else {
                                kiss.selection._updateRecords(fieldId, value)
                                $("selection-batch-update").close()

                                const viewId = kiss.context.viewId
                                $(viewId).deselectAll()
                            }
                        }
                    })
                },

                /**
                 * Update the input field according to the selected field
                 * 
                 * @param {string} fieldId 
                 */
                updateInput(fieldId) {
                    let currentField = $("batch-value")
                    if (currentField) currentField.deepDelete()

                    const fieldConfig = this.buildInput(fieldId)
                    let input = fieldConfig.renderer(fieldConfig)
                    input.render()

                    $("batch-update-button").show()
                },

                /**
                 * Build an input field according to the selected field
                 * 
                 * @param {string} fieldId 
                 * @returns {object} The input field configuration
                 */
                buildInput(fieldId) {
                    const fieldConfig = fields.find(field => field.id == fieldId)
                    let fieldType = fieldConfig.type
                    let fieldBuilderFunction = createField
                    let allowValuesNotInList = true
                    let iconColorOn
                    let checked = false
                    let options = []
                    let optionsFilter
                    let shape = ""
                    let roles = []
                    let multiple
                    let unit
                    let min
                    let max
                    let rows
            
                    switch (fieldType) {
                        case "textarea":
                        case "aiTextarea":
                            fieldType = "textarea"
                            rows = 5
                            break
                        case "select":
                            options = fieldConfig.options
                            optionsFilter = fieldConfig.optionsFilter
                            multiple = fieldConfig.multiple
                            allowValuesNotInList = fieldConfig.allowValuesNotInList
                            fieldBuilderFunction = createSelect
                            break
                        case "checkbox":
                            shape = fieldConfig.shape
                            iconColorOn = fieldConfig.iconColorOn
                            fieldBuilderFunction = createCheckbox
                            break
                        case "slider":
                            min = fieldConfig.min || 0
                            max = fieldConfig.max || 100
                            fieldBuilderFunction = createSlider
                            break
                        case "rating":
                            shape = fieldConfig.shape || "star"
                            min = fieldConfig.min || 0
                            max = fieldConfig.max || 10
                            iconColorOn = fieldConfig.iconColorOn
                            fieldBuilderFunction = createRating
                            break
                        case "color":
                            fieldBuilderFunction = createColorField
                            break
                        case "icon":
                            fieldBuilderFunction = createIconField
                            break
                        case "directory":
                            roles = ["userId"]
                            multiple = fieldConfig.multiple
                            allowValuesNotInList = false
                            fieldBuilderFunction = createDirectory
                            break
                    }
            
                    // Create an input field configuration with the right type
                    return {
                        id: "batch-value",
                        target: "batch-value-container",
                        type: fieldType,
                        label: txtTitleCase("new field value"),
                        labelPosition: "top",
                        width: "100%",

                        // Field options
                        rows,
                        min,
                        max,
                        unit,
                        checked,
                        multiple,
                        allowValuesNotInList,
            
                        // Special fields options
                        renderer: fieldBuilderFunction, // renderer
                        options, // select
                        optionsFilter, // select
                        optionsColor: model.color,
                        roles, // directory
                        shape, // checkbox
                        iconColorOn, // checkbox
                        iconSize: "20px", // checkbox
                    }
                }
            }
        }).render()
    },

    /**
     * Private utility function to update records from a view
     * 
     * @private
     * @ignore
     * @param {string} fieldLabel 
     * @param {*} value 
     */
    async _updateRecords(fieldLabel, value) {
        const model = kiss.app.models[kiss.context.modelId]
        if (!model) return

        const field = model.getFieldByLabel(fieldLabel)
        if (!field) return

        const viewId = kiss.context.viewId
        if (!$(viewId)) return

        const recordIds = kiss.selection.get(viewId)
        const viewCollection = $(viewId).collection
        const selectedRecords = await viewCollection.findById(recordIds)
    
        // Prevent the view from refreshing while batch updates are in progress
        kiss.global.preventViewRefresh = true
        
        const loadingId = kiss.loadingSpinner.show()
        let counter = 0

        for (let record of selectedRecords) {
            record.update({
                [field.id]: value
            })

            await kiss.tools.wait(100)
            
            counter++
            createNotification(counter + " / " + selectedRecords.length)

            // Refresh the view when the last record has been updated
            if (counter == selectedRecords.length - 1) {
                kiss.global.preventViewRefresh = false
            }
        }

        kiss.loadingSpinner.hide(loadingId)
    },

    /**
     * Delete the selected records (send them to the trash)
     */
    deleteSelectedRecords() {
        const model = kiss.app.models[kiss.context.modelId]
        if (!model) return

        const ids = this.getFromActiveView()
        if (ids.length == 0) return createNotification(txtTitleCase("#no selection"))

        createDialog({
            title: txtTitleCase("delete selected documents"),
            type: "danger",
            buttonOKPosition: "left",
            message: txtTitleCase("#warning delete docs", null, {
                n: ids.length
            }),
            action: async () => {
                await kiss.db.deleteMany(model.id, {
                    _id: {
                        "$in": ids
                    }
                }, true)

                const viewId = kiss.context.viewId
                $(viewId).deselectAll()
            }
        })
    }    
}

;/**
 * 
 * ## Session manager
 * 
 * **This module is 100% specific and only works in combination with KissJS server.**
 * **KissJS server is not open source yet, but you can contact us (sales@pickaform.com) for a licence.**
 * 
 * Dependencies:
 * - kiss.ajax, to send credentials to the server
 * - kiss.views, to popup the login window
 * - kiss.router, to route to the right application view if session is valid
 * - kiss.websocket, to init the connection, to check that it's alive and reconnect if not
 * 
 * @namespace
 * 
 */
kiss.session = {

    // Observe img tags to detect failed load due to outdated token to try to refresh them
    // and reload the said resource
    resourcesObserver: null,

    /**
     * Max idle time, in minutes (4 hours by default).
     * After that delay, the user is logged out and its tokens are deleted from localStorage
     */
    maxIdleTime: 4 * 60,

    /**
     * The user id.
     * By default, before authenticating, the user is "anonymous".
     * Once logged in, the user id is the email used to authenticate.
     * Always "anonymous" in offline and memory mode.
     */
    userId: "anonymous",

    /**
     * Flag (true/false) to track if the active user is the account owner.
     */
    isOwner: false,

    // Track current invitations and collaborations
    invitedBy: [],
    isCollaboratorOf: [],

    // Defaults views
    defaultViews: {
        login: "authentication-login",
        home: "home-start",
        application: "application-start"
    },

    /**
     * Possible login methods are currently:
     * - internal (email/password)
     * - google
     * - microsoftAD
     * - microsoft365
     * - linkedin
     * - facebook
     * 
     * Default login methods are internal, google and microsoftAD
     */
    loginMethods: ["internal", "google", "microsoftAD"],

    /**
     * Current host for session requests.
     */
    host: "",

    /**
     * Http port for session requests.
     */
    httpPort: 80,

    /**
     * Https port for session requests.
     */
    httpsPort: 443,

    /**
     * Websocket port for session requests.
     */
    wsPort: 80,

    /**
     * Secure websocket port for session requests.
     */
    wssPort: 443,

    /**
     * Set the hosts and ports for session requests.
     * 
     * @param {object} config
     * @param {string} [config.host]
     * @param {number} [config.httpPort]
     * @param {number} [config.httpsPort]
     * @param {number} [config.wsPort]
     * @param {number} [config.wssPort]
     * 
     * @example
     * kiss.session.setHost({
     *  host: "your-host.com",
     *  httpPort: 3000,
     *  httpsPort: 4000,
     *  wsPort: 3000,
     *  wssPort: 4000
     * })
     */
    setHost(config) {
        config.host = config.host || ""
        config.httpPort = config.httpPort || 80
        config.httpsPort = config.httpsPort || 443
        config.wsPort = config.wsPort || 80
        config.wssPort = config.wssPort || 443
        Object.assign(kiss.session, config)
    },

    /**
     * Flag (true/false) to check the protocol security for session requests (both HTTP and Websocket).
     */
    secure: true,

    /**
     * Set the protocol security for session requests.
     * If true (default):
     * - will use "https" for HTTP
     * - will use "wss" for Websocket
     * 
     * @param {string} host
     * 
     * @example
     * kiss.session.setSecure(true)
     */
    setSecure(secure = true) {
        kiss.session.secure = secure
    },

    /**
     * Get the Http host with protocol and port
     * 
     * @returns {string} The host with protocol and port
     * 
     * @example
     * kiss.session.getHttpHost() // "https://your-host.com:443"
     */
    getHttpHost() {
        const host = (!this.host) ? window.location.host : this.host
        const url = (this.secure) ? "https://" + host : "http://" + host
        return (this.secure) ? url + ":" + this.httpsPort : url + ":" + this.httpPort
    },

    /**
     * Get the websocket host with protocol and port
     * 
     * @returns {string} The host with protocol and port
     * 
     * @example
     * kiss.session.getWebsocketHost() // "wss://your-host.com:443"
     */
    getWebsocketHost() {
        const host = (!this.host) ? window.location.host : this.host
        const url = (this.secure) ? "wss://" + host : "ws://" + host
        return (this.secure) ? url + ":" + this.wssPort : url + ":" + this.wsPort
    },

    /**
     * Define the default views:
     * - login: view to login
     * - home: view to display after login
     * 
     * It allows KissJS to display the right login view and the right home view after login.
     * Defaults are:
     * - login: "authentication-login"
     * - home: "home-start"
     * 
     * @param {object} config
     * @param {string} config.login - Default = "authentication-login"
     * @param {string} config.home - Default = "home-start"
     * 
     * @example
     * kiss.session.setDefaultViews({
     *  login: "your-login-view",
     *  home: "your-home-view"
     * })
     */
    setDefaultViews(views) {
        Object.assign(this.defaultViews, views)
    },

    /**
     * Define the default websocket view
     * (view used to display websocket messages)
     * 
     * @ignore
     * @param {string} viewId
     */
    setWebSocketMessageView(viewId) {
        this.webSocketMessageView = viewId
    },

    /**
     * Define all login methods
     * 
     * @ignore
     * @returns {object[]} Array of login methods and their properties (text, icon...)
     */
    getLoginMethodTypes: () => [{
            type: "internal",
            alias: "i"
        },
        {
            type: "google",
            alias: "g",
            text: "Google",
            icon: "fab fa-google",
            callback: "/auth/google"
        },
        {
            type: "microsoftAD",
            alias: "a",
            text: "Microsoft",
            icon: "fab fa-microsoft",
            callback: "/auth/azureAd"
        },
        {
            type: "microsoft365",
            alias: "m",
            text: "Microsoft 365",
            icon: "fab fa-microsoft",
            callback: "/auth/microsoft"
        },
        {
            type: "linkedin",
            alias: "l",
            text: "LinkedIn",
            icon: "fab fa-linkedin",
            callback: "/auth/linkedin"
        },
        {
            type: "facebook",
            alias: "f",
            text: "Facebook",
            icon: "fab fa-facebook",
            callback: "/auth/facebook"
        },
        {
            //TODO
            type: "instagram",
            alias: "s",
            text: "Instagram",
            icon: "fab fa-instragram",
            callback: "/auth/instagram"
        },
        {
            //TODO
            type: "twitter",
            alias: "t",
            text: " Twitter",
            icon: "fab fa-twitter",
            callback: "/auth/twitter"
        }
    ],

    /**
     * Set the possible login methods.
     * 
     * Possible login methods are currently:
     * - internal
     * - google
     * - microsoftAD
     * - microsoft365
     * - linkedin
     * - facebook
     * 
     * Default login methods are internal, google and microsoftAD
     * 
     * @param {string[]} methods
     * 
     * @example
     * kiss.session.setLoginMethods(["internal", "google"])
     */
    setLoginMethods(methods) {
        kiss.session.loginMethods = methods
    },

    /**
     * Encode the active login methods into a short string.
     * Used internally to adapt the login prompt depending on the lm (login method) parameter
     * 
     * @ignore
     * @returns {string} For example "igf" means internal + google + facebook
     */
    getLoginMethods() {
        if (!kiss.session.loginMethods) {
            return kiss.session.getLoginMethodTypes().map(method => method.alias).join("")
        } else {
            return kiss.session.loginMethods.map(loginMethodType => kiss.session.getLoginMethodTypes().find(loginMethod => loginMethod.type == loginMethodType))
                .filter(loginMethod => loginMethod !== undefined)
                .map(loginMethod => loginMethod.alias)
                .join("")
        }
    },

    /**
     * Check if the environment is offline
     * 
     * @returns {boolean} true if the environment is offline
     */
    isOffline: () => ["memory", "offline"].includes(kiss.db.mode),

    /**
     * Check if the environment is online
     * 
     * @returns {boolean} true if the environment is online
     */
    isOnline: () => !kiss.session.isOffline(),

    /**
     * Set the maximum idle time before automatically logging out the user
     * 
     * @param {number} newIdleTime - Max idle time in minutes
     * 
     * @example
     * kiss.session.setMaxIdleTime(60) // 1 hour
     */
    setMaxIdleTime(newIdleTime) {
        this.maxIdleTime = newIdleTime
        localStorage.setItem("session-max-idle-time", this.maxIdleTime)
    },

    /**
     * Get the maximum idle time before automatically logging out the user
     * 
     * @returns {number} The maximum idle time in minutes
     */
    getMaxIdleTime() {
        return localStorage.getItem("session-max-idle-time") || kiss.session.maxIdleTime
    },

    /**
     * Display a window to set the maximum idle time before automatically logging out the user
     */
    selectMaxIdleTime() {
        const currentMaxIdleTime = kiss.session.getMaxIdleTime() / 60

        createPanel({
            id: "idle-time",
            title: txtTitleCase("#auto logout"),
            icon: "fas fa-clock",
            modal: true,
            draggable: true,
            closable: true,
            align: "center",
            verticalAlign: "center",
            padding: 50,
            items: [
                {
                    id: "maxIdleTime",
                    type: "slider",
                    value: currentMaxIdleTime,
                    label: txtTitleCase("#auto logout help"),
                    labelPosition: "top",
                    min: 0.5,
                    max: 8,
                    step: 0.5,
                    width: 500,
                    events: {
                        change: function () {
                            const newMaxIdleTime = this.getValue() * 60
                            kiss.session.setMaxIdleTime(newMaxIdleTime)
                            createNotification(txtTitleCase("#update done"))
                        }
                    }
                }
            ]
        }).render()
    },

    /**
     * Get the application's server runtinme environment
     * 
     * @ignore
     * @async
     * @returns {string} "dev" | "production" | ... | "unknown"
     */
    getServerEnvironment: async () => {
        const response = await kiss.ajax.request({
            url: "/getEnvironment"
        })
        return response.environment || "unknown"
    },

    /**
     * Get access token
     * 
     * @ignore
     */
    getToken: () => localStorage.getItem("session-token"),

    /**
     * Get refresh token
     * 
     * @ignore
     */
    getRefreshToken: () => localStorage.getItem("session-refresh-token"),

    /**
     * Get token's expiration
     * 
     * @ignore
     */
    getExpiration: () => localStorage.getItem("session-expiration"),

    /**
     * Get websocket non-secure port
     * 
     * @ignore
     */
    getWebsocketPort: () => localStorage.getItem("session-ws.port"),

    /**
     * Get websocket secure port
     * 
     * @ignore
     */
    getWebsocketSSLPort: () => localStorage.getItem("session-ws.sslPort"),

    /**
     * Get the date/time of the last user activity which was tracked
     * 
     * @returns {date} The date/time of the last user activity
     */
    getLastActivity: () => {
        const lastActivity = localStorage.getItem("session-lastActivity")
        if (lastActivity) return new Date(lastActivity)
        else return new Date()
    },

    /**
     * Get authenticated user's id.
     * 
     * Returns "anonymous" in offline and memory mode.
     * 
     * @returns {string} The user id
     */
    getUserId: () => (kiss.session.isOffline()) ? "anonymous" : localStorage.getItem("session-userId") || "anonymous",

    /**
     * Check if the user is authenticated
     * 
     * @returns {boolean} true if the user is authenticated
     */
    isAuthenticated: () => (kiss.session.isOffline()) ? true : kiss.session.getUserId() != "anonymous",

    /**
     * Get authenticated user's first name.
     * 
     * Returns "anonymous" in offline and memory mode.
     * 
     * @returns {string} The user's first name
     */
    getFirstName: () => (kiss.session.isOffline()) ? "anonymous" : localStorage.getItem("session-firstName"),

    /**
     * Get authenticated user's last name.
     * 
     * Returns "anonymous" in offline and memory mode.
     * 
     * @returns {string} The user's last name
     */
    getLastName: () => (kiss.session.isOffline()) ? "anonymous" : localStorage.getItem("session-lastName"),

    /**
     * Get authenticated user's full name.
     * 
     * Returns "anonymous" in offline and memory mode.
     * 
     * @returns {string} The user's full name
     */
    getUserName: () => (kiss.session.isOffline()) ? "anonymous" : kiss.session.getFirstName() + " " + kiss.session.getLastName(),

    /**
     * Get authenticated user's account id.
     * 
     * Returns "anonymous" in offline and memory mode.
     * 
     * @returns {string} The account id
     */
    getAccountId: () => (kiss.session.isOffline()) ? "anonymous" : localStorage.getItem("session-accountId"),

    /**
     * Get authenticated user's current account id.
     * KissJS allows a mechanism to switch from one account to another.
     * The current account id is the one the user is currently working on.
     * 
     * Returns "anonymous" in offline and memory mode.
     * 
     * @returns {string} The current account id
     */
    getCurrentAccountId: () => (kiss.session.isOffline()) ? "anonymous" : localStorage.getItem("session-currentAccountId"),

    /**
     * Get all current user's accounts he collaborates with.
     * 
     * Returns an empty array in offline and memory mode.
     * 
     * @returns {string[]} Array of account ids
     */
    getCollaborators: () => {
        if (!kiss.session.isOffline()) {
            try {
                return JSON.parse(localStorage.getItem("session-isCollaboratorOf"))
            } catch (err) {}
        }
        return []
    },

    /**
     * Get all the user pending invitations to collaborate with.
     * 
     * Returns an empty array in offline and memory mode.
     * 
     * @returns {string[]} Array of account ids
     */
    getInvitations: () => {
        if (!kiss.session.isOffline()) {
            try {
                return JSON.parse(localStorage.getItem("session-invitedBy"))
            } catch (err) {}
        }
        return []
    },

    /**
     * Tell if the authenticated user is the owner of the account
     * 
     * @returns {boolean} true if the user is the account owner
     */
    isAccountOwner: () => {
        if (kiss.session.isOffline()) return true
        return (localStorage.getItem("session-accountId") == localStorage.getItem("session-currentAccountId"))
    },

    /**
     * Tell if the authenticated user is one of the account managers.
     * An account manager is a user who has been promoted to manage the account like the owner.
     * 
     * @returns {boolean} true if the user is an account manager
     */
    isAccountManager() {
        if (kiss.session.isOffline()) return true
        if (!kiss.session.account) return false
        return (kiss.session.account.managers || []).includes(this.getUserId())
    },

    /**
     * Init the session account by retrieving the record which holds the account data.
     * When offline, generates a fake offline account.
     * 
     * @ignore
     * @async
     */
    async initAccount() {
        if (kiss.session.isOnline()) {
            kiss.session.account = await kiss.app.collections.account.findOne(kiss.session.getCurrentAccountId())

            // Observe account updates
            kiss.pubsub.subscribe("EVT_DB_UPDATE:ACCOUNT", async () => kiss.session.account = await kiss.app.collections.account.findOne(kiss.session.getCurrentAccountId()))

        } else {
            kiss.session.account = kiss.app.models.account.create({
                accountId: "anonymous",
                status: "active"
            })
        }
    },

    /**
     * Initialize the account owner
     * Note: a user is always the account owner for in-memory and offline mode
     * 
     * @ignore
     */
    initAccountOwner() {
        if (kiss.db.mode == "memory" || kiss.db.mode == "offline") {
            kiss.session.isOwner = true
        }
        else {
            kiss.session.isOwner = this.isAccountOwner()
        }
    },

    /**
     * Initialize the account managers
     * Note: a user is always an account manager for in-memory and offline mode
     * 
     * @ignore
     */
    initAccountManagers() {
        if (kiss.db.mode == "memory" || kiss.db.mode == "offline") {
            kiss.session.isManager = true
        }
        else {
            kiss.session.isManager = this.isAccountManager()
        }
    },    

    /**
     * Hooks
     * 
     * @ignore
     */
    hooks: {
        beforeInit: [],
        beforeRestore: [],
        afterInit: [
            async () => await kiss.session.initAccount()
        ],
        afterRestore: [
            async () => await kiss.session.initAccount()            
        ]
    },

    /**
     * Add a hook to perform an action before or after the session initialization
     * 
     * @param {string} event - "beforeInit" | "afterInit" | "beforeRestore" | "afterRestore"
     * @param {function} callback - Function to execute. It receives the following parameters: *beforeInit(sessionData), *afterInit(sessionData), *beforeRestore(), *afterRestore()
     * @returns this
     * 
     * @example
     * kiss.session.addHook("afterInit", function(sessionData) {
     *  console.log("The session data is...", sessionData)
     * })
     */
    addHook(event, callback) {
        if (["beforeInit", "afterInit", "beforeRestore", "afterRestore"].includes(event)) this.hooks[event].push(callback)
        return this
    },

    /**
     * Process hook
     * 
     * @private
     * @ignore
     * @param {string} event - "beforeInit" | "afterInit" | "beforeRestore" | "afterRestore"
     * @param {*} sessionData
     */
    _processHook(event, sessionData) {
        if (this.hooks[event].length != 0) {
            this.hooks[event].forEach(hook => {
                hook(sessionData)
            })
        }
    },

    /**
     * Switch the user from one account to another.
     * 
     * @async
     * @param accountId
     * @returns {object} The /switchAccount response
     */
    async switchAccount(accountId) {
        // Prevent from switching from an application
        if (kiss.context.ui == this.defaultViews.application) {
            kiss.router.navigateTo({
                ui: this.defaultViews.home
            })
        }

        const data = await kiss.ajax.request({
            url: "/switchAccount",
            method: "post",
            showLoading: true,
            body: JSON.stringify({
                accountId
            })
        })

        if (!data) return
        if (data.error) return data

        if (typeof data === "object") {
            this._updateCurrentAccount(Object.assign(data, {
                accountId
            }))
        }

        // We want to reload for the user to get his entire UI setup for the account he switched to
        window.location.reload()
    },

    /**
     * Accepts an invitation from another account to collaborate
     * 
     * @ignore
     * @async
     * @param {string} accountId
     * @returns {object} The /acceptInvitation response
     */
    async acceptInvitationOf(accountId) {
        const response = await kiss.ajax.request({
            url: "/acceptInvitationOf",
            method: "post",
            showLoading: true,
            body: JSON.stringify({
                accountId
            })
        })

        if (response.error) return response

        kiss.session.invitedBy.splice(kiss.session.invitedBy.indexOf(accountId), 1)
        kiss.session.isCollaboratorOf.push(accountId)

        localStorage.setItem("session-invitedBy", JSON.stringify(kiss.session.invitedBy))
        localStorage.setItem("session-isCollaboratorOf", JSON.stringify(kiss.session.isCollaboratorOf))

        createNotification({
            message: txtTitleCase("invitation accepted")
        })

        return response
    },

    /**
     * Rejects an invitation from another account to collaborate
     * 
     * @ignore
     * @async
     * @param {string} accountId
     * @returns {object} The /rejectInvitation response
     */
    async rejectInvitationOf(accountId) {
        const response = await kiss.ajax.request({
            url: "/rejectInvitationOf",
            method: "post",
            showLoading: true,
            body: JSON.stringify({
                accountId
            })
        })

        if (response && response.error) return response

        kiss.session.invitedBy.splice(kiss.session.invitedBy.indexOf(kiss.session.accountId), 1)
        localStorage.setItem("session-invitedBy", JSON.stringify(kiss.session.invitedBy))

        return response
    },

    /**
     * Allow the current user to end a collaboration
     * 
     * @ignore
     * @async
     * @param accountId
     * @returns {object} The /quiAccount response
     */
    async quitAccount(accountId) {
        const response = await kiss.ajax.request({
            url: "/quitAccount",
            method: "post",
            showLoading: true,
            body: JSON.stringify({
                accountId
            })
        })

        if (response.error) return response

        const {
            currentAccountChanged,
            currentAccountId,
            token,
            refreshToken,
            expiresIn
        } = response

        if (!currentAccountChanged) return response

        this.isCollaboratorOf.splice(kiss.session.isCollaboratorOf.indexOf(accountId), 1)
        localStorage.setItem("session.isCollaboratorOf", JSON.stringify(this.isCollaboratorOf))

        this._updateCurrentAccount({
            accountId: currentAccountId,
            refreshToken,
            token,
            expiresIn
        })

        kiss.router.navigateTo({
            ui: this.defaultViews.home
        })
    },

    /**
     * Update current account after a switch
     * 
     * @private
     * @ignore
     * @param {string} accountId
     * @param {string} refreshToken
     * @param {string} token
     * @param {int} expiresIn
     */
    _updateCurrentAccount({
        accountId,
        refreshToken,
        token,
        expiresIn
    }) {
        // Since token needed to be re-generated, we must update them into the session
        const expirationDate = new Date()
        expirationDate.setSeconds(expirationDate.getSeconds() + expiresIn)
        localStorage.setItem("session-refresh-token", refreshToken)
        localStorage.setItem("session-token", token)
        localStorage.setItem("session-expiration", expirationDate)
        localStorage.setItem("session-currentAccountId", accountId)
    },    

    /**
     * Attach an event to each provided download link to handle a session expiry.
     * Excludes public files from the process.
     * 
     * @ignore
     * @param {...HTMLLinkElement} links
     */
    setupDownloadLink(...links) {
        links.filter(link => !!link).forEach(link => {
            
            // Excludes public links from the process
            if (link.getAttribute("public")) return

            link.addEventListener("click", async e => {
                // According to the spec, e.currentTarget is null outside the context of the event
                // handler. Since the event handler logic don't await async handlers, thus after
                // the first await, e.currentTarget can't be accessed anymore.
                const currentTarget = e.currentTarget

                e.stopImmediatePropagation()

                if (e.isTrusted) {
                    e.preventDefault()
                    const response = await fetch(currentTarget.href, {
                        method: "head"
                    })

                    if (response.status === 498) {
                        if (!await kiss.session.getNewToken()) {
                            log("kiss.session - setupDownloadLink - Unable to get a new token", 1)
                            return
                        }
                    } else if (response.status === 401) {
                        log("kiss.session - setupDownloadLink - Unauthorized", 1)
                        return
                    }
                    // else if (response.status == 204){
	                //     createNotification({
		            //         message: txtTitleCase("Unable to download this file.")
	                //     })
					// 	return
                    // }

                    link.dispatchEvent(new MouseEvent("click"))
                }
            })
        })
    },

    /**
     * Attach an event to each provided image to handle a session expiry.
     * Excludes public files from the process.
     * 
     * @ignore
     * @param {...HTMLImageElement} imgs
     */
    setupImg(...imgs) {
        imgs.filter(img => !!img).forEach(img => {

            // Exclude public images from the process
            if (img.getAttribute("public")) return

            img.addEventListener("error", async e => {
                // According to the spec, e.currentTarget is null outside the context of the event
                // handler. Since the event handler logic don't await async handlers, thus after
                // the first await, e.currentTarget can't be accessed anymore.
                const currentTarget = e.currentTarget

                let src = currentTarget.src
                const response = await fetch(src, {
                    method: "head"
                })

                // Refresh token expired
                if (response.status === 401) {
                    kiss.session.showLogin()
                    return
                }

                if (response.status !== 498) return

                if (await kiss.session.checkTokenValidity(true)) {
                    currentTarget.src = ""
                    currentTarget.src = src
                } else {
                    kiss.session.showLogin()
                }
            })
        })
    },

    /**
     * Set the session params:
     * - token
     * - expiration date
     * - accountId
     * - user's id
     * - user's first name
     * - user's last name
     * - user's account ownership
     * 
     * @ignore
     * @async
     * @param {object} sessionData
     */
    async init(sessionData) {
        this.observeResources()

        // Abort if there is no token
        if (!sessionData.token) return

        // Hook before the session is initialized
        await this._processHook("beforeInit", sessionData)

        sessionData.expirationDate = new Date()
        sessionData.expirationDate.setSeconds(sessionData.expirationDate.getSeconds() + sessionData.expiresIn)
        Object.assign(this, sessionData)

        // Store session params locally
        localStorage.setItem("session-token", sessionData.token)
        localStorage.setItem("session-refresh-token", sessionData.refreshToken)
        localStorage.setItem("session-expiration", sessionData.expirationDate)
        localStorage.setItem("session-userId", sessionData.userId)
        localStorage.setItem("session-firstName", sessionData.firstName)
        localStorage.setItem("session-lastName", sessionData.lastName)
        localStorage.setItem("session-accountId", sessionData.accountId)
        localStorage.setItem("session-currentAccountId", sessionData.currentAccountId)
        localStorage.setItem("session-isCollaboratorOf", JSON.stringify(sessionData.isCollaboratorOf))
        localStorage.setItem("session-invitedBy", JSON.stringify(sessionData.invitedBy))
        localStorage.setItem("session-isOwner", this.isAccountOwner())
        localStorage.setItem("session-ws.port", sessionData.ws.port)
        localStorage.setItem("session-ws.sslPort", sessionData.ws.sslPort)

        // Init the account owner & managers
        this.initAccountOwner()
        this.initAccountManagers()

        // Init or re-init websocket
        await kiss.websocket.init({
                port: this.getWebsocketPort(),
                sslPort: this.getWebsocketSSLPort()
            })
            .then(() => {
                log("kiss.session - restore - Websocket connected")
            })
            .catch(err => {
                log("kiss.session - restore - Websocket error: ", 4, err)
            })

        // Observe websocket errors
        this.observeWebsocket()

        // Observe user collaborations
        this.observeCollaborations()

        // Init activity tracker
        this.initIdleTracker()

        // Hook after the session is initialized
        await this._processHook("afterInit", sessionData)
    },

    /**
     * Restore session variables (typically after a browser refresh).
     * 
     * @async
     */
    async restore() {
        // Offline sessions don't manage any user info
        if (kiss.session.isOffline()) {
            await this._processHook("afterRestore")
            return true
        }

        // Abort if there is no token to restore
        this.token = this.getToken()
        if (!this.token) return

        // Hook before the session is restored
        await this._processHook("beforeRestore")

        // Restore session infos
        this.refreshToken = this.getRefreshToken()
        this.expirationDate = this.getExpiration()
        this.userId = this.getUserId()
        this.firstName = this.getFirstName()
        this.lastName = this.getLastName()
        this.accountId = this.getAccountId()
        this.currentAccountId = this.getCurrentAccountId()
        this.isCollaboratorOf = this.getCollaborators()
        this.invitedBy = this.getInvitations()
        this.isOwner = this.isAccountOwner()
        this.ws = {
            port: this.getWebsocketPort(),
            sslPort: this.getWebsocketSSLPort()
        }

        // Init the account owner & managers
        this.initAccountOwner()
        this.initAccountManagers()

        // Restore websocket connection
        await kiss.websocket.init({
                port: this.ws.port,
                sslPort: this.ws.sslPort
            })
            .then(() => {
                log("kiss.session - restore - Websocket connected")
            })
            .catch(err => {
                log("kiss.session - restore - Websocket error:", 4, err)
            })

        // Restore activity tracker
        this.lastActivity = this.getLastActivity()
        kiss.session.initIdleTracker()

        // Hook after the session is restored
        await this._processHook("afterRestore")
    },

    /**
     * Reset all kiss.session variables
     */
    reset() {
        const propertiesToReset = ["token", "refreshToken", "accountId", "currentAccountId", "userId", "isOwner", "firstName", "lastName", "lastActivity", "expirationDate"]
        propertiesToReset.forEach(prop => delete this[prop])

        localStorage.removeItem("session-token")
        localStorage.removeItem("session-refresh-token")
        localStorage.removeItem("session-expiration")
        localStorage.removeItem("session-userId")
        localStorage.removeItem("session-firstName")
        localStorage.removeItem("session-lastName")
        localStorage.removeItem("session-lastActivity")
        localStorage.removeItem("session-accountId")
        localStorage.removeItem("session-currentAccountId")
        localStorage.removeItem("session-isCollaboratorOf")
        localStorage.removeItem("session-invitedBy")
        localStorage.removeItem("session-isOwner")
        localStorage.removeItem("session-ws.port")
        localStorage.removeItem("session-ws.sslPort")

        // Close the websocket connection
        if (kiss.websocket.connection.readyState !== WebSocket.CLOSED) {
            kiss.websocket.close()
        }
    },

    /**
     * Initialize user idleness tracker.
     * By default, the user is considered idle if his mouse doesn't move for too long (maxIdleTime).
     * After that delay, the system automatically logout and clear sensitive tokens.
     * 
     * @ignore
     */
    initIdleTracker() {
        // Initialize the max idle time
        this.setMaxIdleTime(this.getMaxIdleTime())

        const reportActivity = () => {
            this.lastActivity = new Date()
            localStorage.setItem("session-lastActivity", new Date())
        }

        // Track mouse moves
        if (!this.idleObserver) {
            this.idleObserver = document.body.addEventListener("mousemove", kiss.tools.throttle(10 * 1000, reportActivity))
        }

        // Logout if user is idle
        setInterval(() => {
            if (kiss.session.isIddle()) {
                log("kiss.session - activity tracker - You were logged out because considered iddled", 1)
                kiss.session.logout()
            }
        }, 1000 * 60)
    },

    /**
     * Check if the user is idle (= no activity for n minutes).
     * 
     * Set the idle threshold with setMaxIdleTime().
     */
    isIddle() {
        if ((new Date() - this.getLastActivity()) > this.maxIdleTime * 1000 * 60) return true
        return false
    },

    /**
     * Get the user's ACL.
     * 
     * @returns {string[]} Array containing all the user names and groups (32 hex id) by which the user is recognized to access the data.
     * 
     * @example:
     * ["*", "bob.wilson@gmail.com", "ED7E7E4CA6F9B6D544257F54003B8F80", "3E4971CB41048BD844257FF70074D40F"]
     */
    getACL() {
        return kiss.directory.getUserACL(this.userId)
    },

    /**
     * Show the login prompt
     * 
     * @param {object} [redirecto] - Route to execute after login, following kiss.router convention. Route to the home page by default.
     * @example
     * kiss.session.showLogin({
     *  ui: "form-view",
     *  modelId: "0183b2a8-cfb4-70ec-9c14-75d215c5e635",
     *  recordId: "0183b2a8-d08a-7067-b400-c110194da391"
     * })
     */
    showLogin(redirectTo) {
        if (redirectTo) {
            kiss.context.redirectTo = redirectTo
        } else {
            kiss.context.redirectTo = {
                ui: this.defaultViews.home
            }
        }

        kiss.router.navigateTo({
            ui: this.defaultViews.login
        })
    },

    /**
     * Login the user
     * 
     * The method takes either a username/password OR a token from 3rd party services
     * 
     * @ignore
     * @async
     * @param {object} login - login informations: username/password, or token
     * @param {string} login.username
     * @param {string} login.password
     * @param {string} login.token
     * @returns {boolean} false if the login failed
     */
    async login(login) {
        let data

        if (!login.token) {
            // Authentication with username / password
            data = await kiss.ajax.request({
                url: "/login",
                method: "post",
                showLoading: true,
                body: JSON.stringify({
                    username: login.username,
                    password: login.password
                })
            })
        } else {
            // Authentication with 3rd party token
            data = await kiss.ajax.request({
                url: "/verifyToken",
                method: "post",
                body: JSON.stringify({
                    token: login.token
                })
            })
        }

        // Wrong username / password
        if (!data || !data.token) return false

        // Reset the session locally with the new token issued by the server
        await kiss.session.init(data)

        // If the login was prompted because of:
        // - a session timeout (498)
        // - a forbidden route (401)
        // ... we have to resume where we aimed to go, otherwise, return true
        const currentRoute = kiss.router.getRoute()

        // If acceptInvitationOf is defined, the user clicked on a mail to accept an invitation from an account.
        if (kiss.context.acceptInvitationOf) {
            await kiss.session.acceptInvitationOf(kiss.context.acceptInvitationOf)
        }

        if (currentRoute && currentRoute.ui != this.defaultViews.login) {
            location.reload()
        } else {
            return true
        }
    },

    /**
     * Renew the current access token if needed. If token is not valid and can"t be renewed, return false
     * 
     * @ignore
     * @async
     * @param {boolean} [autoRenew=true] If true, will try to renew the token if invalid token code (498) is received.
     * @return {Promise<boolean>}
     */
    async checkTokenValidity(autoRenew = true) {
        try {
            const resp = await fetch(kiss.session.host + "/checkTokenValidity", {
                headers: {
                    authorization: "Bearer " + this.getToken()
                }
            })
    
            if (autoRenew && resp.status === 498) return await this.getNewToken()
    
            return resp.status === 200
        }
        catch (err) {
            log(err)
            return false
        }
    },

    /**
     * Logout the user and redirect to the login page
     */
    async logout() {
        // Reset the tokens on the server
        await kiss.ajax.request({
            url: kiss.session.host + "/logout",
            method: "get"
        })

        // Close the websocket connection
        if (kiss.websocket.connection.readyState !== WebSocket.CLOSED) {
            kiss.websocket.close()
        }

        // Reset the tokens locally
        kiss.session.reset()
        document.location.reload()
    },

    /**
     * Gets a new token from the Refresh Token
     * 
     * @ignore
     * @async
     * @returns The token, or false if it failed
     */
    async getNewToken() {
        const newToken = await kiss.ajax.request({
            url: "/refreshToken",
            method: "post",
            body: JSON.stringify({
                refreshToken: kiss.session.getRefreshToken()
            })
        })

        if (newToken) {
            await kiss.session.init(newToken)
            return newToken
        } else {
            // If the refresh token is not valid anymore, we don't want to maintain the socket connection.
            kiss.websocket.close()

            // Close all active windows except login window
            kiss.tools.closeAllWindows(["login"])
            return false
        }
    },

    /**
     * Init resource observer
     * 
     * @ignore
     */
    observeResources() {
        if (this.resourcesObserver) return

        this.resourcesObserver = new MutationObserver(mutations => {
            for (let mutation of mutations) {
                for (let addedNode of mutation.addedNodes) {
                    if (addedNode.tagName === "IMG") {
                        kiss.session.setupImg(addedNode)
                    } else if (addedNode.tagName === "A" && addedNode.hasAttribute("download")) {
                        kiss.session.setupDownloadLink(addedNode)
                    } else if (addedNode.querySelectorAll) {
                        kiss.session.setupImg(...addedNode.querySelectorAll('img'))
                        kiss.session.setupDownloadLink(...addedNode.querySelectorAll('a[download]'))
                    }
                }
            }
        })

        this.resourcesObserver.observe(document.body, {
            childList: true,
            subtree: true
        })
    },

    /**
     * Init websocket observer
     * 
     * @ignore
     */
    observeWebsocket() {
        if (this.websocketObserver) return

        // Disconnection
        kiss.pubsub.subscribe("EVT_DISCONNECTED", () => this.showWebsocketMessage("websocket disconnected"))

        // Reconnection
        kiss.pubsub.subscribe("EVT_RECONNECTED", () => {
            log("kiss.session - observeWebsocket - Socket reconnected")
            this.hideWebsocketMessage()
        })

        // Connection lost
        kiss.pubsub.subscribe("EVT_CONNECTION_LOST", () => this.showWebsocketMessage("websocket connection lost"))

        // Unusable token
        kiss.pubsub.subscribe("EVT_UNUSABLE_TOKEN", () => {
            kiss.session.reset()
            window.location.reload()
        })

        this.websocketObserver = true
    },

    /**
     * Observe collaborations
     * 
     * @ignore
     */
    observeCollaborations() {
        if (this.collaborationObserver) return

        // New collaboration
        kiss.pubsub.subscribe("EVT_COLLABORATION:RECEIVED", data => {
            this.invitedBy.push(data.accountId)
            window.localStorage.setItem("session-invitedBy", JSON.stringify(this.invitedBy))
        })

        // Collaboration deleted
        kiss.pubsub.subscribe("EVT_COLLABORATION:DELETED", (data) => {
            this._updateCurrentAccount({
                accountId: this.getAccountId(),
                token: data.token,
                refreshToken: data.refreshToken,
                expiresIn: data.expiresIn
            })

            kiss.router.navigateTo({
                ui: this.defaultViews.home
            })
        })

        this.collaborationObserver = true
    },

    /**
     * Show the websocket message
     * 
     * @ignore
     * @param {string} message
     */
    showWebsocketMessage(message) {
        if ($("websocket-message")) $("websocket-message").remove()

        createBlock({
            id: "websocket-message",
            fullscreen: true,
            background: "transparent",
            items: [{
                type: "panel",
                maxWidth: () => Math.min(kiss.screen.current.width / 2, 1000),
                header: false,
                layout: "vertical",
                align: "center",
                verticalAlign: "center",
                alignItems: "center",
                justifyContent: "center",
                items: [{
                    type: "html",
                    padding: 32,
                    html: `<div style="font-size: 18px; text-align: center;">${txtTitleCase(message)}</div>`
                }]
            }]
        }).render()
    },    

    /**
     * Hide the websocket message
     * 
     * @ignore
     */
    hideWebsocketMessage() {
        if ($("websocket-message")) $("websocket-message").remove()
    }    
}

;/**
 * 
 * ## Manage the application CSS theme (color and geometry)
 * 
 * @namespace
 * 
 */
kiss.theme = {
    // Defaults
    currentColor: "",
    currentGeometry: "",

    /**
     * Init the theme at startup.
     * It will also observe CSS theme passed in the URL hash parameter "themeColor" / "themeGeometry" and switch theme accordingly.
     * The default theme color is "light", and theme geometry is "default"
     */
    init() {
        const localStorageTheme = kiss.theme.get()
        kiss.context.themeColor = kiss.theme.currentColor = kiss.router.getRoute().themeColor || localStorageTheme.color
        kiss.context.themeGeometry = kiss.theme.currentGeometry = kiss.router.getRoute().themeGeometry || localStorageTheme.geometry

        kiss.theme._load({
            color: kiss.context.themeColor,
            geometry: kiss.context.themeGeometry
        })

        // Observe EVT_ROUTE_UPDATED event to adjust theme according to the "themeColor" and "themeGeometry" parameters of the url hash
        kiss.theme._observe()
    },

    /**
     * Update the theme (color and geometry)
     * 
     * @param {object} config
     * @param {string} config.color
     * @param {string} config.geometry
     * 
     * @example
     * kiss.theme.set({
     *  color: "dark",
     *  geometry: "sharp"
     * })
     */
    set({color, geometry}) {
        color = color || kiss.theme.currentColor
        geometry = geometry || kiss.theme.currentGeometry

        localStorage.setItem("config-themeColor", color)
        localStorage.setItem("config-themeGeometry", geometry)

        kiss.theme._load({
            color,
            geometry
        })

        kiss.router.updateUrlHash({
            themeColor: color,
            themeGeometry: geometry
        })
    },

    /**
     * Get the current theme parameters saved in the localStorage
     * 
     * @returns {object} Theme parameters like: {color: "light", geometry: "default"}
     */
    get() {
        kiss.theme.currentColor = localStorage.getItem("config-themeColor")
        if (!kiss.theme.currentColor) kiss.theme.currentColor = "light"
        
        kiss.theme.currentGeometry = localStorage.getItem("config-themeGeometry")
        if (!kiss.theme.currentGeometry) kiss.theme.currentGeometry = "default"

        return {
            color: kiss.theme.currentColor,
            geometry: kiss.theme.currentGeometry
        }
    },

    /**
     * Switch CSS theme dynamically
     * (replace the existing CSS theme link by the new CSS theme link)
     * 
     * @private
     * @ignore
     * @param {object} config
     * @param {string} config.color - New theme color
     * @param {string} config.geometry - New theme geometry
     */
    _load({color, geometry}) {
        // COLOR THEME
        if (color) {
            
            // Build the right color theme path according to the context
            let colorHrefLink
            if (kiss.global.absolutePath) {
                colorHrefLink = kiss.global.absolutePath + "/kissjs/client/ui/styles/colors/" + color + ".css"
            } else {
                if (kiss.app.name == "pickaform") {
                    // pickaform is built alongside with KissJS
                    colorHrefLink = "../../kissjs/client/ui/styles/colors/" + color + ".css"
                }
                else {
                    colorHrefLink = "https://kissjs.net/resources/lib/kissjs/styles/colors/" + color + ".css"
                }
            }

            // Apply the new color theme (replace exiting one or add a new one)
            if (color != "custom") {
                let colorThemeFound = false
                document.documentElement.removeAttribute("style")

                document.querySelectorAll("link").forEach(link => {
                    if (link.href.indexOf("styles/colors") != -1) {
                        colorThemeFound = true
                        link.href = colorHrefLink
                    }
                })

                if (!colorThemeFound) {
                    const newLink = document.createElement("link")
                    newLink.rel = "stylesheet"
                    newLink.href = colorHrefLink
                    document.head.appendChild(newLink)
                }                
            } else {
                let theme = localStorage.getItem("config-theme")
                if (!theme) return
                theme = JSON.parse(theme)

                Object.keys(theme).forEach(variable => {
                    const color = theme[variable]
                    document.documentElement.style.setProperty(variable, color)
                })
            }
        }

        // GEOMETRY THEME
        if (geometry) {

            // Build the right geometry theme path according to the context
            let geometryHrefLink
            if (kiss.global.absolutePath) {
                geometryHrefLink = kiss.global.absolutePath + "/kissjs/client/ui/styles/geometry/" + geometry + ".css"
            } else {
                if (kiss.app.name == "pickaform") {
                    // pickaform is built alongside with KissJS
                    geometryHrefLink = "../../kissjs/client/ui/styles/geometry/" + geometry + ".css"
                }
                else {
                    geometryHrefLink = "https://kissjs.net/resources/lib/kissjs/styles/geometry/" + geometry + ".css"
                }
            }

            // Apply the new geometry theme (replace exiting one or add a new one)
            let geometryThemeFound = false

            document.querySelectorAll("link").forEach(link => {
                if (link.href.indexOf("styles/geometry") != -1) {
                    geometryThemeFound = true
                    link.href = geometryHrefLink
                }
            })

            if (!geometryThemeFound) {
                const newLink = document.createElement("link")
                newLink.rel = "stylesheet"
                newLink.href =geometryHrefLink
                document.head.appendChild(newLink)
            }
        }

        kiss.theme.currentColor = color || "light"
        kiss.theme.currentGeometry = geometry || "default"
    },

    /**
     * Observe CSS theme passed in the URL hash parameter "theme" and switch theme automatically.
     * For example: /index.html#ui=home&**theme=dark**
     * 
     * @private
     * @ignore
     */
    _observe() {
        subscribe("EVT_ROUTE_UPDATED", (msgData) => {
            if ((msgData.themeColor != kiss.theme.currentColor) || (msgData.themeGeometry != kiss.theme.currentGeometry)) {
                kiss.theme._load({
                    color: msgData.themeColor,
                    geometry: msgData.themeGeometry
                })
            }
        })
    },

    /**
     * Open a window to switch the theme manually
     */
    select() {
        if ($("theme-window")) return
        const isMobile = kiss.screen.isMobile
    
        // Responsive layout options
        let responsiveOptions 
    
        if (isMobile) {
            responsiveOptions = {
                top: () => 0,
                left: () => 0,
                height: "100%",
                borderRadius: "0 0 0 0",
                draggable: false
            }
        }
        else {
            responsiveOptions = {
                verticalAlign: "center",
                draggable: true
            }
        }

        const titleStyle = {
            color: "var(--blue)",
            fontSize: "1.8rem",
            fontWeight: "bold",
            flex: 1,
            width: "100%",
            height: "2.4rem",
            boxShadow: "none",
        }
    
        return createPanel({
            id: "theme-window",
            title: txtTitleCase("theme"),
            icon: "fas fa-sliders-h",
            modal: true,
            closable: true,
            display: "block",
            position: "absolute",
            align: "center",
            maxWidth: "70.5rem",
            overflowY: "auto",
    
            ...responsiveOptions,
    
            defaultConfig: {
                type: "button",
                icon: "fas fa-palette",
                flex: 1,
                height: "5rem",
                width:(isMobile) ? "calc(100% - 2rem)" : "15rem",
                margin: "1rem",
                iconSize: "2.4rem",
                fontSize: "1.6rem",
                textAlign: "left",
                boxShadow: "var(--shadow-1)",
                boxShadowHover: "var(--shadow-4)",
            },
    
            items: [
                // THEME COLORS
                {
                    type: "html",
                    ...titleStyle,
                    html: txtTitleCase("color")
                },
                // LIGHT THEME
                {
                    text: txtTitleCase("light"),
                    color: "#232730",
                    iconColor: "#232730",
                    backgroundColor: "#eeeeee",
                    action: () => kiss.theme.set({color: "light"})
                },
                // DARK THEME
                {
                    text: txtTitleCase("dark"),
                    color: "#ffffff",
                    iconColor: "#ffffff",
                    backgroundColor: "#373a40",
                    action: () => kiss.theme.set({color: "dark"})
                },
                // PINK
                {
                    text: txtTitleCase("pink"),
                    color: "#ffffff",
                    iconColor: "#ffffff",
                    backgroundColor: "#ffa3a3",
                    action: () => kiss.theme.set({color: "pink"})
                },
                // PURPLE
                {
                    text: txtTitleCase("purple"),
                    color: "#ffffff",
                    iconColor: "#ffffff",
                    backgroundColor: "#aeabe8",
                    action: () => kiss.theme.set({color: "purple"})
                },            
                // BLUE
                {
                    text: txtTitleCase("blue"),
                    color: "#232730",
                    iconColor: "#ffffff",
                    backgroundColor: "#c7efff",
                    action: () => kiss.theme.set({color: "blue"})
                },
                // GREEN
                {
                    text: txtTitleCase("green"),
                    color: "#232730",
                    iconColor: "#ffffff",
                    backgroundColor: "#b4e9b4",
                    action: () => kiss.theme.set({color: "green"})
                },            
                // SUPER BLACK THEME
                {
                    text: txtTitleCase("orange"),
                    color: "#ffffff",
                    iconColor: "#ffffff",
                    backgroundColor: "#ffbe61",
                    action: () => kiss.theme.set({color: "orange"})
                },                                  
                // CUSTOM THEME
                {
                    hidden: isMobile,
                    text: txtTitleCase("custom"),
                    color: "var(--body)",
                    icon: "fas fa-cog",
                    iconColor: "var(--body)",
                    backgroundColor: "transparent",
                    action: function () {
                        kiss.theme.set({color: "custom"})
                        $("theme-window").close()
                        kiss.theme.createThemeBuilderWindow()
                    }
                },
                // THEME GEOMETRY
                {
                    type: "html",
                    ...titleStyle,
                    html: txtTitleCase("geometry"),
                },
                {
                    text: txtTitleCase("default"),
                    icon: "far fa-square",
                    action: () => kiss.theme.set({geometry: "default"})
                },
                {
                    text: txtTitleCase("sharp"),
                    icon: "far fa-gem",
                    action: () => kiss.theme.set({geometry: "sharp"})
                },
                {
                    text: txtTitleCase("round"),
                    icon: "far fa-circle",
                    action: () => kiss.theme.set({geometry: "round"})
                }            
            ]
        }).render()
    },

    /**
     * Build the window to create a custom theme
     */
    createThemeBuilderWindow() {
        const cssVariables = [
            txtTitleCase("body"),
            "--body",
            "--body-alt",
            "--body-background",
            "--body-background-alt",
            "--link",
    
            txtTitleCase("panels"),
            "--panel-background",
            "--panel-header",
            "--panel-border",
            "--panel-box-shadow",
    
            txtTitleCase("fields"),
            "--field",
            "--field-label",
            "--field-background",
            "--field-background-hover",
            "--field-background-focus",
            "--field-border",
            "--field-border-hover",
    
            txtTitleCase("select fields"),
            "--select-option",
            "--select-option-background",
            "--select-option-background-selected",
            "--select-option-highlight",
            "--select-option-background-highlight",
            "--select-option-box-shadow",
            "--select-value-shadow",
    
            txtTitleCase("menus"),
            "--menu-background",
            "--menu-item-background-hover",
            "--menu-item-background-selected",
            "--menu-item",
            "--menu-item-hover",
            "--menu-item-selected",
            "--menu-border",
            "--menu-separator",
    
            txtTitleCase("buttons"),
            "--button-background",
            "--button-background-hover",
            "--button-border",
            "--button-border-hover",
            "--button-text",
            "--button-text-hover",
            "--button-icon",
            "--button-shadow",
            "--button-shadow-hover",
    
            txtTitleCase("data components"),
            "--datacomponent-toolbar-background",
            "--datacomponent-header-background",
            "--datacomponent-body-background",
            "--datacomponent-cell-background",
            "--datacomponent-cell-border",
            "--datacomponent-1st-column-background",
            "--datacomponent-group-background",
            "--datacomponent-alternate-border",
            "--datacomponent-row-hover",
            "--datacomponent-row-selected",
            "--datacomponent-header",
            "--datacomponent-1st-column",
            "--datacomponent-cell",
            "--datacomponent-group-text",
            "--datacomponent-input-background",
            "--datacomponent-interaction-hover",
            "--datacomponent-header-background-hover",
    
            txtTitleCase("shadows"),
            "--shadow-1",
            "--shadow-2",
            "--shadow-3",
            "--shadow-4"
        ]
    
        const items = cssVariables.map(variable => {
            if (variable.startsWith("--")) {
                let variableValue = getComputedStyle(document.documentElement).getPropertyValue(variable)
                variableValue = variableValue.trim()
    
                const isColor = (
                    variableValue.startsWith("#") ||
                    variableValue.indexOf("linear-gradient") != -1 ||
                    variableValue == "inherit" ||
                    variableValue == ""
                )
    
                // console.log(variable + " : " + variableValue + " > " + isColor)
    
                return {
                    id: variable,
                    type: (isColor) ? "color" : "text",
                    palette: "default",
                    label: variable,
                    labelPosition: "top",
                    // labelWidth: "50%",
                    // fieldWidth: "50%",
                    width: "100%",
                    value: variableValue,
                    events: {
                        change: function () {
                            const newColor = this.getValue()
                            document.documentElement.style.setProperty(variable, newColor)
                            $("theme-builder").save()
                        }
                    }
                }
            } else {
                return {
                    type: "html",
                    class: "theme-window-title",
                    html: variable,
                    margin: "2rem 0 1rem 0"
                }
            }
        })
    
        const buttonsBlock = {
            layout: "horizontal",
            backgroundColor: "var(--body-background-alt)",
            minHeight: "4rem",
            padding: "0.5rem",
            items: [
                // Download button
                {
                    type: "button",
                    tip: txtTitleCase("#download theme"),
                    icon: "fas fa-download",
                    width: "3.2rem",
                    margin: "0 0.5rem 0 0",
                    action: () => {
                        let theme = $("theme-builder").getData()
                        theme = JSON.stringify(theme, null, 4)
                        theme = theme.replace("{", ":root {")
                        theme = theme.replaceAll('"', "")
                        theme = theme.replaceAll(",\n", ";\n")
                        theme = theme.replace("\n}", ";\n}")
            
                        createDialog({
                            type: "input",
                            title: txtTitleCase("#theme name"),
                            message: txtTitleCase("#theme name help"),
                            autoClose: false,
                            action: (value) => {
                                if (!value) return false
    
                                theme = `/* ${value.toUpperCase()} THEME PARAMETERS */\n` + theme + `\n/* /${value.toUpperCase()} THEME PARAMETERS */\n`
    
                                kiss.tools.downloadFile({
                                    title: txtTitleCase("CSS theme"),
                                    content: theme,
                                    filename: value + ".css"
                                })
                                return true  
                            }
                        })
                    }
                },
                // Load theme button
                {
                    type: "html",
                    tip: txtTitleCase("#load theme"),
                    class: "a-button",
                    display: "flex",
                    justifyContent: "center",
                    width: "3.2rem",
                    html: `
                        <label for="themeFileInput"><i class="fas fa-file button-icon" style="cursor: pointer"></i></label>
                        <input type="file" id="themeFileInput" accept=".css" style="display: none"/>
                    `,
                    methods: {
                        load() {
                            document.getElementById("themeFileInput").addEventListener("change", function(event) {
                                const file = event.target.files[0]
                                if (file) {
                                    const reader = new FileReader()
                                    reader.onload = function(e) {
                                        const content = e.target.result
                                        let  theme = content.split("{")[1].split("}")[0]
                                        theme = theme.replaceAll(";", "")
    
                                        const themeObj = {}
                                        theme.split("\n").forEach((line, index) => {
                                            if (line && line.length > 1) {
                                                const [variable, value] = line.split(":")
                                                themeObj[variable.trim()] = value.trim()
                                            }
                                        })
                                        
                                        Object.keys(themeObj).forEach(variable => {
                                            const color = themeObj[variable]
                                            document.documentElement.style.setProperty(variable, color)
                                            const setupField = $(variable)
                                            if (setupField) setupField.setValue(color)
                                        })
    
                                        $("theme-builder").save()
                                    }
                                    reader.readAsText(file)
                                }
                            })
                        }
                    }
                }
            ]
        }
    
        return createPanel({
            id: "theme-builder",
            title: txtTitleCase("theme builder"),
            icon: "fas fa-sliders-h",
            draggable: true,
            closable: true,
            width: "30rem",
            left: () => "calc(100% - 31rem)",
            maxHeight: () => "calc(100% - 2rem)",
            align: "center",
            verticalAlign: "center",
            layout: "vertical",
            padding: 0,
            zIndex: 10000,
    
            animation: {
                name: "slideInRight",
                speed: "faster"
            },
    
            items: [
                buttonsBlock,
                {
                    layout: "vertical",
                    overflowY: "auto",
                    padding: "1rem",
                    items
                }
            ],
    
            methods: {
                save() {
                    const theme = this.getData()
                    localStorage.setItem("config-theme", JSON.stringify(theme))
                }
            }
        }).render()
    }    
}

;/**
 * 
 * ## Misc tools & helpers
 * 
 * @namespace
 * 
 */
kiss.tools = {
    /**
     * Returns a DOM node from a simple and basic *id* selector.
     * Just work with ids because everything *useful* should be uniquely identified to get things simpler.
     * 
     * @param {string} id - id of the target node
     * @param {HTMLElement} parentNode - Root node to start lookup from
     * @returns {HTMLElement} The element found, or null
     */
    $(id, parentNode) {
        if (parentNode) {
            return parentNode.querySelector("#" + id)
        } else {
            return document.getElementById(id)
        }
    },

    /**
     * As per RFC4122 DRAFT for UUID v7, the UUID bits layout:
     *
     * ```
     *     0                   1                   2                   3
     *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     *    |                           unix_ts_ms                          |
     *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     *    |          unix_ts_ms           |  ver  |       rand_a          |
     *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     *    |var|                        rand_b                             |
     *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     *    |                            rand_b                             |
     *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     * ```
     * 
     * @see https://datatracker.ietf.org/doc/html/draft-peabody-dispatch-new-uuid-format#section-5.2
     * @returns {string} The GUID xxxxxxxx-xxxx-7xxx-xxxx-xxxxxxxxxxxx
     */
    uid() {
        const UUID_UNIX_TS_MS_BITS = 48
        const UUID_VAR = 0b10
        const UUID_VAR_BITS = 2
        const UUID_RAND_B_BITS = 62

        if (!kiss.tools.prevTimestamp) kiss.tools.prevTimestamp = -1

        // Negative system clock adjustments are ignored to keep monotonicity
        const timestamp = Math.max(Date.now(), kiss.tools.prevTimestamp)

        // We need two random bytes for rand_a
        const randA = crypto.getRandomValues(new Uint8Array(2))

        // Adding the version (aka ver) to the first byte.
        randA[0] = (randA[0] & 0x0f) | 0x70

        // Prepare our 2x 32 bytes for rand_b
        const randB = crypto.getRandomValues(new Uint32Array(2))

        // Positioning the UUID variant (aka var) into the first 32 bytes random number
        randB[0] = (UUID_VAR << (32 - UUID_VAR_BITS)) | (randB[0] >>> UUID_VAR_BITS)

        const rawV7 =

            // unix_ts_ms
            // We want a 48 bits timestamp in 6 bytes for the first 12 UUID characters.
            timestamp.toString(16).padStart(UUID_UNIX_TS_MS_BITS / 4, "0") +
            // ver + rand_a
            // The version + first part of rand_a
            randA[0].toString(16) +
            // rand_a
            // Second part of rand_a
            randA[1].toString(16).padStart(2, "0") +
            // var + rand_b
            //First part of rand_b including the UUID variant on 2 bits
            randB[0].toString(16).padStart((UUID_VAR_BITS + UUID_RAND_B_BITS) / 8, "0") +
            // rand_b
            // Last part of rand_b
            randB[1].toString(16).padStart((UUID_VAR_BITS + UUID_RAND_B_BITS) / 8, "0")

        // Formatting
        return (
            rawV7.slice(0, 8) +
            "-" +
            rawV7.slice(8, 12) +
            "-" +
            rawV7.slice(12, 16) +
            "-" +
            rawV7.slice(16, 20) +
            "-" +
            rawV7.slice(20)
        )
    },

    /**
     * Get an URL parameter
     * 
     * @param {string} name 
     * @param {string} url 
     * @returns {string}
     */
    getUrlParameter(name, url = window.location.href) {
        name = name.replace(/[\[\]]/g, "\\$&")
        const regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)")
        const results = regex.exec(url)
        if (!results) return null
        if (!results[2]) return ""
        return decodeURIComponent(results[2].replace(/\+/g, " "))
    },

    /**
     * Copy a text to the clipboard
     * 
     * @param {string} text 
     */
    async copyTextToClipboard(text) {
        await navigator.clipboard.writeText(text)
    },

    /**
     * Given a file, return the required thumbnail.
     * If thumbCode is not found, returns the original file
     * 
     * @param {Object} file
     * @param {string|null} thumbCode
     * @return {Object}
     */
    getThumbnail(file, thumbCode = null) {
        if (thumbCode && file.thumbnails && thumbCode in file.thumbnails) {
            return file.thumbnails[thumbCode]
        }
        return file
    },

    /**
     * Return the URL to access a file object on Amazon S3.
     * The file can be either public or private.
     * 
     * @param {Object} file
     * @param {string|null} [thumb=null]
     * @return {string}
     */
    createFileURL(file, thumb = null) {
        let {
            path,
            size
        } = thumb ? kiss.tools.getThumbnail(file, thumb) : file

        path = path.replaceAll("\\", "/")

        if (
            Array.isArray(file.accessReaders) &&
            file.accessReaders.includes("$authenticated") &&
            !file.accessReaders.includes("*")
        ) {
            // The file is private
            return `/file?path=${encodeURIComponent(path)}&mimeType=${encodeURIComponent(file.mimeType)}&size=${size}`
        } else {
            // The file is public
            return (path.match(/^uploads\//) || path.match(/^file\//)) ? `/${path}` : path
        }
    },

    /**
     * Given some text content, generates a download window for this content
     * 
     * @param {string} config.content 
     * @param {string} [config.mimeType] - Defaults to "application/json"
     * @param {string} [config.title] - Defaults to "Download"
     * @param {string} [config.filename] - Defaults to "file.json"
     */
    downloadFile(config) {
        const blob = new Blob([config.content], {
            type: config.mimeType || "application/json"
        })
        const url = URL.createObjectURL(blob)
        const message =
            /*html*/
            `<center>
                        ${txtTitleCase("#click to download")}
                        <a href="${url}" download="${config.filename || "file.json"}">
                            ${txtTitleCase("download file")}
                        </a>
                    </center>`

        createDialog({
            type: "message",
            title: config.title || "Download file",
            message,
            buttonOKText: txtTitleCase("validate"),
            noOK: true
        })
    },

    /**
     * Async function that waits for an Element to be rendered in the DOM
     * 
     * @param {string} selector - The selector
     * @returns {HTMLElement} The found element
     * 
     * @example
     * kiss.tools.waitForElement("#my-element-id").then(() => doSomething())
     */
    async waitForElement(selector) {
        function rafAsync() {
            return new Promise(resolve => {
                requestAnimationFrame(resolve)
            })
        }

        let retry = 0

        while ((document.querySelector(selector) === null) && (retry < 20)) {
            await rafAsync()
            retry++
        }
        return document.body.querySelector(selector)
    },

    /**
     * Check whether an event occurred inside an element
     * 
     * @param {Event} event - Event to check
     * @param {Node} element - Element to check
     * @param {number} delta - Tolerance in pixels
     */
    isEventInElement(event, element, delta = 0) {
        const rect = element.getBoundingClientRect()

        const x = event.clientX
        if (x < (rect.left - delta) || x >= (rect.right + delta)) return false

        const y = event.clientY
        if (y < (rect.top - delta) || y >= (rect.bottom + delta)) return false

        return true
    },

    /**
     * Move an element inside the viewport
     * 
     * It's useful to recenter an element like a dropdown list or a menu when it's not completely visible inside the viewport
     * 
     * @param {HTMLElement} element - The element to move
     * @returns {HTMLElement} element
     */
    moveToViewport(element) {
        const horizontalDiff = kiss.screen.current.width - (element.offsetLeft + element.clientWidth)
        const verticalDiff = kiss.screen.current.height - (element.offsetTop + element.clientHeight)

        if (horizontalDiff < 0) element.style.left = Math.max(10, element.offsetLeft + horizontalDiff - 10) + "px"
        if (verticalDiff < 0) element.style.top = Math.max(10, element.offsetTop + verticalDiff - 10) + "px"

        return element
    },

    /**
     * Close all the panels and menus at once, except the login window
     * 
     * @param {string[]} [exceptions] - Don't close winddows which id is in the list of exceptions
     */
    closeAllWindows(exceptions = []) {
        Array.from(document.querySelectorAll(".a-panel"))
            .filter(panel => !exceptions.includes(panel.id))
            .forEach(panel => panel.close(true))
        document.querySelectorAll(".a-menu").forEach(panel => panel.close(true))
    },

    /**
     * Benchmark the creation of Fields
     * 
     * @param {integer} numberOfFields - The number of fields to insert in the DOM
     * @param {string} [fieldType] - The field type: "string" | "number" | "date" | "textarea"...
     * @param {string} [targetDomElementId] - The id of the node where the components must be inserted
     * @returns {integer} The number of milliseconds taken
     */
    benchmark(numberOfFields, fieldType, targetDomElementId) {
        kiss.tools.timer.start()

        // Build a dummy field config
        const setConfig = function (i) {
            return {
                id: "cmp-" + i,
                type: fieldType || "text",
                target: targetDomElementId || null,
                display: "inline-block",
                placeholder: "Enter a value... (" + i.toString() + ")",
                label: "Label nr " + i.toString() + " : ",
                labelPosition: "top",
                height: "3.2rem",
                width: "20rem",
                margin: "1rem",
                labelWidth: "20rem",
                events: {
                    onchange: function (event) {
                        publish("EVT_BENCH_UPDATE_FIELD", {
                            fieldId: this.id,
                            value: event.target.value
                        })
                    }
                },
                subscriptions: {
                    EVT_BENCH_UPDATE_FIELD: function (msgData) {
                        if (msgData.fieldId != ("cmp-" + i)) $("cmp-" + i).setValue(msgData.value)
                    }
                }
            }
        }

        for (let i = 0; i < numberOfFields; i++) {
            createField(setConfig(i)).render()
        }

        kiss.tools.timer.show("Components built!")
    },

    /**
     * Convert a flat array of objects into a tree structure
     * 
     * @param {object[]} list - The flat array to transform into a tree structure
     * @param {string} idAttr - Name of the id attribute
     * @param {string} parentAttr - Name of the parent attribute
     * @param {string} childrenAttr - Name of the children attribute
     * @returns {object} The tree structure
     * 
     * @example
     * flat input:  [ { id: "123", parent: "456" }, { id: "456", parent: "" } ]
     * tree output: [ { id: "456", parent: "", children: [ { id: "123", parent: "456" } ] } ]
     */
    treeify(list, idAttr = "id", parentAttr = "parent", childrenAttr = "children") {
        let treeList = []
        let lookup = {}

        list.forEach(function (obj) {
            lookup[obj[idAttr]] = obj
            obj[childrenAttr] = []
        })

        list.forEach(function (obj) {
            if ((obj[parentAttr] != null) && (obj[parentAttr] != "")) {
                lookup[obj[parentAttr]][childrenAttr].push(obj)
            } else {
                treeList.push(obj)
            }
        })
        return treeList
    },

    /**
     * Adjust the luminance of an RGB color and output a new RGB
     * 
     * @param {string} hex - Color in hexa RGB: #00aaee
     * @param {number} lum - luminance adjustment, from -1 to 1
     * @returns {string} - The output color in hexa RGB
     * 
     * @example
     * kiss.tools.adjustColor("#69c", 0)        // returns "#6699cc"
     * kiss.tools.adjustColor("6699CC", 0.2)    // "#7ab8f5" - 20% lighter
     * kiss.tools.adjustColor("69C", -0.5)      // "#334d66" - 50% darker
     * kiss.tools.adjustColor("000", 1)         // "#000000" - true black cannot be made lighter
     */
    adjustColor(hex, lum) {
        // Validate hex string
        hex = String(hex).replace(/[^0-9a-f]/gi, '')
        if (hex.length < 6) {
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2]
        }
        lum = lum || 0

        // Convert to decimal and change luminance
        let rgb = "#",
            c, i;

        for (let i = 0; i < 3; i++) {
            c = parseInt(hex.substring(i * 2, i * 2 + 2), 16)
            c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16)
            rgb += ("00" + c).substring(c.length)
        }

        return rgb
    },

    /**
     * Generate a CSS gradient (for backgrounds)
     * 
     * @param {string} hexColor - Color in hexa RGB: #00aaee
     * @param {number} angle - Gradient orientation in degrees (0-360)
     * @param {number} lum - luminance adjustment, from -1 to 1
     * @returns {string} - The CSS gradient
     * 
     * @example
     * kiss.tools.CSSGradient("#6699cc", 90, -0.5) // returns "linear-gradient(90deg, #6699cc 0%, #334d66 100%)"
     */
    CSSGradient(hexColor, angle = 90, lum = -0.2) {
        const secondaryColor = kiss.tools.adjustColor(hexColor, lum)
        return `linear-gradient(${angle}deg, ${hexColor} 0%, ${secondaryColor}  100%)`
    },

    /**
     * Get a random color from the global palette
     * 
     * @param {number} [fromColorIndex] - Restrict the palette from this color index
     * @param {number} [toColorIndex] - Restrict the palette up to this color index
     * @returns {string} A random color in hexa RGG. Ex: "#00aaee"
     */
    getRandomColor(fromColorIndex = 0, toColorIndex) {
        const randomIndex = fromColorIndex + Math.round(Math.random() * ((toColorIndex - fromColorIndex) || kiss.global.palette.length))
        return "#" + kiss.global.palette[randomIndex]
    },

    /**
     * Get the icon of a field or element type
     * 
     * @param {string} type 
     * @returns {string} icon font class
     * 
     * @example
     * kiss.tools.getIconByType("text") // => "fas fa-font"
     */
    getIconByType(type) {
        let item = kiss.global.fieldTypes.find(item => item.value === type)
        if (!item) item = kiss.global.elementTypes.find(item => item.value === type)
        if (item) return item.icon || ""
        return ""
    },

    /**
     * Return the icon and color of a file type
     * 
     * @param {string} fileType 
     * @returns {object} The icon and color for the file type
     * 
     * @example
     * kiss.tools.fileToIcon("xls") // => {icon: "fas fa-file-excel", color: "#09c60B"}
     */
    fileToIcon(fileType) {
        const associations = [
            // Images
            {
                extensions: ["jpg", "jpeg", "png", "gif", "webp", "psd"],
                icon: "fas fa-file",
                color: "#000000"
            },
            // Word-like
            {
                extensions: ["doc", "docx", "odt"],
                icon: "fas fa-file-word",
                color: "#00aaee"
            },
            // Excel-like
            {
                extensions: ["csv", "xls", "xlsx", "ods"],
                icon: "fas fa-file-excel",
                color: "#09c60B"
            },
            // Powerpoint-like
            {
                extensions: ["ppt", "pptx", "odp"],
                icon: "fas fa-file-powerpoint",
                color: "#ba6044"
            },
            // Acrobat
            {
                extensions: ["pdf"],
                icon: "fas fa-file-pdf",
                color: "#dd0000"
            },
            // Web code
            {
                extensions: ["html", "css", "js", "jsx"],
                icon: "fas fa-file-code",
                color: "#5fabbb"
            }
        ]

        for (let association of associations) {
            if (association.extensions.indexOf(fileType) != -1) return {
                icon: association.icon,
                color: association.color
            }
        }

        // Default
        return {
            icon: "fas fa-file-alt",
            color: "#556677"
        }
    },

    /**
     * Return the same object with only the properties which type is:
     * - string
     * - number
     * - boolean
     * - Array
     * 
     * @param {object} object - Object to convert
     * @returns {object} The converted object
     */
    snapshot(object) {
        let snapshot = {}
        Object.keys(object).forEach(key => {
            const type = typeof object[key]
            const safeKey = (key.startsWith("$")) ? key.substring(1) : key
            if (type == "string" || type == "number" || type == "boolean" || Array.isArray(object[key])) snapshot[safeKey] = object[key]
        })
        return snapshot
    },

    /**
     * 
     * A simple benchmarking tool.
     * 
     * @property {Date} timer.time - The current status in milliseconds
     * @method {function} timer.start - Init the timer
     * @method {function} timer.show - Show the timer status
     * 
     * @example
     * kiss.tools.timer.start()
     * kiss.tools.timer.show("Component rendered!")
     * 
     */
    timer: {
        time: new Date(),
        current: 0,

        /**
         * Start the timer
         * @param {string} msg - The message to display at initialization
         */
        start(msg) {
            kiss.tools.timer.time = performance.now()
            if (msg) console.log(msg)
        },

        /**
         * Show the timer status
         * @param {string} msg - The message to display when reporting
         */
        show(msg) {
            // setTimeout puts the code at the end of the browser's event queue, which ensures that DOM is fully rendered
            setTimeout(function () {
                kiss.tools.timer.current = performance.now() - kiss.tools.timer.time
                //log((kiss.tools.timer.current).toString() + "ms" + ((!msg) ? "" : (" - " + msg)), 1)
                console.log(`${msg || ""} - ${kiss.tools.timer.current + " ms"}`)
            }, 0)
        }
    },

    /**
     * Get an approximate geolocation from the IP address
     * 
     * @async
     * @returns {object} Geolocation: {latitude: X, longitude: Y}
     */
    async getGeolocationFromIP() {
        const response = await fetch('https://ipapi.co/json/')
        if (!response.ok) {
            throw new Error("Impossible to get the geolocation from the IP address")
        }
        const data = await response.json()
        return {
            latitude: data.latitude,
            longitude: data.longitude
        };
    },

    /**
     * Get the geolocation from an address
     * 
     * @async
     * @param {string} address 
     * @returns {object|boolean} - Geolocation object like {lat: ..., lon: ...}, or false if not found
     */
    async getGeolocationFromAddress(address) {
        const url = `https://nominatim.openstreetmap.org/search?q=${address}&format=json`
        const response = await fetch(url)
        const data = await response.json()
        return (data[0]) ? { latitude: data[0].lat, longitude: data[0].lon } : false
    },    

    /**
     * Get the current geolocation.
     * Try with the native browser geolocation, and if not available, use an external service
     * to get an approximate location from the IP address.
     * 
     * @async
     * @returns {object} Geolocation: {latitude: X, longitude: Y}
     */
    async getGeolocation() {
        return new Promise(async (resolve, reject) => {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    position => {
                        const latitude = position.coords.latitude
                        const longitude = position.coords.longitude
                        resolve({
                            latitude,
                            longitude
                        })
                    },
                    error => {
                        kiss.tools.getGeolocationFromIP()
                            .then(geolocation => {
                                resolve(geolocation)
                            })
                            .catch(error => {
                                reject(error)
                            })
                    }
                )
            } else {
                kiss.tools.getGeolocationFromIP()
                    .then(geolocation => {
                        resolve(geolocation)
                    })
                    .catch(error => {
                        reject(error)
                    })
            }
        })
    },

    /**
     * Check if a string represents a valid geolocation (latitude, longitude).
     * 
     * @param {string} input - The string to check.
     * @returns {object|boolean} - Returns an object with the latitude and longitude if the string represents a valid geolocation, otherwise false.
     */
    isGeolocation(input) {
        input = input.trim()

        const parts = input.split(',')

        if (parts.length !== 2) {
            return false
        }

        const latitude = parseFloat(parts[0])
        const longitude = parseFloat(parts[1])

        if (isNaN(latitude) || isNaN(longitude)) {
            return false
        }

        if (latitude < -90 || latitude > 90) {
            return false
        }

        if (longitude < -180 || longitude > 180) {
            return false
        }

        return {
            latitude,
            longitude
        }
    },

    /**
     * Check if the page is visited by a mobile device
     * 
     * @returns {boolean}
     */
    isMobile() {
        const agent = navigator.userAgent
        const mobiles = ["Android", "iPhone", "Windows Phone", "iPod"]

        for (let mobile of mobiles) {
            if (agent.indexOf(mobile) !== -1) {
                return true
            }
        }
        return false
    },

    /**
     * Convert a number of pixels to rem
     * 
     * @param {number} number - The number of pixels
     * @returns {number} The number in rem
     */
    remToPx(number) {
        const oneRemInPixels = parseFloat(getComputedStyle(document.documentElement).fontSize)
        return number * oneRemInPixels
    },

    /**
     * Convert a number of rem to pixels
     * 
     * @param {number} number - The number of rem
     * @returns {number} The number in pixels
     */
    pxToRem(number) {
        const oneRemInPixels = parseFloat(getComputedStyle(document.documentElement).fontSize)
        return number / oneRemInPixels
    },

    /**
     * Outline all DOM elements in the page, mainly to debug the layout
     * 
     * @param {boolean} state - true to display, false to hide
     */
    outlineDOM(state) {
        [].forEach.call($$("*"), function (a) {
            a.style.outline = `${(state) ? "1" : "0"}px solid #` + (~~(Math.random() * (1 << 24))).toString(16)
        })
    },

    /**
     * Highlight an element buy building an overlay around it and a legend under it.
     * 
     * @param {object} config
     * @param {string} config.element - HTMLElement to highlight
     * @param {string} config.text - The legend
     * @param {string} config.position - The position of the legend: "bottom" | "left"
     */
    highlight({element, text, position}) {
        const elementRect = element.getBoundingClientRect()
        const overlay = document.createElement("div")
        overlay.style.position = "fixed"
        overlay.style.top = 0
        overlay.style.left = 0
        overlay.style.width = "100vw"
        overlay.style.height = "100vh"
        overlay.style.zIndex = 9999

        const rects = [{
                top: 0,
                left: 0,
                width: "100vw",
                height: elementRect.top + "px"
            },
            {
                top: elementRect.top + "px",
                left: 0,
                width: elementRect.left + "px",
                height: elementRect.height + "px"
            },
            {
                top: elementRect.top + "px",
                left: elementRect.right + "px",
                width: "calc(100vw - " + elementRect.right + "px)",
                height: elementRect.height + "px"
            },
            {
                top: elementRect.bottom + "px",
                left: 0,
                width: "100vw",
                height: "calc(100vh - " + elementRect.bottom + "px)"
            }
        ]

        position = position || "bottom"
        rects.forEach((rect, index) => {
            const div = document.createElement("div")
            div.style.top = rect.top
            div.style.left = rect.left
            div.style.width = rect.width
            div.style.height = rect.height
            div.classList.add("highlight-overlay")

            if (index === 3) {
                const arrow = document.createElement("div")
                const label = document.createElement("div")

                arrow.classList.add("highlight-arrow")
                label.classList.add("highlight-label")

                switch(position) {
                    case "top":
                        // Arrow
                        arrow.style.top = elementRect.top - kiss.tools.remToPx(3.5) + "px"
                        arrow.style.left = elementRect.left + elementRect.width / 2 - 15 + "px"
                        arrow.style.animation = "highlight-arrow-vertical 0.3s ease-in-out infinite alternate"
                        arrow.style.borderLeft = "1.5rem solid transparent"
                        arrow.style.borderRight = "1.5rem solid transparent"
                        arrow.style.borderTop = "1.5rem solid #ffffff"
                        div.appendChild(arrow)
                        
                        // Label
                        label.style.left = elementRect.left + elementRect.width / 2 - kiss.tools.remToPx(15) + "px"
                        label.innerHTML = text
                        div.appendChild(label)

                        setTimeout(() => {
                            label.style.top = elementRect.top - kiss.tools.remToPx(5) - label.getBoundingClientRect().height + "px"
                        }, 0)
                        break

                    case "bottom":
                        // Arrow
                        arrow.style.top = elementRect.top + elementRect.height + kiss.tools.remToPx(2) + "px"
                        arrow.style.left = elementRect.left + elementRect.width / 2 - 15 + "px"
                        arrow.style.animation = "highlight-arrow-vertical 0.3s ease-in-out infinite alternate"
                        arrow.style.borderLeft = "1.5rem solid transparent"
                        arrow.style.borderRight = "1.5rem solid transparent"
                        arrow.style.borderBottom = "1.5rem solid #ffffff"
                        div.appendChild(arrow)
                        
                        // Label
                        label.style.top = elementRect.top + elementRect.height + kiss.tools.remToPx(5) + "px"
                        label.style.left = elementRect.left + elementRect.width / 2 - kiss.tools.remToPx(15) + "px"
                        label.innerHTML = text
                        div.appendChild(label)
                        break

                    case "left": 
                        // Arrow
                        arrow.style.top = elementRect.top + "px"
                        arrow.style.left = elementRect.left - kiss.tools.remToPx(3) + "px"
                        arrow.style.animation = `highlight-arrow-horizontal 0.3s ease-in-out infinite alternate`
                        arrow.style.borderTop = "1.5rem solid transparent"
                        arrow.style.borderBottom = "1.5rem solid transparent"
                        arrow.style.borderLeft = "1.5rem solid #ffffff"
                        div.appendChild(arrow)

                        // Label
                        label.style.top = elementRect.top + "px"
                        label.innerHTML = text
                        div.appendChild(label)

                        setTimeout(() => {
                            label.style.left = elementRect.left - kiss.tools.remToPx(5) - label.getBoundingClientRect().width + "px"
                        }, 0)
                        break

                    case "right":
                        // Arrow
                        arrow.style.top = elementRect.top + "px"
                        arrow.style.left = elementRect.left + elementRect.width + kiss.tools.remToPx(1.5) + "px"
                        arrow.style.animation = `highlight-arrow-horizontal 0.3s ease-in-out infinite alternate`
                        arrow.style.borderTop = "1.5rem solid transparent"
                        arrow.style.borderBottom = "1.5rem solid transparent"
                        arrow.style.borderRight = "1.5rem solid #ffffff"
                        div.appendChild(arrow)

                        // Label
                        label.style.top = elementRect.top + "px"
                        label.innerHTML = text
                        div.appendChild(label)

                        setTimeout(() => {
                            label.style.left = elementRect.left + elementRect.width + kiss.tools.remToPx(5) + "px"
                        }, 0)
                        break
                }
            }
            overlay.appendChild(div)
        })

        document.body.appendChild(overlay)

        const subscriptionId = kiss.pubsub.subscribe("EVT_CONTAINERS_RESIZED", () => {
            overlay.remove()
            kiss.pubsub.unsubscribe(subscriptionId)
        })

        overlay.onclick = () => {
            overlay.remove()
            kiss.pubsub.unsubscribe(subscriptionId)
            kiss.pubsub.publish("EVT_NEXT_TIP")
        }
    },

    /**
     * Highlight a sequence of elements.
     * Useful to create a quick tutorial.
     * 
     * @param {object[]} elements - Array of elements to highlight sequentially, and corresponding legend
     * @param {function} callback - Function executed when the list of elements to highlight is done
     * 
     * @example
     * kiss.tools.highlightElements([
     *  {
     *      element: document.querySelector("#A"),
     *      text: "Help for element A",
     *      position: "bottom"
     *  },
     *  {
     *      element: document.querySelector("#B"),
     *      text: "Help for element B",
     *      position: "left"
     *  }
     * ])
     */
    highlightElements(elements, callback) {
        const tip = elements.shift()
        kiss.tools.highlight({
            element: tip.element,
            text: tip.text.replaceAll("\n", "<br>"),
            position: tip.position
        })

        const subscriptionId = kiss.pubsub.subscribe("EVT_NEXT_TIP", () => {
            if (elements.length == 0) {
                kiss.pubsub.unsubscribe(subscriptionId)
                if (callback) callback()
            } else {
                const tip = elements.shift()
                kiss.tools.highlight({
                    element: tip.element,
                    text: tip.text,
                    position: tip.position
                })
            }
        })
    },

    /**
     * Animate an element with a sequence of animations
     * 
     * @param {string} id - The id of the element to animate
     * @param {string} animation - The animation name to apply (check Component available animations)
     * @param {number} delay - The delay between each animation, in milliseconds
     * @returns {number} The interval id
     */
    animateElement(id, animation, delay) {
        return setInterval(() => {
            const element = $(id)
            if (!element) return
            element.setAnimation(animation)
        }, delay)
    },

    /**
     * Message display when a KissJS feature is not available in the current context
     * 
     * @private
     * @ignore
     * @param {string} title 
     * @param {string} message 
     */
    featureNotAvailable(title, message) {
        if (!title) title = (kiss.global.mode == "demo") ? "demo" : "offline"
        if (!message) message = (kiss.global.mode == "demo") ? "#not available in demo" : "#not available offline"

        createDialog({
            title: txtTitleCase(title),
            message: txtTitleCase(message),
            icon: "fas fa-exclamation-triangle",
            noCancel: true
        })
    },

    /**
     * Show the list of formulae available for computed fields, inside a selectable textarea.
     * This tool is a helper used to build the Markdown documentation that feeds our AI assistant.
     */
    showFormulae() {
        const formulae = Object.keys(kiss.formula).filter(formula => formula.includes("HELP")).map(key => kiss.formula[key]).join("\n\n")
        createPanel({
            modal: true,
            closable: true,
            width: () => kiss.screen.current.width - 20,
            height: () => kiss.screen.current.height - 20,
            align: "center",
            verticalAlign: "center",
            layout: "vertical",
            items: [{
                id: "formulae",
                type: "textarea",
                width: "100%",
                fieldWidth: "100%",
                height: "100%",
                value: formulae
            }, {
                type: "button",
                text: "Copy to clipboard",
                action: () => {
                    kiss.tools.copyTextToClipboard($("formulae").getValue())
                    createNotification("Copied to clipboard")
                }
            }]
        }).render()
    },

    printDiv(id) {
        const content = $(id)
        const printWindow = window.open("", "_blank", "width=800,height=600")

        printWindow.document.open()
        printWindow.document.write(`
          <!DOCTYPE html>
          <html>
          <head>
            <title>Print Dashboard</title>
            <style>
              @media print {
                body {
                  margin: 0;
                  padding: 0;
                }
                canvas {
                  max-width: 100%;
                  height: auto;
                }
              }
            </style>
          </head>
          <body>
            ${content.outerHTML}
          </body>
          </html>
        `)
        printWindow.document.close()

        printWindow.onload = () => {
            printWindow.print()
            printWindow.close()
        }
    }
      
}

// Shorthands
const {
    $,
    uid
} = kiss.tools

;/**
 * 
 * ## Undo / Redo operations
 * 
 * This module captures the Ctrl+Z (undo) and Ctrl+Y (redo) keys then execute the corresponding callback actions.
 * 
 * @namespace
 * 
 */
kiss.undoRedo = {
    /**
     * Log of all the operations
     * 
     * @type {object} log
     * @property {array} log.undo - List of all the undo operations
     * @property {array} log.redo - List of all the redo operations
     * 
     * @example
     * kiss.undoRedo.addOperation({
     *  action: "updateField",
     *  createdAt: new Date(),
     *  modelId: "contact",
     *  recordId: "01927830-96f4-7167-8aad-1608c82cc415",
     *  fieldId: "fullname",
     *  oldValue: "John Doe",
     *  newValue: "John Doe Jr."
     * })
     * 
     * // List of all the undo operations
     * console.log(kiss.undoRedo.undo.log)
     * 
     * // Undo the last operation, add it to the redo log
     * kiss.undoRedo.undo() 
     * 
     * console.log(kiss.undoRedo.undo.log) // List of all the undo operations
     * console.log(kiss.undoRedo.redo.log) // List of all the redo operations
     */
    log: {
        undo: [],
        redo: []
    },

    /**
     * Init the undo/redo module and specify the callbacks to execute when pressing Ctrl+Z or Ctrl+Y
     * 
     * @param {object} config
     * @param {function} config.undo - Function to call to undo (Ctrl+Z). Can be async.
     * @param {function} config.redo - Function to call to redo (Ctrl+Y). Can be async.
     * 
     * @example
     * kiss.undoRedo.init({
     *  async undo() {
     *     // Undo code here
     *  },
     *  async redo() {
     *   // Redo code here
     *  }
     * })
     * 
     * kiss.undoRedo.undo() // Undo the last operation
     */
    init(config = {}) {

        if (config.undo) kiss.undoRedo.undo = config.undo
        if (config.redo) kiss.undoRedo.redo = config.redo

        const currentOperations = kiss.undoRedo.getOperations()
        if (currentOperations.length > 0) {
            kiss.undoRedo.log.undo = currentOperations
        }

        document.addEventListener("keydown", async function (e) {
            e.preventDefault

            if (e.keyCode === 89 && e.ctrlKey) {

                if (!kiss.undoRedo.log.redo.length > 0) {
                    createNotification(txtTitleCase("nothing to redo"))
                    return
                }

                if (!kiss.undoRedo.redo) return
                await kiss.undoRedo.redo()

            } else if (e.keyCode === 90 && e.ctrlKey) {

                if (!kiss.undoRedo.log.undo.length > 0) {
                    createNotification(txtTitleCase("nothing to undo"))
                    return
                }

                if (!kiss.undoRedo.undo) return
                await kiss.undoRedo.undo()
            }
        })
    },

    /**
     * Add an operation to the undo log
     * 
     * @param {object} operation - Operation to add to the undo log
     */
    addOperation(operation) {
        kiss.undoRedo.log.undo.push(operation)

        try {
            localStorage.setItem("session-undoRedo", JSON.stringify(kiss.undoRedo.log.undo))
        }
        catch(err) {
            // Overflow of the local storage
        }
    },

    /**
     * Get the operations from the undo log
     * 
     * @param {string} order - Order of the operations. Use "asc" (default) or "desc"
     * @returns {object[]} List of operations, in the specified order
     */
    getOperations(order = "asc") {
        const operationsAsString = localStorage.getItem("session-undoRedo")
        if (!operationsAsString) return []
        const operations = JSON.parse(operationsAsString)
        if (order === "asc") return operations
        return operations.reverse()
    },

    /**
     * Undo an operation
     */
    undoOperation(operation) {
        const index = kiss.undoRedo.log.undo.findIndex(update => update.id === operation.id)
        if (index !== -1) {
            kiss.undoRedo.log.undo.splice(index, 1)
            kiss.undoRedo.log.redo.push(operation)

            try {
                localStorage.setItem("session-undoRedo", JSON.stringify(kiss.undoRedo.log.undo))
            }
            catch(err) {
                // Overflow of the local storage
            }
        }
    },

    /**
     * Redo an operation
     */
    redoOperation(operation) {
        const index = kiss.undoRedo.log.redo.findIndex(update => update.id === operation.id)
        if (index !== -1) {
            kiss.undoRedo.log.redo.splice(index, 1)
            kiss.undoRedo.log.undo.push(operation)
            
            try {
                localStorage.setItem("session-undoRedo", JSON.stringify(kiss.undoRedo.log.undo))
            }
            catch(err) {
                // Overflow of the local storage
            }
        }   
    }
}

;/**
 * 
 * ## A simple view manager
 * 
 * @namespace
 * 
 */
kiss.views = {

    /**
     * Contains all the views that are already built
     */
    views: {},

    /**
     * Contains view renderers functions
     */
    viewRenderers: {},

    /**
     * Contains view controllers functions
     */
    viewControllers: {},

    /**
     * Contains view meta informations for SEO
     */
    viewMetas: {},

    /**
     * Contains nodes temporarily detached from the DOM
     */
    cachedNodes: {},

    /**
     * Add a view by storing its renderer function in the list of view renderers.
     * 
     * It does NOT store a view, but instead stores a view 'renderer' function that will generate the view later, and only when needed.
     * The renderer function receives 2 parameters:
     * - the view id
     * - the view target: insertion point in the DOM to insert the view
     * 
     * Note: using this method is equivalent to using kiss.app.defineView({
     *  id,
     *  renderer
     * })
     * 
     * When using KissJS for building a SEO-friendly website, you can use meta configuration to help search engine understand your content.
     * Meta information currently supported is:
     * - url
     * - locale
     * - site_name
     * - type: website | article | ...
     * - title
     * - description
     * - author
     * - image
     * - audio
     * - video
     * - other tags will generate a basic meta, like: &lt;meta name="..." content="..."&gt;
     * 
     * KissJS is dispatching information properly so you don't have to repeat yourself.
     * For example, if you enter a title, this will generate:
     * - a &lt;title&gt; tag
     * - an opengraph title
     * - a twitter title
     * 
     * If meta 'url' property has multiple languages set up, the first is canonical and other are alternate:
     * 
     * ```
     * meta: {
     *  url: {
     *      en: "https://pickaform.fr/en",
     *      fr: "https://pickaform.fr/fr"
     *  }
     * }
     * 
     * // Will generate this in the header:
     * <link rel="canonical" href="https://pickaform.fr/en">
     * <link rel="alternate" hreflang="fr" href="https://pickaform.fr/fr">
     * ```
     *
     * @param {object} config
     * @param {string} config.id - The id of the view to add
     * @param {function} config.renderer - The function that will build the view when needed
     * @param {object} config.meta - Meta informations injected in the HTML header. Can be localized or not. See example.
     * 
     * @example
     * kiss.views.addView({
     *  id: "myView",
     *  renderer: function (id, target) {
     *      let myView = ... // Must be an Html element or a KissJS component
     *      myView.id = id // The view must have the passed id
     *      myView.target = target // The view can optionaly have a target to be inserted at a specific point in the DOM
     *      return myView
     *  }
     * })
     * 
     * // Example of a view using meta informations
     * kiss.app.defineView({
     *  id: "myProductPage",
     *  meta: {
     *      title: "CRM", // Meta without localization
     *      // Meta with localization
     *      description: {
     *          en: "A useful CRM",
     *          fr: "Un CRM utile"
     *      }
     *  },
     *  renderer: function(id, target) {
     *      // ...
     *  }
     * })
     * 
     * // Example returning a KissJS panel
     * kiss.app.defineView({
     *  id: "myPanel",
     *  renderer: function (id, target) {
     *      return createPanel({
     *          id,
     *          target,
     *       
     *          title: "My panel",
     *          icon: "fas fa-check",
     *
     *          width: 300,
     *          height: 200,
     *          align: "center",
     *          verticalAlign: "center",
     *
     *          draggable: true,
     *          modal: true,
     *          closable: true,
     *          expandable: true,
     *
     *          layout: "vertical", // => The content will be "display: flex" and "flex-flow: column"
     *          items: [{
     *                  type: "html",
     *                  flex: 1, // Fill maximum space
     *                  html: `<h3>Title</h3>
     *                       <p>Hello world</p>
     *                       <br>`
     *              },
     *              {
     *                  type: "button",
     *                  text: "Say hello",
     *                  icon: "far fa-comment",
     *                  action: () => createNotification("Hello!")
     *              }
     *          ]
     *      })
     *  }
     * })
     * 
     * // Display the view
     * kiss.views.show("myPanel")
     * 
     * // Display the view using the router
     * kiss.router.navigateTo("myPanel")
     * 
     * // ...or
     * kiss.router.navigateTo({
     *  ui: "myPanel"
     * })
     */
    addView({
        id,
        renderer,
        meta
    }) {
        if (!id || !renderer) {
            log(`kiss.views - You're trying to define the view <${id}>, but it's not properly setup: a view needs an id and a renderer.`, 3)
            return
        }

        this.viewRenderers[id] = renderer
        if (meta) this.viewMetas[id] = meta
    },

    /**
     * Adds a view controller
     * 
     * @param {string} id - The view id which will receive the controller
     * @param {function} controller - The view controller
     */
    addViewController(id, controller) {
        this.viewControllers[id] = controller
    },

    /**
     * Build a view from its renderer function
     * 
     * @ignore
     * @param {string} id - The id of the view to build
     * @param {string} [target] - The DOM node where the view should be inserted
     * @returns {HTMLElement} The DOM node that represents the view
     */
    buildView(id, target) {
        // If the view is generated from a mobile and if a mobile version does exist => build the mobile version
        if (kiss.screen.isMobile && this.viewRenderers["mobile-" + id]) {
            id = "mobile-" + id
        }

        if (!this.views[id]) {
            try {
                log(`kiss.views - buildView - Building view ${id}`)

                const viewRenderer = this.viewRenderers[id]

                // Abort if the view id wasn't found
                if (!viewRenderer) {
                    log(`kiss.views - You're trying to build the view <${id}>, but it hasn't been defined.`, 3)
                    return null
                }

                const view = this.views[id] = viewRenderer(id, target)
                view.isView = true

                // Bind external controllers for views that are *not* KissJS components, but standard HTML Elements
                if (!view.isComponent) {
                    const viewControllers = kiss.views.viewControllers[id]

                    if (viewControllers)
                        for (let method in viewControllers)
                            view[method] = viewControllers[method]
                }

                // Inject meta tags if needed for SEO
                if (this.viewMetas[id]) this._insertMeta(id)

            } catch (err) {
                log(`kiss.views - buildView - The view ${id} couldn't be built`, 4, err)
            }
        }

        // Update view target in case it moved to another DOM insertion point
        if (target) this.views[id].target = target

        return this.views[id]
    },

    /**
     * Get a view from its id
     * 
     * @param {string} id - The id of the view
     * @returns {HTMLElement} The DOM node that represents the view
     */
    get(id) {
        return this.views[id]
    },

    /**
     * Remove a view *OR* any node from its id
     * - removes the view if it exists
     * - delete the node and its children
     * - unsubscribe the node and its children from PubSub to avoid memory leaks
     * 
     * @param {string} id - The id of the view
     */
    remove(id) {
        // Delete the view reference from the manager
        if (this.views[id]) delete this.views[id]

        // Delete the view node (and all its children)
        let node = $(id)
        if (node) node.deepDelete()
    },

    /**
     * Show a view at a specific point of the DOM
     * 
     * If no target has been specified, the view is inserted into the document body.
     * 
     * When calling this method, the view is either built, or retrieved from the cache if it already exists.
     * 
     * If a view is displayed inside a non-empty container, there are 2 scenarii:
     * - by default, the view is appended to the container's children
     * - if the view is "exclusive", it will replace all other children of the container (that will be pushed into the cache for future use)
     * 
     * @param {string} id - The id of the view
     * @param {string} [target] - The DOM node where the view should be inserted
     * @param {boolean} [exclusive] - Indicates if the view must be shown exclusively to other sibling views within its parent container
     * @returns {HTMLElement} The DOM node that represents the view
     * 
     * @example
     * // Example 1:
     * kiss.views.show("view 1", "containerId") // Displays view 1
     * kiss.views.show("view 2", "containerId") // Append view 2 to the container
     * 
     * // Example 2:
     * kiss.views.show("view 1", "containerId") // Displays view 1
     * kiss.views.show("view 2", "containerId", true) // Replace view 2 inside the container. View 2 is pushed into kiss.views.cachedNodes
     * 
     * // Example 3:
     * kiss.views.show("view 1", "containerId") // Displays view 1
     * kiss.views.replaceBy("view 2", "containerId") // Equivalent to previous example
     */
    show(id, target, exclusive) {
        const view = this.buildView(id)

        if (view && (!view.isConnected || view.hidden)) {
            // if (this.getCachedNode(id) != null) {
            //     log("kiss.views - The view **was** in cache: " + id)
            // } else {
            //     log("kiss.views - The view **was not** in cache: " + id)
            // }

            view.render(target)

            // If a view is exclusive within a container, we hide (and cache) all other views within that container.
            if (exclusive) {

                // Remove and cache views which are at the same level
                Object.keys(this.views).forEach(function (viewId) {
                    if (viewId == view.id) return

                    const otherView = kiss.views.views[viewId]
                    if (otherView.parentNode == view.parentNode && viewId != "topbar") kiss.views.removeAndCacheNode(viewId)
                })
            }

            // Cache view params for being able to rebuild it with the same params
            if (target != undefined) view.target = target
            view.exclusive = !!exclusive
        }

        if (view && view.hidden) view.show()

        // Inject meta tags if needed for SEO
        if (this.viewMetas[id]) this._insertMeta(id)

        return view
    },

    /**
     * If the view has some meta informations, it's injected / updated in the header.
     * 
     * @private
     * @ignore
     * @param {string} id
     */
    _insertMeta(id) {
        const meta = this.viewMetas[id]

        Object.keys(meta).forEach(name => {
            switch (name) {
                case "title":
                    document.title = this._getMetaData(meta, "title")
                    this._injectMetaTag("name", "twitter:title", meta, name)
                    this._injectMetaTag("property", "og:title", meta, name)
                    break

                case "description":
                    this._injectMetaTag("name", "description", meta, name)
                    this._injectMetaTag("name", "twitter:description", meta, name)
                    this._injectMetaTag("property", "og:description", meta, name)
                    break

                case "author":
                    this._injectMetaTag("name", "author", meta, name)
                    this._injectMetaTag("name", "twitter:creator", meta, name)
                    this._injectMetaTag("property", "og:article:author", meta, name)
                    break

                case "type":
                    this._injectMetaTag("property", "og:type", meta, name)
                    break

                case "site_name":
                    this._injectMetaTag("property", "og:site_name", meta, name)
                    break

                case "image":
                    this._injectMetaTag("name", "twitter:image", meta, name)
                    this._injectMetaTag("property", "og:image", meta, name)
                    break

                case "audio":
                    this._injectMetaTag("property", "og:audio", meta, name)
                    break

                case "video":
                    this._injectMetaTag("property", "og:video", meta, name)
                    break

                case "url":
                    this._injectMetaTag("name", "twitter:url", meta, name)
                    this._injectMetaTag("property", "og:url", meta, name)
                    this._injectLanguageLinks(meta)
                    break

                case "locale":
                    this._injectMetaTag("property", "og:locale", meta, name)
                    break

                default:
                    this._injectMetaTag("name", name, meta, name)
            }
        })
    },


    /**
     * Update language meta tags for SEO.
     * 
     * @private
     * @ignore
     * @param {object} meta 
     */
    _injectLanguageLinks(meta) {
        const url = meta.url

        if (typeof url == "string") {
            // Single language
            let language = kiss.language.current || "en"
            this._injectLinkRel("canonical", language, url)
        } else {
            // Multiple languages
            Object.keys(url).forEach((language, index) => {
                if (index == 0) {
                    this._injectLinkRel("canonical", language, url[language])
                } else {
                    this._injectLinkRel("alternate", language, url[language])
                }
            })
        }
    },

    /**
     * Insert or update a <link rel="canonical"> or <link rel="alternate" hreflang="..."> tag.
     * 
     * @private
     * @ignore
     * @param {string} type 
     * @param {string} language 
     * @param {string} url 
     */
    _injectLinkRel(type, language, url) {
        let linkTag

        if (type == "canonical") {
            linkTag = document.querySelector('link[rel="canonical"]')
        } else if (type == "alternate") {
            linkTag = document.querySelector('link[rel="alternate"][hreflang="' + language + '"')
        }

        if (linkTag) {
            linkTag.setAttribute("href", url)
        } else {
            linkTag = document.createElement("link")
            linkTag.setAttribute("rel", type)
            if (type == "alternate") linkTag.setAttribute("hreflang", language)
            linkTag.setAttribute("href", url)
            document.head.appendChild(linkTag)
        }
    },

    /**
     * Insert or replace a meta tag in the document header
     * 
     * @private
     * @ignore
     * @param {string} propertyType
     * @param {string} propertyName 
     * @param {object} meta
     * @param {string} name
     */
    _injectMetaTag(propertyType, propertyName, meta, name) {
        let metaTag = document.querySelector('meta[' + propertyType + '="' + propertyName + '"]')
        let value = this._getMetaData(meta, name)

        if (metaTag) {
            metaTag.setAttribute("content", value)
        } else {
            metaTag = document.createElement("meta")
            metaTag.setAttribute(propertyType, propertyName)
            metaTag.setAttribute("content", value)
            document.head.appendChild(metaTag)
        }
    },

    /**
     * Get a meta data which can be:
     * - a string, if there is no translation
     * - an object, if it's localized
     * 
     * @private
     * @ignore
     * @param {object} meta 
     * @param {string} name 
     * @returns {string|object} The meta value
     */
    _getMetaData(meta, name) {
        if (typeof meta[name] == "string") {
            return meta[name]
        } else {
            return meta[name][kiss.language.current]
        }
    },

    /**
     * Destroys a view and rebuild it
     * 
     * @param {string} viewId 
     */
    reset(viewId, target, exclusive) {
        const view = kiss.views.get(viewId)
        kiss.views.remove(viewId)
        kiss.views.show(viewId, view.target, view.exclusive)
    },

    /**
     * Show a view and replace other views in the same container.
     * 
     * All the replaced views are pushed into the cache (kiss.views.cachedNodes) for future use.
     * 
     * @param {string} id - The id of the view
     * @param {string} [target] - The DOM node where the view should be replaced
     * @returns {HTMLElement} The DOM node that represents the view
     * 
     * @example
     * kiss.views.show("view 1", "containerId") // Displays view 1
     * kiss.views.replaceBy("view 2", "containerId") // Replace view 2 inside the container. View 2 is pushed into kiss.views.cachedNodes
     */
    replaceBy(id, target) {
        return this.show(id, target, true)
    },

    /**
     * Remove a node from the DOM and keep it temporarily in cache for future use.
     * It stores an object that keeps track of the parent and the index within its sibling nodes, like this:
     * ```
     * {parentId: "abc", index: 4, node: theCachedNode}
     * ```
     * 
     * Tech note:
     * - Removed elements are kept in a cache to not be garbage collected, so they can be used later.
     * - Compared to display:none, removed elements are **not** triggering their events anymore.
     * - When you have a huge number of hidden elements, preventing them from participating in the events and pubsub mechanism gives a massive performance boost.
     * 
     * @param {string} id - The id of the node Element 
     * @returns {HTMLElement} The DOM node Element that was removed and cached
     */
    removeAndCacheNode(id) {
        log("kiss.views - Pushed node into cache: " + id)

        let node = $(id)

        this.cachedNodes[id] = {
            parentId: node.parentNode.id,
            index: Array.from(node.parentNode.children).indexOf(node),
            node: node.parentElement.removeChild(node)
        }
        return node
    },

    /**
     * Restore a node and inserts it at its previous position within its parent node
     * 
     * @param {string} id - The id of the node Element to restore
     * @returns {HTMLElement} The DOM node Element that was restore into the DOM
     */
    restoreCachedNode(id) {
        log("kiss.views - Restored node from cache: " + id)

        let cachedNode = this.cachedNodes[id]
        let parentNode = (cachedNode.parentId) ? $(cachedNode.parentId) : document.body
        parentNode.insertBefore(cachedNode.node, parentNode.children[cachedNode.index])
        return cachedNode.node
    },

    /**
     * Get a cached node
     * 
     * @returns {HTMLElement} The DOM node actually cached, or null if not found
     */
    getCachedNode(id) {
        let cachedNode = this.cachedNodes[id]
        if (cachedNode) {
            return cachedNode.node
        } else {
            return null
        }
    },

    /**
     * Deletes a node which is in cache to free memory
     * 
     * @param {string} id 
     */
    deleteCachedNode(id) {
        log("kiss.views - Deleted node from cache: " + id)

        delete this.cachedNodes[id]
    }
}

;/** 
 * 
 * List of FontAwesome icon names.
 * (used to build an icon picker)
 * 
 * @ignore
 */
kiss.webfonts = {
    /**
     * Check if an icon is valid
     *  
     * @param {string} icon
     * @returns {boolean}
     *  
     * @example
     * kiss.webfonts.check("fas fa-bell") // true
     * kiss.webfonts.check("fas fa-belll") // false
     */
    check: (icon) => {
        return kiss.webfonts.all.includes(icon)
    },

    /**
     * Get a valid icon name, by replacing an invalid icon name with a default one.
     * 
     * @param {string} icon
     * @returns {string}
     * 
     * @example
     * kiss.webfonts.get("fas fa-bell") // "fas fa-bell"
     * kiss.webfonts.get("fas fa-belll") // "fas fa-th"
     */
    get(icon) {
        if (!kiss.webfonts.check(icon)) {
            return "fas fa-th"
        }
        return icon
    },

    /**
     * List of all the icons
     */
    all: [
        "fab fa-buromobelexperte",
        "fas fa-burn",
        "fas fa-bullseye",
        "fas fa-bullhorn",
        "fas fa-building",
        "far fa-building",
        "fas fa-bug",
        "fab fa-btc",
        "fas fa-briefcase-medical",
        "fas fa-briefcase",
        "fas fa-braille",
        "fas fa-boxes",
        "fas fa-box-open",
        "fas fa-box",
        "fas fa-bowling-ball",
        "fas fa-bookmark",
        "far fa-bookmark",
        "fas fa-book",
        "fas fa-bomb",
        "fas fa-bolt",
        "fas fa-bold",
        "fab fa-bluetooth-b",
        "fab fa-bluetooth",
        "fab fa-blogger-b",
        "fab fa-blogger",
        "fas fa-blind",
        "fab fa-blackberry",
        "fab fa-black-tie",
        "fab fa-bity",
        "fab fa-bitcoin",
        "fab fa-bitbucket",
        "fas fa-birthday-cake",
        "fas fa-binoculars",
        "fab fa-bimobject",
        "fas fa-bicycle",
        "fas fa-bell-slash",
        "far fa-bell-slash",
        "fas fa-bell",
        "far fa-bell",
        "fab fa-behance-square",
        "fab fa-behance",
        "fas fa-beer",
        "fas fa-bed",
        "fas fa-battery-three-quarters",
        "fas fa-battery-quarter",
        "fas fa-battery-half",
        "fas fa-battery-full",
        "fas fa-battery-empty",
        "fas fa-bath",
        "fas fa-basketball-ball",
        "fas fa-baseball-ball",
        "fas fa-bars",
        "fas fa-barcode",
        "fab fa-bandcamp",
        "fas fa-band-aid",
        "fas fa-ban",
        "fas fa-balance-scale",
        "fas fa-backward",
        "fab fa-aws",
        "fab fa-aviato",
        "fab fa-avianex",
        "fab fa-autoprefixer",
        "fas fa-audio-description",
        "fab fa-audible",
        "fas fa-at",
        "fab fa-asymmetrik",
        "fas fa-asterisk",
        "fas fa-assistive-listening-systems",
        "fas fa-arrows-alt-v",
        "fas fa-arrows-alt-h",
        "fas fa-arrows-alt",
        "fas fa-arrow-up",
        "fas fa-arrow-right",
        "fas fa-arrow-left",
        "fas fa-arrow-down",
        "fas fa-arrow-circle-up",
        "fas fa-arrow-circle-right",
        "fas fa-arrow-circle-left",
        "fas fa-arrow-circle-down",
        "fas fa-arrow-alt-circle-up",
        "far fa-arrow-alt-circle-up",
        "fas fa-arrow-alt-circle-right",
        "far fa-arrow-alt-circle-right",
        "fas fa-arrow-alt-circle-left",
        "far fa-arrow-alt-circle-left",
        "fas fa-arrow-alt-circle-down",
        "far fa-arrow-alt-circle-down",
        "fas fa-archive",
        "fab fa-apple-pay",
        "fab fa-apple",
        "fab fa-apper",
        "fab fa-app-store-ios",
        "fab fa-app-store",
        "fab fa-angular",
        "fab fa-angrycreative",
        "fas fa-angle-up",
        "fas fa-angle-right",
        "fas fa-angle-left",
        "fas fa-angle-down",
        "fas fa-angle-double-up",
        "fas fa-angle-double-right",
        "fas fa-angle-double-left",
        "fas fa-angle-double-down",
        "fab fa-angellist",
        "fab fa-android",
        "fas fa-anchor",
        "fab fa-amilia",
        "fas fa-american-sign-language-interpreting",
        "fas fa-ambulance",
        "fab fa-amazon-pay",
        "fab fa-amazon",
        "fas fa-allergies",
        "fas fa-align-right",
        "fas fa-align-left",
        "fas fa-align-justify",
        "fas fa-align-center",
        "fab fa-algolia",
        "fab fa-affiliatetheme",
        "fab fa-adversal",
        "fab fa-adn",
        "fas fa-adjust",
        "fas fa-address-card",
        "far fa-address-card",
        "fas fa-address-book",
        "far fa-address-book",
        "fab fa-accusoft",
        "fab fa-accessible-icon",
        "fab fa-500px",
        "fab fa-youtube-square",
        "fab fa-youtube",
        "fab fa-yoast",
        "fas fa-yen-sign",
        "fab fa-yelp",
        "fab fa-yandex-international",
        "fab fa-yandex",
        "fab fa-yahoo",
        "fab fa-y-combinator",
        "fab fa-xing-square",
        "fab fa-xing",
        "fab fa-xbox",
        "fas fa-x-ray",
        "fas fa-wrench",
        "fab fa-wpforms",
        "fab fa-wpexplorer",
        "fab fa-wpbeginner",
        "fab fa-wordpress-simple",
        "fab fa-wordpress",
        "fas fa-won-sign",
        "fab fa-wolf-pack-battalion",
        "fas fa-wine-glass",
        "fab fa-windows",
        "fas fa-window-restore",
        "far fa-window-restore",
        "fas fa-window-minimize",
        "far fa-window-minimize",
        "fas fa-window-maximize",
        "far fa-window-maximize",
        "fas fa-window-close",
        "far fa-window-close",
        "fab fa-wikipedia-w",
        "fas fa-wifi",
        "fab fa-whmcs",
        "fas fa-wheelchair",
        "fab fa-whatsapp-square",
        "fab fa-whatsapp",
        "fab fa-weixin",
        "fas fa-weight",
        "fab fa-weibo",
        "fas fa-warehouse",
        "fab fa-vuejs",
        "fas fa-volume-up",
        "fas fa-volume-off",
        "fas fa-volume-down",
        "fas fa-volleyball-ball",
        "fab fa-vnv",
        "fab fa-vk",
        "fab fa-vine",
        "fab fa-vimeo-v",
        "fab fa-vimeo-square",
        "fab fa-vimeo",
        "fas fa-video-slash",
        "fas fa-video",
        "fab fa-viber",
        "fas fa-vials",
        "fas fa-vial",
        "fab fa-viadeo-square",
        "fab fa-viadeo",
        "fab fa-viacoin",
        "fas fa-venus-mars",
        "fas fa-venus-double",
        "fas fa-venus",
        "fab fa-vaadin",
        "fas fa-utensils",
        "fas fa-utensil-spoon",
        "fab fa-ussunnah",
        "fas fa-users-cog",
        "fas fa-users",
        "fas fa-user-times",
        "fas fa-user-tie",
        "fas fa-user-tag",
        "fas fa-user-slash",
        "fas fa-user-shield",
        "fas fa-user-secret",
        "fas fa-user-plus",
        "fas fa-user-ninja",
        "fas fa-user-minus",
        "fas fa-user-md",
        "fas fa-user-lock",
        "fas fa-user-graduate",
        "fas fa-user-friends",
        "fas fa-user-edit",
        "fas fa-user-cog",
        "fas fa-user-clock",
        "fas fa-user-circle",
        "far fa-user-circle",
        "fas fa-user-check",
        "fas fa-user-astronaut",
        "fas fa-user-alt-slash",
        "fas fa-user-alt",
        "fas fa-user",
        "far fa-user",
        "fab fa-usb",
        "fas fa-upload",
        "fab fa-untappd",
        "fas fa-unlock-alt",
        "fas fa-unlock",
        "fas fa-unlink",
        "fas fa-university",
        "fas fa-universal-access",
        "fab fa-uniregistry",
        "fas fa-undo-alt",
        "fas fa-undo",
        "fas fa-underline",
        "fas fa-umbrella",
        "fab fa-uikit",
        "fab fa-uber",
        "fab fa-typo3",
        "fab fa-twitter-square",
        "fab fa-twitter",
        "fab fa-twitch",
        "fas fa-tv",
        "fab fa-tumblr-square",
        "fab fa-tumblr",
        "fas fa-tty",
        "fas fa-truck-moving",
        "fas fa-truck-loading",
        "fas fa-truck",
        "fas fa-trophy",
        "fab fa-tripadvisor",
        "fab fa-trello",
        "fas fa-tree",
        "fas fa-trash-alt",
        "far fa-trash-alt",
        "fas fa-trash",
        "fas fa-transgender-alt",
        "fas fa-transgender",
        "fas fa-train",
        "fas fa-trademark",
        "fab fa-trade-federation",
        "fas fa-toggle-on",
        "fas fa-toggle-off",
        "fas fa-tint",
        "fas fa-times-circle",
        "far fa-times-circle",
        "fas fa-times",
        "fas fa-ticket-alt",
        "fas fa-thumbtack",
        "fas fa-thumbs-up",
        "far fa-thumbs-up",
        "fas fa-thumbs-down",
        "far fa-thumbs-down",
        "fas fa-thermometer-three-quarters",
        "fas fa-thermometer-quarter",
        "fas fa-thermometer-half",
        "fas fa-thermometer-full",
        "fas fa-thermometer-empty",
        "fas fa-thermometer",
        "fab fa-themeisle",
        "fas fa-th-list",
        "fas fa-th-large",
        "fas fa-th",
        "fas fa-text-width",
        "fas fa-text-height",
        "fas fa-terminal",
        "fab fa-tencent-weibo",
        "fab fa-telegram-plane",
        "fab fa-telegram",
        "fab fa-teamspeak",
        "fas fa-taxi",
        "fas fa-tasks",
        "fas fa-tape",
        "fas fa-tags",
        "fas fa-tag",
        "fas fa-tachometer-alt",
        "fas fa-tablets",
        "fas fa-tablet-alt",
        "fas fa-tablet",
        "fas fa-table-tennis",
        "fas fa-table",
        "fas fa-syringe",
        "fas fa-sync-alt",
        "fas fa-sync",
        "fab fa-supple",
        "fas fa-superscript",
        "fab fa-superpowers",
        "fas fa-sun",
        "far fa-sun",
        "fas fa-suitcase",
        "fas fa-subway",
        "fas fa-subscript",
        "fab fa-stumbleupon-circle",
        "fab fa-stumbleupon",
        "fab fa-studiovinari",
        "fab fa-stripe-s",
        "fab fa-stripe",
        "fas fa-strikethrough",
        "fas fa-street-view",
        "fab fa-strava",
        "fas fa-stopwatch",
        "fas fa-stop-circle",
        "far fa-stop-circle",
        "fas fa-stop",
        "fas fa-sticky-note",
        "far fa-sticky-note",
        "fab fa-sticker-mule",
        "fas fa-stethoscope",
        "fas fa-step-forward",
        "fas fa-step-backward",
        "fab fa-steam-symbol",
        "fab fa-steam-square",
        "fab fa-steam",
        "fab fa-staylinked",
        "fas fa-star-half",
        "far fa-star-half",
        "fas fa-star",
        "far fa-star",
        "fab fa-stack-overflow",
        "fab fa-stack-exchange",
        "fas fa-square-full",
        "fas fa-square",
        "far fa-square",
        "fab fa-spotify",
        "fas fa-spinner",
        "fab fa-speakap",
        "fas fa-space-shuttle",
        "fab fa-soundcloud",
        "fas fa-sort-up",
        "fas fa-sort-numeric-up",
        "fas fa-sort-numeric-down",
        "fas fa-sort-down",
        "fas fa-sort-amount-up",
        "fas fa-sort-amount-down",
        "fas fa-sort-alpha-up",
        "fas fa-sort-alpha-down",
        "fas fa-sort",
        "fas fa-snowflake",
        "far fa-snowflake",
        "fab fa-snapchat-square",
        "fab fa-snapchat-ghost",
        "fab fa-snapchat",
        "fas fa-smoking",
        "fas fa-smile",
        "far fa-smile",
        "fab fa-slideshare",
        "fas fa-sliders-h",
        "fab fa-slack-hash",
        "fab fa-slack",
        "fab fa-skype",
        "fab fa-skyatlas",
        "fab fa-sith",
        "fas fa-sitemap",
        "fab fa-sistrix",
        "fab fa-simplybuilt",
        "fas fa-signal",
        "fas fa-sign-out-alt",
        "fas fa-sign-language",
        "fas fa-sign-in-alt",
        "fas fa-sign",
        "fas fa-shower",
        "fas fa-shopping-cart",
        "fas fa-shopping-basket",
        "fas fa-shopping-bag",
        "fab fa-shirtsinbulk",
        "fas fa-shipping-fast",
        "fas fa-ship",
        "fas fa-shield-alt",
        "fas fa-shekel-sign",
        "fas fa-share-square",
        "far fa-share-square",
        "fas fa-share-alt-square",
        "fas fa-share-alt",
        "fas fa-share",
        "fab fa-servicestack",
        "fas fa-server",
        "fab fa-sellsy",
        "fab fa-sellcast",
        "fas fa-seedling",
        "fab fa-searchengin",
        "fas fa-search-plus",
        "fas fa-search-minus",
        "fas fa-search",
        "fab fa-scribd",
        "fab fa-schlix",
        "fas fa-save",
        "far fa-save",
        "fab fa-sass",
        "fab fa-safari",
        "fas fa-rupee-sign",
        "fas fa-ruble-sign",
        "fas fa-rss-square",
        "fas fa-rss",
        "fab fa-rockrms",
        "fab fa-rocketchat",
        "fas fa-rocket",
        "fas fa-road",
        "fas fa-ribbon",
        "fas fa-retweet",
        "fab fa-resolving",
        "fab fa-researchgate",
        "fab fa-replyd",
        "fas fa-reply-all",
        "fas fa-reply",
        "fab fa-renren",
        "fab fa-rendact",
        "fas fa-registered",
        "far fa-registered",
        "fas fa-redo-alt",
        "fas fa-redo",
        "fab fa-reddit-square",
        "fab fa-reddit-alien",
        "fab fa-reddit",
        "fab fa-red-river",
        "fas fa-recycle",
        "fab fa-rebel",
        "fab fa-readme",
        "fab fa-react",
        "fab fa-ravelry",
        "fas fa-random",
        "fab fa-r-project",
        "fas fa-quote-right",
        "fas fa-quote-left",
        "fab fa-quora",
        "fab fa-quinscape",
        "fas fa-quidditch",
        "fas fa-question-circle",
        "far fa-question-circle",
        "fas fa-question",
        "fas fa-qrcode",
        "fab fa-qq",
        "fab fa-python",
        "fas fa-puzzle-piece",
        "fab fa-pushed",
        "fab fa-product-hunt",
        "fas fa-procedures",
        "fas fa-print",
        "fas fa-prescription-bottle-alt",
        "fas fa-prescription-bottle",
        "fas fa-power-off",
        "fas fa-pound-sign",
        "fas fa-portrait",
        "fas fa-poo",
        "fas fa-podcast",
        "fas fa-plus-square",
        "far fa-plus-square",
        "fas fa-plus-circle",
        "fas fa-plus",
        "fas fa-plug",
        "fab fa-playstation",
        "fas fa-play-circle",
        "far fa-play-circle",
        "fas fa-play",
        "fas fa-plane",
        "fab fa-pinterest-square",
        "fab fa-pinterest-p",
        "fab fa-pinterest",
        "fas fa-pills",
        "fas fa-piggy-bank",
        "fab fa-pied-piper-pp",
        "fab fa-pied-piper-hat",
        "fab fa-pied-piper-alt",
        "fab fa-pied-piper",
        "fab fa-php",
        "fas fa-phone-volume",
        "fas fa-phone-square",
        "fas fa-phone-slash",
        "fas fa-phone",
        "fab fa-phoenix-squadron",
        "fab fa-phoenix-framework",
        "fab fa-phabricator",
        "fab fa-periscope",
        "fas fa-percent",
        "fas fa-people-carry",
        "fas fa-pencil-alt",
        "fas fa-pen-square",
        "fab fa-paypal",
        "fas fa-paw",
        "fas fa-pause-circle",
        "far fa-pause-circle",
        "fas fa-pause",
        "fab fa-patreon",
        "fas fa-paste",
        "fas fa-paragraph",
        "fas fa-parachute-box",
        "fas fa-paperclip",
        "fas fa-paper-plane",
        "far fa-paper-plane",
        "fas fa-palette",
        "fas fa-pallet",
        "fab fa-palfed",
        "fas fa-paint-brush",
        "fab fa-pagelines",
        "fab fa-page4",
        "fas fa-outdent",
        "fab fa-osi",
        "fab fa-optin-monster",
        "fab fa-opera",
        "fab fa-openid",
        "fab fa-opencart",
        "fab fa-old-republic",
        "fab fa-odnoklassniki-square",
        "fab fa-odnoklassniki",
        "fas fa-object-ungroup",
        "far fa-object-ungroup",
        "fas fa-object-group",
        "far fa-object-group",
        "fab fa-nutritionix",
        "fab fa-ns8",
        "fab fa-npm",
        "fas fa-notes-medical",
        "fab fa-node-js",
        "fab fa-node",
        "fab fa-nintendo-switch",
        "fas fa-newspaper",
        "far fa-newspaper",
        "fas fa-neuter",
        "fab fa-napster",
        "fas fa-music",
        "fas fa-mouse-pointer",
        "fas fa-motorcycle",
        "fas fa-moon",
        "far fa-moon",
        "fas fa-money-bill-alt",
        "far fa-money-bill-alt",
        "fab fa-monero",
        "fab fa-modx",
        "fas fa-mobile-alt",
        "fas fa-mobile",
        "fab fa-mizuni",
        "fab fa-mixcloud",
        "fab fa-mix",
        "fas fa-minus-square",
        "far fa-minus-square",
        "fas fa-minus-circle",
        "fas fa-minus",
        "fab fa-microsoft",
        "fas fa-microphone-slash",
        "fas fa-microphone",
        "fas fa-microchip",
        "fas fa-mercury",
        "fas fa-meh",
        "far fa-meh",
        "fab fa-meetup",
        "fab fa-medrt",
        "fas fa-medkit",
        "fab fa-medium-m",
        "fab fa-medium",
        "fab fa-medapps",
        "fab fa-maxcdn",
        "fab fa-mastodon",
        "fas fa-mars-stroke-v",
        "fas fa-mars-stroke-h",
        "fas fa-mars-stroke",
        "fas fa-mars-double",
        "fas fa-mars",
        "fas fa-map-signs",
        "fas fa-map-pin",
        "fas fa-map-marker-alt",
        "fas fa-map-marker",
        "fas fa-map",
        "far fa-map",
        "fab fa-mandalorian",
        "fas fa-male",
        "fas fa-magnet",
        "fas fa-magic",
        "fab fa-magento",
        "fab fa-lyft",
        "fas fa-low-vision",
        "fas fa-long-arrow-alt-up",
        "fas fa-long-arrow-alt-right",
        "fas fa-long-arrow-alt-left",
        "fas fa-long-arrow-alt-down",
        "fas fa-lock-open",
        "fas fa-lock",
        "fas fa-location-arrow",
        "fas fa-list-ul",
        "fas fa-list-ol",
        "fas fa-list-alt",
        "far fa-list-alt",
        "fas fa-list",
        "fas fa-lira-sign",
        "fab fa-linux",
        "fab fa-linode",
        "fab fa-linkedin-in",
        "fab fa-linkedin",
        "fas fa-link",
        "fab fa-line",
        "fas fa-lightbulb",
        "far fa-lightbulb",
        "fas fa-life-ring",
        "far fa-life-ring",
        "fas fa-level-up-alt",
        "fas fa-level-down-alt",
        "fab fa-less",
        "fas fa-lemon",
        "far fa-lemon",
        "fab fa-leanpub",
        "fas fa-leaf",
        "fab fa-lastfm-square",
        "fab fa-lastfm",
        "fab fa-laravel",
        "fas fa-laptop",
        "fas fa-language",
        "fab fa-korvue",
        "fab fa-kickstarter-k",
        "fab fa-kickstarter",
        "fab fa-keycdn",
        "fas fa-keyboard",
        "far fa-keyboard",
        "fab fa-keybase",
        "fas fa-key",
        "fab fa-jsfiddle",
        "fab fa-js-square",
        "fab fa-js",
        "fab fa-joomla",
        "fab fa-joget",
        "fab fa-jenkins",
        "fab fa-jedi-order",
        "fab fa-java",
        "fab fa-itunes-note",
        "fab fa-itunes",
        "fas fa-italic",
        "fab fa-ioxhost",
        "fab fa-internet-explorer",
        "fab fa-instagram",
        "fas fa-info-circle",
        "fas fa-info",
        "fas fa-industry",
        "fas fa-indent",
        "fas fa-inbox",
        "fab fa-imdb",
        "fas fa-images",
        "far fa-images",
        "fas fa-image",
        "far fa-image",
        "fas fa-id-card-alt",
        "fas fa-id-card",
        "far fa-id-card",
        "fas fa-id-badge",
        "far fa-id-badge",
        "fas fa-i-cursor",
        "fab fa-hubspot",
        "fab fa-html5",
        "fab fa-houzz",
        "fas fa-hourglass-start",
        "fas fa-hourglass-half",
        "fas fa-hourglass-end",
        "fas fa-hourglass",
        "far fa-hourglass",
        "fab fa-hotjar",
        "fas fa-hospital-symbol",
        "fas fa-hospital-alt",
        "fas fa-hospital",
        "far fa-hospital",
        "fab fa-hooli",
        "fas fa-home",
        "fas fa-hockey-puck",
        "fas fa-history",
        "fab fa-hire-a-helper",
        "fab fa-hips",
        "fas fa-heartbeat",
        "fas fa-heart",
        "far fa-heart",
        "fas fa-headphones",
        "fas fa-heading",
        "fas fa-hdd",
        "far fa-hdd",
        "fas fa-hashtag",
        "fas fa-handshake",
        "far fa-handshake",
        "fas fa-hands-helping",
        "fas fa-hands",
        "fas fa-hand-spock",
        "far fa-hand-spock",
        "fas fa-hand-scissors",
        "far fa-hand-scissors",
        "fas fa-hand-rock",
        "far fa-hand-rock",
        "fas fa-hand-pointer",
        "far fa-hand-pointer",
        "fas fa-hand-point-up",
        "far fa-hand-point-up",
        "fas fa-hand-point-right",
        "far fa-hand-point-right",
        "fas fa-hand-point-left",
        "far fa-hand-point-left",
        "fas fa-hand-point-down",
        "far fa-hand-point-down",
        "fas fa-hand-peace",
        "far fa-hand-peace",
        "fas fa-hand-paper",
        "far fa-hand-paper",
        "fas fa-hand-lizard",
        "far fa-hand-lizard",
        "fas fa-hand-holding-usd",
        "fas fa-hand-holding-heart",
        "fas fa-hand-holding",
        "fab fa-hacker-news-square",
        "fab fa-hacker-news",
        "fas fa-h-square",
        "fab fa-gulp",
        "fab fa-grunt",
        "fab fa-gripfire",
        "fab fa-grav",
        "fab fa-gratipay",
        "fas fa-graduation-cap",
        "fab fa-google-wallet",
        "fab fa-google-plus-square",
        "fab fa-google-plus-g",
        "fab fa-google-plus",
        "fab fa-google-play",
        "fab fa-google-drive",
        "fab fa-google",
        "fab fa-goodreads-g",
        "fab fa-goodreads",
        "fas fa-golf-ball",
        "fab fa-gofore",
        "fas fa-globe",
        "fab fa-glide-g",
        "fab fa-glide",
        "fas fa-glass-martini",
        "fab fa-gitter",
        "fab fa-gitlab",
        "fab fa-gitkraken",
        "fab fa-github-square",
        "fab fa-github-alt",
        "fab fa-github",
        "fab fa-git-square",
        "fab fa-git",
        "fas fa-gift",
        "fab fa-gg-circle",
        "fab fa-gg",
        "fab fa-get-pocket",
        "fas fa-genderless",
        "fas fa-gem",
        "far fa-gem",
        "fas fa-gavel",
        "fas fa-gamepad",
        "fab fa-galactic-senate",
        "fab fa-galactic-republic",
        "fas fa-futbol",
        "far fa-futbol",
        "fab fa-fulcrum",
        "fas fa-frown",
        "far fa-frown",
        "fab fa-freebsd",
        "fab fa-free-code-camp",
        "fab fa-foursquare",
        "fas fa-forward",
        "fab fa-forumbee",
        "fab fa-fort-awesome-alt",
        "fab fa-fort-awesome",
        "fas fa-football-ball",
        "fab fa-fonticons-fi",
        "fab fa-fonticons",
        "fab fa-font-awesome-flag",
        "fab fa-font-awesome-alt",
        "fab fa-font-awesome",
        "fas fa-font",
        "fas fa-folder-open",
        "far fa-folder-open",
        "fas fa-folder",
        "far fa-folder",
        "fab fa-fly",
        "fab fa-flipboard",
        "fab fa-flickr",
        "fas fa-flask",
        "fas fa-flag-checkered",
        "fas fa-flag",
        "far fa-flag",
        "fab fa-firstdraft",
        "fab fa-first-order-alt",
        "fab fa-first-order",
        "fas fa-first-aid",
        "fab fa-firefox",
        "fas fa-fire-extinguisher",
        "fas fa-fire",
        "fas fa-filter",
        "fas fa-film",
        "fas fa-file-word",
        "far fa-file-word",
        "fas fa-file-video",
        "far fa-file-video",
        "fas fa-file-powerpoint",
        "far fa-file-powerpoint",
        "fas fa-file-pdf",
        "far fa-file-pdf",
        "fas fa-file-medical-alt",
        "fas fa-file-medical",
        "fas fa-file-image",
        "far fa-file-image",
        "fas fa-file-excel",
        "far fa-file-excel",
        "fas fa-file-code",
        "far fa-file-code",
        "fas fa-file-audio",
        "far fa-file-audio",
        "fas fa-file-archive",
        "far fa-file-archive",
        "fas fa-file-alt",
        "far fa-file-alt",
        "fas fa-file",
        "far fa-file",
        "fas fa-fighter-jet",
        "fas fa-female",
        "fas fa-fax",
        "fas fa-fast-forward",
        "fas fa-fast-backward",
        "fab fa-facebook-square",
        "fab fa-facebook-messenger",
        "fab fa-facebook-f",
        "fab fa-facebook",
        "fas fa-eye-slash",
        "far fa-eye-slash",
        "fas fa-eye-dropper",
        "fas fa-eye",
        "far fa-eye",
        "fas fa-external-link-square-alt",
        "fas fa-external-link-alt",
        "fab fa-expeditedssl",
        "fas fa-expand-arrows-alt",
        "fas fa-expand",
        "fas fa-exclamation-triangle",
        "fas fa-exclamation-circle",
        "fas fa-exclamation",
        "fas fa-exchange-alt",
        "fas fa-euro-sign",
        "fab fa-etsy",
        "fab fa-ethereum",
        "fab fa-erlang",
        "fas fa-eraser",
        "fab fa-envira",
        "fas fa-envelope-square",
        "fas fa-envelope-open",
        "far fa-envelope-open",
        "fas fa-envelope",
        "far fa-envelope",
        "fab fa-empire",
        "fab fa-ember",
        "fas fa-ellipsis-v",
        "fas fa-ellipsis-h",
        "fab fa-elementor",
        "fas fa-eject",
        "fas fa-edit",
        "far fa-edit",
        "fab fa-edge",
        "fab fa-ebay",
        "fab fa-earlybirds",
        "fab fa-dyalog",
        "fab fa-drupal",
        "fab fa-dropbox",
        "fab fa-dribbble-square",
        "fab fa-dribbble",
        "fab fa-draft2digital",
        "fas fa-download",
        "fas fa-dove",
        "fas fa-dot-circle",
        "far fa-dot-circle",
        "fas fa-donate",
        "fas fa-dolly-flatbed",
        "fas fa-dolly",
        "fas fa-dollar-sign",
        "fab fa-docker",
        "fab fa-dochub",
        "fas fa-dna",
        "fab fa-discourse",
        "fab fa-discord",
        "fab fa-digital-ocean",
        "fab fa-digg",
        "fas fa-diagnoses",
        "fab fa-deviantart",
        "fas fa-desktop",
        "fab fa-deskpro",
        "fab fa-deploydog",
        "fab fa-delicious",
        "fas fa-deaf",
        "fas fa-database",
        "fab fa-dashcube",
        "fab fa-d-and-d",
        "fab fa-cuttlefish",
        "fas fa-cut",
        "fas fa-cubes",
        "fas fa-cube",
        "fab fa-css3-alt",
        "fab fa-css3",
        "fas fa-crosshairs",
        "fas fa-crop",
        "fas fa-credit-card",
        "far fa-credit-card",
        "fab fa-creative-commons-share",
        "fab fa-creative-commons-sampling-plus",
        "fab fa-creative-commons-sampling",
        "fab fa-creative-commons-sa",
        "fab fa-creative-commons-remix",
        "fab fa-creative-commons-pd-alt",
        "fab fa-creative-commons-pd",
        "fab fa-creative-commons-nd",
        "fab fa-creative-commons-nc-jp",
        "fab fa-creative-commons-nc-eu",
        "fab fa-creative-commons-nc",
        "fab fa-creative-commons-by",
        "fab fa-creative-commons",
        "fab fa-cpanel",
        "fas fa-couch",
        "fas fa-copyright",
        "far fa-copyright",
        "fas fa-copy",
        "far fa-copy",
        "fab fa-contao",
        "fab fa-connectdevelop",
        "fas fa-compress",
        "fas fa-compass",
        "far fa-compass",
        "fas fa-comments",
        "far fa-comments",
        "fas fa-comment-slash",
        "fas fa-comment-dots",
        "far fa-comment-dots",
        "fas fa-comment-alt",
        "far fa-comment-alt",
        "fas fa-comment",
        "far fa-comment",
        "fas fa-columns",
        "fas fa-cogs",
        "fas fa-cog",
        "fas fa-coffee",
        "fab fa-codiepie",
        "fab fa-codepen",
        "fas fa-code-branch",
        "fas fa-code",
        "fab fa-cloudversify",
        "fab fa-cloudsmith",
        "fab fa-cloudscale",
        "fas fa-cloud-upload-alt",
        "fas fa-cloud-download-alt",
        "fas fa-cloud",
        "fas fa-closed-captioning",
        "far fa-closed-captioning",
        "fas fa-clone",
        "far fa-clone",
        "fas fa-clock",
        "far fa-clock",
        "fas fa-clipboard-list",
        "fas fa-clipboard-check",
        "fas fa-clipboard",
        "far fa-clipboard",
        "fas fa-circle-notch",
        "fas fa-circle",
        "far fa-circle",
        "fab fa-chrome",
        "fas fa-child",
        "fas fa-chevron-up",
        "fas fa-chevron-right",
        "fas fa-chevron-left",
        "fas fa-chevron-down",
        "fas fa-chevron-circle-up",
        "fas fa-chevron-circle-right",
        "fas fa-chevron-circle-left",
        "fas fa-chevron-circle-down",
        "fas fa-chess-rook",
        "fas fa-chess-queen",
        "fas fa-chess-pawn",
        "fas fa-chess-knight",
        "fas fa-chess-king",
        "fas fa-chess-board",
        "fas fa-chess-bishop",
        "fas fa-chess",
        "fas fa-check-square",
        "far fa-check-square",
        "fas fa-check-circle",
        "far fa-check-circle",
        "fas fa-check",
        "fas fa-chart-pie",
        "fas fa-chart-line",
        "fas fa-chart-bar",
        "far fa-chart-bar",
        "fas fa-chart-area",
        "fas fa-certificate",
        "fab fa-centercode",
        "fab fa-cc-visa",
        "fab fa-cc-stripe",
        "fab fa-cc-paypal",
        "fab fa-cc-mastercard",
        "fab fa-cc-jcb",
        "fab fa-cc-discover",
        "fab fa-cc-diners-club",
        "fab fa-cc-apple-pay",
        "fab fa-cc-amex",
        "fab fa-cc-amazon-pay",
        "fas fa-cart-plus",
        "fas fa-cart-arrow-down",
        "fas fa-caret-up",
        "fas fa-caret-square-up",
        "far fa-caret-square-up",
        "fas fa-caret-square-right",
        "far fa-caret-square-right",
        "fas fa-caret-square-left",
        "far fa-caret-square-left",
        "fas fa-caret-square-down",
        "far fa-caret-square-down",
        "fas fa-caret-right",
        "fas fa-caret-left",
        "fas fa-caret-down",
        "fas fa-car",
        "fas fa-capsules",
        "fas fa-camera-retro",
        "fas fa-camera",
        "fas fa-calendar-times",
        "far fa-calendar-times",
        "fas fa-calendar-plus",
        "far fa-calendar-plus",
        "fas fa-calendar-minus",
        "far fa-calendar-minus",
        "fas fa-calendar-check",
        "far fa-calendar-check",
        "fas fa-calendar-alt",
        "far fa-calendar-alt",
        "fas fa-calendar",
        "far fa-calendar",
        "fas fa-calculator",
        "fab fa-buysellads",
        "fas fa-bus"
    ],

    // Icons used by the workflow buttons
    workflow: [
        "fas fa-cog",
        "fas fa-check",
        "fas fa-plus",
        "fas fa-times",
        "fas fa-paper-plane",
        "far fa-paper-plane",
        "fas fa-sitemap",
        "fas fa-lightbulb",
        "fas fa-balance-scale",
        "fas fa-thumbs-up",
        "fas fa-thumbs-down",
        "fas fa-handshake",
        "far fa-handshake",
        "fas fa-hand-holding-usd",
        "fas fa-euro-sign",
        "fas fa-dollar-sign",
        "fas fa-trash",
        "fas fa-power-off",
        "fas fa-sync-alt",
        "fas fa-redo-alt",
        "fas fa-undo-alt",
        "fas fa-star",
        "fas fa-key",
        "fas fa-save",
        "fas fa-heart",
        "far fa-heart",
        "fas fa-exclamation-triangle",
        "fas fa-bolt",
        "fas fa-exclamation",
        "fas fa-question",
        "fas fa-hourglass-half",
        "fas fa-clock",
        "far fa-clock",
        "fas fa-history",
        "fas fa-calendar-times",
        "fas fa-calendar-alt",
        "far fa-flag",
        "fas fa-flag-checkered",
        "fas fa-archive",
        "fas fa-edit",
        "far fa-edit",
        "fas fa-print",
        "fas fa-unlock-alt",
        "fas fa-unlock",
        "fas fa-wrench",
        "fas fa-cogs",
        "fas fa-paperclip",
        "fas fa-file-alt",
        "far fa-file-alt",
        "fas fa-file",
        "far fa-file",
        "fas fa-copy",
        "far fa-copy",
        "fas fa-folder-open",
        "far fa-folder-open",
        "fas fa-folder",
        "far fa-folder",
        "fas fa-comments",
        "far fa-comments",
        "fas fa-comment-dots",
        "far fa-comment-dots",
        "fas fa-comment-alt",
        "far fa-comment-alt",
        "fas fa-comment",
        "far fa-comment",
        "fas fa-search",
        "fas fa-binoculars",
        "fas fa-filter",
        "fas fa-lock-open",
        "fas fa-lock",
        "fas fa-clone",
        "far fa-clone",
        "fas fa-paste",
        "fas fa-notes-medical",
        "fas fa-clipboard-list",
        "fas fa-clipboard-check",
        "fas fa-clipboard",
        "far fa-clipboard",
        "fas fa-child",
        "fas fa-smile",
        "far fa-smile",
        "fas fa-meh",
        "far fa-meh",
        "fas fa-frown",
        "far fa-frown",
        "fas fa-user",
        "fas fa-user-friends",
        "fas fa-users",
        "fas fa-user-check",
        "fas fa-user-plus",
        "fas fa-user-minus",
        "fas fa-user-tie",
        "fas fa-user-graduate",
        "fas fa-graduation-cap",
        "fas fa-address-card",
        "fas fa-step-backward",
        "fas fa-fast-backward",
        "fas fa-backward",
        "fas fa-play",
        "fas fa-pause",
        "fas fa-forward",
        "fas fa-fast-forward",
        "fas fa-step-forward",
        "fas fa-reply-all",
        "fas fa-reply",
        "fas fa-play-circle",
        "fas fa-pause-circle",
        "fas fa-stop-circle",
        "fas fa-check-circle",
        "far fa-check-circle",
        "fas fa-arrow-circle-left",
        "fas fa-arrow-circle-right",
        "fas fa-arrow-alt-circle-left",
        "fas fa-arrow-alt-circle-right",
        "fas fa-chevron-circle-left",
        "fas fa-chevron-circle-right",
        "fas fa-user-circle",
        "fas fa-times-circle",
        "fas fa-plus-circle",
        "fas fa-minus-circle",
        "fas fa-exclamation-circle",
        "fas fa-question-circle",
        "fas fa-adjust",
        "fas fa-plus-square",
        "fas fa-minus-square",
        "fas fa-external-link-square-alt",
        "fas fa-check-square",
        "far fa-check-square",
        "fas fa-caret-square-left",
        "fas fa-caret-square-right",
        "far fa-caret-square-left",
        "far fa-caret-square-right",
        "fas fa-arrow-left",
        "fas fa-chevron-left",
        "fas fa-angle-double-left",
        "fas fa-angle-left",
        "fas fa-caret-left",
        "fas fa-exchange-alt",
        "fas fa-caret-right",
        "fas fa-angle-right",
        "fas fa-angle-double-right",
        "fas fa-chevron-right",
        "fas fa-arrow-right",
        "fas fa-phone",
        "fas fa-bullhorn",
        "fas fa-bell",
        "fas fa-envelope-open",
        "far fa-envelope-open",
        "fas fa-envelope",
        "far fa-envelope",
        "fas fa-chart-pie",
        "fas fa-chart-line",
        "fas fa-chart-bar",
        "fas fa-chart-area",
        "fab fa-windows",
        "fab fa-microsoft",
        "fas fa-desktop",
        "fas fa-laptop",
        "fas fa-keyboard",
        "fas fa-database",
        "fas fa-hockey-puck",
        "fas fa-hdd",
        "fas fa-mobile-alt",
        "fas fa-microchip",
        "fas fa-microphone",
        "fas fa-wifi",
        "fas fa-cloud",
        "fas fa-cloud-upload-alt",
        "fas fa-cloud-download-alt",
        "fas fa-road",
        "fas fa-map-signs",
        "fas fa-map-marker",
        "fas fa-map",
        "fas fa-globe",
        "fas fa-magnet",
        "fas fa-location-arrow",
        "fas fa-mouse-pointer",
        "fas fa-moon",
        "fas fa-bicycle",
        "fas fa-motorcycle",
        "fas fa-car",
        "fas fa-bus",
        "fas fa-truck",
        "fas fa-plane",
        "fas fa-fighter-jet",
        "fas fa-dolly-flatbed",
        "fas fa-dolly",
        "fab fa-dropbox",
        "fas fa-box-open",
        "fas fa-shopping-cart",
        "fas fa-cart-plus",
        "fas fa-home",
        "fas fa-building",
        "fas fa-university",
        "fas fa-book",
        "fas fa-code",
        "fas fa-code-branch",
        "fas fa-bookmark",
        "fas fa-bomb",
        "far fa-eye",
        "fas fa-camera",
        "fas fa-images",
        "fas fa-film",
        "fas fa-music",
        "fas fa-paw",
        "fas fa-dove",
        "fas fa-dna",
        "fas fa-gift",
        "fas fa-gem",
        "far fa-gem",
        "fas fa-puzzle-piece",
        "fas fa-plug",
        "fas fa-cut",
        "fas fa-cubes",
        "fas fa-cube",
        "fas fa-bed",
        "fas fa-couch",
        "fas fa-coffee",
        "fas fa-beer",
        "fas fa-wine-glass",
        "fas fa-glass-martini",
        "fas fa-utensils",
        "fas fa-flask",
        "fas fa-capsules"
    ]
}

;(function () {

	// Avoids collision in websocket config
	const RECONNECTION_SYMBOL = Symbol("reconnection")
	let reconnecting = false,
		closing = false

	/**
	 *
	 * ## A simple client WebSocket wrapper
	 *
	 * **This module is 100% specific and only works in combination with KissJS server.**
	 * The websocket wrapper uses [kiss.session](kiss.session.html) to authenticate the user with the server.
	 *
	 * @namespace
	 *
	 */
	kiss.websocket = {
		// The connection object
		connection: {},

		/**
		 * Init the WebSocket connection
		 *
		 * @async
		 * @param {object} config
		 * @param {string} [config.socketUrl] - optional socket url to use
		 * @param {string} [config.port] - optional socket non-secure port to use
		 * @param {string} [config.sslPort] - optional socket secure port to use
		 * @param {object} [config.reconnection] - optional reconnection config
		 * @param {boolean} [config.reconnection.enabled=true] - optional enable/disable reconnection
		 * @param {number} [config.reconnection.delay=5000] - optional reconnection delay in ms
		 * @param {number} [config.reconnection.delta=2] - optional reconnection delta to avoid DDOS on server reboot
		 * @param {number} [config.reconnection.maxAttempts=10] - optional max reconnection in a row. Reset each time the connection is established.
		 * @param {object} [config.heartbeat] - optional heartbeat config
		 * @param {boolean} [config.heartbeat.enabled=true] - optional enable/disable heartbeat
		 * @param {number} [config.heartbeat.delay=10000] - optional heartbeat frequency in ms
		 * @param {number} [config.heartbeat.timeout=35000] - optional heartbeat timeout before considering the socket as
		 *                                                    closed. Should be set several time greater than heartbeat delay
		 *                                                    to be sure pings are not answered by the server, because it may be
		 *                                                    busy or may forget to send the pong response.
		 * @param {function} [config.onopen] - Hook to the onopen event
		 * @param {function} [config.onmessage] - Hook to the onmessage event
		 * @param {function} [config.onclose] - Hook to the onclose event
		 *
		 * @example
		 * await kiss.websocket.init()
		 * kiss.websocket.send("something")
		 *
		 * // More complex case:
		 * await kiss.websocket.init({
		 * 	socketUrl: "wss://api.valr.com/ws/trade",
		 *
		 * 	onopen: () => {
		 * 		kiss.websocket.send({
		 * 			type: "SUBSCRIBE",
		 * 			subscriptions: [{
		 * 				event: "AGGREGATED_ORDERBOOK_UPDATE",
		 * 				pairs: ["BTCZAR"]
		 * 			}]
		 * 		})
		 * 	},
		 *
		 * 	onmessage: (message) => {
		 * 		console.log("Message received: ", message)
		 *  },
		 *
		 * 	onclose: () => {
		 * 		console.log("Socket closed!")
		 * 	}
		 * })
		 *
		 */
		async init(config = {}) {
			// If a socket is already open, we return immediately as we don't want several connection opened at the same time
			if (
				// Check if the connection have been initialised first
				(
					this.connection.readyState !== undefined
					&& this.connection.readyState !== WebSocket.CLOSED
				) || closing
				  || kiss.context.ws === 'no'

			) {
				return
			}

			// Race conditions may occur, and they are hard to track down if not id is used
			const logPrefix = `kiss.websocket - ${kiss.tools.uid()}`

			let socketUrl = config.socketUrl

			const {
				port = 80,
				sslPort = 443,
				reconnection: {
					enabled: autoReconnect = true,
					delay: reconnectionDelay = 5000,
					delta: reconnectionDelta = 2,
					maxAttempts = 10
				} = {},
				heartbeat: {
					enabled: heartbeatEnabled = true,
					delay: heartbeatDelay = 10000,
					timeout: heartbeatTimeout = 35000
				} = {}
			} = config

			const ws = window.WebSocket || window.MozWebSocket

			// Connect to WS or WSS depending on the current protocol
			if (!socketUrl) {
				socketUrl = kiss.session.getWebsocketHost() + "/?token="
			}

			log(`${logPrefix} - Connecting to ${socketUrl}`)
			const connection = new ws(socketUrl + kiss.session.getToken())

			// Will allow us to leverage the current function asynchronicity despite WebSocket callbacks nature
			const connectionResolver = {}

			connectionResolver.promise = new Promise((resolve, reject) => {
				Object.assign(connectionResolver, {
					resolve,
					reject
				})
			})
				.then(() => connectionResolver.succeeded = true)
				.catch(() => connectionResolver.succeeded = false)

			let heartbeatHandle, heartbeatResponseHandle

			//
			// OPEN
			//
			connection.addEventListener("open", e => {

				log(`${logPrefix} - Connected`)
				connectionResolver.resolve()

				if (RECONNECTION_SYMBOL in config || reconnecting) {
					if(!(RECONNECTION_SYMBOL in config)){
						config[RECONNECTION_SYMBOL] = {
							attempt: 0
						}
					} else {
						config[RECONNECTION_SYMBOL].attempt = 0
					}

					kiss.pubsub.publish("EVT_RECONNECTED")
				} else {
					kiss.pubsub.publish("EVT_CONNECTED")
				}

				// Hook
				if (typeof config.onopen === "function") {
					try {
						config.onopen()
					} catch (err) {
						log(`${logPrefix} - Could not execute 'onopen' hook properly - Error:`, 4, err)
					}
				}

				if (!heartbeatEnabled) return

				heartbeatHandle = setInterval(() => {
					// We only set the timeout if it is not defined or have been reset.
					// If we are already waiting for a ping response, we just resend it.
					// The server may have been busy or may have missed the first one, we want to be
					// certain that it is not reachable by sending several pings.
					if (!heartbeatResponseHandle) {
						heartbeatResponseHandle = setTimeout(() => {
							connection.close(4000, "SERVER_NOT_RESPONDING")
						}, heartbeatTimeout)
					}

					connection.send("ping")
				}, heartbeatDelay)
			})

			//
			// CLOSE
			//

			connection.addEventListener("close", async e => {
				// We check errors there, since the close event is ALWAYS emitted, even on connection error.
				// In fact, we do not need websocket error handler at all.
				log(`${logPrefix} - Closed ${e.reason} (${e.code})`)

				// We enter closing state. No external code must try a reconnection during this process.
				closing = true

				// Do not need the heartbeat anymore
				clearInterval(heartbeatHandle)

				// Hook
				if (typeof config.onclose === "function") {
					try {
						config.onclose()
					} catch (err) {
						log(`${logPrefix} - Could not execute 'onclose' hook properly - Error:`, 4, err)
					}
				}

				if (e.code === 4002) {
					// To many user sockets, we actually WANT to block the UI. And we REALLY don't want to reconnect.
					// Consequence would be to indefinitely loop from disconnection to reconnection across all tabs... not very fun for the user.
					log(`${logPrefix} - Connection locked by server (too many sockets have been opened by this user).`)

					// TODO : since there we want to do something special, EVT_CONNECTION_LOCK may be more accurate ?
					kiss.pubsub.publish("EVT_CONNECTION_LOST")
					return

				} else if (e.code === 4003) {
					// We have a definitive close. We will not try to reconnect.
					log(`${logPrefix} - Connection definitively closed.`)
					kiss.pubsub.publish("EVT_CONNECTION_CLOSED")
					return

				} else if (!e.reason && e.code === 1006) {
					// The websocket specification forbid the client to check the status code.
					// If the socket is rejected because invalid token, it will send the 1006 code. With no message.
					// So... if we want this reconnection algorithm to stop stupidly trying to reconnect with a wrong JWT,
					// we need to force the client to logout and to reauthenticate.
					// @see https://websockets.spec.whatwg.org//#feedback-from-the-protocol

					if(!await kiss.session.checkTokenValidity(true)){
						log(`${logPrefix} - Can't reconnect. No valid token available, and current token can't be renewed !`)
						kiss.pubsub.publish("EVT_UNUSABLE_TOKEN")
						return kiss.session.logout()
					}
				} else if (e.code === 1001) {
					// TODO : Server goes away (restart/shutdown)
					// we may want to display a maintenance screen, and increase the reconnection time
					log(`${logPrefix} - Server gone.`)
					kiss.pubsub.publish("EVT_SERVER_GONE")
					return
				}

				// Configuring the reconnection process. May or may not be used
				if (!config[RECONNECTION_SYMBOL]) {
					config[RECONNECTION_SYMBOL] = {
						attempt: 1
					}
				} else {
					config[RECONNECTION_SYMBOL].attempt++
				}

				// A real disconnection, since we were connected, so the pub/sub must be informed
				if (connectionResolver.succeeded) {
					kiss.pubsub.publish("EVT_DISCONNECTED")
				} else {
					connectionResolver.reject()
				}

				// Socket closed, from there no matter who tries to reconnect, it's ok.
				closing = false

				if (!autoReconnect) return

				if (config[RECONNECTION_SYMBOL].attempt <= maxAttempts) {
					let delay = reconnectionDelay || 5000

					// 1006 is the code for abnormal closure
					// 1001 is the code for Going Away
					// If the serveur is brutally stopped or restarted, we don't want all clients
					// to reconnect at the exact same millisecond.
					// It would be a disaster, as it may become an auto DDOS :(. Not very glorious way to die again and again.
					// So we delay randomly each reconnection in a window between the configured reconnection delay
					// and N times the reconnection delay, N being an arbitrary factor called reconnectionDelta
					if ([1001, 1006].includes(e.code) && reconnectionDelta) {
						// Draw a number between 0 and delay * reconnectionDelta
						delay += Math.floor(Math.random() * ((delay * reconnectionDelta) + 1))
					}

					log(`${logPrefix} - Will try to reconnect to the server in ${delay} ms...`)

					setTimeout(async () => {
						// This one is tricky. When the first connection attempt fails because session token must
						// be regenerated, a reconnection procedure starts.
						// But as soon as the token is automatically regenerated by kiss, init() is called a second
						// time, resulting in the opening of two connections as a result of a race condition.
						// If a connection is open, opening or closing, we abort the current call to avoid this.
						if (
							"readyState" in kiss.websocket.connection &&
							kiss.websocket.connection.readyState !== WebSocket.CLOSED
						) {
							log(`${logPrefix} - Reconnection aborted`)
							return
						}

						log(
							`${logPrefix} - Trying to reconnect (attempt ${
								config[RECONNECTION_SYMBOL].attempt
							}/${maxAttempts})`
						)

						try{
							// One may want to await the reconnection process to succeed or ack its error, so we carry along the init promise.
							const promise = kiss.websocket.init(config)
							kiss.pubsub.publish(
								"EVT_RECONNECTING",
								promise
							)

							reconnecting = true;
						}catch(err){
							reconnecting = false
							log(`${logPrefix} - Unable to reconnect: `, 4, err)
						}
					}, delay)
				} else {
					log(`${logPrefix} - Connection lost (max attempts (${maxAttempts}) reached !)`)
					kiss.pubsub.publish("EVT_CONNECTION_LOST")
				}
			})

			//
			// MESSAGE
			//
			connection.addEventListener("message", message => {
				if (message.data === "pong") {
					// Received in time, we have to clean the timeout
					clearTimeout(heartbeatResponseHandle)
					heartbeatResponseHandle = null
					return
				}

				try {
					log(`${logPrefix} - onmessage - Data:`, 1, message.data)

					let json = JSON.parse(message.data)
					
					// Mark the message as coming from a websocket
					json.websocket = true 
					kiss.pubsub.publish(json.channel, json)

					// Hook
					if (typeof config.onmessage === "function") {
						try {
							config.onmessage(message)
						} catch (err) {
							log(`${logPrefix} - Could not execute 'onmessage' hook properly - Error:`, 4, err)
						}
					}
				} catch (err) {
					log(`${logPrefix} - onmessage - Error:`, 4, err)
				}
			})

			kiss.websocket.connection = connection

			return connectionResolver.promise
		},

		close() {
			// Check if the connection have been initialised
			if (typeof this.connection.close === "function") {
				this.connection.close(4003, 'DEFINITIVE_CLOSE')
			} else throw new Error("No connection to close: kiss.websocket.init has not been called.")
		},

		/**
		 * Send a message to the server via WebSocket
		 *
		 * @param {object} jsonData - Any valid JSON
		 *
		 * @example
		 * kiss.data.send({
		 *  userId: "john.doe@pickaform.com",
		 *  text: "Hello, how are you?"
		 * })
		 */
		send(jsonData) {
			// Check if the connection have been initialised
			if (typeof this.connection.send === "function") {
				const message = JSON.stringify(jsonData)
				this.connection.send(message)
			} else throw new Error("No connection to opened: kiss.websocket.init has not been called.")
		}
	}

})()


;/**
 * 
 * The **Component** is the base class for all KissJS UI components.
 * 
 * KissJS Component derives from HTMLElement, and therefore inherits all native DOM operations.
 * 
 * Most UI frameworks are encapsulating DOM elements with classes.
 * Instead of that, KissJS is directly attaching new properties and new methods to DOM elements.
 * 
 * Let's imagine a Panel component built with KissJS.
 * Because a KissJS Component is a pure DOM element, you can get your Panel using native DOM operations.
 * Then, once you have your panel, you can directly call its methods like this:
 * 
 * ```
 * const myPanel = document.getElementById("my-panel")
 * myPanel.expand()
 * myPanel.setAnimation("shakeX")
 * ```
 * 
 * This way, it avoids the overhead of encapsulation (= no additional layers to cross).
 * It's also easier to keep the memory clean: when you destroy your DOM element, everything attached to it (states, events...) is flushed and can be garbage collected.
 * 
 * KissJS components are partly using the Custom Web Components API.
 * They are "half" Custom Web Components in the sense they're not using shadow DOM.
 * 
 * They are recognizable and easy to lookup in the DOM because their tag name always starts with "a-", like:
 * "a-field", "a-button", "a-panel", "a-menu", and so on...
 * 
 * The Component base class does a few useful things for us:
 * - id generation (all KissJS components must have an id)
 * - automatically inserted at a specific location in the DOM, using the optional "target" property
 * - keep the component config attached to the component, to be able to serialize it / save it / rebuild it later
 * - automatically adds a base class depending on the component type (example: "a-field", "a-button", ...)
 * - we can bind custom methods, using the "methods" config
 * - we can bind W3C events, using the "events" config
 * - we can "subscribe" the component to one ore more PubSub channels, using the "subscriptions" config
 * - a "render" method is automatically attached to manage the component rendering lifecycle
 * - a "load" method **can** be attached to manage the component's loading / re-loading (typically when the component generation relies on external data)
 * - we can bind the component to one or more data collections, using the "collections" config: it will automatically reload the component when one of the binded collections changes
 * - a few helper methods are attached automatically (show, hide, toggle, animation, showLoading, hideLoading...)
 * - we can hook custom behavior in the lifecycle by using private methods like: _afterConnected, _afterRender, _afterShow, _afterHide, _afterDisconnected
 * 
 * _Schema overview of the instanciation and rendering_:
 * 
 * <img src="../../resources/doc/KissJS - Component.png">
 * 
 * @param {object} config
 * @param {string} [config.id] - id of the component. Will be auto-generated if not set
 * @param {boolean} [config.hidden] - true if the component is hidden when rendered for the 1st time
 * @param {string|HTMLElement} [config.target] - DOM target insertion point. Either a DOM element or a CSS selector.
 * @param {object} [config.methods] - Custom methods of the component
 * @param {object} [config.events] - W3C events handled by the component
 * @param {object} [config.subscriptions] - Array of functions registered in the PubSub
 * @param {Collection[]} [config.collections] - List of collections bound to the compoent. Component will reload if a mutation occurs in one of its bound collections.
 * @param {string|object} [config.tip] - hover help message
 * @param {string|object} [config.animation] - Animation to perform when rendering for the 1st time
 * @param {boolean} [config.autoSize] - If true, the component will trigger its "updateLayout" method when its parent container is resized
 * @returns this
 */
kiss.ui.Component = class Component extends HTMLElement {
    constructor() {
        super()
    }

    /**
     * Generates a Component from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config) {
        if (!config) return null

        // Set a flag to define the HTMLElement as a KissJS component
        this.isComponent = true

        // Basic properties
        this.type = config.type || this.constructor.name.toLowerCase()
        this.id = config.id || "cmp-" + (kiss.global.componentCount++).toString()
        this.target = config.target || null // Insertion point in the DOM, or document.body otherwise
        this.config = config // Allows to trace back to the initial config, serialize it, save it, rebuild it

        // Short delay (in ms) while the component stays invisible while its size and position is calculated properly
        // It's not a perfect solution but it stabilizes the rendering behavior
        this.renderDelay = 25

        // Default CSS class is: a-{component-type}
        // Examples: a-field, a-checkbox, a-select, a-button, a-panel...
        this.classList.add("a-" + this.type.toLowerCase())
        if (kiss.screen.isMobile) this.classList.add("a-" + this.type.toLowerCase() + "-mobile")

        // Manage component visibility
        if (config.display) this.displayMode = config.display
        if (config.hidden == true) this.style.display = "none"

        // Setup the component tip/help text (message displayed when the component is hovered)
        if (config.tip) this.attachTip(config.tip)

        // Manage animations
        if (config.animation) this.setAnimation(config.animation)

        // Bind inline methods, defined by the "methods" property of the component
        const methods = config.methods
        if (methods) {
            for (let method in methods) {
                this[method] = methods[method]
            }
        }

        // Bind external methods, defined by calling kiss.views.addViewController(viewId, controllerObject)
        let viewControllers = kiss.views.viewControllers[this.id]

        // Handle the case where a mobile view doesn't have a mobile renderer but has a mobile controller
        if (kiss.screen.isMobile) {
            if (!this.id.includes("mobile")) {
                viewControllers = kiss.views.viewControllers["mobile-" + this.id] || kiss.views.viewControllers[this.id]
            }
        }

        if (viewControllers) {
            for (let method in viewControllers) {
                this[method] = viewControllers[method]
            }
        }

        // Bind custom events
        this._bindEvents(this.config.events)

        // Hold the component's subscriptions to the PubSub
        this.subscriptions = []

        if (this.config.subscriptions) {
            Object.keys(this.config.subscriptions).forEach(pubSubEventName => {
                this.subscriptions.push(
                    subscribe(pubSubEventName, this.config.subscriptions[pubSubEventName].bind(this))
                )
            })
        }

        // Observe when the parent container is resized in order to trigger an updateLayout
        if (config.autoSize) {
            this.resizeCount = 0
            this.subscriptions.push(
                subscribe("EVT_CONTAINERS_RESIZED", (containerIds) => {
                    if (this.parentNode == document.body || (this.parentNode && this.parentNode.id && containerIds.indexOf(this.parentNode.id) != -1)) {
                        // if (this.resizeCount != 0)
                        this.updateLayout("EVT_CONTAINERS_RESIZED")
                        this.resizeCount++
                    }
                })
            )
        }

        //
        // Bind collections
        // It subscribes the component's *load* method to the database updates for the relative models
        //
        if (config.collections && config.collections.length > 0 && config.collections[0]) {
            this.collections = config.collections

            if (this.load) {
                // Get the events to observe
                const observedEvents = []

                this.collections.forEach(collection => {
                    let model = collection.model
                    let modelId = model.id
                    let events = ["EVT_DB_INSERT:", "EVT_DB_UPDATE:", "EVT_DB_DELETE:"]

                    events.forEach(EVT => {
                        let eventName = EVT + modelId.toUpperCase()
                        observedEvents.push(eventName)
                    })
                })

                // Subscribe the component to observe CUD mutations of its bound models
                observedEvents.forEach(eventName => {
                    //log(`kiss.ui.Component - Binding view <${this.id}> to event <${eventName}>`, 1)

                    this.subscriptions.push(
                        subscribe(eventName, (msgData) => {
                            // Will load or reload the component only if it's connected to the DOM
                            if (this.isConnected) {
                                log("kiss.ui - React to " + eventName + " - Component loading " + this.id, 2)
                                this.load(msgData)
                            }
                        })
                    )
                })

                // Subscribe the component to observe bulk updates too
                // (bulk updates can target multiple and different collections)
                const observedModels = this.collections.map(collection => collection.model.id)

                this.subscriptions.push(
                    subscribe("EVT_DB_UPDATE_BULK", (msgData) => {
                        // Will load or reload the component only if:
                        // - it's connected to the DOM
                        // - the bulk update contains an update related to the component's bound models
                        if (this.isConnected) {
                            let shouldLoad = false

                            // Check if one of the updates is related to a component's observed model
                            const bulkUpdates = msgData.data
                            bulkUpdates.forEach(update => {
                                if (observedModels.indexOf(update.modelId) != -1) shouldLoad = true
                            })

                            if (shouldLoad) {
                                log("EVT_DB_UPDATE_BULK - Component loading " + this.id, 2)
                                this.load(msgData)
                            }
                        }
                    })
                )
            }
        }

        return this
    }

    /**
     * Observe the connected-ness of the component and trigger the configured callback
     * 
     * @ignore
     */
    connectedCallback() {
        if (this._afterConnected) this._afterConnected()

        // TODO: before deploying on-the-fly translation: handle external values merged into the translated strings
        // this.translate()
    }

    disconnectedCallback() {
        if (this.loadingId) this.hideLoading() // Try to hide the loading mask (if any)

        if (this._afterDisconnected) this._afterDisconnected()
    }

    /**
     * Translate the localized elements of a Component on the fly
     * TODO: handle external values merged into the translated strings
     */
    translate() {
        Array.from(this.querySelectorAll(".translation")).forEach(element => {
            const textKey = kiss.language.hash[element.id]
            const newText = kiss.language.translate(textKey)
            element.innerHTML = newText
        })
    }

    /**
     * Render an Element at a specified DOM location
     * The rendering is optimized to render only the element that are detached from the DOM.
     * 
     * The render() method is chainable with other Component's methods.
     * For example:
     * ```
     * myElement.render().showAt(100, 100).setAnimation("shakeX")
     * ```
     * 
     * @param {*} [target] - optional DOM target insertion point
     * @param {boolean} load - true (default) to execute the component's load method after DOM insertion
     * @returns this
     */
    render(target, load = true) {
        // Hide the component while it's being rendered and sizes are computed
        this.style.visibility = "hidden"

        //log("Render: " + this.type + " - " + this.id + " on target " + target, 1)

        if (!this.isConnected) {
            // Add custom classes
            if (this.config && this.config.classes) this._dispatchClasses(this.config.classes)
            if (this.config && this.config.class) this.classList.add(this.config.class)

            // Add custom styles
            if (this.config && this.config.styles) this._dispatchStyles(this.config.styles)
            if (this.config && this.config.style) this.style.cssText += this.config.style
            if (this.config && this.config.hidden) this.style.display = "none"

            // Insert the component at a specfic DOM location
            this._insertIntoDOM(target, this.config && this.config.targetIndex)
        }

        // Render container's children, if any
        if ((this.items) && (this.items.length > 0)) this.items.forEach(item => item.render(item.target || target))

        // If the component has a load method, we call it
        if (load && (this.load)) {

            if (this.isComponent) {
                // KissJS components have a more complex loading process
                // because a component might rely on data that should be loaded before
                this._load()
            } else {
                // Standard HTMLElement
                this.load()
            }
        } else {
            // If the component has a sizing a method, we call it now
            if (this.updateLayout) this.updateLayout("Component.render")

            // If the component has an afterRender method, we execute it
            if (this._afterRender) this._afterRender()

            // Wait a short delay before displaying the component so that all sizes are already calculated
            setTimeout(() => this.style.visibility = "visible", this.renderDelay)
        }

        return this
    }

    /**
     * Update a component with a new config
     * 
     * - Internally, destroys the component and re-render it from its config.
     * - If the component was inside a parent container, it re-render it at the same position
     * - Attention: if the component received extra properties/methods/events outside it's default config, they will be lost
     * 
     * @param {object} newConfig
     * @returns {object} The new KissJS component
     */
    update(newConfig) {
        let component
        const config = this.config
        if (newConfig) Object.assign(config, newConfig)

        config.target = this.parentNode.id
        config.targetIndex = Array.from(this.parentNode.children).indexOf(this)

        // Remove the existing component
        this.deepDelete()

        // Build a new one and insert it in the DOM
        if (this.type) {
            if (["text", "textarea", "number", "date", "password", "lookup", "summary"].includes(this.type)) {
                // Input fields and textarea
                component = document.createElement("a-field").init(config)
            } else {
                // Other fields and elements
                component = document.createElement("a-" + this.type.toLowerCase()).init(config)
            }
        } else {
            // Block
            component = document.createElement("a-block").init(config)
        }

        return component.render()
    }

    /**
     * Insert the component at a specfic DOM location
     * 
     * @private
     * @ignore
     * @param {string|HTMLElement} [target] - Target id or DOM element
     */
    _insertIntoDOM(target, index) {
        // Define insertion point in the DOM
        let domTarget = target || this.target

        if (domTarget) {
            // If a dom target is specified, the component is appended here
            if (typeof domTarget == "string") {
                
                // The target is a CSS selector
                if (index) {
                    $(domTarget).insertBefore(this, $(domTarget).children[index])
                } else {
                    $(domTarget).appendChild(this)
                }
            } else {

                // The target is a DOM element
                if (index) {
                    domTarget.insertBefore(this, domTarget.children[index])
                } else {
                    domTarget.appendChild(this)
                }
            }
        } else {
            // ... else it's rendered to the document body
            document.body.appendChild(this)
        }
    }

    /**
     * Load component's data
     * 
     * @private
     * @ignore
     */
    async _load() {
        try {
            // Load the records of the bound collections
            if (this.collections) {
                for (let collection of this.collections) {
                    await collection.find()
                }
            }

            // Call the "load" method of the component
            if (this.load) await this.load()

            // Once loaded, recompute the size and position if it has a "updateLayout" method
            if (this.updateLayout) this.updateLayout("Component._load")

            // If the component has an afterRender method, we execute it
            if (this._afterRender) this._afterRender()

            // Wait a short delay while all sizes are calculated
            setTimeout(() => this.style.visibility = "visible", this.renderDelay)

        } catch (err) {
            log("kiss.ui - Component - Loading error: " + this.id, 4)
            log(err)
        }
    }

    /**
     * Hide the component
     * 
     * @returns this
     */
    hide() {
        // Keep the current display mode in cache for future restore
        let currentDisplayMode = window.getComputedStyle(this, "")["display"]
        if (currentDisplayMode != "" && currentDisplayMode != "none") this.displayMode = currentDisplayMode

        this.style.display = "none"
        this.hidden = true

        if (this._afterHide) this._afterHide()

        return this
    }

    /**
     * Display the component
     * 
     * @param {string} [mode] - Force a display mode. Ex: block, flex, inline, inline-block, inline-flex
     * @returns this
     */
    show(mode) {
        if (this.style.display != "none") return this

        this.style.display = mode || this.displayMode || (this.config && this.config.display) || "block"
        this.hidden = false

        if (this._afterShow) this._afterShow()

        return this
    }

    /**
     * Show the component at a specified (x, y) position on the screen.
     * If the component leaks outside the viewport, it's re-centered to fit in.
     * 
     * @param {number} x - Coord x in pixels
     * @param {number} y - Coord y in pixels 
     * @param {number} [animationTimeInSeconds] - Optional parameter to animate the translation of the Element
     * @returns this
     * 
     * @example
     * // It wil take 2 seconds to translate to position 500,500:
     * myElement.showAt(500, 500, 2)
     */
    showAt(x, y, animationTimeInSeconds) {
        if (animationTimeInSeconds) this.style.transition = animationTimeInSeconds + "s"
        this.style.left = x + "px"
        this.style.top = y + "px"
        this.show().moveToViewport()
        return this
    }

    /**
     * Move the component inside the visible viewport.
     * This is useful for example to re-center a component so that it's entirely visible.
     * 
     * @returns this
     */
    moveToViewport() {
        kiss.tools.moveToViewport(this)
        return this
    }

    /**
     * Test if the component is hidden
     * 
     * @returns {boolean}
     */
    isHidden() {
        return (this.style.display == "none") || (this.hidden == true)
    }

    /**
     * Test if the component is visible
     * 
     * @returns {boolean}
     */
    isVisible() {
        return !this.isHidden()
    }

    /**
     * Show / hide alternatively the Component
     * 
     * @returns this
     */
    toggle() {
        if (this.isHidden()) {
            this.show()
        } else {
            this.hide()
        }
        return this
    }

    /**
     * Show a loading spinner over the Component.
     * By default, the overlay has the size of the element.
     * 
     * @param {object} config
     * @param {boolean} config.fullscreen - If true, the loading mask cover the full screen
     * @param {boolean} config.mask - Set to false to hide the background overlay
     * @param {number|string} config.spinnerSize - Size of the spinning symbol. If a number, it's in pixels. If a string, it's a CSS size.
     * @returns this
     * 
     * @example
     * myPanel.showLoading({spinnerSize: 32})
     */
    showLoading(config = {}) {
        // Exit if the component is already in loading state
        if (this.isLoading) return

        const box = this.getBoundingClientRect()

        // Create an overlay
        const mask = document.createElement("div")
        mask.classList.add("component-loader-mask")
        mask.id = "mask-" + kiss.tools.shortUid()
        mask.style.top = (config.fullscreen == true) ? 0 : box.y + "px"
        mask.style.left = (config.fullscreen == true) ? 0 : box.x + "px"
        mask.style.width = (config.fullscreen == true) ? "100vw" : box.width + "px"
        mask.style.height = (config.fullscreen == true) ? "100vh" : box.height + "px"

        if (this.type == "panel") mask.style.borderRadius = "var(--panel-border-radius)"
        if (config.mask !== false) mask.style.background = "var(--background-overlay)"

        // Create the loading spinner
        const spinner = document.createElement("div")
        spinner.classList.add("component-loader")
        spinner.id = "spinner-" + this.id

        // Set the spinner size
        if (config.spinnerSize) {
            if (typeof config.spinnerSize == "number") {
                spinner.style.width = config.spinnerSize + "px"
                spinner.style.height = config.spinnerSize + "px"
            } else {
                spinner.style.width = config.spinnerSize
                spinner.style.height = config.spinnerSize
            }
        } else {
            spinner.style.width = "3.2rem"
            spinner.style.height = "3.2rem"
        }

        // Attach the spinner id to the element so that we can remove it later
        this.loadingId = mask.id

        // Attach overlay & spinner to the component
        const maskNode = document.body.appendChild(mask)
        maskNode.appendChild(spinner)

        this.isLoading = true
        return this
    }

    /**
     * Hide the loading spinner of the Component
     * 
     * @returns this
     */
    hideLoading() {
        try {
            $(this.loadingId).remove()
            delete this.loadingId
            this.isLoading = false
        } catch (err) {
            // log("<Component>.hideLoading() - Could not find element to hide:" + this.id)
        }
        return this
    }

    /**
     * Attach a tip text to the component
     * 
     * TODO: At the moment, attaching a tip prevents from having other "onmouseenter" events. Don't overwrite onmouseenter event
     * 
     * @param {object|text} tipConfig - Config object {text: ..., deltaX: ..., deltaY: ...}, or a simple string
     * @param {string} tipConfig.text - Tip text
     * @param {string} [tipConfig.textAlign] - Tip text alignment: "center", "right". Default "left"
     * @param {number} [tipConfig.x] - Optional static x
     * @param {number} [tipConfig.Y] - Optional static y
     * @param {number} [tipConfig.deltaX] - Shift the tip on X coordinate
     * @param {number} [tipConfig.deltaY] - Shift the tip on Y coordinate
     * @returns this
     * 
     * @example
     * // Using a configuration object
     * myField.attachTip({
     *  text: "Please enter your name",
     *  deltaX: 20,
     *  deltaY: 20
     * })
     * 
     * // Using a simple text
     * myField.attachTip("Please enter your name")
     */
    attachTip(tipConfig) {
        if (kiss.screen.isMobile) return
        if (kiss.screen.isTouch()) return
        if (this.tip) return

        if (typeof tipConfig === "object") {
            this.tip = createTip({
                target: this,
                text: tipConfig.text,
                textAlign: tipConfig.textAlign,
                x: tipConfig.x,
                y: tipConfig.y,
                deltaX: tipConfig.deltaX,
                deltaY: tipConfig.deltaY,
                minWidth: tipConfig.minWidth,
                maxWidth: tipConfig.maxWidth
            })
        } else {
            this.tip = createTip({
                target: this,
                text: tipConfig
            })
        }

        // Wait for the DOM before attaching the event
        setTimeout(() => {
            if (this.config && !this.isConnected) {
                // If the component is not initialized yet, we just modify its configuration
                if (!this.config.events) this.config.events = {}
                this.config.events.onmouseenter = () => this.tip.render()
            } else {
                // Otherwise, we override its onmouseenter event
                this.onmouseenter = () => this.tip.render()
            }
        }, 0)
        return this
    }

    /**
     * Detach the tip from the component (if any)
     * 
     * @returns this
     */
    detachTip() {
        if (!this.tip) return this
        this.tip.detach()
        delete this.tip
        return this
    }

    /**
     * Get the component's width
     * 
     * @returns {number} The width in pixels
     */
    getWidth() {
        return this.clientWidth
    }

    /**
     * Get the component's height
     * 
     * @returns {number} The height in pixels
     */
    getHeight() {
        return this.clientHeight
    }

    /**
     * Bind events to the Component
     * 
     * @private
     * @ignore
     * @param {object} events - Object containing the functions to bind to DOM events. Ex: {"click": event => {...}, "mouseover": event => {...} }
     * @param {HTMLElement} [target] - Optional DOM Element to which the event should be bound. Defaults to "this" (= the Component)
     * @returns this
     * 
     * @example
     * Event names can follow various conventions as they will be automatically normalized to the W3C event:
     * - change => OK
     * - onchange => OK
     * - onChange => OK
     */
    _bindEvents(events, target) {
        let targetElement = target || this

        if (events) {
            for (let event in events) {
                const eventName = (event.slice(0, 2).toLowerCase() == "on") ? event : "on" + event
                targetElement[eventName.toLowerCase()] = events[event]
            }
        }
        return this
    }

    /**
     * Apply multiple style properties on multiple targets.
     * 
     * The property array supports property aliases, in case the config object can't match the exact targeted property name.
     * See the example below with an aliased property (config.headerBackgroundColor will set panelHeader.style.backgroundColor)
     * 
     * @private
     * @ignore
     * @param {object} config - The configuration object passed to the Component init method
     * @param {array[][][]} rules - 3 dimensions array of rules that defines which properties should be applied to which targets.
     * @returns this
     * 
     * @example
     * // Here, the headerBackgroundColor config will set the backgroundColor property of the panel header style:
     * this._setProperties(config, [
     *      [["headerBackgroundColor=backgroundColor"], [panelHeader.style]],
     *      [["backgroundColor"], [panel.style]],
     *      [["padding"], [panelContent.style]],
     *      [["overflow", "overflowX", "overflowY"], [this.style, panel.style, panelContent.style]]
     * ])
     */
    _setProperties(config, rules) {
        rules.forEach(rule => {
            let properties = rule[0]
            let targets = rule[1]

            properties.forEach(property => {
                let [configProperty, targetProperty] = property.split("=")

                if (config[configProperty] != null) {

                    let value = config[configProperty]

                    // Every property involving a dimension goes through "_computeSize" process
                    if ([
                            "padding",
                            "margin",
                            "top",
                            "right",
                            "bottom",
                            "left",
                            "width",
                            "minWidth",
                            "maxWidth",
                            "height",
                            "minHeight",
                            "maxHeight",
                            "fontSize",
                            "iconSize",
                            "borderWidth",
                            "borderRadius",
                            "fieldWidth",
                            "fieldHeight",
                            "labelWidth",
                            "headerHeight",
                            "colorWidth",
                            "colorHeight"
                        ].includes(configProperty)) {
                        value = this._computeSize(configProperty)
                    }

                    targets.forEach(target => {
                        if (target) {
                            if (!targetProperty) {
                                target[configProperty] = value
                            } else {
                                target[targetProperty] = value
                            }
                        }
                    })
                }
            })
        })
        return this
    }

    /**
     * Compute the element size. It can handle various use cases:
     * - the size is a static string, like "300px" or "5vw" or "80em" => it's applied "as this"
     * - the size is static number, like 300 => it's converted to pixels: "300px"
     * - the size is a function => it's computed before being applied
     * 
     * @private
     * @ignore
     * @param {string} type - Example: "width", "labelWidth", "height", "top", "fontSize"
     * @returns {string} The computed size
     */
    _computeSize(type) {
        let newSize = this.config[type]

        // Size is a function
        if (typeof newSize == "function") {
            try {
                newSize = newSize()
            } catch (err) {
                //log("Couldn't compute the size of an element: " + this.id)
                newSize = 0
            }
        }

        // Size if a number => convert it to pixels
        if (typeof newSize == "number") newSize = newSize.toString() + "px"

        return newSize
    }

    /**
     * Set the component's size
     * 
     * @param {object} [config.width] - Any CSS valid size, or a number (will be converted to pixels)
     * @param {object} [config.height] - Any CSS valid size, or a number (will be converted to pixels)
     * @returns this
     * 
     * @example
     * myComponent.setSize({width: "10vw"})
     * myComponent.setSize({height: "100px"})
     * myComponent.setSize({width: 300, height: "20%"})
     */
    setSize(config) {
        if (config.width) {
            this.config.width = config.width
            this._setWidth()
        }
        if (config.height) {
            this.config.height = config.height
            this._setHeight()
        }
        return this
    }

    /**
     * Set the component's left position
     * 
     * @param {string|function} newLeft - Any CSS valid size, or a function returning a size
     * @returns this
     */
    setLeft(newLeft) {
        this.config.left = newLeft
        this._setLeft()
        return this
    }

    /**
     * Set the component's top position
     * 
     * @param {string|function} newTop - Any CSS valid size, or a function returning a size
     * @returns this
     */
    setTop(newTop) {
        this.config.top = newTop
        this._setTop()
        return this
    }

    /**
     * Manage the component size & position
     * 
     * @private
     * @ignore
     */
    _setTop() {
        setTimeout(() => this.style.top = this._computeSize("top"), 0)
    }

    _setLeft() {
        setTimeout(() => this.style.left = this._computeSize("left"), 0)
    }

    _setBottom() {
        setTimeout(() => this.style.bottom = this._computeSize("bottom"), 0)
    }

    _setRight() {
        setTimeout(() => this.style.right = this._computeSize("right"), 0)
    }

    _setWidth() {
        setTimeout(() => this.style.width = this._computeSize("width"), 0)
    }

    _setMinWidth() {
        setTimeout(() => this.style.minWidth = this._computeSize("minWidth"), 0)
    }

    _setMaxWidth() {
        setTimeout(() => this.style.maxWidth = this._computeSize("maxWidth"), 0)
    }

    _setHeight() {
        setTimeout(() => this.style.height = this._computeSize("height"), 0)
    }

    _setMinHeight() {
        setTimeout(() => this.style.minHeight = this._computeSize("minHeight"), 0)
    }

    _setMaxHeight() {
        setTimeout(() => this.style.maxHeight = this._computeSize("maxHeight"), 0)
    }

    /**
     * Dispatch multiple CSS classes on a list of targeted classes elements
     * 
     * @private
     * @ignore
     * @param {object} cssClasses - Configuration should be passed as shown in the example below
     * @returns this
     * 
     * @example
     * this._dispatchClasses({
     *  "window-header": "myCSS1 myCSS2 myCSS3",
     *  "window-content": "myCSS4 myCSS5 myCSS6"
     * })
     */
    _dispatchClasses(cssClasses) {
        Object.keys(cssClasses).forEach(cssClass => {
            let arrayOfClasses = cssClasses[cssClass].split(/\s+/)

            try {
                // Add classes to the root element
                if (cssClass == "this") {
                    this.classList.add(...arrayOfClasses)
                }
                // Add classes to children nodes
                else {
                    let targetElement = this.querySelector("." + cssClass)
                    targetElement.classList.add(...arrayOfClasses)
                }
            } catch (err) {
                log(`Component._dispatchClasses: the class selector <${cssClass}> is not valid for the component <${this.id}>`, 2)
            }
        })
        return this
    }

    /**
     * Dispatch multiple styles on a list of targeted classes elements
     * 
     * @private
     * @ignore
     * @param {object} styles - Configuration should be passed as shown in the example below
     * @returns this
     * 
     * @example
     * this._dispatchStyles({
     *      "window-header": "background-color: #000000",
     *      "window-content": "background-color: #ffffff"
     * })
     */
    _dispatchStyles(styles) {
        if (styles) {
            Object.keys(styles).forEach(cssClass => {
                try {
                    // Add styles to the root element
                    if (cssClass == "this") {
                        let currentStyles = this.style.cssText
                        this.style = currentStyles + ";" + styles[cssClass]
                    }
                    // Add styles to children nodes
                    else {
                        let currentStyles = this.querySelector("." + cssClass).style.cssText
                        this.querySelector("." + cssClass).style = currentStyles + ";" + styles[cssClass]
                    }
                } catch (err) {
                    log(`Component._dispatchStyles: the class selector <${cssClass}> is not valid for the component <${this.id}>`, 2)
                }
            })
        }
        return this
    }

    /**
     * Toggle one or more CSS classes of a single HTMLElement
     * 
     * @private
     * @ignore
     * @param {string} cssClasses - String containing the names of the classes to toggle, separated with spaces. Ex: "panel panel-body"
     * @returns this
     */
    _toggleClass(cssClasses) {
        if (cssClasses) cssClasses.split(/\s+/).forEach(cssClass => this.classList.toggle(cssClass))
        return this
    }

    /**
     * Special method to manage the "locked" properties of fields components
     * 
     * @ignore
     */
    isLocked() {
        this.locker = `<span class="field-label-read-only fas fa-lock"></span> `
        return (this.config && this.config.label && this.config.locked === true) 
    }

    /**
     * Special method to manage the "required" properties of fields components
     * 
     * @ignore
     */
    isRequired() {
        this.asterisk = ` <span class="field-label-required"><sup>*</sup></span>`
        return (this.config && this.config.label && this.config.required === true && this.config.readOnly !== true && this.config.disabled !== true && !this.isLocked())
    }

    /**
     * Animate an HTMLElement.
     * 
     * - The animation must be set *before* rendering the component
     * - It's chainable, so it can be combined with render() and showAt()
     * 
     * Animation speed can be modified with the param "speed":
     * - slower
     * - slow
     * - fast
     * - faster
     * 
     * Animation repetition can be adjusted with the param "repeat":
     * - repeat-1
     * - repeat-2
     * - repeat-3
     * - infinite
     * 
     * Available animation names are:
     * - bounce
     * - flash
     * - pulse
     * - rubberBand
     * - shakeX
     * - shakeY
     * - headShake
     * - swing
     * - tada
     * - wobble
     * - jello
     * - heartBeat
     * - hinge
     * - jackInTheBox
     * - rollIn
     * - rollOut
     * - flipInX
     * - flipInY
     * - flipOutX
     * - flipOutY
     * - backInDown
     * - backInLeft
     * - backInRight
     * - backInUp
     * - backOutDown
     * - backOutLeft
     * - backOutRight
     * - backOutUp
     * - bounceIn
     * - bounceInDown
     * - bounceInLeft
     * - bounceInRight
     * - bounceInUp
     * - bounceOut
     * - bounceOutDown
     * - bounceOutLeft
     * - bounceOutRight
     * - bounceOutUp
     * - fadeIn
     * - fadeInDown
     * - fadeInDownBig
     * - fadeInLeft
     * - fadeInLeftBig
     * - fadeInRight
     * - fadeInRightBig
     * - fadeInUp
     * - fadeInUpBig
     * - fadeInTopLeft
     * - fadeInTopRight
     * - fadeInBottomLeft
     * - fadeInBottomRight
     * - fadeOut
     * - fadeOutDown
     * - fadeOutDownBig
     * - fadeOutLeft
     * - fadeOutLeftBig
     * - fadeOutRight
     * - fadeOutRightBig
     * - fadeOutUp
     * - fadeOutUpBig
     * - fadeOutTopLeft
     * - fadeOutTopRight
     * - fadeOutBottomLeft
     * - fadeOutBottomRight
     * - lightSpeedInRight
     * - lightSpeedInLeft
     * - lightSpeedOutRight
     * - lightSpeedOutLeft
     * - rotateIn
     * - rotateInDownLeft
     * - rotateInDownRight
     * - rotateInUpLeft
     * - rotateInUpRight
     * - rotateOut
     * - rotateOutDownLeft
     * - rotateOutDownRight
     * - rotateOutUpLeft
     * - rotateOutUpRight
     * - zoomIn
     * - zoomInDown
     * - zoomInLeft
     * - zoomInRight
     * - zoomInUp
     * - zoomOut
     * - zoomOutDown
     * - zoomOutLeft
     * - zoomOutRight
     * - zoomOutUp
     * - slideInDown
     * - slideInLeft
     * - slideInRight
     * - slideInUp
     * - slideOutDown
     * - slideOutLeft
     * - slideOutRight
     * - slideOutUp
     * 
     * @param {string|object} config - If the param is a string, it must be the animation name. Otherwise, it's a config like: {name: "zoomIn", speed: "fast", repeat: "repeat-3", callback: function() {...}}. Set the animation to false to remove the animation.
     * @param {string} config.name - Animation name
     * @param {string} [config.speed] - "slower" | "slow" | "fast" | "faster"
     * @param {string} [config.repeat] - "repeat-1" | "repeat-2" | "repeat-3" | "infinite"
     * @param {function} [config.callback] - Function to execute when the animation ends
     * @returns this - The component
     * 
     * @example
     * // Using only the animation name:
     * myComponent.setAnimation("fadeIn").render().showAt(100,100)
     * 
     * // Using a config object:
     * myComponent.setAnimation({
     *      name: "tada",
     *      speed: "fast",
     *      repeat: "repeat-1",
     *      callback: function() {
     *          this.hide()
     *      }
     * })
     * 
     * // Remove the animation
     * myComponent.setAnimation(false)
     */
    setAnimation(config) {
        // Remove all animation classes
        if (config === false) {
            Array.from(this.classList).forEach(className => {
                if (className.startsWith("animate__")) this.classList.remove(className)
            })
            return this
        }

        // Add animation classes
        let animationName, animationSpeed, animationRepeat

        if (typeof config === "string") {
            animationName = "animate__" + config
            animationSpeed = "animate__fast"
            animationRepeat = "animate__repeat-1"
        } else {
            animationName = (config.name) ? "animate__" + config.name : "animate__fadeIn"
            animationSpeed = (config.speed) ? "animate__" + config.speed : "animate__fast"
            animationRepeat = (config.repeat) ? "animate__" + config.repeat : "animate__repeat-1"
            this.animationCallback = config.callback
        }

        // Wait for the next frame before adding animation classes
        setTimeout(() => this.classList.add("animate__animated", animationName, animationSpeed, animationRepeat), 10)

        this.handleAnimationEnd = function (event) {
            event.stopPropagation()
            this.classList.remove("animate__animated", animationName, animationSpeed, animationRepeat)
            this.removeEventListener("animationend", this.handleAnimationEnd)

            if (typeof this.animationCallback === "function") this.animationCallback()
        }

        this.addEventListener("animationend", this.handleAnimationEnd, {
            once: true
        })

        return this
    }
};

/**
 * Find the Component encapsulating a DOM Element.
 * This is useful when you need to access the Component from an inner Element composing the Component.
 * 
 * @note
 * All the Components have their classname beginning with "a-", like "a-panel", "a-field", "a-button"...
 * So, we're simply looking for "a-" in the classname of the ancestors' hierarchy.
 * 
 * @param {HTMLElement} element - The element which we want to get the outer Component
 * @returns {HTMLElement} The DOM element found, or null
 */
HTMLElement.prototype.getComponent = function () {
    function getParent(node) {
        let parent = node.parentNode
        if (!parent) return null
        if (!parent.classList) return null
        if (parent.constructor.name == "HTMLDocument") return null
        return parent
    }

    let parentNode = this.parentNode
    while (getParent(parentNode)) {
        if (parentNode.classList.value != "") {
            if (parentNode.classList[0].slice(0, 2) == "a-") return parentNode
        }
        parentNode = parentNode.parentNode
    }

    return null
};

// Allow any HTMLElement to be processed in views like kiss Components
HTMLElement.prototype.render = kiss.ui.Component.prototype.render
HTMLElement.prototype._insertIntoDOM = kiss.ui.Component.prototype._insertIntoDOM
HTMLElement.prototype.show = kiss.ui.Component.prototype.show
HTMLElement.prototype.hide = kiss.ui.Component.prototype.hide
HTMLElement.prototype.showLoading = kiss.ui.Component.prototype.showLoading
HTMLElement.prototype.hideLoading = kiss.ui.Component.prototype.hideLoading
HTMLElement.prototype.attachTip = kiss.ui.Component.prototype.attachTip
HTMLElement.prototype.detachTip = kiss.ui.Component.prototype.detachTip
HTMLElement.prototype.setAnimation = kiss.ui.Component.prototype.setAnimation

;/** 
 * 
 * The Container derives from [Component](kiss.ui.Component.html).
 * 
 * A Container is useful to embed other items.
 * Containers can also embed other containers to build complex layouts.
 * 
 * The Container class should not be instanciated directly: it's the base class for the 2 types of containers:
 * - [Block](kiss.ui.Block.html), which is a simple "div" container
 * - [Panel](kiss.ui.Panel.html), which has a header and is useful to build windows or modals, for example.
 * 
 * It's also possible to bind a Record to a container:
 * - in this case, the record will be bound to all the container's fields (text, number, date, checkbox, select...)
 * - the fields will be automatically synchronized with the Record, **but only if their id matches a record's property**
 * - it's a 2-way binding:
 *      - if a field of the container is updated, the database will be updated automatically
 *      - if the database is updated, the fields will react to the change as well
 * 
 * @param {object} config
 * @param {object[]} config.items - The array of contained items
 * @param {string} [layout] - "vertical" | "horizontal". Shortcut to define flex + flexFlow properties at the same time.
 * @param {boolean} [multiview] - If true, only displays one item at a time
 * @param {string} [align] - "center" to automatically center the container horizontally
 * @param {string} [verticalAlign] - "center" to automatically center the container vertically
 * @param {Record} [config.record] - Record to bind to the contained fields. The fields will be synchronized with the record.
 * @returns this
 * 
 * @example
 * let myRecord = myModel.create({firstName: "Bob", lastName: "Wilson"})
 * await myRecord.save()
 * 
 * let myForm = createPanel({
 *  title: "Binding example",
 *  width: 300,
 *  height: 300,
 *  align: "center",
 *  verticalAlign: "center",
 * 
 *  record: myRecord, // Bind the record to the container's fields
 * 
 *  items: [
 *      {
 *          id: "firstName", // Updating the field will update the database
 *          type: "text",
 *          value: myRecord.firstName
 *      },
 *      {
 *          id: "lastName",
 *          type: "text",
 *          value: myRecord.lastName
 *      }
 *  ]
 * }).render()
 * 
 * await myRecord.update({firstName: "Will"}) // Updating the database will update the field in the UI
 * 
 */
kiss.ui.Container = class Container extends kiss.ui.Component {
    constructor() {
        super()
    }

    /**
     * Generates a Container and all its contained items, which are defined from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config) {

        // Define a vertical or horizontal layout (= "layout" is a shortcut to define flex + flexFlow properties at the same time)
        if (config.layout) {
            config.display = "flex"

            if (config.layout == "vertical") {
                config.flexFlow = "column"
            } else if (config.layout == "horizontal") {
                config.flexFlow = "row"
            }
        }

        // Init the base component
        super.init(config)

        if (this.type == "block") this.containerId = this.id
        else this.containerId = "panel-body-" + this.id // panel and wizardPanel

        // Bind a record to the contained fields
        if (config.record) config.items.forEach(item => {
            if (item.items || kiss.global.fieldTypes.map(type => type.value).includes(item.type)) {
                item.record = config.record
            }
        })

        // Insert items into the container (and filters out deleted items)
        this.items = []
        this.config.items = this.config.items || []
        this._insertItems(this.config.items)

        // Observe the window resize
        this.subscriptions = this.subscriptions || []

        // Adjust top and left property if the component is auto-centered
        let _this = this
        if (this.config.align == "center" && !this.config.left) this.config.left = () => (kiss.screen.current.width - $(_this.id).clientWidth) / 2
        if (this.config.verticalAlign == "center" && !this.config.top) this.config.top = () => (kiss.screen.current.height - $(_this.id).clientHeight) / 2

        // Add the container to the resize observer & flag the component as a container (containers are unobserved when destroyed)
        this.isContainer = true
        kiss.screen.getResizeObserver().observe(this)

        return this
    }

    /**
     * For multiview containers, show only a specific item of the container, given by index
     * 
     * @param {number} itemIndex
     * @param {object|string} [animation] - Optional animation when displaying the item
     * @returns this
     */
    showItem(itemIndex, animation) {
        if (itemIndex > this.items.length) return
        if (this.activeItemIndex == itemIndex) return

        this.activeItemIndex = itemIndex
        for (let i = 0; i < this.items.length; i++) this.items[i].hide()
        this.items[itemIndex].show()

        if (animation) this.items[itemIndex].setAnimation(animation)
        return this
    }

    /**
     * For multiview containers, show only a specific item of the container, given by id
     * 
     * @param {string} id
     * @param {object|string} [animation] - Optional animation when displaying the item
     * @returns this
     */
    showItemById(itemId, animation) {
        let itemIndex = this.items.findIndex(item => item.id == itemId)
        if (itemIndex != -1) this.showItem(itemIndex, animation)
        return this
    }

    /**
     * For multiview containers, show only a specific item of the container, given by CSS class
     * 
     * @param {string} className
     * @param {object|string} [animation] - Optional animation when displaying the item
     * @returns this
     */
    showItemByClass(className, animation) {
        let itemIndex = this.items.findIndex(item => Array.from(item.classList).includes(className))
        if (itemIndex != -1) this.showItem(itemIndex, animation)
        return this
    }

    /**
     * Returns the HTMLElement which is the real container of the component.
     * It can differ depending on the component type.
     * For example, for a panel, the container is the panel body.
     * 
     * @returns {HTMLElement} The real component's container
     */
    getContainer() {
        return $(this.containerId)
    }

    /**
     * Get the ids of all the contained items.
     * Can be useful to check if a component is contained by this container.
     * 
     * @returns {string[]}
     */
    getComponentIds() {
        let ids = []
        ids.push(this.id)

        this.items.forEach(function (item) {
            if (item.items) ids.push(item.getComponentIds())
            else if (item.id) ids.push(item.id)
        })
        return ids.flat()
    }

    /**
     * Set container items.
     * 
     * Overwrite existing items if the container is not empty.
     * 
     * @param {object[]} newItems - Array of new items
     * @returns this
     */
    setItems(newItems) {
        const containerElement = this.getContainer()
        containerElement.deepDelete(false)

        // Reset items and also items configuration
        this.items = []
        this.config.items = []

        // Insert new items and re-render
        this._insertItems(newItems)
        this.render(this.target, false)

        return this
    }

    /**
     * Insert items and manage multiview.
     * For multiview containers, only the first item is displayed, other items are hidden.
     * 
     * @private
     * @ignore
     * @param {*} newItems - Items to insert: can be an HTMLElement, a Component, or a Component's JSON config, or all mixed
     */
    _insertItems(newItems) {
        if (this.config.multiview) {
            this.activeItemIndex = 0

            newItems.forEach((item, index) => {
                // Insert the first element
                if (index == 0) {
                    this._insertOrAddItem(item)
                    return
                }

                // Other items must be hidden.
                // An item can be a component JSON config or an HTMLElement
                if (item.tagName) {
                    // It's an HTMLElement, hide it
                    item.hide()
                }
                else {
                    // It's a JSON config: the component is not instanciated yet so we just edit its "hidden" property
                    item.hidden = true
                }

                this._insertOrAddItem(item)
            })
        } else {
            newItems.forEach((item) => this._insertOrAddItem(item))
        }
    }

    /**
     * Insert or add a child item into the container
     * 
     * @private
     * @ignore
     * @param {object} item - Item JSON configuration
     * @param {number} position - Position at which to insert the new item, for insert operations
     * @param {boolean} isNewItem - If true, the item is also added to the initial config object
     * @returns Inserted item
     */
    _insertOrAddItem(item, position, isNewItem) {
        if (!item) return

        // Set the DOM insertion node
        item.target = this.containerId

        // Apply container defaults to the item
        const containerDefaults = this.config.defaultConfig

        if (containerDefaults) {
            for (let defaultProperty in containerDefaults) {
                if (!item[defaultProperty]) item[defaultProperty] = containerDefaults[defaultProperty]
            }
        }

        // Build the new item
        let newItem = this._createNewItem(item)

        if (position != null) {
            // Insert
            //log("kiss.ui.Container - Inserting...... " + item.id + " to " + this.id)
            this.config.items.splice(position, 0, item)
            const targetNode = this.items[position]
            this.items.splice(position, 0, newItem)
            this.insertBefore(newItem, targetNode)
        } else {
            // Add
            //log("kiss.ui.Container - Adding...... " + item.id + " to " + this.id)
            if (isNewItem) this.config.items.push(item)
            this.items.push(newItem)
        }

        return newItem
    }

    /**
     * Creates a new item into the container
     * 
     * @private
     * @ignore
     * @param {object|HTMLElement} item - The item can be a JSON config (= the Component or View has to be built), or an HTMLElement (which can be directly inserted)
     */
    _createNewItem(item) {
        // If the item has no "render" method, it means it's a component config, and we have to generate the markup
        if (!item.render) {
            // Generate items according to their type
            // If no type is specified, KissJS builds a basic "block" container
            const type = item.type

            if (type) {
                if (["text", "textarea", "number", "date", "password", "lookup", "summary"].includes(type)) {
                    // Input fields and textarea
                    return document.createElement("a-field").init(item)
                }
                else if (type == "view") {
                    // Build a view
                    return kiss.views.buildView(item.id, this.containerId)
                }
                else {
                    // Other fields and elements
                    return document.createElement("a-" + type.toLowerCase()).init(item)
                }
            }
            else {
                // Block
                return document.createElement("a-block").init(item)
            }
        } else {
            // The item has a render method: it means it's already a Component and we inject it "as this" into the container
            return item
        }
    }

    /**
     * Add a child item into the container
     * 
     * @param {object} item - Item JSON configuration
     * @returns this
     */
    addItem(item) {
        let insertedItem = this._insertOrAddItem(item, null, true)
        insertedItem.render()
        return this
    }

    /**
     * Insert a child item into the container at a specified position
     * 
     * @param {object} item - Item JSON configuration
     * @param {number} position
     * @returns this
     */
    insertItem(item, position) {
        let insertedItem = this._insertOrAddItem(item, position)
        insertedItem.render()
        return this
    }

    /**
     * Delete an item from the container
     * 
     * @param {string} itemId
     * @returns this
     */
    deleteItem(itemId) {
        this.config.items = this.config.items.filter(item => item.id != itemId)
        this.items = this.items.filter(item => item.id != itemId)
        $(itemId).deepDelete()
        return this
    }

    /**
     * Find all the panels inside a container and expand them recursively
     * 
     * @returns this
     */
    expandAll() {
        this.items.forEach(function (item) {
            if (item.items) {
                if (item.type == "panel") item.expand()
                item.expandAll()
            }
        })
        return this
    }

    /**
     * Find all the panels inside a container and collapse them recursively
     * 
     * @returns this
     */
    collapseAll() {
        this.items.forEach(function (item) {
            if (item.items) {
                if (item.type == "panel") item.collapse()
                item.collapseAll()
            }
        })
        return this
    }

    /**
     * Get all the fields found in this container
     * 
     * @returns {Object[]} An array of objects containing the fields
     */
    getFields() {
        let values = []

        Array.from(this.getContainer().children).forEach(function (item) {
            if (item.items) {
                values.push(item.getFields())
            } else {
                if (kiss.global.fieldTypes.map(type => type.value).indexOf(item.type) != -1) {
                    values.push(item)
                }
            }
        })

        return values.flat()
    }

    /**
     * Reset all the fields found in this container
     * 
     * @returns this
     */
    resetFields() {
        const fields = this.getFields()
        fields.forEach(field => field.clearValue())
    }

    /**
     * Get all the elements found in this container
     * 
     * Elements are non-field items, like:
     * - html
     * - image
     * - button
     * 
     * @returns {Object[]} An array of objects containing the elements
     */
    getElements() {
        let values = []

        Array.from(this.getContainer().children).forEach(function (item) {
            if (item.items) {
                values.push(item.getElements())
            } else {
                if (kiss.global.elementTypes.map(type => type.value).indexOf(item.type) != -1) {
                    values.push(item)
                }
            }
        })

        return values.flat()
    }    

    /**
     * Validate all the container's fields and return the result
     * 
     * @returns {boolean} true if all fields have passed the validation
     */
    validate() {
        let isValid = true
        const fields = this.getFields()
        fields.forEach(field => {
            let fieldElement = this.querySelector("#" + field.id.replaceAll(":", "\\:"))
            isValid = isValid && fieldElement.validate()
        })
        
        if (!isValid) createNotification(txtTitleCase("#fields incorrect value"))
        return isValid
    }

    /**
     * Get fields data found in this container.
     * 
     * This method:
     * - finds all the contained items which are fields
     * - also explores nested containers, if any
     * 
     * @param {object} config
     * @param {boolean} config.useLabels - If true, return data using field labels instead of field ids
     * @returns {object}
     * 
     * @example
     * let formData = myForm.getData()
     * console.log(formData) // {title: "Training ICT", amount: 1234.56, dueDate: "2020-02-20T20:19:15Z"}
     * 
     * formData = myForm.getData({
     *  useLabels: true
     * })
     * console.log(formData) // {"Lead name": "Training ICT", "Lead amount": 1234.56, "Due date": "2020-02-20T20:19:15Z"}
     */
    getData(config) {
        let record = {}
        this.getFields().forEach(function (field) {
            if (config && config.useLabels) {
                let label = field.getLabel()
                if (!label) label = field.id
                label = label.replaceAll(" *", "") // Remove asterisks of mandatory fields
                record[label] = field.getValue()
            }
            else {
                record[field.id] = field.getValue()
            }
        })
        return record
    }

    /**
     * Set the value of the fields found in this container, given a data object.
     * 
     * This method:
     * - finds all the contained items which are fields
     * - also explores nested containers, if any
     * - set their value if the field id matches a property of the given data object
     * 
     * @param {object} data
     * @param {boolean} [rawUpdate] - If true, the field's value is updated without triggering the "change" event. Default is false.
     * @returns this
     * 
     * @example
     * const data = {title: "Training ICT", amount: 1234.56, dueDate: "2020-02-20T20:19:15Z"}
     * myForm.setData(data)
     */
    setData(data, rawUpdate) {
        this.getFields().forEach(function (field) {
            if (data[field.id] != undefined) field.setValue(data[field.id], rawUpdate)
        })
        return this
    }

    /**
     * Update layout of the component with its new config parameters.
     * It affects:
     * - the size properties
     * - the position
     * 
     * It can be useful to update the layout for example when:
     * - the global window (screen) is resized
     * - the parent container is resized
     * - a parameter used in the function to compute a width or height has changed
     * 
     * Note: the layout is updated only if the Element is connected to the DOM.
     * 
     * @returns this
     * 
     * @example
     * myComponent.updateLayout()
     */
    updateLayout() {
        if (this.isConnected) {
            // Width
            this._setWidth()
            this._setMinWidth()
            this._setMaxWidth()

            // Height
            this._setHeight()
            this._setMinHeight()
            this._setMaxHeight()

            // Position
            this._setTop()
            this._setLeft()
        }
        return this
    }

    /**
     * Set the label position of all the container's fields
     * 
     * @param {string} position - "left" (default) | "top" | "right" | "bottom"
     * @returns this
     */
    setLabelPosition(position = "left") {
        const fields = this.getFields()

        if (position == "top" || position == "bottom") {
            fields.forEach(item => {
                if (item.field) item.field.style.transition = "all 0.1s"

                if (item.setFieldWidth) item.setFieldWidth("100%")

                if (item.label) {
                    item.label.style.transition = "all 0.1s"
                    if (item.setLabelPosition) {
                        item.setLabelPosition(position)
                    }
                    if (item.setLabelWidth) {
                        item.setLabelWidth("100.00%")
                    }
                }
            })
        } else if (position == "left" || position == "right") {
            fields.forEach(item => {
                if (item.field) item.field.style.transition = "all 0.1s"

                if (item.setFieldWidth) item.setFieldWidth("50%")

                if (item.label) {
                    item.label.style.transition = "all 0.1s"
                    if (item.setLabelPosition) {
                        item.setLabelPosition(position)
                    }
                    if (item.setLabelWidth) {
                        item.setLabelWidth("50.00%")
                    }
                }
            })
        }
        return this
    }

    /**
     * Set the label size of all the container's fields
     * 
     * @param {string} size - "1/6" | "1/4" | "1/3" (default) | "1/2" | "2/3" | "3/4"
     * @returns this
     */
    setLabelSize(size = "1/3") {
        const fields = this.getFields()
        let labelSize
        let fieldSize

        switch (size) {
            case "1/6":
                labelSize = "16.66%"
                fieldSize = "83.33%"
                break
            case "1/4":
                labelSize = "25.00%"
                fieldSize = "75.00%"
                break
            case "1/3":
                labelSize = "33.33%"
                fieldSize = "66.66%"
                break
            case "1/2":
                labelSize = "50.00%"
                fieldSize = "50.00%"
                break
            case "2/3":
                labelSize = "66.66%"
                fieldSize = "33.33%"
                break
            case "3/4":
                labelSize = "75.00%"
                fieldSize = "25.00%"
                break
        }

        fields.forEach(item => {
            // Don't modify fields with labels at the top or bottom
            if (item.style.flexFlow == "column") return

            if (item.field) item.field.style.transition = "all 0.1s"
            if (item.setFieldWidth) item.setFieldWidth(fieldSize)

            if (item.label) {
                item.label.style.transition = "all 0.1s"
                if (item.setLabelWidth) item.setLabelWidth(labelSize)
            }
        })
        return this
    }

    /**
     * Set the label alignment of all the container's fields
     * 
     * @param {string} position - "left" (default) | "right"
     * @returns this
     */
    setLabelAlign(position = "left") {
        const fields = this.getFields()

        fields.forEach(item => {
            if (item.label) {
                item.label.style.transition = "all 1s"
                item.config.labelAlign = item.label.style.textAlign = position
            }
        })
        return this
    }

    /**
     * Dispatch container's content on multiple columns
     * 
     * @param {number} numberOfColumns
     * @returns this
     */
    setColumns(numberOfColumns = 1) {
        const fields = this.getFields()
        const elements = this.getElements()
        const items = fields.concat(elements)
        const percent = (100 / numberOfColumns).toFixed(2) + "%"

        if (numberOfColumns > 1) this.setDisplayMode("block")
        else this.setDisplayMode("flex")

        items.forEach(item => {
            const displayType = (item.type == "html") ? "block" : "flex"
            if (!item.config.deleted) item.style.display = item.config.display = "inline-" + displayType
            if (item.field) item.field.style.transition = "all 1s"
            if (item.setWidth) item.setWidth(percent)
        })
        return this
    }

    /**
     * Set the display mode
     * 
     * @param {string} mode - "flex" | "inline-flex" | "block" | "inline-block"
     */
    setDisplayMode(mode = "flex") {
        this.config.display = this.container.style.display = mode
    }
}

;/**
 * 
 * The DataComponent derives from [Component](kiss.ui.Component.html).
 * 
 * This is an **abstract class**: don't use it directly.
 * It's the base class for all the components used to display a collection of records, like:
 * - Datatable
 * - Calendar
 * - Kanban
 * - Timeline
 * - ChartView
 * - Dashboard
 * 
 * Each **DataComponent** is associated with its own Collection.
 * 
 * The Collection can be provided directly in the config.
 * If not, a Model must be passed instead, and a new Collection will be created from this Model.
 * 
 * A **DataComponent** can manipulate its collection:
 * - selecting the fields to display
 * - filtering the data
 * - sorting the data
 * - grouping the data
 * 
 * These operations are achieved thanks to built-in windows that you can display using:
 * ```
 * // Display the window to select fields
 * myComponent.showFieldsWindow(x, y, color)
 * 
 * // Display the window to sort data
 * myComponent.showSortWindow(x, y, color)
 * 
 * // Display the window to filter data
 * myComponent.showFilterWindow(x, y, color)
 * ```
 * 
 * A **DataComponent** can persist its configuration inside its associated record, using updateConfig method.
 * 
 * A **DataComponent** needs to be setup with either a collection or a model.
 * For this, you can directly pass the collection or the model in the config.
 * Or you can pass a collectionId or a modelId, and the component will retrieve the collection or the model from the ones declared in kiss.app.models and kiss.app.collections.
 * 
 * @param {object} config
 * @param {object} [config.collection] - Optional collection.
 * @param {string} [config.collectionId] - Optional collectionId.
 * @param {object} [config.model] - Optional model.
 * @param {string} [config.modelId] - Optional modelId.
 * @param {object} [config.record] - Optional record to persist the view configuration.
 * @returns {HTMLElement}
 */
kiss.ui.DataComponent = class DataComponent extends kiss.ui.Component {
    constructor() {
        super()
    }

    init(config = {}) {
        super.init(config)

        if (config.collection) {
            // Case a) a Collection is given in the config
            // In that case, the Model is taken from the Collection definition
            this.collection = config.collection
            this.model = config.model || this.collection.model
            this.modelId = this.model.id
        } else if (config.model) {
            // Case b) a Model is given in the config
            // In that case, create and register a new Collection from the Model
            this.model = config.model
            this.modelId = this.model.id
            this.collection = new kiss.data.Collection({
                model: this.model,
                sort: [{
                    [this.model.getPrimaryKeyField().id]: "asc" // Sort on the primary key field by default
                }]
            })
        } else if (config.collectionId) {
            // Case c) a CollectionId is given in the config
            // In that case, create and register a new Collection from the CollectionId
            this.collection = kiss.app.collections[config.collectionId]
            this.model = this.collection.model
            this.modelId = this.model.id
        }
        else if (config.modelId) {
            // Case d) a ModelId is given in the config
            // In that case, create and register a new Collection from the ModelId
            this.model = kiss.app.models[config.modelId]
            this.modelId = this.model.id
            this.collection = new kiss.data.Collection({
                model: this.model,
                sort: [{
                    [this.model.getPrimaryKeyField().id]: "asc" // Sort on the primary key field by default
                }]
            })
        }

        this._initParameters()
        return this
    }

    /**
     * Apply filter, sort, group, projection, groupUnwind.
     * If a record is binded to persist the view configuration, we take the view parameters from this record.
     * Priority is given to local config, then to the passed collection, then to default.
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initParameters() {
        if (this.config.record) {
            this.record = this.config.record
            this.id = this.record.id
            this.name = this.record.name
            this.filter = this.record.filter || {}
            this.filterSyntax = this.record.filterSyntax || this.collection.filterSyntax || "normalized"
            this.sort = this.record.sort || this.collection.sort || []
            this.sortSyntax = this.record.sortyntax || this.collection.sortyntax || "normalized"
            this.group = this.record.group || this.collection.group || []
            this.projection = this.record.projection || this.collection.projection || {}
            this.groupUnwind = this.record.groupUnwind || this.collection.groupUnwind || false
            this.canCreateRecord = (this.record.canCreateRecord !== false)
        } else {
            this.id = this.config.id || kiss.tools.shortUid()
            this.name = this.config.name
            this.filter = this.config.filter || this.collection.filter || {}
            this.filterSyntax = this.config.filterSyntax || this.collection.filterSyntax || "normalized"
            this.sort = this.config.sort || this.collection.sort || []
            this.sortSyntax = this.config.sortyntax || this.collection.sortyntax || "normalized"
            this.group = this.config.group || this.collection.group || []
            this.projection = this.config.projection || this.collection.projection || {}
            this.groupUnwind = this.config.groupUnwind || this.collection.groupUnwind || false
            this.canCreateRecord = (this.config.canCreateRecord !== false)
        }

        // Apply local configuration, if any
        this.localConfig = this.getLocalConfig()
        if (this.localConfig) {
            if (this.localConfig.filter) this.filter = this.localConfig.filter
            if (this.localConfig.sort) this.sort = this.localConfig.sort
            if (this.localConfig.group) this.group = this.localConfig.group
        }

        return this
    }

    /**
     * show search bar immediately after being connected, if there is an active search
     * 
     * @private
     * @ignore
     */
    _afterConnected() {
        if (this.currentSearchTerm) {
            this.showSearchBar()
        } else {
            this.resetSearchBar()
        }
    }

    /**
     * Hide search bar immediately after being disconnected
     * 
     * @private
     * @ignore
     */
    _afterDisconnected() {
        if (this.currentSearchTerm) this.hideSearchBar()
    }

    /**
     * Initialize subscriptions to PubSub
     * 
     * @private
     * @ignore
     */
    _initSubscriptions() {
        this.subscriptions = [
            // Local events (not coming from websocket)
            subscribe("EVT_VIEW_SORTING:" + this.id, (msgData) => this._dataSort(msgData)),
            subscribe("EVT_VIEW_FILTERING:" + this.id, (msgData) => this._dataFilterBy(msgData)),
            subscribe("EVT_VIEW_GROUPING:" + this.id, (msgData) => this._dataGroupBy(msgData)),

            subscribe("EVT_VIEW_FIELD_TOGGLED_ONE:" + this.id, (fieldId) => this._columnsToggleOne(fieldId)),
            subscribe("EVT_VIEW_FIELD_TOGGLED_ALL:" + this.id, (newState) => this._columnsToggleAll(newState)),
            subscribe("EVT_VIEW_FIELD_MOVING:" + this.id, (msgData) => this._columnsMove(msgData.sourceFieldId, msgData.targetFieldId, msgData.position)),

            /*
             * View changes must be propagated to all **other** connected clients.
             * View changes come from various events, like:
             * 
             * I) Model updates
             * - field add
             * - field update
             * - field delete
             * 
             * II) View updates
             * - filter
             * - sort
             * - group
             * - projection (not implemented yet: all columns are loaded then hidden/shown)
             * - move column
             * - show/hide column
             * - show/hide record creation button
             */
            subscribe("EVT_DB_UPDATE:VIEW", (msgData) => {
                if (msgData.id != this.id) return

                // Update the component setup
                if (msgData.data.filter) this.filter = msgData.data.filter
                if (msgData.data.sort) this.sort = msgData.data.sort
                if (msgData.data.group) this.group = msgData.data.group
                if (msgData.data.projection) this.projection = msgData.data.projection
                
                // Update the component toolbar
                if (msgData.data.hasOwnProperty("canCreateRecord")) {
                    this.canCreateRecord = !!msgData.data.canCreateRecord
                    this._updateToolbar()
                }

                // Will force the collection to reload for the next find() request
                this.collection.hasChanged = true

                // Re-compute columns (a combination of existing views columns, model fields, and plugin fields)
                // Patch columns in the record or locally
                if (msgData.data.config && msgData.data.config.columns) {
                    if (this.record) {
                        this.record.config.columns = msgData.data.config.columns
                    } else {
                        this.config.columns = msgData.data.config.columns
                    }
                    this._initColumns()

                    // If we only changed the columns, it's not necessary to reload the collection
                    this.collection.hasChanged = false
                }

                // Update + display a message if the connected user is not the one who updated
                this._reloadWhenNeeded(msgData, 0)
            }),

            // TODO: Update the view => mostly used for ACL change, but redundant most of the time with EVT_DB_UPDATE:VIEW
            // TODO: Remove this and add an ACL change event (less generic than a model update)
            subscribe("EVT_DB_UPDATE:MODEL", (msgData) => {
                if (msgData.id == this.model.id) {
                    this.reload()
                }
            }),

            // When records are deleted, we need to remove them from the view selection
            subscribe("EVT_DB_DELETE:" + this.model.id.toUpperCase(), (msgData) => {
                kiss.selection.delete(this.id, msgData.id)
            }),

            subscribe("EVT_DB_DELETE_MANY:" + this.model.id.toUpperCase(), (msgData) => {
                const filter = msgData.data
                if (filter && filter._id && filter._id.$in) {
                    const ids = filter._id.$in
                    ids.forEach(id => kiss.selection.delete(this.id, id))
                }
            })
        ]
    }

    /**
     * Reload the view when needed.
     * 
     * It depends:
     * - if the view is connected to the DOM
     * - if the update has been done by the active user
     * 
     * @private
     * @ignore
     * @param {object} msgData - The original pubsub message
     * @param {number} [delay] - Delay to retard the reload, when the back-end update needs time
     */
    async _reloadWhenNeeded(msgData, delay) {

        // If the datatable exists but is not connected, it means it's in the cache.
        // We can't reload it, but we put a flag on it so it will be reloaded when displayed again
        if (!this.isConnected) {
            this.hasChanged = true
            return
        }

        // Reload the view only if the application global state allows to refresh the view
        // For example, this is forbidden while batch updates
        if (kiss.global.preventViewRefresh) {
            return
        }

        // Reload the view only if the user is the author of the updates
        if (kiss.session.getUserId() == msgData.userId) {
            if (delay) await kiss.tools.wait(delay)
            await this.reload()
        }
    }

    /**
     * 
     * DATA SORT MANAGEMENT
     * 
     */

    /**
     * Sort by an array of fields
     * 
     * @async
     * @param {object[]} sortFields - Array where each object is a sort option, like: {firstName: "asc"}
     * 
     * @example
     * myDatatable.sortBy([
     *  {
     *      birthDate: "desc"
     *  },
     *  {
     *      lastName: "asc"
     *  }
     * ])
     */
    async sortBy(sortFields) {
        this.sort = sortFields
        await this._dataSortUpdate()
    }

    /**
     * Sort by a single field
     * 
     * @async
     * @param {string} fieldId 
     * @param {string} direction - "asc" | "desc"
     * 
     * @example
     * myDatatable.sortByField("birthDate", "desc")
     */
    async sortByField(fieldId, direction) {
        const currentSortFields = this.sort
        let isSortUpdated = false

        currentSortFields.forEach(sortField => {
            if (Object.keys(sortField)[0] == fieldId) {
                sortField[fieldId] = direction
                isSortUpdated = true
            }
        })

        if (!isSortUpdated) {
            currentSortFields.push({
                [fieldId]: direction
            })
        }

        await this.sortBy(currentSortFields)
    }

    /**
     * Update the sort according to the message received in the PubSub
     * 
     * @ignore
     * @param {object} msgData 
     */
    async _dataSort(msgData) {
        if (msgData.sortAction == "remove") {
            await this._dataSortRemove(msgData.sortIndex)
        } else {
            await this._dataSortBy(msgData.sortFieldName, msgData.sortDirection, msgData.sortIndex)
        }
    }

    /**
     * Sort the table by a specific field.
     * If the field hasn't been used yet to sort the datatable, then a new sort option is added.
     * If the field has already been used to sort the datatable, then the sort option is updated.
     * 
     * @private
     * @ignore
     * @param {string} fieldId - Field used to sort the datatable
     * @param {string} sortOrder - "asc" or "desc"
     * @param {number} sortIndex - position of the sort option to add/update
     */
    async _dataSortBy(fieldId, sortOrder, sortIndex) {
        let newSortOption = {}
        newSortOption[fieldId] = sortOrder

        if (this.sort.length == 0) {
            this.sort.push(newSortOption)
        } else {
            this.sort[sortIndex] = newSortOption
        }

        await this._dataSortUpdate()
    }

    /**
     * Remove one of the sort options
     * 
     * @private
     * @ignore
     * @param {number} sortIndex - Index of the sort option to remove
     */
    async _dataSortRemove(sortIndex) {
        this.sort.splice(sortIndex, 1)
        await this._dataSortUpdate()
    }

    /**
     * Update the sort options
     * 
     * @private
     * @ignore
     */
    async _dataSortUpdate() {
        // Sort view data with new sort params
        await this.collection.sortBy(this.sort)
        this._render()

        // Save new sort options
        await this.updateConfig({
            sort: this.sort
        })

        // Broadcast changes for local and offline, so that "dataSortWindow" can be updated (check dataSortWindow.js)
        kiss.pubsub.publish("EVT_VIEW_SORTED:" + this.id)

        // Broadcast changes for the parent dashboard, if any
        if (this.dashboard) kiss.pubsub.publish("EVT_DASHBOARD_SETUP", this.id)
    }

    /**
     * 
     * DATA GROUPING MANAGEMENT
     * 
     */

    /**
     * Group by a list of fields
     * 
     * @param {string[]} groupFields - List of field names (not ids)
     * 
     * @example
     * myDatatable.groupBy(["Country", "City", "Age"])
     */
    groupBy(groupFieldIds) {
        $("grouping-field:" + this.id).setValue(groupFieldIds)
    }

    /**
     * Group data by a list of fields
     * 
     * @private
     * @ignore
     * @param {string[]} groupFields - Array of fields to group by.
     */
    async _dataGroupBy(groupFields) {
        // Generates the groups, then get the grouped records
        this.skip = 0
        await this.collection.groupBy(groupFields)
        this._render()

        // Show / hide:
        // - Expand and Collapse buttons
        // - Switch hierarchy button
        if (groupFields.length === 0) {
            this.buttonExpand.hide()
            this.buttonCollapse.hide()
        } else {
            this.buttonExpand.show()
            this.buttonCollapse.show()
        }

        // Save the new group config
        this.group = groupFields
        await this.updateConfig({
            group: this.group
        })
    }

    /**
     * Expand / Collapse a group
     * 
     * @private
     * @ignore
     * @param {string} groupId - Id of the group to expand/collapse. Example: 3.10.7
     * @param {number} rowIndex - Index of the group row into the datatable
     */
    _groupToggle(groupId, groupLevel, rowIndex) {
        if (this.collection.collapsedGroups.includes(groupId)) {
            this._groupExpand(groupId, rowIndex)
        } else {
            this._groupCollapse(groupId)
        }
    }

    /**
     * Expand a group
     * 
     * @private
     * @ignore
     * @param {string} groupId - Id of the group to expand/collapse. Example: 3.10.7
     * @param {number} rowIndex - Index of the group row into the datatable
     */
    _groupExpand(groupId, rowIndex) {
        this.collection.groupExpand(groupId, rowIndex)
        this._render()
        this._renderScroller()
    }

    /**
     * Collapse a group
     * 
     * @private
     * @ignore
     * @param {string} groupId - Id of the group to expand/collapse. Example: 3.10.7
     */
    _groupCollapse(groupId) {
        this.collection.groupCollapse(groupId)
        this._render()
    }

    /**
     * Expand all groups
     * 
     * @ignore
     */
    expandAll() {
        this.collection.groupExpandAll()
        this._render()
    }

    /**
     * Collapse all groups
     * 
     * @ignore
     */
    collapseAll() {
        this.skip = 0
        this.collection.groupCollapseAll()
        this._render()
    }    

    /**
     * Update the list of grouping fields that appear in the "Group by" field
     * 
     * @private
     * @ignore
     */
    _groupUpdateGroupingFields() {
        if (!this.isConnected) return

        const groupingField = $("grouping-field:" + this.id)
        const modelFields = this._groupGetModelFields()

        groupingField.value = this.group
        groupingField.updateOptions(modelFields)
    }

    /**
     * Get the list of grouping fields that appear in the "Group by" field
     * 
     * @private
     * @ignore
     * @param {object} config
     * @param {boolean} config.excludeSystemFields - Exclude system fields from the list. Default to false
     * @param {boolean} config.excludePluginFields - Exclude plugin fields from the list. Default to false
     */
    _groupGetModelFields(config = {}) {
        const isDynamicModel = kiss.tools.isUid(this.model.id)
        const excludedFields = ["password", "link", "attachment", "aiImage", "textarea", "aiTextarea", "richTextField", "codeEditor", "mapField"]
        
        let modelFields = this.model.fields.filter(field => !excludedFields.includes(field.type) && field.label && field.deleted != true)

        if (config.excludeSystemFields) modelFields = modelFields.filter(field => !field.isSystem)
        if (config.excludePluginFields) modelFields = modelFields.filter(field => !field.isFromPlugin)

        return modelFields.map(field => {
            return {
                value: field.id,
                label: (isDynamicModel && !field.isSystem) ? field.label.toTitleCase() : txtTitleCase(field.label)
            }
        })
    }

    /**
     * Update the filter
     * 
     * @private
     * @ignore
     * @param {object} filterConfig 
     */
    async _dataFilterBy(filterConfig) {
        // Reset ftsearch
        this.resetSearchBar()

        // Filter view data with new filter params
        this.skip = 0
        await this.collection.filterBy(filterConfig)
        this._render()

        // Save the new filter config
        this.filter = filterConfig
        await this.updateConfig({
            filter: this.filter
        })

        // Broadcast changes for the parent dashboard, if any
        if (this.dashboard) kiss.pubsub.publish("EVT_DASHBOARD_SETUP", this.id)
    }

    /**
     * Update view configuration:
     * - while offline, just reload
     * - while online, check ACL prior to updating
     * - if ACL check is successful, save the new configuration into db
     * 
     * @param {object} update - The new configuration
     * @param {boolean} [needsDataReload] - If false, the data won't be reloaded. Default to true
     * @async
     */
    async updateConfig(update, needsDataReload = true) {
        try {

            // Prevents the data from being reloaded if it doesn't need to
            if (needsDataReload === false) {
                this.collection.hasChanged = false
            }

            // If the view is not persisted into a record,
            // we just reload the view locally and we don't save the updates permanently
            if (!this.record) {
                this.updateLocalConfig(update)
                this.reload()
                return
            }

            // If the user has insufficient access to update the view configration,
            // we just reload the view locally and we don't save the updates permanently
            const canUpdate = await kiss.acl.check({
                action: "update",
                record: this.record
            })

            if (!canUpdate) {
                this.updateLocalConfig(update)
                this.reload()
                return
            }

            // The user has sufficient access: the view configuration is updated permanently
            const newConfig = this._buildConfig(this.record, update)
            await this.record.update(newConfig)

        } catch (err) {
            log("kiss.ui - dataComponent - Didn't save new view config", 4, err)
        }
    }

    /**
     * Reload the component's data and re-render it
     */
    async reload() {
        if (!this.isConnected) return
        if (this.columns) this._initColumns()
        await this.load()
        this._render()
    }    

    /**
     * When the view configuration can't be persisted into db,
     * we tried to store its parameters in the local storage.
     * 
     * @param {object} update 
     */
    updateLocalConfig(update) {
        let currentConfig = this.getLocalConfig() || {}
        let newConfig = this._buildConfig(currentConfig, update)
        Object.assign(currentConfig, newConfig)
        const storageId = "config-view-" + this.id
        localStorage.setItem(storageId, JSON.stringify(currentConfig))
    }

    /**
     * Build a new configuration by keeping only what is updated.
     * 
     * A dataComponent has basically 4 properties: sort, filter, group, config.
     * Sort, filter and group are generic properties for every dataComponent, while config is specific to the view.
     * For this, we need to merge the new config with the current one, and keep only the updated properties.
     * 
     * @private
     * @ignore
     * @param {object} record 
     * @param {object} update 
     * @returns {object} The new configuration, with only the updated properties
     */
    _buildConfig(record, update) {
        let config = {}
        if (update.hasOwnProperty("name")) config.name = update.name
        if (update.hasOwnProperty("sort")) config.sort = update.sort
        if (update.hasOwnProperty("filter")) config.filter = update.filter
        if (update.hasOwnProperty("group")) config.group = update.group
        if (update.hasOwnProperty("config")) {
            let currentConfig = record.config || {}
            Object.assign(currentConfig, update.config)
            config.config = currentConfig
        }
        return config
    }
   
    /**
     * When a view configuration can't be persisted into db,
     * it can be stored and retrieved from the local storage
     * 
     * @returns {object} The view configuration stored locally
     */
    getLocalConfig() {
        const storageId = "config-view-" + this.id
        const localConfig = localStorage.getItem(storageId)
        if (!localConfig) return false

        let setup = JSON.parse(localConfig)

        // Clean local config columns according to the model's fields
        if (setup.config && setup.config.columns && Array.isArray(setup.config.columns)) {
            // For each model's field, update the corresponding column
            this.model.getFields().forEach(field => {
                let column = setup.config.columns.get(field.id)

                if (column) {
                    // The column exists: we udpate it
                    column.type = this.model.getFieldType(field)
                    column.title = field.label
                    if (column.title.startsWith("#")) column.title = txtTitleCase(column.title)
                    column.title = column.title.toTitleCase()
                    column.deleted = !!field.deleted
                } else {
                    // The column doesn't exist: we add it
                    if (field.label && field.type && !field.deleted) {
                        setup.config.columns.push({
                            id: field.id,
                            type: this.model.getFieldType(field),
                            title: field.label.toTitleCase(),
                            hidden: (field.type == "link") ? true : false
                        })
                    }
                }
            })
        }

        // Filters out deleted fields from sorts
        if (setup.sort) {
            const sortableFields = this.model.getSortableFields().map(field => field.id)
            setup.sort = setup.sort.filter(sort => sortableFields.includes(Object.keys(sort)[0]))
        }

        // Filters out deleted fields from groups
        if (setup.group) {
            const groupableFields = this.model.getGroupableFields().map(field => field.id)
            setup.group = setup.group.filter(fieldId => groupableFields.includes(fieldId))
        }

        return setup
    }

    /**
     * Reset all local component parameters:
     * - collection configurations (sort, filter, group)
     * - columns configuration (visibility, width, colors, aggregation)
     * 
     * When the component's configuration is persisted into local storage,
     * it's useful to be able to reset it
     * 
     * @returns this
     */
    async resetLocalViewParameters() {
        // Reset local storage
        const storageId = "config-view-" + this.id
        localStorage.removeItem(storageId)

        // Get last version of the record that holds the config
        if (this.record) await this.record.read()

        // Reset the columns, if any
        if (this.columns) this.resetColumnsWidth()

        // Restore base component parameters (filter, sort, group...)
        this._initParameters()

        // Reload data and render
        this.collection.hasChanged = true
        await this.reload()
        return this
    }

    /**
     * Reload the toolbar, if any
     * In the generic case, the toolbar is a set of buttons that can be hidden or shown according to its settings.
     * For now, we only manage the "create" button.
     */
    async _updateToolbar() {
        const createButton = this.querySelector("." + this.type + "-create-record")
        if (!createButton) return

        if (this.canCreateRecord === false) {
            createButton.hide()
        }
        else {
            createButton.show()
        }
    }

    /**
     * 
     * COLUMNS MANAGEMENT
     * 
     */

    /**
     * Initialize (or reset) the view columns.
     * If no config is provided, the columns are auto-generated according to the model.
     * 
     * @private
     * @ignore
     * @param {object[]} columns - Array of column configurations
     * @returns this
     */
    _initColumns(columns) {
        if (columns) {
            this.columns = columns
        } else {
            this.columns = (this.record) ? this.record.config.columns : this.config.columns
            const localConfig = this.getLocalConfig()
            if (localConfig && localConfig.config && localConfig.config.columns) this.columns = localConfig.config.columns
        }

        if (this.columns) {
            // A config is provided
            // Filters out the columns which field doesn't exist anymore in the model
            this.columns = this.columns.filter(column => {
                if (column.type == "button") return true

                const field = this.model.getField(column.id)
                if (field) {
                    return true
                }
                return false
            })

            this._appendMissingColumns()

        } else {
            // No config provided
            // Auto-configure the columns from the model
            this.columns = this.model.getFieldsAsColumns()
        }

        // Apply ACL and hide unwanted columns
        this.columns = this.columns.filter(column => {
            if (column.type == "button") return true
            if (column.type == "link" && this.config.showLinks === false) return false

            const field = this.model.getField(column.id)
            if (field && field.acl && field.acl.read === false) {
                return false
            }
            return true
        })

        // - Apply renderers, if any
        // - Reset the column title
        // - Adjust the column width depending on the unit
        this.columns.forEach(column => {
            if (!column.id) return
            
            const field = this.model.getField(column.id)
            if (!field) return
            
            column.title = field.label
            if (column.title.startsWith("#")) column.title = txtTitleCase(column.title)
            column.title = column.title.toTitleCase()

            if (field && field.valueRenderer) {
                column.renderer = field.valueRenderer
            }

            if (column.widthUnit != "rem") {
                column.widthUnit = "rem"
                column.width = kiss.tools.pxToRem(column.width)
            }
        })
        return this
    }

    /**
     * Sync view columns with model fields and extra plugin fields.
     * 
     * Context: a view has a set of columns representing the model's fields.
     * Then, a plugin is enabled on the model, and this plugin adds some extra fields to the model.
     * The view columns must reflect these extra fields.
     * This function checks the missings fields and creates a new column for each missing field.
     * 
     * @private
     * @ignore
     */
    _appendMissingColumns() {
        // Adds the model fields which are not inside the saved list of columns
        const fieldIds = this.model.fields.filter(field => !field.deleted).map(field => field.id)
        const columnIds = this.columns.filter(column => !column.deleted).map(column => column.id)
        const missingIds = fieldIds.filter(item => !columnIds.includes(item))

        if (missingIds.length > 0) {
            missingIds.forEach(fieldId => {
                const field = this.model.getField(fieldId)
                if (!field.label) return

                let columnConfig = {
                    id: field.id,
                    type: this.model.getFieldType(field),
                    title: field.label
                }

                // Plugin columns
                if (field.isFromPlugin) {
                    columnConfig.isFromPlugin = true
                    columnConfig.pluginId = field.pluginId
                    columnConfig.title = txtTitleCase(field.label)
                    columnConfig.hidden = true
                }

                // System columns
                if (field.isSystem) {
                    columnConfig.isSystem = true
                    columnConfig.title = txtTitleCase(field.label)
                    columnConfig.hidden = (field.hidden === true)
                }

                this.columns.push(columnConfig)
            })
        }
    }

    /**
     * Get the view columns
     * 
     * @returns {object[]} Array of column definitions
     */
    getColumns() {
        return this.columns
    }

    /**
     * Get the view fields.
     * 
     * Note: in a some view (like datatables), fields are the same thing as columns.
     * 
     * @returns {object[]} Array of column definitions
     */
    getFields() {
        return this.columns
    }

    /**
     * Toggle one column on/off
     * 
     * @private
     * @ignore
     * @param {string} columnId - Id of the column to show/hide
     */
    _columnsToggleOne(columnId) {
        this._columnsToggle(columnId)
        this._render()
        this.updateConfig({
            config: {
                columns: this.columns
            }
        })
    }

    /**
     * Switch on / off all the columns at the same time
     * 
     * @private
     * @ignore
     * @param {string} newState - hide|show
     */
    _columnsToggleAll(newState) {
        let hidden = (newState == "hide")
        this.columns.forEach(column => this._columnsToggle(column.id, hidden))
        this._render()
        this.updateConfig({
            config: {
                columns: this.columns
            }
        })
    }

    /**
     * Toggle a column to be hidden/visible
     * 
     * @private
     * @ignore
     * @param {string} columnId - Id of the column to show/hide
     * @param {boolean} [hidden] - Force the column state to be hidden or visible
     * @returns this
     */
    _columnsToggle(columnId, hidden = null) {
        let columnIndex = this.columns.findIndex(column => column.id == columnId)
        let newState = (hidden != null) ? hidden : !this.columns[columnIndex].hidden
        this.columns[columnIndex].hidden = newState
        return this
    }

    /**
     * Check if there are hidden columns
     * 
     * @private
     * @ignore
     * @returns {boolean}
     */
    _columnsHasHiddenColumns() {
        let hasHiddenColumns = false
        this.columns.forEach(column => {
            if (column.hidden == true) hasHiddenColumns = true
        })
        return hasHiddenColumns
    }

    /**
     * Move a "source" column before /after a "target" column
     * 
     * @private
     * @ignore
     * @param {string} sourceColumnId - Source column id
     * @param {string} targetColumnId - Target column id
     * @param {string} position - "before" or "after"
     */
    async _columnsMove(sourceColumnId, targetColumnId, position) {
        let currentColumn = this.getColumn(sourceColumnId)
        let currentColumnIndex = this.columns.findIndex(column => column.id == sourceColumnId)

        let newColumns = this.columns.filter(column => column.id != currentColumn.id)
        let targetColumnIndex = newColumns.findIndex(column => column.id == targetColumnId)

        // Same position? => Exit!
        let adjustPositionIndex = (position == "before") ? 0 : 1
        if ((targetColumnIndex == -1) || (currentColumnIndex == (targetColumnIndex + adjustPositionIndex))) return

        // Update column config
        newColumns.splice(targetColumnIndex + adjustPositionIndex, 0, currentColumn)
        this.columns = newColumns

        this._render()

        await this.updateConfig({
            config: {
                columns: this.columns
            }
        })

        // Broadcast changes for local and offline, so that "dataFieldsWindow" can be updated (check dataFieldsWindow.js)
        kiss.pubsub.publish("EVT_VIEW_FIELD_MOVED:" + this.id)
    }

    /**
     * Get the column config used to display a field
     * 
     * @param {string} fieldId 
     * @returns {object} The column config
     */
    getColumn(fieldId) {
        return this.columns.find(column => column.id == fieldId)
    }

    /**
     * 
     * SELECT FIELDS, SORT, FILTER options
     * 
     */

    /**
     * Show a modal window to select / deselect fields
     * 
     * @param {number} [x] - x coordinate
     * @param {number} [Y] - y coordinate
     * @param {string} [color] - Window color, in hexa: "#00aaee"
     */
    showFieldsWindow(x, y, color = "#00aaee") {
        const selectionWindow = createDataFieldsWindow(this.id, color)
        this.selectFieldWindowId = selectionWindow.id

        if (!y || !x) {
            selectionWindow.top = () => kiss.screen.current.height / 3 - selectionWindow.offsetHeight / 2
            selectionWindow.left = () => kiss.screen.current.width / 2 - selectionWindow.offsetWidth / 2
            selectionWindow.render()
        } else {
            selectionWindow.showAt(x, y).render()
        }
    }

    /**
     * Show a modal window to sort data
     * 
     * @param {number} [x] - x coordinate
     * @param {number} [Y] - y coordinate
     * @param {string} [color] - Window color, in hexa: "#00aaee"
     */
    showSortWindow(x, y, color = "#00aaee") {
        const sortWindow = createDataSortWindow(this.id, color)
        this.sortWindowId = sortWindow.id

        if (!y || !x) {
            sortWindow.top = () => kiss.screen.current.height / 3 - sortWindow.offsetHeight / 2
            sortWindow.left = () => kiss.screen.current.width / 2 - sortWindow.offsetWidth / 2
            sortWindow.render()
        } else {
            sortWindow.render().showAt(x, y)
        }
    }

    /**
     * Show a modal window to filter data
     * 
     * @param {number} [x] - x coordinate
     * @param {number} [Y] - y coordinate
     * @param {string} [color] - Window color, in hexa: "#00aaee"
     */
    showFilterWindow(x, y, color = "#00aaee") {
        const filterWindow = createDataFilterWindow(this.id, color)
        this.filterWindowId = filterWindow.id

        if (!y || !x) {
            filterWindow.top = () => kiss.screen.current.height / 3 - filterWindow.offsetHeight / 2
            filterWindow.left = () => kiss.screen.current.width / 2 - filterWindow.offsetWidth / 2
            filterWindow.render()
        } else {
            filterWindow.render().showAt(x, y)
        }
    }

    /**
     * 
     * SEARCH MANAGEMENT
     * 
     */

    /**
     * Show the search bar
     */
    showSearchBar() {
        if (kiss.screen.isMobile) {
            return this.showMobileSearchBar()
        }

        if ($("search-bar-" + this.id)) return

        const id = this.id
        const searchButton = $("search:" + id)
        const searchButtonTop = searchButton.getBoundingClientRect().top

        this.searchBar = createPanel({
            id: "search-bar-" + id,
            title: txtTitleCase("#ftsearch title"),
            icon: "fas fa-search",
            headerBackgroundColor: this.color || "var(--background-blue)",
            draggable: true,
            closable: false,
            autoSize: true,
            opacity: 0.8,

            top: () => {
                if (!searchButton) return 0
                return searchButtonTop + 40
            },
            left: "calc(100vw - 30rem)",

            position: "absolute",
            width: "28rem",
            height: "10rem",
            layout: "horizontal",
            alignItems: "center",

            animation: {
                name: "zoomIn",
                speed: "faster"
            },

            items: [
                // Input field to enter search term
                {
                    id: "search-term-" + id,
                    type: "text",
                    fieldWidth: "22rem",
                    borderColor: "var(--body-1)",
                    autocomplete: "off",
                    events: {
                        keydown: function (event) {
                            let view = $(id)
                            if (!view) return

                            if (this.getValue() == view.currentSearchTerm) return

                            if (event.key == "Enter") {
                                view.currentSearchTerm = this.getValue()
                                view.ftsearch(view.currentSearchTerm)
                            }
                        }
                    }
                },
                // Button to close the search bar
                {
                    type: "button",
                    icon: "fas fa-times",
                    width: "3rem",
                    height: "3rem",
                    action: async () => {
                        if (this.currentSearchTerm !== undefined && this.currentSearchTerm !== "") {
                            this.skip = 0
                            await this.collection.filterBy(this.filter)
                            this.refresh()
                        }

                        this.resetSearchBar()
                    }
                }
            ],

            methods: {
                // Focus on the search term field
                _afterRender() {
                    setTimeout(() => {
                        if ($("search-term-" + id)) $("search-term-" + id).focus()
                        this.restoreSearchTerm()
                    }, 100)
                },
                restoreSearchTerm: () => {
                    if ($("search-term-" + id)) $("search-term-" + id).setValue(this.currentSearchTerm || "")
                }
            }
        }).render()
    }

    /**
     * Show the mobile search bar
     */
    showMobileSearchBar() {
        if ($("search-term-" + this.id)) return

        this.switchToSearchMode()
        const id = this.id

        this.searchBar = createBlock({
            target: "search-field:" + id,
            layout: "horizontal",
            alignItems: "center",

            animation: {
                name: "slideInLeft",
                speed: "faster"
            },

            items: [
                // Button to close the search bar
                {
                    type: "button",
                    icon: "fas fa-times",
                    width: "3rem",
                    height: "3rem",
                    action: async () => {
                        if (this.currentSearchTerm !== undefined && this.currentSearchTerm !== "") {
                            this.skip = 0
                            await this.collection.filterBy(this.filter)
                            this.refresh()
                        }

                        this.resetSearchBar()
                    }
                },
                // Input field to enter search term
                {
                    id: "search-term-" + id,
                    type: "text",
                    placeholder: txtTitleCase("search"),
                    borderColor: "var(--body-1)",
                    autocomplete: "off",
                    flex: 1,
                    fieldWidth: "100%",
                    events: {
                        keydown: function (event) {
                            let view = $(id)
                            if (!view) return

                            if (this.getValue() == view.currentSearchTerm) return

                            if (event.key == "Enter") {
                                view.currentSearchTerm = this.getValue()
                                view.ftsearch(view.currentSearchTerm)
                            }
                        }
                    },
                    methods: {
                        // Focus on the search term field
                        _afterRender() {
                            setTimeout(() => {
                                if ($("search-term-" + id)) $("search-term-" + id).focus()
                                this.restoreSearchTerm()
                            }, 100)
                        },
                        restoreSearchTerm: () => {
                            if ($("search-term-" + id)) $("search-term-" + id).setValue(this.currentSearchTerm || "")
                        }
                    }

                }
            ]
        }).render()
    }

    /**
     * Reset the search made from the search bar
     */
    hideSearchBar() {
        if (this.searchBar) {
            if (kiss.screen.isMobile)
                this.searchBar.remove()
            else
                this.searchBar.close()
        }
    }

    /**
     * Reset the search made from the search bar
     */
    resetSearchBar() {
        this.currentSearchTerm = ""
        this.hideSearchBar()
        if (this.resetSearchMode) this.resetSearchMode()
    }

    /**
     * Full-text search on all text fields
     * 
     * @param {string} value 
     */
    async ftsearch(value) {
        const searchFilter = this.createSearchFilter(value)
        this.skip = 0
        await this.collection.filterBy(searchFilter)
        this.refresh()
    }

    /**
     * Create a filter that appends the search term to the existing filters
     * 
     * @param {string} value 
     * @returns {object} The filter configuration
     */
    createSearchFilter(value) {
        const model = this.model || this.collection.model
        const textFields = model.getFieldsByType(["text", "textarea", "aiTextarea", "richTextField", "select", "selectViewColumn", "selectViewColumns", "date", "lookup", "directory", "map"])

        const textFilters = textFields.map(field => {
            return {
                type: "filter",
                fieldId: field.id,
                fieldLabel: field.label,
                operator: "contains",
                value
            }
        })

        return {
            type: "group",
            operator: "and",
            filters: [{
                    type: "group",
                    operator: "or",
                    filters: textFilters
                },
                this.filter
            ]
        }
    }

    /**
     * 
     * SELECTION MANAGEMENT
     * 
     */

    /**
     * Show a single record (passing its id)
     * 
     * @param {string} recordId - id of the record to show
     */
    async selectRecordById(recordId) {
        let record = await this.collection.findOne(recordId)
        await this.selectRecord(record)
    }

    /**
     * Show a single record
     * 
     * Important: this method can be overriden in the instanced component
     * 
     * @async
     * @param {object} record - Record to show
     */
    async selectRecord(record) {
        createForm(record)
    }

    /**
     * Open the form to create a new record
     * 
     * Important: this method can be overriden in the instanced component
     * 
     * @async
     * @param {object} model - Model to create the record
     */
    async createRecord(model) {
        const newRecord = model.create()
        await newRecord.save()
        createForm(newRecord)
    }

    /**
     * 
     * SELECTION MANAGEMENT
     * 
     */

    /**
     * Get the list of ids of selected records
     * 
     * @returns {string[]} The list of selected record ids
     */
    getSelection() {
        this.selectedRecords = kiss.selection.get(this.id)
        return this.selectedRecords
    }

    /**
     * Get the list of selected records
     * 
     * @returns {array} Array of records
     */
    getSelectedRecords() {
        let records = []
        for (let id of this.getSelection()) records.push(this.collection.getRecord(id))
        return records
    }

    /**
     * Select / Deselect records
     */
    toggleSelection() {
        if (this._pageHasUnselectedRows()) {
            const ids = this._getVisibleIds()
            kiss.selection.insertMany(this.id, ids)
        } else {
            kiss.selection.reset(this.id)
        }
        this._renderSelectionRestore()
    }

    /**
     * Deselect records
     */
    deselectAll() {
        kiss.selection.reset(this.id)
        this._renderSelectionRestore()
    }

    /**
     * Select multiple records (using the SHIFT key)
     * 
     * @param {number} rangeStart 
     * @param {number} rangeEnd 
     */
    selectRange(rangeStart, rangeEnd) {
        const loadingId = kiss.loadingSpinner.show()

        setTimeout(() => {
            let selectedIds = []
            this.collection.records.forEach((record, index) => {
                if (record.$type == "group") return
                if (index >= rangeStart && index <= rangeEnd) selectedIds.push(record.id)
            })
    
            kiss.selection.insertMany(this.id, selectedIds)
            this._renderSelectionRestore()
            kiss.loadingSpinner.hide(loadingId)
        }, 0)
    }

    /**
     * Export records as XLS or JSON
     */
    async export() {
        const exportSelection = {
            datatable: true,
            calendar: false,
            kanban: false,
            timeline: true
        }

        const canExportSelection = exportSelection[this.type]

        createPanel({
            id: "export-setup",
            title: txtTitleCase("#export view"),
            icon: "fas fa-cloud-download-alt",
            modal: true,
            closable: true,
            draggable: true,
            align: "center",
            verticalAlign: "center",
            width: "40rem",

            layout: "vertical",
            items: [
                // Export type
                {
                    id: "export-type",
                    label: txtTitleCase("format"),
                    labelPosition: "top",
                    type: "select",
                    value: "xls",
                    options: [{
                        label: "EXCEL",
                        color: "var(--green)",
                        value: "xls"
                    }, {
                        label: "CSV",
                        color: "var(--blue)",
                        value: "csv"
                    }, {
                        label: "JSON",
                        color: "var(--orange)",
                        value: "json"
                    }]
                },
                // Export set (all or selection)
                {
                    hidden: !canExportSelection,
                    id: "export-set",
                    label: txtTitleCase("#export target"),
                    labelPosition: "top",
                    type: "select",
                    value: "selection",
                    options: [{
                        label: txtTitleCase("#all view records"),
                        value: "all"
                    }, {
                        label: txtTitleCase("#selected documents"),
                        value: "selection"
                    }]
                },
                // Button to export
                {
                    type: "button",
                    text: txtTitleCase("export"),
                    icon: "fas fa-bolt",
                    height: "4rem",
                    margin: "2rem 0 0 0",

                    action: async () => {
                        const exportType = $("export-type").getValue()
                        const exportSet = (canExportSelection) ? $("export-set").getValue() : "all"
                        let exportString
                        let records
                        let mimeType
                        let extension

                        // Define the set of target records (all, or a subset)
                        if (exportSet == "selection") {
                            records = this.getSelectedRecords()
                            if (records.length == 0) return createNotification(txtTitleCase("#no selection"))
                        } else {
                            records = await this.collection.find({})
                            records = records.filter(record => record.$type != "group")
                        }

                        if (exportType == "xls") {
                            // XLS export
                            mimeType = "application/application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                            extension = "xls"

                            const columns = this.columns.filter(column => !column.hidden && column.type != "link")
                            exportString = "<table border=1 borderColor=#cccccc><tr>"
                            exportString += columns.map(column => `<th style="background-color: #00aaee; color: #ffffff; font-size: 1.6rem;">${column.title}</th>`).join("")
                            exportString += "<tr>"

                            for (let record of records) {
                                const data = await record.getData({
                                    convertNames: true,
                                    includeLinks: false
                                })
                                exportString += "<tr>"
                                exportString += columns.map(column => `<td>${data[column.id]}</td>`).join("")
                                exportString += "</tr>"
                            }
                            exportString += "</table>"

                        } else if (exportType == "json") {
                            // JSON export
                            mimeType = "application/json"
                            extension = "json"

                            let exportRecords = []
                            for (let record of records) exportRecords.push(await record.getData({
                                useLabels: true,
                                convertNames: true,
                                includeLinks: false
                            }))
                            exportString = JSON.stringify(exportRecords)
                        } else {
                            // CSV export
                            mimeType = "text/csv"
                            extension = "csv"

                            const columns = this.columns.filter(column => !column.hidden && column.type != "link")
                            exportString = columns.map(column => column.title).join(",")
                            exportString += "\n"

                            for (let record of records) {
                                const data = await record.getData({
                                    convertNames: true,
                                    includeLinks: false
                                })
                                exportString += columns.map(column => data[column.id]).join(",")
                                exportString += "\n"
                            }
                        }

                        // Encode data and create a download link
                        const encodedData = encodeURIComponent("\ufeff" + exportString)
                        const dataURI = `data:${mimeType};charset=utf-8,${encodedData}`
                        const sourceUrl = `<br><br><center><a href="${dataURI}" download="export.${extension}">${txtTitleCase("download file")}</a></center>`

                        createDialog({
                            type: "message",
                            title: txtTitleCase("#export view"),
                            message: txtTitleCase("#click to download") + sourceUrl,
                            noOK: true
                        })

                        $("export-setup").close()
                    }
                }
            ]
        }).render()
    }

    /**
     * Copy the selection to the clipboard
     */
    async copySelectionToClipboard() {
        const ids = kiss.selection.get(this.id)
        if (ids.length == 0) return createNotification(txtTitleCase("#no selection"))

        const records = this.collection.records.filter(record => ids.includes(record.id))

        let clipboardData = ""
        for (const record of records) {
            const recordData = await record.getData({
                convertNames: true
            })

            this.columns.forEach(column => {
                if (column.hidden) return
                let value = recordData[column.id]
                value = this.formatValueForClipboard(column, value)
                clipboardData += value + "\t"
            })

            clipboardData += "\n"
        }

        kiss.tools.copyTextToClipboard(clipboardData)
        createNotification(txtTitleCase("copied to clipboard"))
    }

    /**
     * Format a value for the clipboard
     * 
     * @param {object} column - Column configuration
     * @param {*} value - Value to format
     * @returns {*} The formatted value so it can be used in the clipboard for copy/paste
     */
    formatValueForClipboard(column, value) {
        if (value == undefined) return ""

        if (column.type == "link" || column.type == "password") {
            value = ""
        }
        else if (typeof value == "string" && (value.includes("\n") || value.includes('"'))) {
            value = `"${value.replace(/"/g, '""')}"`
        }
        else if (Array.isArray(value)) {
            if (column.type == "attachment" || column.type == "aiImage") {
                value = value.map(attachment => attachment.filename).join(", ")
            }
            else {
                value = value.join(", ")
            }                    
        }
        else if (value === true) {
            value = "☑"
        }
        else if (value === false) {
            value = "☐"
        }
        return value
    }

    /**
     * Check if the current page has unselected rows
     * 
     * @private
     * @ignore
     * @returns {boolean}
     */
    _pageHasUnselectedRows() {
        let hasUnselectedRows = false
        const rows = this.querySelectorAll("." + this.type + "-row")
        Array.from(rows).every(row => {
            if (row.classList.contains(this.type + "-row-selected")) {
                return true
            } else {
                hasUnselectedRows = true
                return false
            }
        })
        return hasUnselectedRows
    }

    /**
     * Get the list of ids of visible records
     * 
     * @private
     * @ignore
     * @returns {string[]}
     */
    _getVisibleIds() {
        const rows = this.querySelectorAll("." + this.type + "-row")
        return Array.from(rows).map(row => row.getAttribute("recordid"))
    }

    /**
     * Render the menu of actions
     * 
     * @private
     * @ignore
     */
    async _buildActionMenu() {
        let actions = []
        let buttonLeftPosition = $("actions:" + this.id).offsetLeft
        let buttonTopPosition = $("actions:" + this.id).offsetTop

        // Inject specific actions
        if (this.actions.length) {
            actions = actions.concat(this.actions)
        }

        // Inject advanced actions, if any
        if (kiss.app.customActions && kiss.app.customActions.length > 0) {
            const userACL = kiss.session.getACL()

            let customActions = kiss.app.customActions.filter(action => {
                const isTargetView = action.type && action.type.includes("view") && action.viewIds && (action.viewIds.includes(this.id) || action.viewIds.includes("*"))
                const isTargetUser = kiss.tools.intersects(userACL, action.accessRead)
                return isTargetView && isTargetUser
            })

            actions.push("-")
            customActions.forEach(action => {
                const menuAction = {
                    id: action.id,
                    text: action.name,
                    icon: action.icon,
                    iconColor: action.color,
                    action: () => {
                        // Inject the view in the context so that custom actions can use it
                        kiss.context.view = this
                        eval(action.code)
                    }
                }
                actions.push(menuAction)
            })
        }

        createMenu({
            top: buttonTopPosition,
            left: buttonLeftPosition,
            items: actions
        }).render()
    }    
}

;/**
 * 
 * The Block derives from [Container](kiss.ui.Container.html).
 * 
 * A Block is a general purpose container for items, where items can be:
 * - KissJS components (Field, Button, ...)
 * - KissJS containers (Block, Form, Panel...)
 * - KissJS views
 * - any HTMLElement
 * - any function that returns an HTMLElement
 * 
 * Don't forget you can use the Container's methods like **update, addItem, insertItem, deleteItem, getFields, getData...**
 * 
 * @param {object} config
 * @param {object[]} config.items - The array of contained items
 * @param {boolean} [config.multiview] - If true, the container only displays one item at a time. Useful for Tab layouts.
 * @param {boolean} [config.fullscreen]
 * @param {string} [config.position]
 * @param {string} [config.top]
 * @param {string} [config.left]
 * @param {string} [config.right]
 * @param {string} [config.align] - "center" to center the block horizontally on the screen
 * @param {string} [config.verticalAlign] - "center" to center the block vertically on the screen
 * @param {string} [config.display]
 * @param {string} [config.flex]
 * @param {string} [config.flexFlow]
 * @param {string} [config.flexWrap]
 * @param {string} [config.flexGrow]
 * @param {string} [config.flexShrink]
 * @param {string} [config.alignItems]
 * @param {string} [config.alignContent]
 * @param {string} [config.justifyContent]
 * @param {string|number} [config.width]
 * @param {string|number} [config.minWidth]
 * @param {string|number} [config.maxWidth]
 * @param {string|number} [config.height]
 * @param {string|number} [config.minHeight]
 * @param {string|number} [config.maxHeight]
 * @param {string} [config.margin]
 * @param {string} [config.padding]
 * @param {string} [config.background]
 * @param {string} [config.backgroundColor]
 * @param {string} [config.backgroundImage]
 * @param {string} [config.backgroundSize]
 * @param {string} [config.border]
 * @param {string} [config.borderStyle]
 * @param {string} [config.borderWidth]
 * @param {string} [config.borderColor]
 * @param {string} [config.borderRadius]
 * @param {string} [config.boxShadow]
 * @param {string} [config.overflow]
 * @param {string} [config.overflowX]
 * @param {string} [config.overflowY]
 * @param {number} [config.zIndex]
 * @param {number} [config.transform]
 * @param {boolean} [config.draggable]
 * @returns this
 * 
 * ## Generated markup
 * ```
 * <a-block class="a-block">
 *  <!-- Block items are inserted here -->
 * </a-block>
 * ```
 */
kiss.ui.Block = class Block extends kiss.ui.Container {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the 3 following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const myBlock = document.createElement("a-block").init(config)
     * ```
     * 
     * Or use the shorthand for it:
     * ```
     * const myBlock = createBlock({
     *   padding: "10px",
     *   items: [
     *       // Block items...
     *   ]
     * })
     * 
     * myBlock.render()
     * ```
     * 
     * Or directly declare the config inside a container component:
     * ```
     * const myPanel = createPanel({
     *   items: [
     *       {
     *           type: "block",
     *           title: "Foo",
     *           items: [
     *               // Block items...
     *           ]
     *       }
     *   ]
     * })
     * myPanel.render()
     * ```
     * 
     * ## IMPORTANT
     * When embedded into another container, the item type defaults to "block", which means it's not necessary to set the **type** property for **block** elements:
     * ```
     * const myPanel = createPanel({
     *   items: [
     *       {
     *           // This item has no type: KissJS will generate a block by default
     *           title: "Foo",
     *           items: [
     *               // Block items...
     *           ]
     *       }
     *   ]
     * })
     * myPanel.render()
     * ```
     * 
     */
    constructor() {
        super()
    }

    /**
     * Generates a Block and its items from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config) {
        super.init(config)

        // Fullscreen
        if (config.fullscreen) {
            this.style.display = "block"
            this.style.position = "fixed"
            this.style.top = "0px"
            this.style.left = "0px"
            this.style.width = "100%"
            this.style.height = "100%"
        }

        // Define component's items container
        // It can vary depending on the component: for example, for the Panel, the items container is the panel body
        // The basic block directly contains the items without any sub-hierarchy
        this.container = this

        // Dispatch component's config properties to the right targets
        this._setProperties(config, [
            [
                ["draggable"],
                [this]
            ],
            [
                ["display", "padding", "margin", "position", "top", "left", "right", "overflow", "overflowX", "overflowY", "flex", "flexFlow", "flexWrap", "flexGrow", "flexShrink", "alignItems", "alignContent", "justifyContent", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "background", "backgroundColor", "backgroundImage", "backgroundSize", "border", "borderStyle", "borderWidth", "borderColor", "borderRadius", "boxShadow", "zIndex", "transform"],
                [this.style]
            ]
        ])

        return this
    }

    /**
     * Set the Html content of the block component
     * 
     * @param {string} html
     * @returns this
     */
    setInnerHtml(html) {
        this.innerHTML = html
        return this
    }

    /**
     * Get the Html content of the block component
     * 
     * @returns {string} The html content
     */
    getInnerHtml() {
        return this.innerHTML
    }
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-block", kiss.ui.Block)

/**
 * Shorthand to create a new Block. See [kiss.ui.Block](kiss.ui.Block.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createBlock = (config) => document.createElement("a-block").init(config)

;/**
 * 
 * The Panel derives from [Container](kiss.ui.Container.html).
 * 
 * It's a container with a header and other properties that allow to create standard draggable windows and modal windows.
 * 
 * Don't forget you can use the Container's methods like **update, addItem, insertItem, deleteItem, getFields, getData...**
 * 
 * @param {object} config
 * @param {object[]} config.items - The array of contained items
 * @param {boolean} [config.multiview] - If true, the container only displays one item at a time. Useful for Tab layouts.
 * @param {string} [config.title]
 * @param {string} [config.icon]
 * @param {string} [config.iconColor]
 * @param {string} [config.iconSize]
 * @param {boolean} [config.modal] - Makes the panel modal (clicking out of the panel will close it)
 * @param {boolean} [config.expandable] - Adds a header icon to expand the panel in fullscreen
 * @param {boolean} [config.closable] - Adds a header icon to close the panel
 * @param {string} [config.closeMethod] - Use "hide" or "remove" (default, destroys the DOM node)
 * @param {boolean} [config.draggable] - Makes the panel draggable.
 * @param {boolean} [config.collapsible] - Allows the panel content to be collapsed. Note that This property is disabled if the panel is also draggable.
 * @param {boolean} [config.collapsed] - Default collapse state
 * @param {boolean} [config.header]
 * @param {boolean} [config.headerColor]
 * @param {string} [config.headerBackgroundColor]
 * @param {string} [config.headerBorderRadius]
 * @param {string} [config.headerBorderColor]
 * @param {object[]} [config.headerButtons] - Buttons injected in the header. See example below.
 * @param {object[]} [config.headerIcons] - Icons injected in the header. See example below.
 * @param {string|number} [config.headerHeight] - The header's height
 * @param {string} [config.position]
 * @param {string|number} [config.top]
 * @param {string|number} [config.left]
 * @param {string|number} [config.right]
 * @param {string} [config.align] - "center" to center the panel horizontally on the screen
 * @param {string} [config.verticalAlign] - "center" to center the panel vertically on the screen
 * @param {string} [config.layout]
 * @param {string} [config.display]
 * @param {string} [config.flex]
 * @param {string} [config.flexFlow]
 * @param {string} [config.flexWrap]
 * @param {string} [config.alignItems]
 * @param {string} [config.alignContent]
 * @param {string} [config.justifyContent]
 * @param {string|number} [config.width]
 * @param {string|number} [config.minWidth]
 * @param {string|number} [config.maxWidth]
 * @param {string|number} [config.height] - A calculation involving the header's height and panel border-width
 * @param {string} [config.margin]
 * @param {string} [config.padding]
 * @param {string} [config.background]
 * @param {string} [config.backgroundColor]
 * @param {string} [config.backgroundImage]
 * @param {string} [config.backgroundSize]
 * @param {string} [config.border]
 * @param {string} [config.borderStyle]
 * @param {string} [config.borderWidth]
 * @param {string} [config.borderColor]
 * @param {string} [config.borderRadius]
 * @param {string} [config.boxShadow]
 * @param {string} [config.overflow]
 * @param {string} [config.overflowX]
 * @param {string} [config.overflowY]
 * @param {number} [config.zIndex]
 * @param {number} [config.opacity]
 * @param {number} [config.transform] 
 * @param {string} [maskBackgroundColor] - Allows to adjust the opacity of the mask for modal windows. Example: rgba(0, 0, 0, 0.5)
 * @returns this
 * 
 * ## Generated markup
 * ```
 * <a-panel class="a-panel">
 *  <div class="panel-header">
 *      <span class="panel-icon"></span>
 *      <span class="panel-title"></span>
 *      <span class="panel-custom-buttons"></span>
 *      <span class="panel-button-expand-collapse"></span>
 *      <span class="panel-button-maximize"></span>
 *      <span class="panel-button-close"></span>
 *  </div>
 *  <div class="panel-body">
 *      <!-- Panel items are inserted here -->
 *  </div>
 * </a-panel>
 * ```
 * 
 * ## Todo
 * - add a panel footer?
 * - add a panel toolbar?
 * 
 */
kiss.ui.Panel = class Panel extends kiss.ui.Container {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the 3 following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const myPanel = document.createElement("a-panel").init(config)
     * ```
     * 
     * Or use the shorthand for it:
     * ```
     * const myPanel = createPanel({
     *   title: "Setup"
     *   icon: "fas fa-wrench",
     *   headerBackgroundColor: "#00aaee",
     *   closable: true,
     *   draggable: true,
     *   modal: true,
     *   display: "flex"
     *   flexFlow: "column",
     *   padding: "10px",
     *   items: [
     *       // Panel items...
     *   ]
     * })
     * 
     * myPanel.render()
     * ```
     * 
     * Or directly declare the config inside a container component:
     * ```
     * const myBlock = createBlock({
     *   items: [
     *       {
     *           type: "panel",
     *           title: "Foo",
     *           items: [
     *               // Panel items...
     *           ]
     *       }
     *   ]
     * })
     * myBlock.render()
     * ```
     * 
     * To add buttons or icons in the header:
     * ```
     * createPanel({
     *  headerButtons: [
     *      {
     *          icon: "fas fa-bolt",
     *          text: "Do something"
     *          action: () => this.doSomething()
     *      }
     *  ],
     *  headerIcons: [
     *      {
     *          icon: "fas fa-bolt",
     *          action: () => this.doSomething()
     *      }
     *  ],
     *  items: [
     *      // ...
     *  ]
     * })
     * ```
     */
    constructor() {
        super()
    }

    /**
     * Generates a Panel from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config) {
        super.init(config)

        // Template
        const id = this.id
        this.innerHTML =
            `${((config.collapsible == true) && (config.draggable != true))
                ? `<div id="panel-header-${id}" class="panel-header panel-header-collapsible">`
                : `<div id="panel-header-${id}" class="panel-header ${(config.draggable == true) ? "panel-header-draggable" : ""}">`
            }
                <span id="panel-icon-${id}" class="panel-icon ${(config.icon) ? config.icon : ""}"></span>
                <span id="panel-title-${id}" class="panel-title">${config.title || ""}</span>
                <span style="flex:1"></span>
                <span class="panel-custom-buttons"></span>
                <span class="panel-custom-icons"></span>

                ${(config.collapsible) ? `<span id="panel-button-expand-collapse-${id}" class="fas fa-chevron-down panel-buttons panel-button-expand-collapse"></span>` : ""}
                ${(config.expandable) ? `<span id="panel-button-maximize-${id}" class="fas fa-expand panel-buttons panel-button-expand"></span>` : ""}
                ${(config.closable) ? `<span id="panel-button-close-${id}" class="fas fa-times panel-buttons panel-button-close"></span>` : ""}
            </div>
            
            <div tabindex=1 id="panel-body-${id}" class="panel-body ${(config.header == false) ? "panel-body-no-header" : ""}">
            </div>`.removeExtraSpaces()

        // Mask (for modal windows)
        if (config.modal == true) {
            this.mask = document.createElement("div")
            this.mask.setAttribute("id", "panel-mask-" + id)
            this.mask.classList.add("panel-mask")
            this.mask.onmousedown = () => $(id).close()
            if (config.zIndex) this.mask.style = `z-index: ${config.zIndex}`
            document.body.appendChild(this.mask)
        }

        // Set properties
        this.panelHeader = this.querySelector(".panel-header")
        this.panelTitle = this.querySelector(".panel-title")
        this.panelIcon = this.querySelector(".panel-icon")
        this.panelButtonExpandCollapse = this.querySelector(".panel-button-expand-collapse")
        this.panelButtons = this.querySelectorAll(".panel-buttons")
        this.panelCustomButtons = this.querySelector(".panel-custom-buttons")
        this.panelCustomIcons = this.querySelector(".panel-custom-icons")

        // Define component's items container (which can vary depending on the component)
        this.panelBody = this.container = this.querySelector(".panel-body")

        // Draggable panels need to have a fixed position
        config.position = (config.draggable) ? "fixed" : ((config.modal) ? "absolute" : (config.position || "relative"))

        // Restrict header's border radius to upper corners
        if ((config.borderRadius) && (config.borderRadius.split(" ").length == 4)) {
            const borderRadiusConfig = config.borderRadius.split(" ")
            const topLeftBorderRadius = borderRadiusConfig[0]
            const topRightBorderRadius = borderRadiusConfig[1]
            config.headerBorderRadius = topLeftBorderRadius + " " + topRightBorderRadius + " 0px 0px"
        }

        this._setProperties(config, [
            [
                ["position", "top", "left", "right", "flex", "margin", "border", "borderColor", "borderRadius", "boxShadow", "transform", "zIndex", "opacity"],
                [this.style]
            ],
            [
                ["headerHeight=height", "headerBackgroundColor=background", "headerBorderColor=borderColor", "headerBorderRadius=borderRadius"],
                [this.panelHeader.style]
            ],
            [
                ["headerColor=color"],
                [this.panelTitle.style]
            ],            
            [
                ["headerColor=color", "iconColor=color", "iconSize=fontSize"],
                [this.panelIcon.style]
            ],
            [
                ["headerColor=color"],
                Array.from(this.panelButtons).map(panelButton => panelButton.style)
            ],                 
            [
                ["display", "flexFlow", "flexWrap", "alignItems", "alignContent", "justifyContent", "padding", "overflow", "overflowX", "overflowY", "background", "backgroundColor", "backgroundImage", "backgroundSize"],
                [this.panelBody.style]
            ],
            [
                ["maskBackgroundColor=backgroundColor"],
                [this.mask?.style]
            ]
        ])

        // Header visibility
        if (config.header == false) this.panelHeader.style.display = "none"

        // Closable
        if (config.closable) this.isClosable = true

        // Close action (hide or remove)
        this.closeMethod = config.closeMethod || "remove"

        // Draggable
        if (config.draggable == true) {
            this.isDraggable = true
            this._enableDrag()
        }

        // If it's a draggable (floating) windows or auto-centered window, we update the layout when window is resized
        if (config.draggable || config.align == "center" || config.verticalAlign == "center") {
            this.subscriptions.push(subscribe("EVT_WINDOW_RESIZED", () => this.updateLayout()))
        }

        if (config.autoSize === true) {
            kiss.screen.getResizeObserver().observe(this.panelBody)
        }

        // Expandable
        if (config.expandable) this.isExpandable = true
        this.expanded = true

        // Collapsible
        if (config.collapsible) this.isCollapsible = true

        // Collapse panel if requested
        if (config.collapsed) {
            setTimeout(() => this.collapse(), 0)
        }

        // Add custom header buttons
        if (config.headerButtons) {
            config.headerButtons.forEach(button => this.addHeaderButton(button))
        }

        // Add custom header icons
        if (config.headerIcons) {
            config.headerIcons.filter(icon => icon.hidden !== true).forEach(icon => this.addHeaderIcon(icon))
        }

        this._initHeaderClickEvent()
        return this
    }

    /**
     * Manage click event in the panel's header to perform various actions like "close", "expand", "collapse"...
     * 
     * @private
     * @ignore
     */
    _initHeaderClickEvent() {
        this.panelHeader.onclick = function(event) {
            const element = event.target
            let panel = element.closest("a-panel")

            if (element.classList.contains("panel-button-close")) {
                panel.close()
            }
            else if (element.classList.contains("panel-button-expand")) {
                panel.maximize(20)
            }
            else if (element.classList.contains("panel-button-expand-collapse") || element.classList.contains("panel-header-collapsible")) {
                panel.expandCollapse()
            }
            else if ((element.classList.contains("panel-title") || element.classList.contains("panel-icon")) && panel.config.collapsible === true && panel.config.draggable !== true) {
                panel.expandCollapse()
            }
        }
    }

    /**
     * Set or update the panel icon
     * 
     * @param {string} iconClass
     * @returns this
     */
    setIcon(iconClass) {
        this.config.icon = iconClass
        this.panelIcon.className = "panel-icon " + iconClass
        return this
    }

    /**
     * Set or update the panel header text color
     * 
     * @param {string} color - Hexa color code. Ex: #00aaee
     * @returns this
     */
    setHeaderColor(color) {
        this.config.headerColor = color
        this.panelIcon.style.color = color
        this.panelTitle.style.color = color
        Array.from(this.panelButtons).forEach(panelButton => panelButton.style.color = color)
        return this
    }

    /**
     * Set or update the panel header background color
     * 
     * @param {string} color - Hexa color code. Ex: #00aaee
     * @returns this
     */
    setHeaderBackgroundColor(color) {
        this.config.headerBackgroundColor = color
        this.panelHeader.style.backgroundColor = color
        return this
    }

    /**
     * Add a custom button inside the panel's header
     * 
     * @param {object} config
     * @param {string} config.icon - Font Awesome icon class. Ex: "fas fa-check"
     * @param {string} config.tip - Help text
     * @param {function} config.action - Action performed when the button is clicked
     * @returns this
     * 
     * @example
     * myPanel.addHeaderButton({
     *  icon: "fas fa-check",
     *  text: "Save and exit",
     *  action: async () => {
     *      await myRecord.save()
     *      myPanel.close()
     *  }
     * })
     */
    addHeaderButton(config) {
        const button = createButton(config)
        button.classList.add("panel-button")
        this.panelCustomButtons.appendChild(button)
        return this
    }

    /**
     * Add a custom icon inside the panel's header
     * 
     * @param {object} config
     * @param {string} config.icon - Font Awesome icon class. Ex: "fas fa-cog"
     * @param {string} config.tip - Help text
     * @param {function} config.action - Action performed when the icon is clicked
     * @returns this
     * 
     * @example
     * myPanel.addHeaderIcon({
     *  icon: "fas fa-cog",
     *  tip: "Opens the model properties",
     *  action: () => kiss.views.show("model-properties")
     * })
     */    
    addHeaderIcon(config) {
        if (!config.icon) return

        const icon = document.createElement("span")
        icon.setAttribute("id", kiss.tools.shortUid())
        icon.classList.add("panel-buttons", ...config.icon.split(" "))
        if (config.action) icon.onclick = config.action
        if (config.tip) icon.attachTip(config.tip)
        if (config.margin) icon.style.margin = config.margin
        
        this.panelCustomIcons.appendChild(icon)
        return this
    }

    /**
     * Set the panel's title
     * 
     * @param {string} newTitle
     * @returns this
     */
    setTitle(newTitle) {
        this.panelTitle.innerHTML = newTitle
        return this
    }

    /**
     * Set the Html content of the panel component
     * 
     * @param {string} html
     * @returns this
     */
    setInnerHtml(html) {
        this.panelBody.innerHTML = html
        return this
    }

    /**
     * Get the Html content of the panel component
     * 
     * @returns {string} The html content
     */
    getInnerHtml() {
        return this.panelBody.innerHTML
    }

    /**
     * Close the panel using one of 2 possible behaviors:
     * - hide: just hide the panel, without removing it from the DOM
     * - remove: (default) remove the panel from the DOM + all its children + all listeners + all subscriptions
     * 
     * The close method also checks if an event "close|onclose|onClose" has been defined:
     * - if it has been defined, the method is executed
     * - if it returns false, the closing is interrupted
     * 
     * @param {string} [closeMethod] - "hide" or "remove"
     * @param {boolean} [forceClose] - true to force closing, even if the close event returns false
     * @returns {boolean} false if the panel couldn't be closed
     */
    close(closeMethod, forceClose = false) {
        // Trigger onclose event if required
        const closeEvent = (this.config?.events?.onclose) || (this.config?.events?.onClose) || (this.config?.events?.close)
        if (closeEvent) {
            const doClose = closeEvent(forceClose)

            // If the closeEvent returns false, we prevent from closing
            if (doClose === false) return false
        }

        let method = closeMethod || this.closeMethod
        if (method == "hide") {
            this.hide()
            if (this.mask) this.mask.hide()
        } else {
            kiss.views.remove(this.id)
            if (this.mask) kiss.views.remove("panel-mask-" + this.id)
        }
        return true
    }

    /**
     * Set the new panel width
     * 
     * The width can be:
     * - a number, which will be converted in pixels
     * - a valid CSS value: 50px, 10vw
     * - a function that returns a number or a valid CSS value
     * 
     * @param {number|string|function} width 
     * @returns this
     * 
     * @example
     * myPanel.setWidth(500)
     * myPanel.setWidth("500px")
     * myPanel.setWidth("40%")
     * myPanel.setWidth(() => kiss.screen.current.width / 2) // Half the current screen size
     */
    setWidth(width) {
        this.config.width = width
        this.updateLayout()
        return this
    }

    /**
     * Set the new panel height
     * 
     * The height can be:
     * - a number, which will be converted in pixels
     * - a valid CSS value: 50px, 10vw
     * - a function that returns a number or a valid CSS value
     * 
     * @param {number|string|function} height 
     * @returns this
     * 
     * @example
     * myPanel.setHeight(500)
     * myPanel.setHeight("500px")
     * myPanel.setHeight("40%")
     * myPanel.setHeight(() => kiss.screen.current.height / 2) // Half the current screen size
     */    
    setHeight(height) {
        this.config.height = height
        this.updateLayout()
        return this
    }

    /**
     * Collapse the panel
     * 
     * @returns this
     */
    collapse() {
        if (this.expanded) {
            let panelBorderWidth = Number(getComputedStyle(this, "")["border-width"].replace("px", ""))
            this.style.height = (this.panelHeader.offsetHeight + 2 * panelBorderWidth).toString() + "px"
            this.panelBody.style.height = "0px"
            this.panelBody.style.padding = "0px"
            this.panelButtonExpandCollapse.classList.remove("fa-chevron-down")
            this.panelButtonExpandCollapse.classList.add("fa-chevron-right")
            this.expanded = false
        }
        return this
    }

    /**
     * Expand the panel
     * 
     * @returns this
     */
    expand() {
        if (!this.expanded) {
            if (this.config.height) {
                this._setHeight()
            } else {
                this.style.height = ""
                this.panelBody.style.height = ""
                this.panelBody.style.padding = ""
            }

            this.panelButtonExpandCollapse.classList.remove("fa-chevron-right")
            this.panelButtonExpandCollapse.classList.add("fa-chevron-down")
            this.expanded = true
        }
        return this
    }

    /**
     * Expand / Collapse the panel alternatively
     * 
     * @returns this
     */
    expandCollapse() {
        if (!this.isCollapsible) return

        if (this.expanded) {
            this.collapse()
        } else {
            this.expand()
        }
        return this
    }

    /**
     * Enable / Disable the collapsible property
     * 
     * @param {boolean} status
     * @returns this
     */
    setCollapsible(status) {
        this.isCollapsible = status
        return this
    }

    /**
     * Set the panel to the max size
     * 
     * @param {boolean} [delta] - Optional values, in pixels, to make the panel a bit smaller than fullscreen
     * @param {boolean} [state] - true to force fullscreen mode / false to exit fullscreen mode / leave undefined to alternate
     * @returns this
     */
    maximize(delta = 0, state) {
        // Exit for non changing states
        if (this.isFullscreen && state == true) return
        if (!this.isFullscreen && state === false) return

        if (this.isFullscreen != true || state == true) {
            // Set full screen
            // Keep actual values so we can restore them when fullscreen is unset
            this.isFullscreen = true
            this.fullscreenDelta = delta

            this.currentWidth = this.config.width || this.clientWidth
            this.currentHeight = this.config.height || this.clientHeight
            this.currentTop = this.config.top
            this.currentLeft = this.config.left

            // Update config values
            this.config.width = () => kiss.screen.current.width - delta
            this.config.height = () => kiss.screen.current.height - delta
            this.config.top = delta / 2
            this.config.left = delta / 2
        }
        else if (this.isFullscreen == true || state === false) {
            // Unset full screen
            this.isFullscreen = false
            this.config.width = this.currentWidth
            this.config.height = this.currentHeight
            this.config.top = this.currentTop
            this.config.left = this.currentLeft
        }

        this.updateLayout()
        return this
    }

    /**
     * Set the panel to its original size, if it was maximized
     * 
     * @returns this
     */
    minimize() {
        this.maximize(this.fullscreenDelta, false)
        return this
    }

    /**
     * Show the panel's header
     * 
     * @returns this
     */
    showHeader() {
        this.panelHeader.show()
        return this
    }

    /**
     * Hide the panel's header
     * 
     * @returns this
     */
    hideHeader() {
        this.panelHeader.hide()
        return this
    }

    /**
     * Show the panel's mask
     * 
     * @returns this
     */
    showMask() {
        this.mask.show()
        return this
    }

    /**
     * Hide the panel's mask
     * 
     * @returns this
     */
    hideMask() {
        this.mask.hide()
        return this
    }

    /**
     * Enable a draggable behavior on the Panel
     * 
     * @private
     * @ignore
     */
    _enableDrag() {
        let _this = this
        let deltaX = 0
        let deltaY = 0
        let posX = 0
        let posY = 0

        // Enable the element's header
        let header = _this.querySelector(".panel-header")
        if (header.style.display != "none") {
            header.onmousedown = dragStart
        } else {
            _this.onmousedown = dragStart
        }

        // Enable dragging
        function dragStart(e) {
            e = e || window.event
            e.stop()

            posX = e.clientX
            posY = e.clientY
            document.onmouseup = dragStop
            document.onmousemove = dragMove
        }

        // Move
        function dragMove(e) {
            e = e || window.event

            // Prevent drag behavior when the cursor is inside a field, to allow text selection
            if (e.target.nodeName == "INPUT") {
                dragStop(e)
                return e
            }
            e.stop()

            deltaX = posX - e.clientX
            deltaY = posY - e.clientY
            posX = e.clientX
            posY = e.clientY

            _this.style.opacity = "0.8"
            _this.style.top = (_this.offsetTop - deltaY) + "px"
            _this.style.left = (_this.offsetLeft - deltaX) + "px"
        }

        // Disable dragging
        function dragStop(e) {
            e = e || window.event
            e.stop()

            _this.style.opacity = "1"
            document.onmouseup = null
            document.onmousemove = null
        }
    }
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-panel", kiss.ui.Panel)

/**
 * Shorthand to create a new Panel. See [kiss.ui.Panel](kiss.ui.Panel.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createPanel = (config) => document.createElement("a-panel").init(config)

;/**
 * 
 * The Wizard Panel derives from [Panel](kiss.ui.Panel.html).
 * 
 * It's a panel where items are displayed one at a time (each wizard page) with helper buttons (next, previous) to navigate through the pages.
 * The panel title is updated with the current page number.
 * 
 * @param {object} config
 * @param {function} config.action - Action triggered when the last page of the wizard is validated. The function is called with the wizard panel as context, so that this.getData() can be used to get the data of all fields of the wizard.
 * @param {object} [config.actionText] - Text of the action button of the last page, like "Done", "Proceed", "Let's go". Default = "OK"
 * @param {boolean} [config.pageValidation] - If true, validate each page when navigating next/previous. Default = false
 * @returns this
 * 
 * ## Generated markup
 * ```
 * <a-wizardpanel class="a-panel">
 *  <div class="panel-header">
 *      <span class="panel-icon"></span>
 *      <span class="panel-title"></span>
 *      <span class="panel-custom-buttons"></span>
 *      <span class="panel-button-expand-collapse"></span>
 *      <span class="panel-button-maximize"></span>
 *      <span class="panel-button-close"></span>
 *  </div>
 *  <div class="panel-body">
 *      <!-- Panel items are inserted here -->
 *  </div>
 * </a-wizardpanel>
 * ```
 * 
 */
kiss.ui.WizardPanel = class WizardPanel extends kiss.ui.Panel {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the 3 following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const myWizardPanel = document.createElement("a-wizardpanel").init(config)
     * ```
     * 
     * Or use the shorthand for it:
     * ```
     * const myWizardPanel = createWizardPanel({
     * 
     *   // Can have the same config properties as a panel
     *   title: "Setup"
     *   icon: "fas fa-wrench",
     *   headerBackgroundColor: "#00aaee",
     *   closable: true,
     *   draggable: true,
     *   modal: true,
     *   display: "flex"
     *   flexFlow: "column",
     *   padding: "10px",
     * 
     *   // Wizard pages
     *   items: [
     *      wizardPage1,
     *      wizardPage2,
     *      wizardPage3
     *   ],
     *   actionText: "Proceed",
     *   action: function() {
     *      // Get the data of all fields of the wizard
     *      const data = this.getData()
     *     // Do something with the data
     *   }
     * })
     * 
     * myWizardPanel.render()
     * ```
     * 
     * Or directly declare the config inside a container component:
     * ```
     * const myBlock = createBlock({
     *   items: [
     *       {
     *           type: "wizardpanel",
     *           title: "Foo",
     *           items: [
     *               wizardPage1,
     *               wizardPage2,
     *               wizardPage3
     *           ],
     *           actionText: "Proceed",
     *           action: function() {
     *              // Get the data of all fields of the wizard
     *              const data = this.getData()
     *              // Do something with the data
     *           }
     *       }
     *   ]
     * })
     * myBlock.render()
     * ```
     * 
     * If you need to validate a page before navigating to the next one, you can add a **validate** method to the page:
     * ```
     * const wizardPage1 = {
     *  type: "panel", // or "block"
     *  items: [
     *      // Page items
     *  ],
     *  methods: {
     *     validate: function() {
     *       // Validate the page
     *       return true // or false
     *     }
     *  }
     * }
     * 
     * Use this in combination with "pageValidation" property in the wizard panel config.
     * If you don't need a specific validation, "pageValidation" will validate all the pages as normal forms, checking for validation rules of each field.
     * ```
     * 
     */
    constructor() {
        super()
    }

    /**
     * Generates a Wizard Panel from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config) {
        config.id = config.id || "cmp-" + (kiss.global.componentCount++).toString()
        this.id = config.id
        this.currentPage = 0
        this.numberOfPages = config.items.length
        this.pageValidation = !!config.pageValidation

        this._initButtons(config)
        config.items = this._initStructure(config)

        super.init(config)
        this._updateTitle()

        this.classList.add("a-panel")
        return this
    }

    /**
     * Manage click event in the panel's header to perform various actions like "close", "expand", "collapse"...
     * 
     * @private
     * @ignore
     */
    _initHeaderClickEvent() {
        this.panelHeader.onclick = function(event) {
            const element = event.target
            let panel = element.closest("a-wizardpanel")

            if (element.classList.contains("panel-button-close")) {
                panel.close()
            }
            else if (element.classList.contains("panel-button-expand")) {
                panel.maximize(20)
            }
            else if (element.classList.contains("panel-button-expand-collapse") || element.classList.contains("panel-header-collapsible")) {
                panel.expandCollapse()
            }
            else if ((element.classList.contains("panel-title") || element.classList.contains("panel-icon")) && panel.config.collapsible === true && panel.config.draggable !== true) {
                panel.expandCollapse()
            }
        }
    }    

    /**
     * Initialize the DOM structure of the wizard panel:
     * - original items are inserted into "pages" block
     * - a button bar is added to the bottom of the panel to navigate between pages
     * 
     * @private
     * @ignore
     * @param {object} config 
     * @returns {object} The final structure
     */
    _initStructure(config) {
        const items = [
            {
                id: this.id + "-pages",
                multiview: true,
                items: config.items
            },
            {
                id: this.id + "-buttons",
                layout: "horizontal",
                defaultConfig: {
                    type: "button",
                    margin: "1rem 0.5rem 0 0",
                    height: "4rem",
                    flex: 1
                },
                items: [
                    this.buttonCancel,
                    (this.numberOfPages > 1) ? this.buttonNext : this.buttonOK
                ]
            }
        ]
        return items
    }

    /**
     * Initialize the buttons of the wizard panel:
     * - cancel
     * - previous / next
     * - validate
     * 
     * @private
     * @ignore
     * @param {object} config 
     */
    _initButtons(config) {
        this.buttonCancel = {
            icon: "fas fa-times",
            text: txtTitleCase("cancel"),
            action: function () {
                this.closest("a-wizardpanel").close()
            }
        }

        this.buttonPrevious = {
            icon: "fas fa-chevron-left",
            text: txtTitleCase("previous"),
            action: function () {
                this.closest("a-wizardpanel").previous()
            }
        }

        this.buttonNext = {
            icon: "fas fa-chevron-right",
            iconPosition: "right",
            text: txtTitleCase("next"),
            action: function () {
                this.closest("a-wizardpanel").next()
            }
        }             

        this.buttonOK = {
            icon: "fas fa-check",
            text: config.actionText || "OK",
            action: () => {
                if (this.pageValidation && !this.validatePage()) return

                // this = wizard panel, which allows to reference the wizard panel inside the action
                config.action.bind(this)() 
            }
        }     
    }

    /**
     * Update the buttons when navigating between pages
     * 
     * @private
     * @ignore
     */
    _updateButtons() {
        let buttons
        if (this.currentPage == 0) {
            buttons = [this.buttonCancel, (this.numberOfPages > 1) ? this.buttonNext : this.buttonOK]
        }
        else if (this.currentPage == this.numberOfPages - 1) {
            buttons = [this.buttonPrevious, this.buttonOK]
        }
        else {
            buttons = [this.buttonPrevious, this.buttonNext]
        }
        $(this.id + "-buttons").setItems(buttons)
    }

    /**
     * Update the title of the wizard panel with the current page number
     * 
     * @private
     * @ignore
     */
    _updateTitle() {
        this.setTitle((this.currentPage + 1) + "/" + this.numberOfPages + " - " + this.config.title)
    }

    /**
     * Validates the form of a wizard page.
     * Prevents from navigating to the next page if the form is not validated.
     * 
     * @param {number} [pageIndex] - Optional wizard's page to validate. If not specified, tries to validate the current page.
     */
    validatePage(pageIndex) {
        this.pages = $(this.id + "-pages").children
        if (!this.pages) return true
        const currentPage = this.pages[pageIndex || this.currentPage]
        return (currentPage.validate) ? currentPage.validate() : true
    }

    /**
     * Navigate to the next wizard page
     */
    next() {
        if (this.pageValidation && !this.validatePage()) return

        this.currentPage++
        this._updateButtons()
        this._updateTitle()

        $(this.id + "-pages").showItem(this.currentPage, {
            name: "slideInRight",
            speed: "faster"
        })
    }

    /**
     * Navigate to the previous wizard page
     */
    previous() {
        this.currentPage--
        this._updateButtons()
        this._updateTitle()
        
        $(this.id + "-pages").showItem(this.currentPage, {
            name: "slideInLeft",
            speed: "faster"
        })
    }
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-wizardpanel", kiss.ui.WizardPanel)

/**
 * Shorthand to create a new Wizard Panel. See [kiss.ui.WizardPanel](kiss.ui.WizardPanel.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createWizardPanel = (config) => document.createElement("a-wizardpanel").init(config)

;/** 
 * 
 * The **Calendar** derives from [DataComponent](kiss.ui.DataComponent.html).
 * 
 * It's a [powerful calendar](https://kissjs.net/#ui=start&section=calendar) with the following features:
 * - various range of periods (1 week, 2 weeks, 3 weeks, 1 month)
 * - 1 week + details view
 * - choosing the fields to display in the cards
 * - choosing the field to use as the date reference
 * - complex filtering with combination of AND/OR filters
 * - display the week-end or not
 * - start the week on Monday or not
 * 
 * @param {object} config
 * @param {string} [config.date] - The initial date to display in the timeline (default = today)
 * @param {string} [config.period] - "month" (default) | "3 weeks" | "2 weeks" | "1 week" | "1 week + details"
 * @param {boolean} [config.startOnMonday]
 * @param {boolean} [config.showWeekend]
 * @param {string} config.dateField - The field to use as reference for the calendar
 * @param {string} [config.timeField]
 * @param {Collection} config.collection - The data source collection
 * @param {object} [config.record] - Record to persist the view configuration into the db
 * @param {object[]} [config.columns] - Where each column is: {title: "abc", type: "text|number|integer|float|date|button", id: "fieldId", button: {config}, renderer: function() {}}
 * @param {string} [config.color] - Hexa color code. Ex: #00aaee
 * @param {boolean} [config.showToolbar] - false to hide the toolbar (default = true)
 * @param {boolean} [config.showActions] - false to hide the custom actions button (default = true)
 * @param {boolean} [config.showSetup] - false to hide the setup button (default = true)
 * @param {boolean} [config.canFilter] - false to hide the filter button (default = true)
 * @param {boolean} [config.canSelectFields] - false to hide the button to select fields (default = true)
 * @param {boolean} [config.canChangePeriod] - false to hide the possibility to change period (1 month, 2 weeks...) (default = true)
 * @param {boolean} [config.canCreateRecord] - Can we create new records from the calendar?
 * @param {object[]} [config.actions] - Array of menu actions, where each menu entry is: {text: "abc", icon: "fas fa-check", action: function() {}}
 * @param {number|string} [config.width]
 * @param {number|string} [config.height]
 * @returns this
 * 
 * ## Generated markup
 * ```
 * <a-calendar class="a-calendar">
 *      <div class="calendar-toolbar">
 *          <!-- Calendar toolbar items -->
 *      </div>
 *      <div class="calendar-body">
 *          <!-- Calendar entries here -->
 *      </div>
 * </a-calendar>
 * ```
 */
kiss.ui.Calendar = class Calendar extends kiss.ui.DataComponent {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const myCalendar = document.createElement("a-calendar").init(config)
     * ```
     * 
     * Or use the shorthand for it:
     * ```
     * const myCalendar = createCalendar({
     *   id: "my-calendar",
     *   color: "#00aaee",
     *   collection: kiss.app.collections["meetings"],
     *   
     *   // We can add custom methods, and also override default ones
     *   methods: {
     * 
     *      // Override the createRecord method
     *      createRecord(model) {
     *          // Create a record from this model
     *          console.log(model)
     *      },
     * 
     *      // Override the selectRecord method
     *      selectRecord(record) {
     *          // Show the clicked record
     *          console.log(record)
     *      },
     * 
     *      sayHello: () => console.log("Hello"),
     *   }
     * })
     * 
     * myCalendar.render()
     * ```
     */
    constructor() {
        super()
    }

    /**
     * Generates a Calendar from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config) {
        // This component must be resized with its parent container
        config.autoSize = true

        // Init the parent DataComponent
        super.init(config)

        // Options
        this.showToolbar = (config.showToolbar !== false)
        this.showActions = (config.showActions !== false)
        this.showSetup = (config.showSetup !== false)
        this.canSearch = (config.canSearch !== false)
        this.canFilter = (config.canFilter !== false)
        this.canSelectFields = (config.canSelectFields !== false)
        this.canChangePeriod = (config.canChangePeriod !== false)
        this.color = config.color || "#00aaee"
        this.actions = config.actions || []

        // Build calendar skeletton markup
        let id = this.id
        this.innerHTML =
            /*html*/
            `<div id="calendar-toolbar:${id}" class="calendar-toolbar">
                <div id="create:${id}"></div>
                <div id="actions:${id}"></div>
                <div id="setup:${id}"></div>
                <div id="select:${id}"></div>
                <div id="filter:${id}"></div>
                <div id="refresh:${id}"></div>
                <div class="spacer"></div>
                <div id="title:${id}" class="calendar-title"></div>
                <div class="spacer"></div>
                <div id="pager-index:${id}" class="calendar-toolbar-pager-index"></div>
                <div id="pager-mode:${id}"></div>
                <div id="pager-previous:${id}"></div>
                <div id="pager-next:${id}"></div>
                <div id="pager-today:${id}"></div>
                <div id="layout:${id}"></div>
            </div>
            <div id="calendar-body:${id}" class="calendar-body">`.removeExtraSpaces()

        // Set calendar components
        this.calendar = this.querySelector(".calendar")
        this.calendarToolbar = this.querySelector(".calendar-toolbar")
        this.calendarBody = this.querySelector(".calendar-body")

        this._initColumns(config.columns)
            ._initCalendarParams(config)
            ._initTexts()
            ._initElementsVisibility()
            ._initEvents()
            ._initSubscriptions()

        return this
    }

    /**
     * Load data into the calendar.
     * 
     * @private
     * @ignore
     */
    async load() {
        try {
            log(`kiss.ui - Calendar ${this.id} - Loading collection <${this.collection.id} (changed: ${this.collection.hasChanged})>`)

            this.collection.filter = this.filter
            this.collection.filterSyntax = this.filterSyntax
            await this.collection.find({}, true)

            this._renderToolbar()
            this.showCalendar(this.date)

        } catch (err) {
            log(err)
            log(`kiss.ui - Calendar ${this.id} - Couldn't load data properly`)
        }
    }

    /**
     * Reload the data and re-render
     */
    async reload() {
        await this.load()
        this._initColumns()
        this._render()
    }

    /**
     * Update the calendar layout
     */
    updateLayout() {
        if (this.isConnected) {
            this._render()
        }
    }

    /**
     * Update the calendar color (toolbar buttons + modal windows)
     * 
     * @param {string} newColor
     */
    async setColor(newColor) {
        this.color = newColor
        Array.from(this.calendarToolbar.children).forEach(item => {
            if (item && item.firstChild && item.firstChild.type == "button") item.firstChild.setIconColor(newColor)
        })
        this._render()
    }

    /**
     * Show the calendar at a given date
     * 
     * @param {date|string} date - Date given as a Date or an ISO date string like "2023-06-24"
     * @returns this
     */
    showCalendar(date) {
        if (typeof date == "string" && kiss.tools.isISODate(date, true)) date = new Date(date)
        const animation = (date.toISO() == this.date.toISO()) ? "fadeIn" : ((date.toISO() < this.date.toISO()) ? "slideInLeft" : "slideInRight")
        this.date = date
        this._render()

        this.calendarBody.setAnimation({
            name: animation,
            speed: "light"
        })
        return this
    }

    /**
     * Show the window to setup the calendar:
     * - source date field
     * - source time field
     * - prefered layout (1 month, 2 weeks, 1 week...)
     * - show week-ends
     * - week starts on monday
     */
    showSetupWindow() {
        let dateFields = this.model.getFieldsByType("date")
            .filter(field => !field.deleted)
            .map(field => {
                return {
                    value: field.id,
                    label: field.label.toTitleCase()
                }
            })

        let timeFields = this.model.getFieldsByType("select")
            .filter(field => !field.deleted && field.template == "time")
            .map(field => {
                return {
                    value: field.id,
                    label: field.label.toTitleCase()
                }
            })

        createPanel({
            icon: "fas fa-calendar",
            title: txtTitleCase("setup the calendar"),
            headerBackgroundColor: this.color,
            modal: true,
            draggable: true,
            closable: true,
            align: "center",
            verticalAlign: "center",
            width: "40rem",

            defaultConfig: {
                labelPosition: "top",
                optionsColor: this.color
            },

            items: [
                // Source date field
                {
                    type: "select",
                    id: "calendar-datefield:" + this.id,
                    label: txtTitleCase("date field used"),
                    options: dateFields,
                    maxHeight: () => kiss.screen.current.height - 200,
                    value: this.dateField,
                    events: {
                        change: async function () {
                            let dateField = this.getValue()
                            let viewId = this.id.split(":")[1]
                            publish("EVT_VIEW_SETUP:" + viewId, {
                                dateField
                            })
                        }
                    }
                },
                // Source time field
                {
                    type: "select",
                    id: "calendar-timefield:" + this.id,
                    label: txtTitleCase("time field used"),
                    options: timeFields,
                    maxHeight: () => kiss.screen.current.height - 200,
                    value: this.timeField,
                    events: {
                        change: async function () {
                            let timeField = this.getValue()
                            let viewId = this.id.split(":")[1]
                            publish("EVT_VIEW_SETUP:" + viewId, {
                                timeField
                            })
                        }
                    }
                },
                // Default period
                {
                    type: "select",
                    id: "calendar-period:" + this.id,
                    label: txtTitleCase("default period"),
                    options: [{
                            label: txtTitleCase("month"),
                            value: "month"
                        },
                        {
                            label: "3 " + txtTitleCase("weeks"),
                            value: "3 weeks"
                        },
                        {
                            label: "2 " + txtTitleCase("weeks"),
                            value: "2 weeks"
                        },
                        {
                            label: "1 " + txtTitleCase("week"),
                            value: "1 week"
                        },
                        {
                            label: "1 " + txtTitleCase("week") + " + " + txtTitleCase("details"),
                            value: "1 week + details"
                        }
                    ],
                    value: this.period || "month",
                    events: {
                        change: async function () {
                            let period = this.getValue()
                            let viewId = this.id.split(":")[1]
                            publish("EVT_VIEW_SETUP:" + viewId, {
                                period
                            })
                        }
                    }
                },
                // Show week-end ?
                {
                    type: "checkbox",
                    id: "calendar-showWeekend:" + this.id,
                    label: txtTitleCase("show week-ends"),
                    labelPosition: "right",
                    shape: "switch",
                    iconColorOn: this.color,
                    value: this.showWeekend,
                    events: {
                        change: async function () {
                            let showWeekend = this.getValue()
                            let viewId = this.id.split(":")[1]
                            publish("EVT_VIEW_SETUP:" + viewId, {
                                showWeekend
                            })

                            if (showWeekend == true) {
                                $("calendar-startOnMonday:" + viewId).show()
                            } else {
                                $("calendar-startOnMonday:" + viewId).hide()
                            }
                        }
                    }
                },
                // Weeks start on monday ?
                {
                    hidden: !this.showWeekend,
                    type: "checkbox",
                    id: "calendar-startOnMonday:" + this.id,
                    label: txtTitleCase("weeks start on monday"),
                    labelPosition: "right",
                    shape: "switch",
                    iconColorOn: this.color,
                    value: this.startOnMonday,
                    events: {
                        change: async function () {
                            let startOnMonday = this.getValue()
                            let viewId = this.id.split(":")[1]
                            publish("EVT_VIEW_SETUP:" + viewId, {
                                startOnMonday
                            })
                        }
                    }
                }
            ]
        }).render()
    }

    /**
     * Show the window just under the fields selector button
     */
    showFieldsWindow() {
        let selectionButton = $("select:" + this.id)
        const box = selectionButton.getBoundingClientRect()
        super.showFieldsWindow(box.left, box.top + 40, this.color)
    }

    /**
     * Show the window just under the filter button
     */
    showFilterWindow() {
        super.showFilterWindow(null, null, this.color)
    }

    /**
     * Define the specific calendar params:
     * - the initial date
     * - date field used to filter and display records
     * - time field used
     * - displayed period (1 month, 2 months...)
     * - start on Monday
     * - show weekend
     * 
     * @private
     * @ignore
     * @param {object} config - {date, dateField, timeField, period, startOnMonday, showWeekend}
     * @returns this
     */
    _initCalendarParams(config) {
        this.date = this.config.date || new Date()

        if (this.record) {
            this.dateField = config.dateField || this.record.config.dateField
            this.timeField = config.timeField || this.record.config.timeField
            this.period = config.period || this.record.config.period || "month"
            this.startOnMonday = (config.hasOwnProperty("startOnMonday")) ? !!config.startOnMonday : (this.record.config.startOnMonday !== false)
            this.showWeekend = (config.hasOwnProperty("showWeekend")) ? !!config.showWeekend : (this.record.config.showWeekend !== false)

        } else {
            this.dateField = config.dateField || this.config.dateField
            this.timeField = config.timeField || this.config.timeField
            this.period = config.period || this.config.period || "month"
            this.startOnMonday = (config.hasOwnProperty("startOnMonday")) ? !!config.startOnMonday : (this.config.startOnMonday !== false)
            this.showWeekend = (config.hasOwnProperty("showWeekend")) ? !!config.showWeekend : (this.config.showWeekend !== false)
        }

        // Defaults to the first date field, or the creation date if no date field was found
        if (!this.dateField) {
            let modelDateFields = this.model.getFieldsByType(["date"])
            if (modelDateFields.length != 0) {
                this.dateField = modelDateFields[0].id
            } else {
                this.dateField = "createdAt"
            }
        }

        // Defaults to the first time field
        if (!this.timeField && this.timeField !== "") {
            let modelTimeFields = this.model.getFieldsByType(["select"])
            modelTimeFields = modelTimeFields.filter(field => field.template == "time")

            if (modelTimeFields.length != 0) {
                this.timeField = modelTimeFields[0].id
            }
        }

        return this
    }

    /**
     * Set toolbar visibility
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initElementsVisibility() {
        if (this.showToolbar == false) this.calendarToolbar.style.display = "none"
        return this
    }    

    /**
     * Initialize subscriptions to PubSub
     * 
     * TODO: don't reload the view when records are inserted/deleted/updated outside of the current viewport
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initSubscriptions() {
        super._initSubscriptions()

        const viewModelId = this.modelId.toUpperCase()

        this.subscriptions = this.subscriptions.concat([
            // Local events (not coming from websocket)
            subscribe("EVT_VIEW_SETUP:" + this.id, (msgData) => this._updateConfig(msgData)),

            // React to database mutations
            subscribe("EVT_DB_INSERT:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData)),
            subscribe("EVT_DB_UPDATE:" + viewModelId, (msgData) => this._updateOneAndReload(msgData)),
            subscribe("EVT_DB_DELETE:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData)),
            subscribe("EVT_DB_INSERT_MANY:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData, 2000)),
            subscribe("EVT_DB_UPDATE_MANY:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData, 2000)),
            subscribe("EVT_DB_DELETE_MANY:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData, 2000)),
            subscribe("EVT_DB_UPDATE_BULK", (msgData) => this._reloadWhenNeeded(msgData, 2000))
        ])

        return this
    }

    /**
     * Initialize all calendar events
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initEvents() {
        this.onclick = async (event) => {
            const clickedElement = event.target
            const recordElement = clickedElement.closest(".calendar-record")
            if (!recordElement) return

            if (recordElement.classList.contains("calendar-record")) {
                const recordId = recordElement.getAttribute("recordid")
                const record = await this.collection.getRecord(recordId)
                await this.selectRecord(record)
                return event
            }
        }
        return this
    }

    /**
     * Render the calendar
     * 
     * @private
     * @ignore
     * @returns this
     */
    _render() {
        switch (this.period) {
            case "month":
                return this._renderAsWeeks(6)
            case "3 weeks":
                return this._renderAsWeeks(3)
            case "2 weeks":
                return this._renderAsWeeks(2)
            case "1 week":
                return this._renderAsWeeks(1)
            case "1 week + details":
                return this._renderAsWeeks(1, true)
            default:
                return this._renderAsWeeks(6)
        }
    }

    /**
     * Render the calendar for 2, 3 or 6 weeks
     * 
     * @private
     * @ignore
     * @param {number} numberOfWeeks - 1 to 6 (month)
     * @param {boolean} expanded - If true, display large items in the calendar
     * @returns this
     */
    _renderAsWeeks(numberOfWeeks, expanded) {
        let date = this.date
        let currentMonth = date.getMonth()
        let currentDate = (this.startOnMonday) ? this._getPreviousMonday(date) : this._getPreviousSunday(date)
        this.startDate = currentDate

        switch (this.period) {
            case "month":
                this.date.setDate(1)
                break
            default:
                this.date = this._getPreviousMonday(this.date)
        }

        let calendarHTML = /*html*/ `
            <div class="calendar-header">
                ${this.weekDays.map(day => `<div class="calendar-header-title">${day}</div>`).join("")}
            </div>`

        for (let weekIndex = 1; weekIndex <= numberOfWeeks; weekIndex++) {
            calendarHTML += `<div class="calendar-week">`
            for (let dayIndex = 1; dayIndex <= 7; dayIndex++) {
                let day = currentDate.getDate()
                let month = currentDate.getMonth()
                let year = currentDate.getFullYear()
                let dayId = this._getDayId(day, month + 1, year)
                let dayClass = ""

                // Week-end => Alternate background color
                if (currentDate.getDay() == 0 || currentDate.getDay() == 6) {
                    dayClass = (this.showWeekend) ? "calendar-weekend" : "calendar-no-weekend"
                }

                // Other months => Light font color
                if (month != currentMonth) day = `<span class="calendar-otherMonth">${day}</span>`

                calendarHTML += `<div class="calendar-day ${dayClass}"><div>${day}</div><div class="day-items" id="${dayId}"></div></div>`
                currentDate = new Date(kiss.formula.ADJUST_DATE(currentDate, 0, 0, 1, 0, 0, 0))
            }
            calendarHTML += `</div>`
        }

        this.endDate = currentDate
        this._renderToolbarTitle()
        this.calendarBody.innerHTML = calendarHTML

        this._renderRecords(expanded)
        this._renderToday()
        return this
    }

    /**
     * Render records inside the calendar
     * 
     * @private
     * @ignore
     * @param {boolean} expanded - If true, display items as cards in the calendar
     */
    _renderRecords(expanded) {
        const startDateISO = this.startDate.toISO()
        const endDateISO = this.endDate.toISO()

        let records = this.collection.records.filter(record => {
            const date = record[this.dateField]
            if (date instanceof Date) return date >= this.startDate && date <= this.endDate
            return date >= startDateISO && date <= endDateISO
        })

        if (this.timeField) records = records.sortBy(this.timeField)

        records.forEach(record => {
            const date = new Date(record[this.dateField]).toISO()
            const calendarCell = $(date)
            if (!calendarCell) return

            const recordHtml = document.createElement("div")
            recordHtml.innerHTML = (!expanded) ? this._renderRecord(record) : this._renderRecordAsCard(record)
            recordHtml.classList.add("calendar-record")
            recordHtml.style.borderColor = this.model.color
            recordHtml.setAttribute("recordid", record.id)
            calendarCell.appendChild(recordHtml)
        })
    }

    /**
     * Render a single record
     * 
     * @private
     * @ignore
     * @param {object} record
     * @returns {string} Html for a single record
     */
    _renderRecord(record) {
        let recordHtml = ((this.timeField) ? record[this.timeField] : "") || ""
        if (recordHtml) recordHtml = `<span style="color: ${this.model.color}">${recordHtml}</span>`

        this.columns
            .filter(column => column.hidden !== true)
            .forEach(column => {
                let field = this.model.getField(column.id)
                if (!field) return

                let value = record[column.id]
                if (!value && value !== false && value !== 0) return

                recordHtml += " · " + this._renderSingleValue(field, value, record)
            })
        return recordHtml
    }

    /**
     * Highlight today
     * 
     * @private
     * @ignore
     */
    _renderToday() {
        let today = new Date().toISO()
        let todayCell = $(today)
        if (!todayCell) return

        let day = todayCell.parentNode.children[0]
        day.classList.add("calendar-today")
        day.style.color = "#ffffff"
        day.style.backgroundColor = this.color
    }    

    /**
     * Render a single record as a Card for 1 week view
     * 
     * @private
     * @ignore
     * @param {object} record
     * @returns {string} Html for a single record
     */
    _renderRecordAsCard(record) {
        // Add time at the beginning of the card, if available
        let recordHtml = ((this.timeField) ? record[this.timeField] : "") || ""
        if (recordHtml) recordHtml = `<span style="color: ${this.model.color}">${recordHtml}</span>`

        this.columns
            .filter(column => column.hidden !== true)
            .forEach(column => {
                let field = this.model.getField(column.id)
                if (!field) return
                
                if (["attachment", "password", "link"].includes(field.type)) return

                let value = record[column.id]
                if (!value && value !== false && value !== 0) return

                let valueHtml = this._renderSingleValue(field, value, record)
                recordHtml += /*html*/ `
                    <div class="calendar-record-field">
                        <div class="calendar-record-label">${field.label} ${(field.unit) ? `(${field.unit})` : ""}</div>
                        <div class="calendar-record-value">${valueHtml}</div>
                    </div>
                `.removeExtraSpaces()
            })

        return recordHtml
    }

    /**
     * Render a single value inside a card
     * 
     * @private
     * @ignore
     * @param {object} field - Field to render
     * @param {*} value - Field value
     * @param {object} record - The record, useful for custom renderers
     * @returns {string} Html for the value
     */
    _renderSingleValue(field, value, record) {
        const renderer = kiss.fields.renderers[this.model.id][field.id]
        const type = kiss.fields.getFieldType(field)

        switch (type) {
            case "date":
            case "textarea":
            case "aiTextarea":
            case "select":
            case "directory":
            case "checkbox":
            case "rating":
            case "color":
            case "icon":
            case "selectViewColumn":
                return renderer({
                    value,
                    record
                })

            case "number":
            case "slider":
                return renderer({
                    value,
                    record,
                    config: {
                        unit: false
                    }
                })                
            default:
                return value
        }
    }

    /**
     * Update a single record then reload the view if required.
     * 
     * @private
     * @ignore
     * @param {object} msgData - The original pubsub message
     */
    async _updateOneAndReload(msgData) {
        const filterFields = kiss.db.mongo.getFilterFields(this.filter)
        let dateHasChanged = false
        let timeHasChanged = false
        let filterHasChanged = false

        let updates = msgData.data
        for (let fieldId of Object.keys(updates)) {
            if (this.dateField == fieldId) dateHasChanged = true
            if (this.timeField == fieldId) timeHasChanged = true
            if (filterFields.indexOf(fieldId) != -1) filterHasChanged = true
        }

        if (dateHasChanged || timeHasChanged || filterHasChanged) {
            this._reloadWhenNeeded(msgData, 2000)
        }
        else {
            this._updateRecord(msgData.id)
        }
    }

    /**
     * Update a single record of the calendar.
     * 
     * Does nothing if the record is not displayed on the active page.
     * 
     * @private
     * @ignore
     * @param {string} recordId 
     */
    _updateRecord(recordId) {
        const record = this.collection.getRecord(recordId)
        const recordNode = document.querySelector(`.calendar-record[recordid="${recordId}"]`)

        if (recordNode) {
            const replacementNode = document.createElement("div")
            replacementNode.classList.add("calendar-record")
            replacementNode.style.borderColor = this.model.color
            replacementNode.innerHTML = (this.period.includes("details")) ? this._renderRecordAsCard(record) : this._renderRecord(record)
            recordNode.parentNode.replaceChild(replacementNode, recordNode)
            replacementNode.setAttribute("recordid", recordId)
        }
    }

    /**
     * Update the calendar configuration
     * 
     * @private
     * @ignore
     * @param {object} newConfig 
     */
    async _updateConfig(newConfig) {
        if (newConfig.hasOwnProperty("dateField")) this.dateField = newConfig.dateField
        if (newConfig.hasOwnProperty("timeField")) this.timeField = newConfig.timeField
        if (newConfig.hasOwnProperty("period")) this.period = newConfig.period
        if (newConfig.hasOwnProperty("startOnMonday")) this.startOnMonday = newConfig.startOnMonday
        if (newConfig.hasOwnProperty("showWeekend")) this.showWeekend = newConfig.showWeekend

        this._initTexts()
        this._render()

        let currentConfig
        if (this.record) {
            currentConfig = this.record.config
        }
        else {
            currentConfig = {
                dateField: this.dateField,
                timeField: this.timeField,
                period: this.period,
                startOnMonday: this.startOnMonday,
                showWeekend: this.showWeekend,
                columns: this.columns
            }
        }

        let config = Object.assign(currentConfig, newConfig)
        await this.updateConfig({
            config
        })
    }

    /**
     * Render the toolbar
     * 
     * @private
     * @ignore
     */
    _renderToolbar() {
        if (this.isToolbarRendered) return
        this.isToolbarRendered = true

        // New record creation button
        createButton({
            hidden: !this.canCreateRecord,
            class: "calendar-create-record",
            target: "create:" + this.id,
            text: this.config.createRecordText || this.model.name.toTitleCase(),
            icon: "fas fa-plus",
            iconColor: this.color,
            borderWidth: "0.3rem",
            borderRadius: "3.2rem",
            maxWidth: (kiss.screen.isMobile && kiss.screen.isVertical()) ? "16rem" : null,
            action: async () => this.createRecord(this.model)
        }).render()

        // Setup date/time button
        createButton({
            hidden: !this.showSetup,
            target: "setup:" + this.id,
            tip: txtTitleCase("setup the calendar"),
            icon: "fas fa-cog",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this.showSetupWindow()
        }).render()

        // Column selection button
        createButton({
            hidden: !this.canSelectFields,
            target: "select:" + this.id,
            tip: txtTitleCase("#display fields"),
            icon: "fas fa-bars fa-rotate-90",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this.showFieldsWindow()
        }).render()

        // Filtering button
        createButton({
            hidden: !this.canFilter,
            target: "filter:" + this.id,
            tip: txtTitleCase("to filter"),
            icon: "fas fa-filter",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this.showFilterWindow()
        }).render()

        // Pager display mode
        if (this.canChangePeriod) {
            let _this = this
            createSelect({
                target: "pager-mode:" + this.id,
                id: "pager-mode:" + this.id,
                options: [{
                        label: txtTitleCase("month"),
                        value: "month"
                    },
                    {
                        label: "3 " + txtTitleCase("weeks"),
                        value: "3 weeks"
                    },
                    {
                        label: "2 " + txtTitleCase("weeks"),
                        value: "2 weeks"
                    },
                    {
                        label: "1 " + txtTitleCase("week"),
                        value: "1 week"
                    },
                    {
                        label: "1 " + txtTitleCase("week") + " + " + txtTitleCase("details"),
                        value: "1 week + details"
                    }
                ],
                optionsColor: this.color,
                value: this.period || "month",
                fieldWidth: "15rem",
                styles: {
                    "this": "align-items: center;",
                    "field-label": "white-space: nowrap;",
                    "field-select": "white-space: nowrap;",
                },
                events: {
                    change: async function () {
                        _this.period = this.getValue()
                        _this._render()
                    }
                }
            }).render()
        }

        // Pager previous
        createButton({
            target: "pager-previous:" + this.id,
            icon: "fas fa-chevron-left",
            iconColor: this.color,
            width: "3.2rem",
            events: {
                click: () => {
                    let previousDate
                    switch (this.period) {
                        case "month":
                            previousDate = kiss.formula.ADJUST_DATE(this.date, 0, -1, 0, 0, 0, 0)
                            break
                        case "3 weeks":
                            previousDate = kiss.formula.ADJUST_DATE(this.startDate, 0, 0, -21, 0, 0, 0)
                            break
                        case "2 weeks":
                            previousDate = kiss.formula.ADJUST_DATE(this.startDate, 0, 0, -14, 0, 0, 0)
                            break
                        case "1 week":
                        case "1 week + details":
                            previousDate = kiss.formula.ADJUST_DATE(this.startDate, 0, 0, -7, 0, 0, 0)
                            break
                        default:
                    }
                    this.showCalendar(previousDate)
                }
            }
        }).render()

        // Pager next
        createButton({
            target: "pager-next:" + this.id,
            icon: "fas fa-chevron-right",
            iconColor: this.color,
            width: "3.2rem",
            events: {
                click: () => {
                    let nextDate
                    switch (this.period) {
                        case "month":
                            nextDate = kiss.formula.ADJUST_DATE(this.date, 0, 1, 0, 0, 0, 0)
                            break
                        default:
                            nextDate = kiss.formula.ADJUST_DATE(this.endDate, 0, 0, 1, 0, 0, 0)
                    }
                    this.showCalendar(nextDate)
                }
            }
        }).render()

        // Pager today
        const todayButton = {
            target: "pager-today:" + this.id,
            icon: "fas fa-stop",
            iconColor: this.color,
            events: {
                click: () => {
                    let currentDate = new Date()
                    let startDate = currentDate
                    switch (this.period) {
                        case "month":
                            startDate.setDate(1)
                            break
                        default:
                            startDate = this._getPreviousMonday(currentDate)
                    }
                    this.showCalendar(startDate)
                }
            }
        }
        if (!kiss.screen.isMobile) todayButton.text = txtTitleCase("today")
        createButton(todayButton).render()

        // View refresh button
        if (!kiss.screen.isMobile) {
            createButton({
                target: "refresh:" + this.id,
                tip: txtTitleCase("refresh"),
                icon: "fas fa-undo-alt",
                iconColor: this.color,
                width: "3.2rem",
                events: {
                    click: () => this.reload()
                }
            }).render()
        }
    }

    /**
     * Render the title inside the toolbar
     * 
     * @private
     * @ignore
     */
    _renderToolbarTitle() {
        let title
        this.startDay = this.startDate.getDate()
        this.startMonth = this.startDate.getMonth()
        this.startYear = this.startDate.getFullYear()
        this.endDay = new Date(kiss.formula.ADJUST_DATE(this.endDate, 0, 0, -1, 0, 0, 0))
        this.endMonth = this.endDay.getMonth()
        this.endYear = this.endDay.getFullYear()
        this.endDay = this.endDay.getDate()

        switch (this.period) {
            case "month":
                title = this.months[this.date.getMonth()].toUpperCase() + " " + this.date.getFullYear()
                break
            default:
                title =
                    String(this.startDay).padStart(2, "0") +
                    " " +
                    this.months[this.startMonth] +
                    " - " +
                    String(this.endDay).padStart(2, "0") +
                    " " +
                    this.months[this.endMonth] +
                    " " +
                    ((new Date().getFullYear() != this.endYear) ? this.endYear : "")
        }

        this.calendarTitle = title
        $("title:" + this.id).innerHTML = this.calendarTitle
    }

    /**
     * Get the previous monday
     * 
     * @private
     * @ignore
     */
    _getPreviousMonday(date) {
        let newDate = new Date(date)
        let dayOfWeek = date.getDay()
        if (dayOfWeek !== 1) newDate.setDate(date.getDate() - ((dayOfWeek === 0) ? 6 : dayOfWeek - 1))
        return newDate
    }

    /**
     * Get the previous sunday
     * 
     * @private
     * @ignore
     */
    _getPreviousSunday(date) {
        let newDate = new Date(date)
        let dayOfWeek = date.getDay()
        if (dayOfWeek !== 0) newDate.setDate(date.getDate() - dayOfWeek)
        return newDate
    }

    /**
     * Init the localized texts
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initTexts() {
        this.months = [
            txtTitleCase("january"),
            txtTitleCase("february"),
            txtTitleCase("march"),
            txtTitleCase("april"),
            txtTitleCase("may"),
            txtTitleCase("june"),
            txtTitleCase("july"),
            txtTitleCase("august"),
            txtTitleCase("september"),
            txtTitleCase("october"),
            txtTitleCase("november"),
            txtTitleCase("december")
        ]

        this.weekDays = [
            txtTitleCase("sunday"),
            txtTitleCase("monday"),
            txtTitleCase("tuesday"),
            txtTitleCase("wednesday"),
            txtTitleCase("thursday"),
            txtTitleCase("friday"),
            txtTitleCase("saturday")
        ]

        if (this.showWeekend === false) {
            this.weekDays.shift()
            this.weekDays.pop()
        }

        if (this.showWeekend && this.startOnMonday) {
            let lastElement = this.weekDays.shift()
            this.weekDays.push(lastElement)
        }

        if (kiss.screen.isMobile && kiss.screen.isVertical()) {
            this.months = this.months.map(month => month.substring(0, 4) + ".")
        }

        return this
    }

    /**
     * Generates a simple day id
     * 
     * @private
     * @ignore
     * @param {number} day
     * @param {number} month
     * @param {number} year
     * @returns {string} String like "2023-07-17"
     */
    _getDayId(day, month, year) {
        return year + "-" + (month + "").padStart(2, "0") + "-" + (day + "").padStart(2, "0")
    }
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-calendar", kiss.ui.Calendar)

/**
 * Shorthand to create a new Calendar. See [kiss.ui.Calendar](kiss.ui.Calendar.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createCalendar = (config) => document.createElement("a-calendar").init(config)

;/** 
 * 
 * The **Chart** derives from [DataComponent](kiss.ui.DataComponent.html).
 * 
 * It's a [powerful chart view](https://kissjs.net/#ui=start&section=chart) with the following features:
 * 
 * @param {object} config
 * @param {string} config.name - The chart title. We use the "name" property instead of "title" to be consistent with all view names.
 * @param {Collection} config.collection - The data source collection
 * @param {boolean} [config.dashboard] - true if the chart is part of a dashboard. Default is false.
 * @param {object} [config.record] - Record to persist the view configuration into the db
 * @param {string} [config.chartType] - bar | line | pie | doughnut
 * @param {string} [config.isTimeSeries] - true if the chart is a time series. It will manage the timeField and timePeriod for X axis.
 * @param {string} [config.categoryField] - Field to group by, if not a time series
 * @param {string} [config.timeField] - Field to use as time axis, if a time series
 * @param {string} [config.timePeriod] - Grouping unit for time axis, if a time series: day, week, month, quarter, year
 * @param {string} [config.operationType] - "count" or "summary"
 * @param {string} [config.summaryOperation] - "sum", "average". Only used if operationType is "summary"
 * @param {string} [config.valueField] - Field to use as value (Y axis)
 * @param {number} [config.precision] - Number of decimal places to show, only for "number" charts. Default is 0.
 * @param {boolean} [config.startAtZero] - true to start the Y axis at zero. Not used for pie & doughnut charts
 * @param {boolean} [config.showLegend] - true to show the legend
 * @param {string} [config.legendPosition] - top, bottom, left, right
 * @param {boolean} [config.showValues] - true to show the values on the chart
 * @param {boolean} [config.showLabels] - true to show the labels on the chart
 * @param {boolean} [config.centerLabels] - true to center labels inside the chart. Default is true.
 * @param {string} [config.labelColor] - Hexa color code for labels inside the chart. Ex: #00aaee
 * @param {string} [config.color] - Hexa color code. Ex: #00aaee
 * @param {boolean} [config.showToolbar] - false to hide the toolbar (default = true)
 * @param {boolean} [config.showActions] - false to hide the custom actions menu (default = true)
 * @param {boolean} [config.canSort] - false to hide the sort button (default = true)
 * @param {boolean} [config.canFilter] - false to hide the filter button (default = true)
 * @param {object[]} [config.actions] - Array of menu actions, where each menu entry is: {text: "abc", icon: "fas fa-check", action: function() {}}
 * @param {boolean} [config.useCDN] - Set to false to use the local version of ChartJS. Default is true.
 * @returns this
 * 
 * ## Generated markup
 * ```
 * <a-chartview class="a-chartview">
 *      <div class="chartview-header">
 *          <div class="chartview-title">
 *              <!-- Chart title -->
 *          </div>
 *          <div class="chartview-toolbar">
 *              <!-- Chart view toolbar items -->
 *          </div>
 *      </div>
 *      <div class="chartview-chart">
 *          <!-- Embedded chart component -->
 *      </div>
 * </a-chartview>
 * ```
 */
kiss.ui.ChartView = class ChartView extends kiss.ui.DataComponent {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const myChartView = document.createElement("a-chartview").init(config)
     * ```
     * 
     * Or use the shorthand for it:
     * ```
     * const myChartView = createChartView({
     *   id: "my-chartview",
     *   color: "#00aaee",
     *   collection: kiss.app.collections["opportunity"],
     *   chartType: "bar",
     *   categoryField: "Country"
     * })
     * 
     * myChartView.render()
     * ```
     */
    constructor() {
        super()
    }

    /**
     * Generates a Chart view from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config) {
        // This component must be resized with its parent container
        config.autoSize = true

        // Init the parent DataComponent
        super.init(config)

        // Options
        this.dashboard = (config.dashboard === true)
        this.showToolbar = (config.showToolbar !== false)
        this.showActions = (config.showActions !== false)
        this.showSetup = (config.showSetup !== false)
        this.canSort = (config.canSort !== false)
        this.canFilter = (config.canFilter !== false)
        this.canGroup = (config.canGroup !== false)
        this.actions = config.actions || []
        this.color = config.color || "#00aaee"
        this.useCDN = (config.useCDN === false) ? false : true

        // Build chart view skeletton markup
        let id = this.id
        this.innerHTML = /*html*/
            `<div class="chartview-container">
                <div class="chartview-header">
                    <div class="chartview-title">
                        ${this.name || ""}
                    </div>
                    <div style="flex: 1"></div>
                    <div id="chartview-toolbar:${id}" class="chartview-toolbar">
                        <div id="actions:${id}"></div>
                    </div>
                </div>
                <div class="chartview-chart"></div>
            </div>`.removeExtraSpaces()

        // Set chart components
        this.header = this.querySelector(".chartview-header")
        this.headerTitle = this.querySelector(".chartview-title")
        this.toolbar = this.querySelector(".chartview-toolbar")
        this.chartContainer = this.querySelector(".chartview-chart")

        this._initChartParams(config)
            ._initSubscriptions()
            ._initClickEvents()

        return this
    }

    /**
     * 
     * CHART METHODS
     * 
     */

    /**
     * Load data into the chart.
     * 
     * @ignore
     */
    async load() {
        try {
            log(`kiss.ui - Chart ${this.id} - Loading collection <${this.collection.id} (changed: ${this.collection.hasChanged})>`)

            // Apply filter, sort, group, projection
            // Priority is given to local config, then to the passed collection, then to default
            this.collection.filter = this.filter
            this.collection.filterSyntax = this.filterSyntax
            this.collection.sort = this.sort
            this.collection.sortSyntax = this.sortSyntax
            this.collection.group = this.group
            this.collection.projection = this.projection
            this.collection.groupUnwind = this.groupUnwind

            // Load records
            await this.collection.find()

            // Render the chart toolbar
            this._renderToolbar()

        } catch (err) {
            log(err)
            log(`kiss.ui - Chart ${this.id} - Couldn't load data properly`)
        }
    }

    /**
     * Set the chart title
     * 
     * @param {string} newTitle 
     */
    setTitle(newTitle) {
        this.headerTitle.innerHTML = newTitle
    }

    /**
     * Update the chart color (toolbar buttons + modal windows)
     * 
     * @param {string} newColor
     */
    setColor(newColor) {
        this.color = newColor
        Array.from(this.toolbar.children).forEach(item => {
            if (item && item.firstChild && item.firstChild.type == "button") item.firstChild.setIconColor(newColor)
        })
    }

    /**
     * Update the chart layout
     */
    updateLayout(msg) {
        if (this.isConnected) {
            this._render()
        }
    }

    /**
     * Update the chart size according to its container
     * 
     * @private
     * @ignore
     * @returns this
     */
    updateSize() {
        if (!this.chart) return this

        this._initChartSize()
        this.chart.resize(this.chartWidth, this.chartHeight)
        return this
    }    

    /**
     * Display the setup window to configure the chart
     */
    showSetupWindow() {
        let _this = this
        let chartType
        let color = this.color

        //
        // CHART TYPE
        //
        const sectionForChartType = {
            id: "chart-setup-type",
            class: "chartview-wizard-section",
            layout: "horizontal",
            defaultConfig: {
                type: "button",
                margin: "0 0.5rem 0 0",
                flex: 1,
                justifyContent: "center",
                height: "6.4rem",
                iconSize: "4rem",
                iconColor: this.color,
                action: function () {
                    chartType = this.config.chartType
                    $("chart-setup-type").highlightButton(chartType)
                    $("chartType").setValue(chartType)

                    let data = $("chart-setup").getData()
                    publish("EVT_CHART_SETUP_CHANGED", data)
                }
            },
            items: [{
                    tip: txtTitleCase("#bar chart"),
                    icon: kiss.global.getChartIcon("bar"),
                    chartType: "bar"
                },
                {
                    tip: txtTitleCase("#line chart"),
                    icon: kiss.global.getChartIcon("line"),
                    chartType: "line"
                },
                {
                    tip: txtTitleCase("#pie chart"),
                    icon: kiss.global.getChartIcon("pie"),
                    chartType: "pie"
                },
                {
                    tip: txtTitleCase("#pie chart"),
                    icon: kiss.global.getChartIcon("doughnut"),
                    chartType: "doughnut"
                },
                {
                    tip: txtTitleCase("#number chart"),
                    icon: kiss.global.getChartIcon("number"),
                    chartType: "number"
                },
                {
                    id: "chartType",
                    type: "text",
                    value: this.chartType,
                    hidden: true
                }
            ],
            methods: {
                load: () => {
                    chartType = this.chartType
                    $("chart-setup-type").highlightButton(this.chartType)
                },
                highlightButton(chartType) {
                    const allButtons = this.querySelectorAll("a-button")
                    allButtons.forEach(button => {
                        if (button.config.chartType != chartType) {
                            button.setColor(color)
                            button.setIconColor(color)
                            button.setBackgroundColor("var(--button-background)")
                        } else {
                            button.setColor("#ffffff")
                            button.setIconColor("#ffffff")
                            button.setBackgroundColor(color)
                        }
                    })
                }
            }
        }

        // 
        // CHART DATA
        // 
        const categoryFields = this.model.getFieldsAsOptions([
            "text",
            "select",
            "selectViewColumn",
            "selectViewColumns",
            "checkbox",
            "directory",
            "rating",
            "icon",
            "color"
        ]).filter(field => !field.isFromPlugin) // For now, don't use the fields coming from plugins

        const sectionForChartData = {
            class: "chartview-wizard-section",
            type: "panel",
            title: txtTitleCase("data"),
            headerColor: "var(--body)",
            headerBackgroundColor: "var(--body-background-alt)",
            border: "none",

            defaultConfig: {
                width: "100%",
                labelWidth: "50%",
                fieldWidth: "50%",
                labelPosition: "left"
            },

            items: [
                // TITLE (NAME)
                {
                    type: "text",
                    id: "name",
                    label: txtTitleCase("title"),
                    value: this.name || ""
                },                
                // TIME SERIES
                {
                    type: "checkbox",
                    id: "isTimeSeries",
                    label: txtTitleCase("#time series"),
                    value: this.isTimeSeries,
                    shape: "switch",
                    width: "100%",
                    subscriptions: {
                        EVT_CHART_SETUP_CHANGED: function (data) {
                            if (data.chartType == "pie" || data.chartType == "doughnut" || data.chartType == "number") return this.hide()
                            this.show()
                        }
                    },
                    events: {
                        change: () => publish("EVT_CHART_SETUP_CHANGED", $("chart-setup").getData())
                    }
                },
                // CATEGORY FIELD
                {
                    type: "select",
                    id: "categoryField",
                    label: txtTitleCase("#category field"),
                    multiple: false,
                    options: categoryFields,
                    value: this.categoryField,
                    maxHeight: () => kiss.screen.current.height - 200,
                    optionsColor: this.color,
                    subscriptions: {
                        EVT_CHART_SETUP_CHANGED: function (data) {
                            if (data.isTimeSeries && data.chartType != "pie" && data.chartType != "doughnut") return this.hide()
                            if (data.chartType == "number") return this.hide()
                            this.show()
                        }
                    }
                },
                // TIME FIELD
                {
                    type: "select",
                    id: "timeField",
                    label: txtTitleCase("time axis"),
                    multiple: false,
                    options: this.model.getFieldsAsOptions("date"),
                    value: this.timeField,
                    autocomplete: "off",
                    maxHeight: () => kiss.screen.current.height - 200,
                    optionsColor: this.color,
                    subscriptions: {
                        EVT_CHART_SETUP_CHANGED: function (data) {
                            if (data.isTimeSeries && data.chartType != "pie" && data.chartType != "doughnut" && data.chartType != "number") return this.show()
                            this.hide()
                        }
                    }
                },
                // TIME GROUPING UNIT
                {
                    type: "select",
                    id: "timePeriod",
                    label: txtTitleCase("group by"),
                    multiple: false,
                    options: [
                        {
                            value: "week",
                            label: txtTitleCase("week")
                        },
                        {
                            value: "month",
                            label: txtTitleCase("month")
                        },
                        {
                            value: "quarter",
                            label: txtTitleCase("quarter")
                        },
                        {
                            value: "year",
                            label: txtTitleCase("year")
                        }
                    ],
                    value: this.timePeriod || "month",
                    maxHeight: () => kiss.screen.current.height - 200,
                    optionsColor: this.color,
                    autocomplete: "off",
                    subscriptions: {
                        EVT_CHART_SETUP_CHANGED: function (data) {
                            if (data.isTimeSeries && data.chartType != "pie" && data.chartType != "doughnut" && data.chartType != "number") return this.show()
                            this.hide()
                        }
                    }
                },
                // OPERATION TYPE
                {
                    type: "select",
                    id: "operationType",
                    label: txtTitleCase("chart values"),
                    multiple: false,
                    autocomplete: "off",
                    options: [{
                            label: txtTitleCase("#count data"),
                            value: "count"
                        },
                        {
                            label: txtTitleCase("#summarize data"),
                            value: "summary"
                        },
                    ],
                    value: this.operationType || "count",
                    width: "100%",
                    maxHeight: () => kiss.screen.current.height - 200,
                    optionsColor: this.color,
                    events: {
                        change: () => publish("EVT_CHART_SETUP_CHANGED", $("chart-setup").getData())
                    }
                },
                // SUMMARY OPERATION
                {
                    type: "select",
                    id: "summaryOperation",
                    label: txtTitleCase("summary operation"),
                    multiple: false,
                    options: [{
                            label: txtTitleCase("sum"),
                            value: "sum"
                        },
                        {
                            label: txtTitleCase("average"),
                            value: "average"
                        },
                    ],
                    value: this.summaryOperation || "sum",
                    width: "100%",
                    maxHeight: () => kiss.screen.current.height - 200,
                    optionsColor: this.color,
                    autocomplete: "off",
                    subscriptions: {
                        EVT_CHART_SETUP_CHANGED: function (data) {
                            if (data.operationType != "summary") return this.hide()
                            this.show()
                        }
                    }
                },
                // VALUE FIELD
                {
                    type: "select",
                    id: "valueField",
                    label: txtTitleCase("#summary field"),
                    multiple: false,
                    options: this.model.getFieldsAsOptions(["number", "slider"]),
                    value: this.valueField,
                    autocomplete: "off",
                    width: "100%",
                    maxHeight: () => kiss.screen.current.height - 200,
                    optionsColor: this.color,
                    subscriptions: {
                        EVT_CHART_SETUP_CHANGED: function (data) {
                            if (data.operationType != "summary") return this.hide()
                            this.show()
                        }
                    }
                },

                // Sort & filter
                {
                    layout: "horizontal",
                    margin: "2rem 0 0 0",
                    defaultConfig: {
                        type: "button",
                        width: "100%",
                        labelWidth: "50%",
                        fieldWidth: "50%",
                        labelPosition: "left",
                        iconColor: this.color,
                        height: "4rem"
                    },                    
                    items: [
                        {
                            type: "button",
                            text: txtTitleCase("to sort"),
                            icon: "fas fa-sort",
                            action: () => this.showSortWindow(),
                            margin: "0 0.5rem 0 0"
                        },
                        {
                            type: "button",
                            text: txtTitleCase("to filter"),
                            icon: "fas fa-filter",
                            action: () => this.showFilterWindow()
                        }
                    ]
                }
            ]
        }

        //
        // CHART LAYOUT
        // 
        const sectionForChartLayout = {
            class: "chartview-wizard-section",
            type: "panel",
            title: txtTitleCase("layout"),
            headerColor: "var(--body)",
            headerBackgroundColor: "var(--body-background-alt)",
            border: "none",

            defaultConfig: {
                width: "100%",
                labelWidth: "50%",
                fieldWidth: "50%",
                labelPosition: "left"
            },

            items: [
                // SHOW LEGEND
                {
                    type: "checkbox",
                    id: "showLegend",
                    label: txtTitleCase("show legend"),
                    shape: "switch",
                    value: this.showLegend === false ? false : true,
                    subscriptions: {
                        EVT_CHART_SETUP_CHANGED: function (data) {
                            if (data.chartType != "number") return this.show()
                            this.hide()
                        }
                    },
                    events: {
                        change: () => publish("EVT_CHART_SETUP_CHANGED", $("chart-setup").getData())
                    }
                },
                // LEGEND POSITION
                {
                    type: "select",
                    id: "legendPosition",
                    label: txtTitleCase("legend position"),
                    autocomplete: "off",
                    options: [{
                            value: "top",
                            label: txtTitleCase("top")
                        },
                        {
                            value: "bottom",
                            label: txtTitleCase("bottom")
                        },
                        {
                            value: "left",
                            label: txtTitleCase("left")
                        },
                        {
                            value: "right",
                            label: txtTitleCase("right")
                        }
                    ],
                    value: this.legendPosition || "top",
                    subscriptions: {
                        EVT_CHART_SETUP_CHANGED: function (data) {
                            if (data.showLegend === false || data.chartType == "number") return this.hide()
                            this.show()
                        }
                    }
                },
                // SHOW VALUES ON CHART
                {
                    type: "checkbox",
                    id: "showValues",
                    label: txtTitleCase("show values on chart"),
                    shape: "switch",
                    value: this.showValues === false ? false : true,
                    subscriptions: {
                        EVT_CHART_SETUP_CHANGED: function (data) {
                            if (data.chartType == "line" || data.chartType == "number") return this.hide()
                            this.show()
                        }
                    },
                    events: {
                        change: () => publish("EVT_CHART_SETUP_CHANGED", $("chart-setup").getData())
                    }
                },
                // SHOW LABELS ON CHART
                {
                    type: "checkbox",
                    id: "showLabels",
                    label: txtTitleCase("show labels on chart"),
                    shape: "switch",
                    value: !!this.showLabels,
                    subscriptions: {
                        EVT_CHART_SETUP_CHANGED: function (data) {
                            if (data.chartType == "pie" || data.chartType == "doughnut") return this.show()
                            this.hide()
                        }
                    },
                    events: {
                        change: () => publish("EVT_CHART_SETUP_CHANGED", $("chart-setup").getData())
                    }
                },
                // LABELS POSITION ON CHART
                {
                    type: "checkbox",
                    id: "centerLabels",
                    label: txtTitleCase("#center labels"),
                    shape: "switch",
                    value: this.centerLabels === false ? false : true,
                    subscriptions: {
                        EVT_CHART_SETUP_CHANGED: function (data) {
                            if (data.chartType == "number") return this.hide()
                            else if (
                                (data.showValues && (data.chartType != "line")) ||
                                (data.showLabels && (data.chartType == "pie" || data.chartType == "doughnut"))
                            ) return this.show()
                            this.hide()
                        }
                    }
                },
                // LABELS COLOR ON CHART
                {
                    type: "color",
                    id: "labelColor",
                    label: txtTitleCase("color"),
                    value: this.labelColor || "#000000",
                    subscriptions: {
                        EVT_CHART_SETUP_CHANGED: function (data) {
                            if (
                                (data.showValues && (data.chartType != "line")) ||
                                (data.showLabels && (data.chartType == "pie" || data.chartType == "doughnut")) ||
                                (data.chartType == "number")
                            ) return this.show()
                            this.hide()
                        }
                    }
                },
                // START AT ZERO
                {
                    type: "checkbox",
                    id: "startAtZero",
                    label: txtTitleCase("start at zero"),
                    value: this.startAtZero === false ? false : true,
                    shape: "switch",
                    width: "100%",
                    subscriptions: {
                        EVT_CHART_SETUP_CHANGED: function (data) {
                            if (data.chartType == "pie" || data.chartType == "doughnut" || data.chartType == "number") return this.hide()
                            this.show()
                        }
                    }
                },                
                // NUMBER PRECISION
                {
                    hidden: true, // Not used yet
                    type: "select",
                    id: "precision",
                    label: txtTitleCase("number style"),
                    autocomplete: "off",
                    value: this.precision || 0,
                    options: [{
                            label: "1",
                            value: 0
                        },
                        {
                            label: "1.0",
                            value: 1
                        },
                        {
                            label: "1.00",
                            value: 2
                        },
                        {
                            label: "1.000",
                            value: 3
                        },
                        {
                            label: "1.0000",
                            value: 4
                        },
                        {
                            label: "1.00000",
                            value: 5
                        },
                        {
                            label: "1.000000",
                            value: 6
                        },
                        {
                            label: "1.0000000",
                            value: 7
                        },
                        {
                            label: "1.00000000",
                            value: 8
                        }
                    ],
                    optionsColor: this.color,
                    // subscriptions: {
                    //     EVT_CHART_SETUP_CHANGED: function (data) {
                    //         if (data.chartType != "number") return this.hide()
                    //         this.show()
                    //     }
                    // }
                },
                // FIELD UNIT
                {
                    hidden: true, // Not used yet
                    type: "text",
                    id: "unit",
                    label: txtTitleCase("unit"),
                    value: this.unit,

                    // subscriptions: {
                    //     EVT_CHART_SETUP_CHANGED: function (data) {
                    //         if (data.chartType != "number") return this.hide()
                    //         this.show()
                    //     }
                    // }
                }
            ]
        }

        // 
        // Build the final panel
        // 
        const viewId = this.id
        createPanel({
            id: "chart-setup",
            title: txtTitleCase("setup the chart"),
            icon: "fas fa-cog",
            draggable: true,
            closable: true,
            modal: true,
            top: 0,
            left: "calc(100vw - 50rem)",
            width: "50rem",
            height: () => kiss.screen.current.height,
            headerHeight: "4.9rem",
            headerBackgroundColor: this.color,
            overflowY: "auto",
            animation: {
                name: "fadeIn",
                speed: "faster"
            },

            items: [
                sectionForChartType,
                sectionForChartData,
                sectionForChartLayout,

                // Save button
                {
                    layout: "horizontal",
                    overflow: "unset",
                    defaultConfig: {
                        type: "button",
                        flex: 1,
                        height: "4rem",
                        margin: "0.5rem 1rem"
                    },
                    items: [{
                        type: "button",
                        icon: "fas fa-check",
                        iconColor: "var(--green)",
                        text: txtTitleCase("save"),
                        action: () => $("chart-setup").save()
                    }]
                }
            ],

            methods: {
                load() {
                    // Allow the different fields to show/hide at startup depending on the chart config
                    publish("EVT_CHART_SETUP_CHANGED", this.getData())

                    // Focus on the first field
                    setTimeout(() => $("name").focus(), 100)
                },
                async save() {
                    const {
                        name,
                        chartType,
                        isTimeSeries,
                        categoryField,
                        timeField,
                        timePeriod,
                        operationType,
                        summaryOperation,
                        valueField,
                        startAtZero,
                        showLegend,
                        legendPosition,
                        showValues,
                        showLabels,
                        centerLabels,
                        labelColor,
                        precision,
                        unit
                    } = $("chart-setup").getData()

                    // Controls...
                    if (!chartType ||
                        (!isTimeSeries && !categoryField && chartType != "number") ||
                        (chartType == "pie" && !categoryField) ||
                        (chartType == "doughnut" && !categoryField) ||
                        (isTimeSeries && !timeField) ||
                        (operationType == "summary" && !summaryOperation) ||
                        (operationType == "summary" && !valueField)
                    ) {
                        return createNotification(txtTitleCase("#chart wrong params"))
                    }

                    // Broadcast the new chart setup
                    publish("EVT_VIEW_SETUP:" + viewId, {
                        name,
                        chartType,
                        isTimeSeries,
                        categoryField,
                        timeField,
                        timePeriod,
                        operationType,
                        summaryOperation,
                        valueField,
                        startAtZero,
                        showLegend,
                        legendPosition,
                        showValues,
                        showLabels,
                        centerLabels,
                        labelColor,
                        precision,
                        unit
                    })

                    // If the chart is part of a dashboard, tell the dashboard to update
                    if (_this.dashboard) publish("EVT_DASHBOARD_SETUP", viewId)
                }
            }
        }).render()
    }

    /**
     * Display the source records of the chart
     * 
     * @param {string} [category] - Optional category to filter the records
     */
    async showRecords(category) {
        const model = this.model
        const tempDatatableId = "chart-data-" + this.id
        const tempCollection = this.collection.clone()
        let newFilter

        if (category) {
            if (!this.isTimeSeries) {
                // Bar, Pie, Doughnut
                const categoryField = this.model.getField(this.categoryField)
                newFilter = {
                    type: "group",
                    operator: "and",
                    filters: [
                        this.collection.filter,
                        {
                            type: "filter",
                            fieldId: categoryField.id,
                            fieldType: categoryField.type,
                            operator: "=",
                            value: category
                        }
                    ]
                }
            }
            // else if (this.isTimeSeries) {
            //     // Bar, Line
            //     const timeField = this.model.getField(this.timeField)
            // }

            tempCollection.filter = newFilter
            tempCollection.group = []
        }

        // Load the records
        await tempCollection.find()

        // Create the datatable
        const datatable = createDatatable({
            id: "datatable-" + tempDatatableId,
            type: "datatable",
            collection: tempCollection,
            color: this.color,
            showActions: false,
            showLinks: false,
            canEdit: false,
            canAddField: false,
            canEditField: false,
            canCreateRecord: false,
            canSelect: false,
            autoSize: true
        })       
    
        // Build the panel to show the datatable
        createPanel({
            modal: true,
            closable: true,
            title: "<b>" + model.namePlural + "</b>",
            icon: model.icon,
            headerBackgroundColor: model.color,
            display: "flex",
            layout: "vertical",
            align: "center",
            verticalAlign: "center",
            background: "var(--body-background)",
            padding: 0,
            width: () => "calc(100vw - 2rem)",
            height: () => "calc(100vh - 2rem)",
            autoSize: true,
            methods: {
                load() {
                    setTimeout(() => this.setItems([datatable]), 50)
                }
            }
        }).render()
    }  


    /**
     * Define the specific chart params:
     * - chartType: pie, bar, line
     * - chartValueField: field used to display the values
     * 
     * @private
     * @ignore
     * @param {object} config - {chartType, chartValueField}
     * @returns this
     */
    _initChartParams(config) {
        if (this.record) {
            this.chartType = config.chartType || this.record.config.chartType
            this.isTimeSeries = config.isTimeSeries || this.record.config.isTimeSeries
            this.categoryField = config.categoryField || this.record.config.categoryField
            this.timeField = config.timeField || this.record.config.timeField
            this.timePeriod = config.timePeriod || this.record.config.timePeriod
            this.operationType = config.operationType || this.record.config.operationType
            this.summaryOperation = config.summaryOperation || this.record.config.summaryOperation
            this.valueField = config.valueField || this.record.config.valueField
            this.startAtZero = config.startAtZero || this.record.config.startAtZero
            this.showLegend = config.showLegend || this.record.config.showLegend
            this.legendPosition = config.legendPosition || this.record.config.legendPosition
            this.showValues = config.showValues || this.record.config.showValues
            this.showLabels = config.showLabels || this.record.config.showLabels
            this.centerLabels = config.centerLabels || this.record.config.centerLabels
            this.labelColor = config.labelColor || this.record.config.labelColor
            this.precision = config.precision || this.record.config.precision || 0
            this.unit = config.unit || this.record.config.unit || ""

        } else {
            this.chartType = config.chartType || this.config.chartType
            this.isTimeSeries = config.isTimeSeries || false
            this.categoryField = config.categoryField || this.config.categoryField
            this.timeField = config.timeField || this.config.timeField
            this.timePeriod = config.timePeriod || "month"
            this.operationType = config.operationType || "count"
            this.summaryOperation = config.summaryOperation || "sum"
            this.valueField = config.valueField || this.config.valueField
            this.startAtZero = (config.startAtZero === false) ? false : true
            this.showLegend = (config.showLegend === false) ? false : true
            this.legendPosition = config.legendPosition || "top"
            this.showValues = (config.showValues === false) ? false : true
            this.showLabels = config.showLabels || false
            this.centerLabels = (config.centerLabels === false) ? false : true
            this.labelColor = config.labelColor || "#000000"
            this.precision = config.precision || 0
            this.unit = config.unit || ""
        }

        // Pie and doughnut charts don't support time series
        this.isTimeSeries = this.isTimeSeries && (this.chartType == "line" || this.chartType == "bar")

        // Set category field
        if (this.isTimeSeries) {
            // In time series, we need to sort by time
            this.sort = [{
                [this.timeField]: "asc"
            }]
            this.group = [this.timeField]
        } else {
            if (this.chartType != "number") {
                this.group = [this.categoryField]
            }
            else {
                this.group = []
            }
        }

        // Defaults to the first number field
        if (!this.valueField) {
            let modelNumberFields = this.model.getFieldsByType(["number"])
            if (modelNumberFields.length != 0) {
                this.valueField = modelNumberFields[0].id
            } else {
                this.valueField = null
            }
        }

        return this
    }

    /**
     * Initialize subscriptions to PubSub
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initSubscriptions() {
        super._initSubscriptions()

        const viewModelId = this.modelId.toUpperCase()

        // React to database mutations
        this.subscriptions = this.subscriptions.concat([
            // Local events (not coming from websocket)
            subscribe("EVT_VIEW_SETUP:" + this.id, (msgData) => this._updateConfig(msgData)),

            // React to database mutations
            subscribe("EVT_DB_INSERT:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData)),
            subscribe("EVT_DB_UPDATE:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData)),
            subscribe("EVT_DB_DELETE:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData)),
            subscribe("EVT_DB_INSERT_MANY:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData, 2000)),
            subscribe("EVT_DB_UPDATE_MANY:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData, 2000)),
            subscribe("EVT_DB_DELETE_MANY:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData, 2000)),
            subscribe("EVT_DB_UPDATE_BULK", (msgData) => this._reloadWhenNeeded(msgData, 2000)),
            subscribe("EVT_DB_UPDATE:VIEW", (msgData) => this._updateTitle(msgData))
        ])

        return this
    }

    /**
     * Initialize click events
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initClickEvents() {
        this.onclick = (e) => {
            const target = e.target
            if (!target.closest(".a-button") && !target.closest(".chartview-number") && target.tagName != "CANVAS") {
                publish("EVT_CHART_CLICKED", {
                    chartId: this.id,
                    event: e
                })
            }
        }
        return this
    }

    /**
     * Initialize chart sizes inside component
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initChartSize() {
        const VERTICAL_SPACE = 80 // total space when adding toolbar, header, margins, paddings...
        const HORIZONTAL_SPACE = 40
        let width = this.clientWidth - HORIZONTAL_SPACE
        let height = this.clientHeight - VERTICAL_SPACE

        // Maintain max aspect ratio to 2
        // if (width > (2 * height)) width = 2 * height

        this.chartWidth = width
        this.chartHeight = height
        return this
    }

    /**
     * Update the chart title
     * 
     * @private
     * @ignore
     */
    _updateTitle(msgData) {
        if (!this.record) return
        if (msgData.id == this.record.id && msgData.data.name) {
            this.setTitle(msgData.data.name)
        }
    }


    /**
     * Update the chart configuration
     * 
     * @private
     * @ignore
     * @param {object} newConfig 
     */
    async _updateConfig(newConfig) {
        let currentConfig
        let finalConfig

        // Evaluate if the new config impacts data or not
        let needsDataReload = false
        if (this.chartType != newConfig.chartType) needsDataReload = true
        if (this.isTimeSeries != newConfig.isTimeSeries) needsDataReload = true
        if (this.isTimeSeries && this.timeField != newConfig.timeField) needsDataReload = true
        if (this.isTimeSeries && this.timePeriod != newConfig.timePeriod) needsDataReload = true
        if (this.categoryField != newConfig.categoryField) needsDataReload = true
        if (this.operationType != newConfig.operationType) needsDataReload = true
        if (this.operationType == "summary" && this.summaryOperation != newConfig.summaryOperation) needsDataReload = true
        if (this.valueField != newConfig.valueField) needsDataReload = true
        if (needsDataReload) this.collection.hasChanged = true
        
        // Get the current config
        if (this.record) {
            currentConfig = this.record.config
        } else {
            currentConfig = {
                chartType: this.chartType,
                isTimeSeries: this.isTimeSeries,
                categoryField: this.categoryField,
                timeField: this.timeField,
                timePeriod: this.timePeriod,
                operationType: this.operationType,
                summaryOperation: this.summaryOperation,
                valueField: this.valueField,
                startAtZero: this.startAtZero,
                showLegend: this.showLegend,
                legendPosition: this.legendPosition,
                showValues: this.showValues,
                showLabels: this.showLabels,
                centerLabels: this.centerLabels,
                labelColor: this.labelColor,
                precision: this.precision,
                unit: this.unit
            }
        }
        
        // Update the chart configuration
        if (newConfig.hasOwnProperty("name")) this.name = newConfig.name
        if (newConfig.hasOwnProperty("chartType")) this.chartType = newConfig.chartType
        if (newConfig.hasOwnProperty("isTimeSeries")) this.isTimeSeries = newConfig.isTimeSeries
        if (newConfig.hasOwnProperty("categoryField")) this.categoryField = newConfig.categoryField
        if (newConfig.hasOwnProperty("timeField")) this.timeField = newConfig.timeField
        if (newConfig.hasOwnProperty("timePeriod")) this.timePeriod = newConfig.timePeriod
        if (newConfig.hasOwnProperty("operationType")) this.operationType = newConfig.operationType
        if (newConfig.hasOwnProperty("summaryOperation")) this.summaryOperation = newConfig.summaryOperation
        if (newConfig.hasOwnProperty("valueField")) this.valueField = newConfig.valueField
        if (newConfig.hasOwnProperty("startAtZero")) this.startAtZero = newConfig.startAtZero
        if (newConfig.hasOwnProperty("showLegend")) this.showLegend = newConfig.showLegend
        if (newConfig.hasOwnProperty("legendPosition")) this.legendPosition = newConfig.legendPosition
        if (newConfig.hasOwnProperty("showValues")) this.showValues = newConfig.showValues
        if (newConfig.hasOwnProperty("showLabels")) this.showLabels = newConfig.showLabels
        if (newConfig.hasOwnProperty("centerLabels")) this.centerLabels = newConfig.centerLabels
        if (newConfig.hasOwnProperty("labelColor")) this.labelColor = newConfig.labelColor
        if (newConfig.hasOwnProperty("precision")) this.precision = newConfig.precision
        if (newConfig.hasOwnProperty("unit")) this.unit = newConfig.unit

        // Apply the new config
        let config = Object.assign(currentConfig, newConfig)
        this.setTitle(this.name)

        // Pie and doughnut charts don't support time series
        this.isTimeSeries = newConfig.isTimeSeries && (newConfig.chartType == "line" || newConfig.chartType == "bar")
        
        if (this.isTimeSeries) {
            // In time series, we need to sort by time
            finalConfig = {
                name: this.name,
                sort: [{
                    [config.timeField]: "asc"
                }],
                group: [config.timeField],
                config
            }
        } else {
            if (config.chartType != "number") {
                finalConfig = {
                    name: this.name,
                    group: [config.categoryField],
                    config
                }
            }
            else {
                finalConfig = {
                    name: this.name,
                    group: [],
                    config
                }
            }
        }

        // Apply the new config locally
        if (!this.record) {
            Object.assign(this, finalConfig)
        }

        // Store the new config in the record
        await this.updateConfig(finalConfig, needsDataReload)
    }

    /**
     * 
     * RENDERING THE CHART
     * 
     */

    /**
     * Consolidates data for temporal display in Chart.js
     * 
     * @param {Array} rawData - Array of raw data [{ x: <date>, y: <value> }]
     * @param {String} interval - Sampling interval ("day", "week", "month", "quarter", "year")
     * @param {String} operation - Aggregation operation ("count", "sum", "average")
     * @returns {Array} - Consolidated dataset for Chart.js
     */
    _consolidateData(rawData, interval, operation) {
        // Parse a date from various formats (ISO string, Date object, etc.)
        const parseDate = (date) => {
            if (typeof date === "string") {
                // Convert to Date object regardless of the string format
                return new Date(date)
            }
            if (date instanceof Date) {
                return date
            }
            throw new Error("Invalid date format")
        }

        // Format the date into a key based on the specified interval
        const formatKey = (date, interval) => {
            const parsedDate = parseDate(date)
            const year = parsedDate.getFullYear()
            const month = (parsedDate.getMonth() + 1).toString().padStart(2, "0")
            const day = parsedDate.getDate().toString().padStart(2, "0")

            switch (interval) {
                case "day":
                    return `${year}-${month}-${day}`

                case "week": {
                    const firstDayOfYear = new Date(year, 0, 1)
                    const weekNumber = Math.ceil((((parsedDate - firstDayOfYear) / 86400000) + firstDayOfYear.getDay() + 1) / 7)
                    return `${year}-W${weekNumber}`
                }
                case "month":
                    return `${year}-${month}`

                case "quarter":
                    const qMonth = Math.ceil((parsedDate.getMonth() + 1) / 3)
                    return `${year}-Q${qMonth}`

                case "year":
                    return `${year}`

                default:
                    throw new Error("Unsupported interval")
            }
        }

        // Group data by the calculated keys
        const groupedData = rawData.reduce((acc, {
            x,
            y
        }) => {
            const key = formatKey(x, interval)
            if (!acc[key]) {
                acc[key] = {
                    total: 0,
                    count: 0
                }
            }
            acc[key].total += y
            acc[key].count += 1
            return acc
        }, {})

        // Convert grouped data into a Chart.js-compatible dataset
        return Object.entries(groupedData).map(([key, {
            total,
            count
        }]) => {
            const value = operation === "average" ? total / count : total
            return {
                x: key,
                y: value
            }
        })
    }

    /**
     * Render the chart / number chart
     * 
     * @private
     * @ignore
     * @returns this
     */
    _render() {
        if (this.chartType == "number") return this._renderNumber()
        return this._renderChart()
    }

    /**
     * Render a simple "number" chart
     * 
     * @private
     * @ignore
     * @returns this
     */
    _renderNumber() {
        // Replace the chart by a number
        if (this.chart) {
            this.chart.destroy()
            this.chart = null
        }

        // Reset container
        this.chartContainer.innerHTML = ""
        this.chartContainer.classList.remove("chartview-container-empty")

        // Aggregate data according to the operation
        let operation = (this.operationType == "count") ? "count" : this.summaryOperation
        const valueField = this.valueField
        let total = 0

        // Get the field's unit, if any
        let unit
        let precision
        if (operation != "count") {
            const field = this.model.getField(this.valueField)
            unit = field.unit || ""
            precision = field.precision || 0
        }

        switch (operation) {
            case "count":
                total = this.collection.records.length
                break
            case "sum":
                total = this.collection.records.reduce((acc, record) => acc + record[valueField] || 0, 0)
                break
            case "average":
                total = this.collection.records.reduce((acc, record) => acc + record[valueField] || 0, 0) / this.collection.records.length
                break
            default:
        }

        this.number = createBlock({
            target: this.chartContainer,
            class: "chartview-number",
            backgroundColor: this.labelColor + "20",
            items: [
                {
                    type: "html",
                    color: this.labelColor,
                    html: total.format(precision) + (unit ? ` <span class="chartview-unit">${unit}</span>` : "")
                }
            ],
            events: {
                click: () => this.showRecords()
            }
        }).render()
        return this
    }

    /**
     * Render a chart using Chart.js
     * 
     * @private
     * @ignore
     * @returns this
     */    
    _renderChart() {
        /**
         * datasource
         * filter
         * sort
         * group
         * title
         * subtitle
         * 
         * number:
         *  color
         *  values:
         *      count
         *      summary
         *          sum
         *          avg
         *          (+ median, min, max)     
         * bar:
         *  x-axis: field
         *      time:
         *          unit (week, month, quarter, year)
         *          format
         *  y-axis: count
         *  categories
         *  values:
         *      count
         *      summary
         *          sum
         *          avg
         *          (+ median, min, max)
         *  color
         *  size (small medium large)
         *  orientation
         *  show records count on chart
         * 
         * pie:
         *  categories (= group)
         *  values:
         *      count
         *      summary
         *         sum
         *         avg
         *         (+ median, min, max)
         *  size
         * 
         */
        if (this.collection.group.length === 0) {
            // No group: can't render a Chart view
            this.chartContainer.classList.remove("chartview-chart-empty")
            this.chartContainer.innerHTML = `<div class="chartview-help">${txtTitleCase("#chart help")}</div>`

            // Destroy the chart if it exists
            if (this.chart) {
                this.chart.destroy()
                this.chart = null
            }
            else if (this.number) {
                this.number.deepDelete()
                this.number = null
            }

            return this

        } else {

            // If there are no records, show the "empty" icon and exit
            if (this.collection.records.length == "0") {
                this.chartContainer.classList.add("chartview-container-empty")
                return this
            }

            // Reset container
            this.chartContainer.classList.remove("chartview-container-empty")

            // Get data from the collection
            let sourceData = this.collection.records.filter(record => record.$type == "group")

            // Normalize data to [{x: "foo", y: 100}, ...]
            let xyData
            let operation = (this.operationType == "count") ? "count" : this.summaryOperation
            const valueField = this.valueField
            
            // TODO: implement valueRenderer compatibility with canvas which does not support HTML tags
            // const categoryField = this.model.getField(this.categoryField)
            // const renderer = categoryField.valueRenderer
            const renderer = false

            switch (operation) {
                case "count":
                    if (!renderer) {
                        xyData = sourceData.map(rec => {
                            return {
                                x: "" + rec.$name,
                                y: rec.$size
                            }
                        })
                    }
                    else {
                        xyData = sourceData.map(rec => {
                            return {
                                x: renderer({
                                    value: rec.$name,
                                    record: rec
                                }),
                                y: rec.$size
                            }
                        })
                    }
                    break

                case "sum":
                    if (!renderer) {
                        xyData = sourceData.map(rec => {
                            return {
                                x: "" + rec.$name,
                                y: rec[valueField]?.sum || 0
                            }
                        })
                    }
                    else {
                        xyData = sourceData.map(rec => {
                            return {
                                x: renderer(rec.$name),
                                y: rec[valueField]?.sum || 0
                            }
                        })
                    }
                    break
                    
                case "average":
                    if (!renderer) {
                        xyData = sourceData.map(rec => {
                            return {
                                x: "" + rec.$name,
                                y: rec[valueField]?.avg || 0
                            }
                        })
                    }
                    else {
                        xyData = sourceData.map(rec => {
                            return {
                                x: renderer(rec.$name),
                                y: rec[valueField]?.avg || 0
                            }
                        })
                    }

                    break
                default:
            }

            // Consolidate data for time series
            let normalizedData = xyData
            if (this.isTimeSeries) normalizedData = this._consolidateData(xyData, this.timePeriod, operation)

            // Filters out empty categories
            normalizedData = normalizedData.filter(record => record.x !== "" && record.x !== "undefined")

            // Get the color of each category
            let groupFieldId = this.collection.group[0]
            const startIndex = 0//Math.floor(Math.random() * 20)
            let colors = normalizedData.map((record, index) => {
                return this._getCategoryColor(groupFieldId, record.x, startIndex + index)
            })

            // Build the chart data
            const data = {
                datasets: [{
                    data: normalizedData,
                    borderWidth: 1,
                    borderRadius: 5,
                    backgroundColor: colors
                }]
            }

            // Plugin to add margin to the legend
            // const legendMargin = {
            //     id: "legendMargin",
            //     afterInit(chart, args, plugins) {
            //         const originalFit = chart.legend.fit
            //         const margin = plugins.margin || 0
            //         chart.legend.fit = function fit() {
            //             if (originalFit) originalFit.call(this)
            //             this.height += margin * 2
            //             this.width += margin * 2
            //             return
            //         }
            //     }
            // }

            // Build chart plugins property
            const currentChartType = this.chartType
            const showLabels = this.showLabels
            const showValues = this.showValues
            const displayLabels = (this.showValues && this.chartType != "line") || (this.showLabels && (this.chartType == "pie" || this.chartType == "doughnut"))
            const legendTitleFieldId = (this.isTimeSeries) ? this.timeField : this.categoryField
            const legendTitleField = (legendTitleFieldId) ? this.model.getField(legendTitleFieldId) : ""
            const legendText = (legendTitleField) ? legendTitleField.label : txtTitleCase("legend")

            let plugins = {

                // Adjust tooltip content depending on the chart type
                tooltip: {
                    callbacks: {
                        label: function (tooltipItem) {
                            const label = tooltipItem.raw.x || ''
                            const value = tooltipItem.raw.y || 0
                            if (currentChartType == "line" || currentChartType == "bar") return value
                            return `${label}: ${value}`
                        }
                    }
                },

                // Legend setup
                legend: {
                    display: this.showLegend,
                    position: this.legendPosition,
                    title: {
                        display: true,
                        text: legendText,
                        font: {
                            weight: "bold",
                            size: 14
                        },
                    },
                    labels: {
                        boxWidth: 10,
                        boxHeight: 10,
                        generateLabels: function (chart) {
                            const dataset = chart.data.datasets[0]
                            return dataset.data.map((record, index) => ({
                                datasetIndex: 0,
                                text: record.x,
                                fillStyle: colors[index],
                                textAlign: "left",
                                borderRadius: {
                                    topLeft: 3,
                                    topRight: 3,
                                    bottomLeft: 3,
                                    bottomRight: 3
                                }
                            }))
                        }
                    },
                    onClick: (event, legendItem, legend) => {
                        kiss.context.chartLegendClicked = true
                        const category = legendItem.text
                        if (this.isTimeSeries) return // Not implemented yet
                        this.showRecords(category)
                    }
                },

                // Data labels setup (plugin)
                datalabels: {
                    display: displayLabels,
                    align: "center",
                    anchor: (this.centerLabels) ? "center" : "end",
                    color: this.labelColor,
                    font: {
                        weight: "normal"
                    },
                    formatter: (value) => {
                        if (currentChartType == "pie" || currentChartType == "doughnut") {
                            if (showLabels && showValues) return value.x + ": " + Math.round(value.y || 0)
                            if (showLabels) return value.x
                            if (showValues) return Math.round(value.y || 0)
                        }
                        return Math.round(value.y || 0)
                    }
                }
            }

            // Add legend margin if needed
            // if (this.showLegend) {
            //     plugins.legendMargin = {
            //         margin: 20 // Only works for top and left positions at the moment
            //     }
            // }

            // Build chart options property
            let options = {
                scales: {
                    y: {
                        display: (currentChartType == "pie" || currentChartType == "doughnut") ? false : true,
                        beginAtZero: this.startAtZero
                    }
                },
                responsive: true,
                maintainAspectRatio: false,
                normalized: true,
                animation: false,
                plugins
            }

            if (this.chartType == "pie" || this.chartType == "doughnut") {
                // Key for pie and doughnut chart
                options.parsing = {
                    key: "y"
                }
            } else if (this.isTimeSeries) {
                // X-axis for time series
                options.scales.x = {
                    type: "time",
                    time: {
                        unit: this.timePeriod,
                        displayFormats: {
                            day: "DD/MM/YYYY",
                            week: "YYYY [W]WW",
                            year: "YYYY",
                            quarter: "[Q]Q-YYYY"
                        }
                    }
                }

                // Adjust scale according to the time period
                if (this.timePeriod == "week") {
                    // options.scales.x.time.parser = "YYYY-[W]WW"
                }
                else if (this.timePeriod == "quarter") {
                    options.scales.x.time.parser = "YYYY-[Q]Q"
                }
            }

            // Compute the chart width
            this._initChartSize()

            options.onClick = (event, elements) => {
                if (elements.length > 0) {
                    const element = elements[0].element
                    const context = element.$context
                    const category = context.raw.x
                    if (this.isTimeSeries) return // Not implemented yet
                    this.showRecords(category)
                }
            }

            if (this.chart) {
                // The chart already exists, we just update it
                this.chart.refresh({
                    chartType: this.chartType,
                    width: this.chartWidth,
                    height: this.chartHeight,
                    useDataLabels: displayLabels,
                    useMoment: true,
                    data,
                    options,
                    useCDN: this.useCDN
                    // plugins: (this.showLegend) ? [legendMargin]: []
                })
            } else {
                // The chart doesn't exist, we create it
                this.chartContainer.innerHTML = ""
                this.chart = createChart({
                    target: this.chartContainer,
                    chartType: this.chartType,
                    width: this.chartWidth,
                    height: this.chartHeight,
                    useDataLabels: displayLabels,
                    useMoment: true,
                    data,
                    options,
                    useCDN: this.useCDN
                    // plugins: (this.showLegend) ? [legendMargin]: []
                })

                this.chart.render()
            }

            // Manage when the user clicks on the chart but not a colored element of the chart
            this.chart.onclick = (event) => {
                setTimeout(() => {
                    if (kiss.context.chartLegendClicked == true) {
                        kiss.context.chartLegendClicked = false
                        return
                    }
    
                    const elements = this.chart.chart.getElementsAtEventForMode(event, "nearest", { intersect: true }, false)
                    if (elements.length === 0) {
                        publish("EVT_CHART_CLICKED", {
                            chartId: this.id,
                            event
                        })
                    }
                }, 50)
            }

        }
        return this        
    }

    /**
     * Get the color of a category, if any
     * 
     * @param {string} groupFieldId 
     * @param {*} columnValue 
     * @returns {string} The color of the category
     */
    _getCategoryColor(groupFieldId, columnValue, index) {
        const field = this.model.getField(groupFieldId)
        const options = field.options || []
        const randomColor = "#" + kiss.global.palette[(index * 2) % 40]
        if (Array.isArray(options)) {
            const option = options.find(option => option.value == columnValue)
            return (option) ? (option.color || randomColor) : randomColor
        }
        return randomColor
    }

    /**
     * Render the toolbar
     * 
     * @private
     * @ignore
     */
    _renderToolbar() {
        if (this.isToolbarRendered) return

        // Actions button
        createButton({
            hidden: this.showActions === false,
            target: "actions:" + this.id,
            icon: "fas fa-chevron-down",
            iconColor: this.color,
            width: "3.2rem",
            border: "none",
            boxShadow: "none",
            action: (event) => {
                createMenu({
                    left: event.x - 10,
                    top: event.y - 10,
                    items: [
                        // Setup
                        {
                            text: txtTitleCase("setup the chart"),
                            icon: "fas fa-cog",
                            iconColor: this.color,
                            action: () => this.showSetupWindow()
                        },
                        // Refresh
                        {
                            text: txtTitleCase("refresh"),
                            icon: "fas fa-undo-alt",
                            iconColor: this.color,
                            action: () => this.reload()
                        },
                        // Download image as PNG
                        {   hidden: this.chartType == "number",
                            text: txtTitleCase("download image"),
                            icon: "fas fa-image",
                            iconColor: this.color,
                            action: () => {
                                if (!this.chart) return
                                this.chart.downloadBase64Image("image/png", 1)
                            }
                        },

                        // Delete the chart from a dashboard
                        (this.dashboard) ? "-" : "",
                        (this.dashboard) ? {
                            text: txtTitleCase("delete"),
                            icon: "fas fa-trash",
                            iconColor: "var(--red)",
                            action: () => publish("EVT_DASHBOARD_CHART_DELETED", this.id)
                        } : ""
                    ]
                }).render()
                
            }
        }).render()

        // Flag the toolbar as "rendered", so that the method _renderToolbar() is idempotent
        this.isToolbarRendered = true
    }
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-chartview", kiss.ui.ChartView)

/**
 * Shorthand to create a new Chart. See [kiss.ui.Chart](kiss.ui.Chart.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createChartView = (config) => document.createElement("a-chartview").init(config)

;/** 
 * 
 * The **Dashboard** derives from [DataComponent](kiss.ui.DataComponent.html).
 * 
 * A dashboard is a group of charts that are displayed together in a single screen.
 * 
 * @param {object} config
 * @param {string} config.name - The dashboard title. We use the "name" property instead of "title" to be consistent with all view names.
 * @param {Collection} config.collection - The data source collection
 * @param {object} [config.record] - Record to persist the view configuration into the db
 * @param {boolean} [config.canEditView] - true if the user can edit the view setup. Default is true.
 * @param {boolean} [config.useCDN] - Set to false to use the local version of ChartJS. Default is true.
 * @returns this
 * 
 * ## Generated markup
 * ```
 * <a-dashboard class="a-dashboard">
 *      <div class="dashboard-header">
 *          <div class="dashboard-title">
 *              <!-- Dashboard title -->
 *          </div>
 *          <div class="dashboard-toolbar">
 *              <!-- Dashboard toolbar items -->
 *          </div>
 *      </div>
 *      <div class="dashboard-container">
 *          <!-- Embedded charts -->
 *      </div>
 * </a-dashboard>
 * ```
 */
kiss.ui.Dashboard = class Dashboard extends kiss.ui.DataComponent {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const myDashboard = document.createElement("a-dashboard").init(config)
     * ```
     * 
     * Or use the shorthand for it:
     * ```
     * const myDashboard = createDashboard({
     *   id: "my-dashboard",
     *   collection: kiss.app.collections["opportunity"]
     * })
     * 
     * myDashboard.render()
     * ```
     */
    constructor() {
        super()
    }

    /**
     * Generates a Dashboard from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config) {
        // This component must be resized with its parent container
        config.autoSize = true

        // Init the parent DataComponent
        super.init(config)

        // Options
        this.color = config.color || "#00aaee"
        this.canEditView = (config.canEditView === false) ? false : true
        this.useCDN = (config.useCDN === false) ? false : true
        this.CHART_TOP_SPACE = 13 // Busy space at the top of each chart, in rem

        // Build dashboard skeletton markup
        let id = this.id
        this.innerHTML = /*html*/
            `<div class="dashboard-container">
                <div class="dashboard-header">
                    <div class="dashboard-title">
                        ${this.name || ""}
                    </div>
                    <div style="flex: 1"></div>
                    <div id="dashboard-toolbar:${id}" class="dashboard-toolbar">
                        <div id="setup:${id}"></div>
                    </div>
                </div>
                <div id="dashboard-groups:${id}" class="dashboard-groups"></div>
            </div>`.removeExtraSpaces()

        // Set dashboard components
        this.header = this.querySelector(".dashboard-header")
        this.headerTitle = this.querySelector(".dashboard-title")
        this.toolbar = this.querySelector(".dashboard-toolbar")
        this.dashboardGroups = this.querySelector(".dashboard-groups")

        this._initClickEvents()
        this._initSubscriptions()

        return this
    }

    /**
     * Load the dashboard
     * 
     * @ignore
     */
    async load() {
        await this.collection.find()
        this._render()
    }

    /**
     * Render the dashboard
     * 
     * @private
     * @ignore
     * @returns this
     */
    _render() {
        let isFirstGroup = false
        this.dashboardGroups.innerHTML = ""
        let items = this.record.config || []

        // Init an empty group if no items are found
        if (items.length == 0) {
            isFirstGroup = true
            const groupId = "dashboard-group:" + uid()
            const viewId = uid()

            items.push({
                id: groupId,
                class: "dashboard-group",
                height: `calc(calc(calc(100vh - ${this.CHART_TOP_SPACE}rem) * 0.5) - 1px)`, // 50% of the container's available height
                items: [{
                    id: viewId,
                    type: "chartview",
                    chartType: "bar",
                    dashboard: true,
                    name: txtTitleCase("untitled"),
                    color: this.color,
                    collection: this.collection.clone("memory"),
                    useCDN: this.useCDN
                }]
            })
        }

        // Hide the setup button of each chart if the user cannot update the dashboard
        if (!this.canEditView) {
            items.forEach(group => {
                group.items.forEach(item => {
                    if (item.type == "chartview") {
                        item.showActions = false
                    }
                })
            })
        }

        // Constrain CDN parameter of each chart to reflect the dashboard
        items.forEach(group => {
            group.items.forEach(item => {
                if (item.type == "chartview") {
                    item.useCDN = this.useCDN
                }
            })
        })

        // Inject the new group
        this.dashboardGroups.appendChild(
            createBlock({
                id: "dashboard-groups-container:" + this.id,
                width: "100%",
                flex: 1,
                overflow: "auto",
                items
            }
        ).render())

        // Add buttons to manage the dashboard (= add a chart to a group)
        this._manageDashboardButtons()

        // Enable drag and drop
        this._enableDragAndDrop()

        // Adjust buttons color
        this.setColor(this.color)

        // Show the quick tips for the 1st created group
        if (isFirstGroup) this._showQuickTips()

        return this
    }

    /**
     * Set the dashboard title
     * 
     * @param {string} newTitle 
     */
    setTitle(newTitle) {
        this.headerTitle.innerHTML = newTitle
    }    

    /**
     * Set the color of the dashboard (mainly buttons at the moment)
     * 
     * @param {string} color 
     * @returns this
     */
    setColor(color) {
        const charts = this._getCharts()
        for (const chart of charts) {
            chart.setColor(color)
        }
        return this
    }

    /**
     * Add a group of charts to the dashboard
     * 
     * @async
     * @returns this
     */
    async addGroup() {
        const newGroupId = uid()
        const newGroup = createBlock({
            id: "dashboard-group:" + newGroupId,
            class: "dashboard-group",
            items: []
        }).render()

        const groupsContainer = this._getGroupsContainer()
        groupsContainer.appendChild(newGroup)
        await this.saveConfig()

        const escapedId = CSS.escape("dashboard-group:" + newGroupId)
        kiss.tools.waitForElement("#" + escapedId).then(() => {
            $("dashboard-group:" + newGroupId).scrollIntoView({
                behavior: "smooth"
            })
        })

        this.addChart("dashboard-group:" + newGroupId)
        this._manageDashboardButtons()
        this._enableDragAndDrop()

        return this
    }

    /**
     * Delete a group of charts from the dashboard
     * 
     * @param {string} groupId - The group ID to delete
     */
    async deleteGroup(groupId) {
        createDialog({
            title: txtTitleCase("delete this row"),
            icon: "fas fa-trash",
            headerBackgroundColor: "var(--red)",
            message: txtTitleCase("#delete row"),
            action: async () => {
                const groupsContainer = this._getGroupsContainer()
                groupsContainer.deleteItem(groupId)
                await this.saveConfig()
                this._render()
            }
        })
    }

    /**
     * Move a group up in the dashboard
     * 
     * @param {string} groupId 
     * @returns this
     */
    moveGroupUp(groupId) {
        const group = $(groupId)
        if (!group) return
    
        const previousGroup = group.previousElementSibling
        if (!previousGroup || !previousGroup.classList.contains("dashboard-group")) return // Already at the top
    
        previousGroup.before(group)
        this.saveConfig()
        return this
    }

    /**
     * Move a group down in the dashboard
     * 
     * @param {string} groupId 
     * @returns this
     */
    moveGroupDown(groupId) {
        const group = $(groupId)
        if (!group) return
    
        const nextGroup = group.nextElementSibling
        if (!nextGroup || !nextGroup.classList.contains("dashboard-group")) return // Already at the bottom
    
        nextGroup.after(group)
        this.saveConfig()
        return this
    }

    /**
     * Checks whether a group can be moved up or down.
     *
     * @param {string} groupId - The ID of the group to check.
     * @returns {object} - An object with `up` and `down` properties indicating the possible moves.
     */
    checkGroupMove(groupId) {
        const group = $(groupId)
        if (!group) return false

        const previousGroup = group.previousElementSibling;
        const nextGroup = group.nextElementSibling;

        return {
            up: !!(previousGroup && previousGroup.classList.contains("dashboard-group")),
            down: !!(nextGroup && nextGroup.classList.contains("dashboard-group")),
        }
    }

    /**
     * Get the groups of the dashboard
     * 
     * @returns {HTMLElement[]} - The groups of charts (1 group = 1 row in the dashboard)
     */
    getGroups() {
        return Array.from(this.querySelectorAll(".dashboard-group"))
    }

    /**
     * Get the number of groups in the dashboard
     * 
     * @returns {number} - The number of groups
     */
    getGroupCount() {
        return this.getGroups().length
    }

    /**
     * Get the charts of a group
     * 
     * @param {string} groupId 
     * @returns {HTMLElement[]} - The charts of the group
     */
    getGroupCharts(groupId) {
        return Array.from($(groupId).querySelectorAll(".a-chartview"))
    }

    /**
     * Get a chart from its ID
     * 
     * @param {string} chartId
     * @returns {HTMLElement} - The chart element
     */
    getChart(chartId) {
        const dashboardGroups = $("dashboard-groups:" + this.id)
        let chart = null

        for (const dashboardGroup of dashboardGroups.firstChild.items) {
            chart = dashboardGroup.items.find(item => item.id == chartId)
            if (chart) break
        }
        return chart
    }

    /**
     * Add a chart to a group of charts
     * 
     * @async
     * @param {string} groupId 
     * @returns this
     */
    async addChart(groupId) {
        const viewId = uid()
        const dashboardGroup = $(groupId)

        dashboardGroup.insertItem({
            id: viewId,
            type: "chartview",
            chartType: "bar",
            dashboard: true,
            name: txtTitleCase("untitled"),
            color: this.color,
            collection: this.collection.clone("memory"),
            useCDN: this.useCDN
        }, dashboardGroup.items.length - 1)

        this._manageDashboardButtons()
        this._enableDragAndDrop()
        
        await this.saveConfig()
        return this
    }

    /**
     * Move a chart to another position in the dashboard
     * 
     * @param {string} chartId 
     * @param {string} targetChartId
     * @returns this
     */
    moveChart(chartId, targetChartId) {
        const sourceChart = $(chartId)
        const targetChart = $(targetChartId)
        const sourceGroup = $(chartId).closest(".dashboard-group")
        const targetGroup = $(targetChartId).closest(".dashboard-group")
        
        // Case 1: same group
        if (sourceGroup.id == targetGroup.id) {
            const sourceIndex = this.getChartIndexInGroup(chartId)
            const targetIndex = this.getChartIndexInGroup(targetChartId)

            if (sourceIndex < targetIndex) {
                targetChart.after(sourceChart)
            } else {
                targetChart.before(sourceChart)
            }

            this.saveConfig()
            return this
        }

        // Case 2: different groups
        const chartsInTargetGroup = targetGroup.querySelectorAll(".a-chartview").length

        if (chartsInTargetGroup >= 4) {
            return createNotification(txtTitleCase("this row is full"))
        }

        const targetIndex = [...targetGroup.children].indexOf(targetChart)

        if (targetIndex !== -1) {
            targetChart.before(sourceChart)
        } else {
            targetGroup.appendChild(sourceChart)
        }

        // Recompute the size of the charts
        sourceChart.updateSize()
        this._updateGroupLayout(sourceGroup)

        // If the source group is empty, remove it
        if (sourceGroup.children.length == 1) {
            sourceGroup.deepDelete()
        }

        this.saveConfig()
        return this
    }    

    /**
     * Remove a chart from the dashboard
     * 
     * @async
     * @param {string} chartId - The chart ID to remove
     * @returns this
     */
    async deleteChart(chartId) {
        const dashboardGroup = $(chartId).closest(".dashboard-group")
        dashboardGroup.deleteItem(chartId)
        this._manageDashboardButtons()
        await this.saveConfig()
        return this
    }

    /**
     * Get the index of a chart in a group
     * 
     * @param {string} chartId 
     * @returns {number} - The chart index in the group
     */
    getChartIndexInGroup(chartId) {
        const sourceChart = $(chartId)
        const sourceGroup = $(chartId).closest(".dashboard-group")
        return [...sourceGroup.children].indexOf(sourceChart)
    }    

    /**
     * Get the current dashboard configuration
     * 
     * @returns {object[]} - The dashboard configuration, as an array of groups of charts
     */
    getConfig() {
        const dashboardGroupsContainer = $("dashboard-groups:" + this.id)
        let dashboardGroups = []

        const dashboardGroupElements = Array.from(dashboardGroupsContainer.firstChild.children)
        dashboardGroupElements.forEach(dashboardGroup => {
            let group = {
                id: dashboardGroup.id,
                height: dashboardGroup.config.height,
                class: "dashboard-group",
            }

            let items = []
            const groupItems = [...dashboardGroup.children]
            groupItems.forEach(item => {
                if (item.type == "chartview") {
                    let newItem = {
                        type: "chartview",
                        dashboard: true,
                        id: item.id,
                        name: item.name,
                        modelId: item.model.id,
                        chartType: item.chartType,
                        sort: item.sort,
                        filter: item.filter,
                        isTimeSeries: item.isTimeSeries,
                        categoryField: item.categoryField,
                        timeField: item.timeField,
                        timePeriod: item.timePeriod,
                        operationType: item.operationType,
                        summaryOperation: item.summaryOperation,
                        valueField: item.valueField,
                        startAtZero: item.startAtZero,
                        showLegend: item.showLegend,
                        legendPosition: item.legendPosition,
                        showValues: item.showValues,
                        showLabels: item.showLabels,
                        centerLabels: item.centerLabels,
                        labelColor: item.labelColor,
                        precision: item.precision,
                        unit: item.unit,
                        useCDN: this.useCDN
                    }
                    items.push(newItem)
                }
            })
            group.items = items
            dashboardGroups.push(group)
        })
        return dashboardGroups
    }
    
    /**
     * Save the current dashboard configuration
     * 
     * @async
     * @returns this
     */
    async saveConfig() {
        const config = this.getConfig()
        await this.record.update({
            config
        })
        return this
    }
    
    /**
     * Update the layout of the dashboard
     * 
     * @returns this
     */
    updateLayout() {
        return this
    }

    /**
     * Print the dashboard - Work in progress
     */
    async print() {
        // const charts = document.querySelectorAll("a-chart")
        // charts.forEach((chartElement) => {
        //     const chartInstance = chartElement.chart
        //     if (chartInstance) {
        //         const img = document.createElement("img")
        //         img.src = chartInstance.canvas.toDataURL()
        //         img.style.display = "block"
        //         img.style.width = "100%"
        //         img.style.maxWidth = "fit-content"
        //         img.style.height = "100%"
        //         img.style.maxHeight = "fit-content"
        //         chartElement.replaceChild(img, chartInstance.canvas)
        //     }
        // })
        // setTimeout(() => window.print(), 500)
    }

    /**
     * Initialize click events
     * 
     * @private
     * @ignore
     */
    _initClickEvents() {
        if (!this.canEditView) return

        // this.onclick = (e) => {
        //     const target = e.target
        //     log("---------")
        //     log(target)
        //     const chartButton = target.closest(".a-button")

        //     if (!chartButton && target.closest(".dashboard-group")) {
        //         const groupId = target.closest(".dashboard-group").id
        //         this._showGroupSetup(groupId, e)
        //     }
        // }
    }

    /**
     * Initialize subscriptions to PubSub
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initSubscriptions() {
        // React to database mutations
        this.subscriptions = this.subscriptions.concat([
            subscribe("EVT_DB_UPDATE:VIEW", (msgData) => this._updateTitle(msgData)),

            // React to events coming from individual charts
            subscribe("EVT_DASHBOARD_SETUP", (chartId) => {
                if (!this.isConnected) return

                const chartIds = this._getChartIds()
                if (chartIds.length == 0) return

                if (chartIds.includes(chartId)) {
                    this.saveConfig()
                }
            }),

            // React when one of the charts is deleted
            subscribe("EVT_DASHBOARD_CHART_DELETED", (chartId) => {
                if (!this.isConnected) return

                const chartIds = this._getChartIds()
                if (chartIds.length == 0) return

                if (chartIds.includes(chartId)) {
                    this.deleteChart(chartId)
                }
            }),

            // React when one of the charts is clicked
            subscribe("EVT_CHART_CLICKED", (msg) => {
                if (!this.isConnected) return

                const chartIds = this._getChartIds()
                if (chartIds.length == 0) return

                if (chartIds.includes(msg.chartId)) {
                    const group = this._getChartGroup(msg.chartId)
                    this._showGroupSetup(group.id, msg.event)
                }
            })
        ])

        return this
    }

    /**
     * Initialize the charts drag and drop
     * 
     * @private
     * @ignore
     */
    _enableDragAndDrop() {
        if (!this.canEditView) return
        
        // Drag and drop helpers
        const getCharts = () => this.querySelectorAll(".a-chartview")
        const resetCharts = () => getCharts().forEach(chart => chart.classList.remove("chartview-highlight"))
        const resetChart = (chart) => chart.classList.remove("chartview-highlight")
        const highlightChart = (chart) => chart.classList.add("chartview-highlight")

        // Drag and drop events
        const dndEvents = {
            ondragstart: (event) => {
                const chart = event.target.closest(".a-chartview")
                kiss.context.chartId = chart.id
            },

            ondragover: (event) => {
                event.preventDefault()
                resetCharts()
                const chart = event.target.closest(".a-chartview")
                if (!chart) return
                highlightChart(chart)
            },

            ondrop: (event) => {
                event.preventDefault()
                resetCharts()
                const chart = event.target.closest(".a-chartview")
                if (!chart) return

                const chartId = kiss.context.chartId
                this.moveChart(chartId, chart.id)
            },

            ondragleave: (event) => {
                const chart = event.target.closest(".a-chartview")
                if (!chart) return
                resetChart(chart)
            }
        }

        this.querySelectorAll(".a-chartview").forEach(chart => {
            chart.draggable = true
            chart.ondragstart = dndEvents.ondragstart
            Object.assign(chart, dndEvents)
        })
    }

    /**
     * Show the menu to setup a group of charts
     * 
     * @param {string} groupId 
     * @param {object} event - The click event
     */
    _showGroupSetup(groupId, event) {
        const _this = this
        const group = $(groupId)
        const groupMoves = this.checkGroupMove(groupId)

        createMenu({
            items: [
                // SIZE
                `<h3>${txtTitleCase("row height")}</h3>`,
                "-",
                {
                    text: "20%",
                    icon: "fas fa-circle",
                    iconSize: "0.2rem",
                    action: async function() {
                        group.config.height = group.style.height = `calc(calc(calc(100vh - ${_this.CHART_TOP_SPACE}rem) * 0.2) - 1px)`
                        await _this.saveConfig()
                    }
                },                
                {
                    text: "25%",
                    icon: "fas fa-circle",
                    iconSize: "0.5rem",
                    action: async function() {
                        group.config.height = group.style.height = `calc(calc(calc(100vh - ${_this.CHART_TOP_SPACE}rem) * 0.25) - 1px)`
                        await _this.saveConfig()
                    }
                },
                {
                    text: "33%",
                    icon: "fas fa-circle",
                    iconSize: "0.66rem",
                    action: async function() {
                        group.config.height = group.style.height = `calc(calc(calc(100vh - ${_this.CHART_TOP_SPACE}rem) * 0.33) - 1px)`
                        await _this.saveConfig()
                    }
                },
                {
                    text: "40%",
                    icon: "fas fa-circle",
                    iconSize: "0.8rem",
                    action: async function() {
                        group.config.height = group.style.height = `calc(calc(calc(100vh - ${_this.CHART_TOP_SPACE}rem) * 0.40) - 1px)`
                        await _this.saveConfig()
                    }
                },                
                {
                    text: "50%",
                    icon: "fas fa-circle",
                    iconSize: "1rem",
                    action: async function() {
                        group.config.height = group.style.height = `calc(calc(calc(100vh - ${_this.CHART_TOP_SPACE}rem) * 0.5) - 1px)`
                        await _this.saveConfig()
                    }
                },
                {
                    text: "66%",
                    icon: "fas fa-circle",
                    iconSize: "1.3rem",
                    action: async function() {
                        group.config.height = group.style.height = `calc(calc(calc(100vh - ${_this.CHART_TOP_SPACE}rem) * 0.66) - 1px)`
                        await _this.saveConfig()
                    }
                },
                {
                    text: "75%",
                    icon: "fas fa-circle",
                    iconSize: "1.5rem",
                    action: async function() {
                        group.config.height = group.style.height = `calc(calc(calc(100vh - ${_this.CHART_TOP_SPACE}rem) * 0.75) - 1px)`
                        await _this.saveConfig()
                    }
                },          
                {
                    text: "100%",
                    icon: "fas fa-circle",
                    iconSize: "2rem",
                    action: async function() {
                        group.config.height = group.style.height = `calc(100vh - ${_this.CHART_TOP_SPACE}rem)`
                        await _this.saveConfig()
                    }
                },
                "-",
                // MOVE UP
                {
                    hidden: groupMoves.up ? false : true,
                    text: txtTitleCase("move up"),
                    icon: "fas fa-arrow-up",
                    action: async () => this.moveGroupUp(groupId)
                },
                // MOVE DOWN
                {
                    hidden: groupMoves.down ? false : true,
                    text: txtTitleCase("move down"),
                    icon: "fas fa-arrow-down",
                    action: async () => this.moveGroupDown(groupId)
                },
                // ADD A ROW OF CHARTS
                {
                    text: txtTitleCase("add row"),
                    icon: "fas fa-plus",
                    action: async () => this.addGroup()
                },
                // DELETE
                "-",
                {
                    text: txtTitleCase("delete this row"),
                    icon: "fas fa-trash",
                    iconColor: "var(--red)",
                    action: async () => this.deleteGroup(groupId)
                }
            ]
        }).render().showAt(event.clientX - 20, event.clientY - 20)
    }

    /**
     * Show quick tips for the 1st created chart
     * 
     * @private
     * @ignore
     */
    _showQuickTips() {
        const dashboardGroup = this.getGroups()[0]
        setTimeout(() => {
            const buttonSetup = $("actions:" + dashboardGroup.items[0].id)
            const buttonAdd = dashboardGroup.items[dashboardGroup.items.length - 1]

            kiss.tools.highlightElements([
                {
                    element: buttonSetup,
                    text: txtTitleCase("#help setup chart"),
                    position: "left"
                },
                {
                    element: buttonAdd,
                    text: txtTitleCase("#help add chart"),
                    position: "left"
                }
            ])
        }, 1000)
    }

    /**
     * Manage the dashboard buttons
     * 
     * @private
     * @ignore
     */
    _manageDashboardButtons() {
        if (!this.canEditView) return

        setTimeout(() => {
            const dashboardGroupsContainer = $("dashboard-groups:" + this.id)
            const dashboardGroupElements = Array.from(dashboardGroupsContainer.firstChild.children)

            // Remove all buttons from the dashboard
            dashboardGroupElements.forEach(dashboardGroup => {
                dashboardGroup.items.forEach((item, index) => {
                    if (item.type == "button") {
                        dashboardGroup.deleteItem(item.id)
                    }
                })
            })

            // Add a button to add a chart to each group
            dashboardGroupElements.forEach(dashboardGroup => {
                if (dashboardGroup.items.length > 3) return

                let buttonConfig = {
                    type: "button",
                    icon: "fas fa-plus",
                    width: "3.2rem",
                    height: "3.2rem",
                    margin: "0 0 0 -2.5rem",
                    tip: txtTitleCase("add chart"),
                    action: () => this.addChart(dashboardGroup.id)
                }

                dashboardGroup.addItem(buttonConfig)
            })
        }, 0)
    }
 
    /**
     * Update the dashboard title
     * 
     * @private
     * @ignore
     */
    _updateTitle(msgData) {
        if (!this.record) return
        if (msgData.id == this.record.id && msgData.data.name) {
            this.setTitle(msgData.data.name)
        }
    }

    /**
     * Get the charts of the dashboard
     * 
     * @returns {HTMLElement[]} - The charts
     */
    _getCharts() {
        return Array.from(this.querySelectorAll(".a-chartview"))
    }

    /**
     * Get the chart IDs from the dashboard
     * 
     * @private
     * @ignore
     * @returns {string[]} - The chart IDs
     */
    _getChartIds() {
        return this._getCharts().map(chart => chart.id)
    }

    /**
     * Get the group of a chart
     * 
     * @private
     * @ignore
     * @param {string} chartId 
     * @returns {HTMLElement} - The group element
     */
    _getChartGroup(chartId) {
        return $(chartId).closest(".dashboard-group")
    }

    /**
     * Get the index of a group in the dashboard
     * 
     * @private
     * @ignore
     * @param {string} groupId 
     * @returns {number} - The group index, or -1 if not found
     */
    _getGroupIndex(groupId) {
        const dashboardGroups = $("dashboard-groups:" + this.id)
        return dashboardGroups.firstChild.items.findIndex(group => group.id == groupId)
    }

    /**
     * Get the groups container
     * 
     * @private
     * @ignore
     * @returns {HTMLElement} - The groups container
     */
    _getGroupsContainer() {
        return $("dashboard-groups-container:" + this.id)
    }

    /**
     * Refresh the sizes of the charts in a group
     * 
     * @private
     * @ignore
     * @param {HTMLElement} group - The group element
     */
    _updateGroupLayout(group) {
        group.querySelectorAll(".a-chartview").forEach(chart => chart.updateSize())
    }    
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-dashboard", kiss.ui.Dashboard)

/**
 * Shorthand to create a new Dashboard. See [kiss.ui.Dashboard](kiss.ui.Dashboard.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createDashboard = (config) => document.createElement("a-dashboard").init(config)

;/** 
 * 
 * The **Datatable** derives from [DataComponent](kiss.ui.DataComponent.html).
 * 
 * It's a [powerful datatable](https://kissjs.net/#ui=start&section=datatable) with the following features:
 * - display / hide columns
 * - move columns with drag&drop
 * - resize columns
 * - multi-column sorting
 * - complex filtering with combination of AND/OR filters
 * - multi-column grouping
 * - virtual scrolling which also works with grouped data
 * - customizable behavior when opening a record: overriding the selectRecord method
 * - customizable action menu: using actions property
 * - inline cell editing
 * - pre-built cell renderers like text, number, date, select, buttons...
 * - custom cell renderers
 * 
 * Tech note:
 * - rendering time is proportional to the number of cells (= rows x columns) that are visible in the viewport (other cells are not rendered at all)
 * - rendering takes an average of 0.05 to 0.07 millisecond (depending on the cell type) per visible cell on an Intel i7-4790K
 * 
 * @param {object} config
 * @param {Collection} config.collection - The data source collection
 * @param {object} [config.record] - Record to persist the view configuration into the db
 * @param {object[]} [config.columns] - Where each column is: {title: "abc", type: "text|number|integer|float|date|button", id: "fieldId", button: {config}, renderer: function() {}}
 * @param {string} [config.color] - Hexa color code. Ex: #00aaee
 * @param {string} [config.rowHeight] - CSS row height in rem. Important! Use rem and not pixels. Ex: 4rem
 * @param {boolean} [config.showHeader] - false to hide the header (default = true)
 * @param {boolean} [config.showColumnType] - true to display an icon in the header indicating the column type (default = false)
 * @param {boolean} [config.showToolbar] - false to hide the toolbar (default = true)
 * @param {boolean} [config.showPagerIndex] - false to hide the pager index (default = true)
 * @param {boolean} [config.showScroller] - false to hide the virtual scroller (default = true)
 * @param {boolean} [config.showActions] - false to hide the custom actions menu (default = true)
 * @param {boolean} [config.showLayoutButton] - false to hide the button to adjust the layout (default = true)
 * @param {boolean} [config.showGroupButtons] - false to hide the button to expand/collapse groups (default = true)
 * @param {boolean} [config.showGroupHierarchyButton] - false to hide the button to show group hierarchy (default = true)
 * @param {boolean} [config.showLinks] - false to hide the columns which field type is "link"
 * @param {boolean} [config.canSearch] - false to hide the search button (default = true)
 * @param {boolean} [config.canSelect] - false to hide the selection checkboxes (default = true)
 * @param {boolean} [config.canSelectCells] - false to prevent selection of cells to copy their value (default = true)
 * @param {boolean} [config.canSort] - false to hide the sort button (default = true)
 * @param {boolean} [config.canFilter] - false to hide the filter button (default = true)
 * @param {boolean} [config.canGroup] - false to hide the group button (default = true)
 * @param {boolean} [config.canEdit] - Can we edit the cells?
 * @param {boolean} [config.canSelectFields] - Can we select the fields (= columns) to display in the table? (default = true)
 * @param {boolean} [config.canAddField] - Can we add a field (= column) to the table?
 * @param {boolean} [config.canEditField] - Can we edit an existing field (= column)?
 * @param {boolean} [config.canCreateRecord] - Can we create new records from the datatable?
 * @param {boolean} [config.createRecordText] - Optional text to insert in the button to create a new record, instead of the default model's name
 * @param {boolean} [config.iconAction] - Font Awesome icon class to display the "open record" symbol. Defaults to "far fa-file-alt"
 * @param {object[]} [config.actions] - Array of menu actions, where each menu entry is: {text: "abc", icon: "fas fa-check", action: function() {}}
 * @param {object[]} [config.buttons] - Array of custom buttons, where each button is: {position: 3, text: "button 3", icon: "fas fa-check", action: function() {}}
 * @param {number|string} [config.width]
 * @param {number|string} [config.height]
 * @returns this
 * 
 * ## Generated markup
 * ```
 * <a-datatable class="a-datatable">
 *      <div class="datatable-toolbar">
 *          <!-- Datatable toolbar items -->
 *      </div>
 *      <div class="datatable-header-container">
 *          <div class="datatable-header-1st-column">
 *              <!-- Header 1st column -->
 *          </div>
 *          <div class="datatable-header">
 *              <!-- Header other columns -->
 *          </div>
 *      </div>
 *      <div class="datatable-body-container">
 *          <div class="datatable-body-1st-column">
 *              <!-- Body 1st column -->
 *          </div>
 *          <div class="datatable-body">
 *              <!-- Body other columns -->
 *          </div>
 *      </div>
 *      <div class="datatable-virtual-scroller-container">
 *          <div class="datatable-virtual-scroller"></div>
 *      </div>
 * </a-datatable>
 * ```
 */
kiss.ui.Datatable = class Datatable extends kiss.ui.DataComponent {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const myDatatable = document.createElement("a-datatable").init(config)
     * ```
     * 
     * Or use the shorthand for it:
     * ```
     * const myDatatable = createDatatable({
     *   id: "my-table",
     *   color: "#00aaee",
     *   collection: kiss.app.collections["contact"],
     * 
     *   // Columns must match the Model's fields
     *   columns: [
     *       {
     *           id: "firstName", // Must match the model's field id
     *           type: "text",
     *           title: "First name",
     *       },
     *       {
     *           id: "lastName",
     *           type: "text",
     *           title: "Last name",
     *       },
     *       {
     *           id: "birthDate",
     *           type: "date",
     *           title: "Birth date"
     *       }
     *   ],
     * 
     *   // We can define a menu with custom actions
     *   actions: [
     *       {
     *           text: "Group by country and city",
     *           icon: "fas fa-sort",
     *           action: () => $("my-table").groupBy(["Country", "City"])
     *       }
     *   ],
     *   
     *   // We can add custom methods, and also override default ones
     *   methods: {
     * 
     *      // Override the createRecord method
     *      createRecord(model) {
     *          // Create a record from this model
     *          console.log(model)
     *      },
     * 
     *      // Override the selectRecord method
     *      selectRecord(record) {
     *          // Show the clicked record
     *          console.log(record)
     *      },
     * 
     *      sayHello: () => console.log("Hello"),
     *   }
     * })
     * 
     * myDatatable.render()
     * ```
     */
    constructor() {
        super()
    }

    /**
     * Generates a Datatable from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config) {
        // This component must be resized with its parent container
        config.autoSize = true

        // Init the parent DataComponent
        super.init(config)

        // Display options
        this.showHeader = (config.showHeader !== false)
        this.showColumnType = !!config.showColumnType
        this.showToolbar = (config.showToolbar !== false)
        this.showPagerIndex = (config.showPagerIndex !== false)
        this.showScroller = (config.showScroller !== false)
        this.showActions = (config.showActions !== false)
        this.showLayoutButton = (config.showLayoutButton !== false)
        this.showGroupButtons = (config.showGroupButtons !== false)
        this.showGroupHierarchy = !!config.showGroupHierarchy
        this.showGroupHierarchyButton = (config.showGroupHierarchyButton !== false)
        this.canSearch = (config.canSearch !== false)
        this.canSort = (config.canSort !== false)
        this.canFilter = (config.canFilter !== false)
        this.canGroup = (config.canGroup !== false)
        this.color = config.color || "#00aaee"
        this.iconAction = config.iconAction || "far fa-file-alt"
        this.defaultRowHeight = 4 // in rem
        this.resizerWidth = 1.5 // in rem

        // Behaviour options
        this.canSelect = (config.canSelect !== false)
        this.canSelectCells = (config.canSelectCells !== false)
        this.canEdit = !!config.canEdit
        this.canAddField = !!config.canAddField
        this.canEditField = !!config.canEditField
        this.canSelectFields = (config.canSelectFields !== false)
        this.actions = config.actions || []
        this.buttons = config.buttons || []

        // Build datatable skeletton markup
        let id = this.id
        this.innerHTML =
            /*html*/
            `<div class="datatable">
                <div id="datatable-toolbar:${id}" class="datatable-toolbar">
                    <div id="search-field:${id}"></div>
                    <div id="create:${id}"></div>
                    <div id="actions:${id}"></div>
                    <div id="select:${id}"></div>
                    <div id="sort:${id}"></div>
                    <div id="filter:${id}"></div>
                    <div id="group:${id}"></div>
                    <div id="collapse:${id}"></div>
                    <div id="expand:${id}"></div>
                    <div id="refresh:${id}"></div>
                    <div id="search:${id}"></div>
                    <div id="hierarchy:${id}"></div>
                    <div id="add:${id}"></div>
                    <div id="explode:${id}"></div>
                    <div class="spacer"></div>
                    <div id="pager-index:${id}" class="datatable-toolbar-pager-index"></div>
                    <div id="pager-first:${id}"></div>
                    <div id="pager-previous:${id}"></div>
                    <div id="pager-next:${id}"></div>
                    <div id="pager-last:${id}"></div>
                    <div id="layout:${id}"></div>
                </div>

                <div class="datatable-header-container">
                    <div class="datatable-header-1st-column"></div>
                    <div id="datatable-header:${id}" class="datatable-header"></div>
                </div>

                <div class="datatable-body-container">
                    <div class="datatable-body-1st-column"></div>
                    <div id="datatable-body:${id}" class="datatable-body"></div>
                </div>

                <div class="datatable-virtual-scroller-container">
                    <div class="datatable-virtual-scroller"></div>
                </div>
            </div>`.removeExtraSpaces()

        // Set datatable components
        this.datatable = this.querySelector(".datatable")
        this.datatableToolbar = this.querySelector(".datatable-toolbar")
        this.datatableHeader = this.querySelector(".datatable-header")
        this.datatableBody = this.querySelector(".datatable-body")
        this.datatableBodyContainer = this.querySelector(".datatable-body-container")
        this.datatableHeader1stColumn = this.querySelector(".datatable-header-1st-column")
        this.datatableBody1stColumn = this.querySelector(".datatable-body-1st-column")
        this.datatableScrollerContainer = this.querySelector(".datatable-virtual-scroller-container")
        this.datatableScroller = this.querySelector(".datatable-virtual-scroller")
        this.datatablePagerIndex = this.querySelector(".datatable-toolbar-pager-index")

        // Set header, toolbar and scroller visibility
        if (this.showHeader === false) this.datatableHeader.style.display = "none"
        if (this.showToolbar === false) this.datatableToolbar.style.display = "none"
        if (this.showScroller === false) this.datatableScrollerContainer.style.display = "none"
        if (this.showPagerIndex === false) this.datatablePagerIndex.style.display = "none"

        this._initColumnsDefaultWidth()
            ._initColumns()
            ._initSize(config)
            ._initEvents()
            ._initSubscriptions()

        return this
    }

    /**
     * 
     * DATATABLE METHODS
     * 
     */

    /**
     * Load data into the datatable.
     * 
     * Remark:
     * - rendering time is proportional to the number of visible cells (= rows x columns)
     * - rendering takes an average of 0.06 millisecond per cell on an Intel i7-4790K
     * 
     * @ignore
     */
    async load() {
        try {
            log(`kiss.ui - Datatable ${this.id} - Loading collection <${this.collection.id} (changed: ${this.collection.hasChanged})>`)

            // Add the search filter if needed
            let currentFilter = this.filter
            if (this.currentSearchTerm) {
                currentFilter = this.createSearchFilter(this.currentSearchTerm)
            }

            // Apply filter, sort, group, projection
            // Priority is given to local config, then to the passed collection, then to default
            this.collection.filter = currentFilter
            this.collection.filterSyntax = this.filterSyntax
            this.collection.sort = this.sort
            this.collection.sortSyntax = this.sortSyntax
            this.collection.group = this.group
            this.collection.projection = this.projection
            this.collection.groupUnwind = this.groupUnwind

            // Load records
            await this.collection.find()

            // Hide the virtual scroller while the datatable is being built
            this._hideScroller()

            // Try to adjust columns width from local config
            this._columnsAdjustWidthFromLocalStorage()

            // Get the selected records
            this.getSelection()

            // Render the datatable toolbar
            this._renderToolbar()

            // Get paging params (skip & limit)
            this.skip = 0
            this._setLimit()

            // Show onboarding tutorial if needed
            if (kiss.context.onboard == true) {
                this.showTutorial()
            }

        } catch (err) {
            log(`kiss.ui - Datatable ${this.id} - Couldn't load data properly`)
        }
    }

    /**
     * Switch to search mode
     * 
     * Show/hide only the necessary buttons in this mode.
     */
    switchToSearchMode() {
        if (kiss.screen.isMobile) {
            $("create:" + this.id).hide()
            $("search:" + this.id).hide()
            $("expand:" + this.id).hide()
            $("collapse:" + this.id).hide()
        }
    }

    /**
     * Reset search mode
     */
    resetSearchMode() {
        if (kiss.screen.isMobile) {
            $("create:" + this.id).show()
            $("search:" + this.id).show()
            $("expand:" + this.id).show()
            $("collapse:" + this.id).show()
        }
    }

    /**
     * Update the datatable color (toolbar buttons + modal windows)
     * 
     * @param {string} newColor
     */
    async setColor(newColor) {
        this.color = newColor
        Array.from(this.datatableToolbar.children).forEach(item => {
            if (item && item.firstChild && item.firstChild.type == "button") item.firstChild.setIconColor(newColor)
        })
    }

    /**
     * Set the datatable row height
     * 
     * @param {number} height - The row height in pixels
     */
    setRowHeight(height) {
        this.rowHeight = height
        document.documentElement.style.setProperty("--datacomponent-cell-height", this.rowHeight + "rem")
        document.documentElement.style.setProperty("--datacomponent-group-cell-height", this.rowHeight + "rem")
        this._setThumbSize()

        // Save new row height locally
        const localStorageId = "config-view-datatable-" + this.id + "-row-height"
        localStorage.setItem(localStorageId, this.rowHeight)
        this.reload()
    }

    /**
     * Reset all the columns to their default width
     */
    async resetColumnsWidth() {
        this.columns.forEach(column => {
            let width = this.defaultColumnWidth[column.type]
            if (!width) width = this.defaultColumnWidth.default
            this._columnsSetWidth(column.id, width)
        })
    }

    /**
     * Generic method to refresh / re-render the view
     * 
     * Note: used in dataComponent (parent class) showSearchBar method.
     * This method is invoked to refresh the view after a full-text search has been performed
     */
    refresh() {
        this._render()
    }

    /**
     * Update the datatable size (recomputes its width and height functions)
     */
    updateLayout() {
        if (this.isConnected) {
            this._setWidth()
            this._setHeight()
            this._setLimit()
            this._renderPagerIndex()
            this._render()
            this._renderSelectionRestore()
        }
    }

    /**
     * Highlight a chosen record
     * 
     * @param {string} recordId 
     */
    highlightRecord(recordId) {
        let index = this.goToRecord(recordId)
        if (index != -1) this._rowHighlight(index)
    }

    /**
     * Scroll to a chosen record
     * 
     * @param {string} recordId
     * @returns {number} The index of the found record, or -1 if not found
     */
    goToRecord(recordId) {
        let index = this._rowFindIndex(recordId)
        if (index != -1) this.goToIndex(index)
        return index
    }

    /**
     * Scroll to a chosen index
     * 
     * @param {number} index
     */
    goToIndex(index) {
        this.skip = index
        this._render()
    }

    /**
     * Show the first page
     */
    showFirstPage() {
        this.skip = 0
        this._renderPage(0)
    }

    /**
     * Show the previous page
     */
    showPreviousPage() {
        this._renderPage(-this.limit)
    }

    /**
     * Show the next page
     */
    showNextPage() {
        this._renderPage(this.limit)
    }

    /**
     * Show the last page
     */
    showLastPage() {
        this.skip = this.collection.count - this.limit - 1
        this._renderPage(this.limit)
    }

    /**
     * Show the window just under the sorting button
     */
    showSortWindow() {
        let sortButton = $("sort:" + this.id)
        const box = sortButton.getBoundingClientRect()
        super.showSortWindow(box.left, box.top + 40, this.color)
    }

    /**
     * Show the window just under the fields selector button
     */
    showFieldsWindow() {
        let selectionButton = $("select:" + this.id)
        const box = selectionButton.getBoundingClientRect()
        super.showFieldsWindow(box.left, box.top + 40, this.color)
    }

    /**
     * Show the window just under the filter button
     */
    showFilterWindow() {
        super.showFilterWindow(null, null, this.color)
    }

    /**
     * Show the window to adjust the color of a column
     */
    showColorWindow(column) {
        const picker = createPanel({
            modal: true,
            header: false,
            align: "center",
            verticalAlign: "center",
            items: [{
                id: "column-color",
                type: "colorPicker",
                value: column.color,
                palette: kiss.global.palette.slice(0, 20),
                selectorBorderRadius: "3.2rem",
                height: "10rem",
                events: {
                    change: () => {
                        let color = $("column-color").getValue()
                        column.color = color

                        this._render()
                        this.updateConfig({
                            config: {
                                columns: this.columns
                            }
                        })
                        picker.close()
                    }
                }
            }]
        }).render()
    }

    /**
     * Initialize datatable sizes
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initSize(config) {
        this._initRowHeight(config)

        if (config.width) {
            this._setWidth()
        } else {
            this.style.width = this.config.width = `calc(100%)`
        }

        if (config.height) {
            this._setHeight()
        } else {
            this.style.height = this.config.height = `calc(100% - 1rem)`
        }

        return this
    }

    /**
     * Init the row height according to local settings and/or config
     * 
     * @private
     * @ignore
     */
    _initRowHeight(config = {}) {
        this.rowHeight = config.rowHeight || this._getRowHeightFromLocalStorage()
        document.documentElement.style.setProperty("--datacomponent-cell-height", this.rowHeight + "rem")
        document.documentElement.style.setProperty("--datacomponent-group-cell-height", this.rowHeight + "rem")
        this._setThumbSize()
    }

    /**
     * Initialize all datatable events
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initEvents() {
        // Define the list of non-selectable cells
        const nonSelectableCells = [
            "datatable-type-attachment",
            "datatable-type-link",
            "datatable-type-aiImage"
        ]

        // Init the selection of cells to copy their value
        if (this.canSelectCells) this._initCellsCopyToClipboard()

        // Clicked on the checkbox to deselect all records
        this.datatableHeader1stColumn.onclick = (event) => {
            if (event.target.classList.contains("datatable-header-checkbox")) {
                this.toggleSelection()
            }
        }

        // Clicked on the header
        this.datatableHeader.onclick = (event) => {
            const clickedElement = event.target

            // Clicked on a column menu
            if (clickedElement.classList.contains("datatable-column-header-properties")) {
                const columnId = clickedElement.id.split(":")[1]
                this._showColumnMenu(columnId, clickedElement, event)
            }

            // Clicked on the last header to create a new column
            if (clickedElement.classList.contains("datatable-header-last-column") || clickedElement.parentNode.classList.contains("datatable-header-last-column")) {
                if (this.canAddField) {
                    this._showColumnSetup()
                    return event
                }
            }
        }

        // Clicked on the 1st column resizer
        this.datatableHeader1stColumn.onmousedown = (event) => {
            const clickedElement = event.target
            if (clickedElement.classList.contains("datatable-column-header-resizer")) {
                this._columnsResizeWithDragAndDrop(event, clickedElement)
            }
        }

        // Clicked on a column resizer
        this.datatableHeader.onmousedown = (event) => {
            const clickedElement = event.target
            if (clickedElement.classList.contains("datatable-column-header-resizer")) {
                this._columnsResizeWithDragAndDrop(event, clickedElement)
            }
        }

        // Clicked somewhere in the datatable
        this.onclick = async (event) => {
            const clickedElement = event.target
            const clickedParent = clickedElement.parentNode

            // CLICKED INSIDE A THUMBNAIL (attachment or image)
            if (clickedElement.classList.contains("data-thumbnail")) {
                const fieldId = event.target.getAttribute("fieldId")
                const attachmentId = event.target.getAttribute("id")
                const cell = event.target.closest(".datatable-cell")
                const record = this._cellGetRecord(cell)
                const cellAttachments = record[fieldId]
                createPreviewWindow(cellAttachments, attachmentId)
            }

            // CLICKED INSIDE A BLANK CELL (last column)
            if (clickedElement.classList.contains("datatable-cell-blank")) {
                return event
            }

            // CLICKED INSIDE A CELL WHICH IS ALREADY IN EDIT MODE
            if (clickedElement.tagName.toLowerCase() == "input") {
                return event
            }

            // CLICKED ON A COMPUTED CELL CONTAINING AN URL
            if (clickedElement.classList.contains("datatable-cell-selected-locked")) {
                const cellValue = clickedElement.innerText
                if (cellValue && cellValue.match(kiss.tools.regex.url)) {
                    window.open(cellValue)
                    return
                }
            }

            // CLICKED A LINKED FIELD
            if (clickedElement.classList.contains("field-link-value-cell") || clickedParent.classList.contains("field-link-value-cell")) {
                const cell = clickedElement.closest("div")
                const fieldId = this._cellGetFieldId(cell)
                const recordId = clickedElement.closest(".datatable-row").getAttribute("recordId")
                this._cellOpenLinkedRecord(fieldId, recordId)
                return event
            }

            // CLICKED A WORKFLOW HISTORY
            if (clickedElement.classList.contains("form-feature-workflow-history-button") || clickedParent.classList.contains("form-feature-workflow-history-button")) {
                const recordId = clickedElement.closest(".datatable-row").getAttribute("recordId")
                displayWorkflowHistoryFromView(this.id, recordId)
                return event
            }

            // SELECT / DESELECT A ROW
            // = clicked on the checkbox to select a record
            if (clickedElement.classList.contains("datatable-row-checkbox")) {
                const rowIndex = clickedParent.getAttribute("row")
                this._rowToggleSelect(rowIndex)

                if (event.shiftKey && this.lastSelectedRowIndex != null) {
                    const rangeStart = Math.min(this.lastSelectedRowIndex, rowIndex)
                    const rangeEnd = Math.max(this.lastSelectedRowIndex, rowIndex)
                    this.selectRange(rangeStart, rangeEnd)
                    delete this.lastSelectedRowIndex
                    return event
                }

                this.lastSelectedRowIndex = rowIndex
                return event
            }

            // SELECT A RECORD (GENERALLY TO OPEN IT AS A FORM)
            // = clicked on the 1st column cell to expand a record and display it as a form
            if (Array.from(clickedParent.classList).concat(Array.from(clickedElement.classList)).indexOf("datatable-cell-1st") != -1) {
                const cell = clickedElement.closest("div")
                const recordId = cell.getAttribute("recordid")
                const record = await this.collection.getRecord(recordId)
                await this.selectRecord(record)
                return event
            }

            // EXPAND / COLLAPSE A GROUP
            // = clicked on a group section
            if (clickedElement.classList.contains("datatable-group-summary") || clickedParent.classList.contains("datatable-group-summary")) {
                const colIndex = clickedElement.closest("div").getAttribute("col")
                const visibleColumn = this.visibleColumns[colIndex]
                const columnId = visibleColumn.id
                const column = this.columns.get(columnId)

                await this._columnsSetAggregationType(column, event.pageX - 32, event.pageY - 32)
                return event
            }

            if (clickedParent.classList[0] && clickedParent.classList[0].indexOf("datatable-group") != -1) {
                const rowIndex = this._cellGetRowIndex(clickedElement)
                const record = this.collection.records[Number(rowIndex)]
                const groupId = record.$groupId
                const groupLevel = record.$groupLevel

                this._groupToggle(groupId, groupLevel, rowIndex)
                return event
            }

            if (clickedElement.classList.contains("datatable-group")) {
                const rowIndex = clickedElement.getAttribute("row")
                const record = this.collection.records[Number(rowIndex)]
                const groupId = record.$groupId
                const groupLevel = record.$groupLevel

                this._groupToggle(groupId, groupLevel, rowIndex)
                return event
            }

            // OPEN A RECORD
            // (when "canEdit" property == false)
            if (!this.canEdit) {
                if ((clickedElement.classList.contains("datatable-cell")) || clickedParent.classList.contains("datatable-cell")) {
                    const row = clickedElement.closest(".datatable-row")
                    const recordId = row.getAttribute("recordid")
                    const record = await this.collection.getRecord(recordId)
                    await this.selectRecord(record)
                }
                return event
            }

            // EDIT A CELL (or exit if the datatable is not editable)
            if (clickedParent.classList.contains("datatable-cell-selected") && !clickedParent.classList.contains("datatable-cell-selected-locked")) {
                this._cellSwitchToEditMode(clickedParent, event)
                return event
            }

            if (clickedElement.classList.contains("datatable-cell-selected") && !clickedElement.classList.contains("datatable-cell-selected-locked")) {
                this._cellSwitchToEditMode(clickedElement, event)
                return event
            }

            // SELECT A CELL (prior to edition)
            let selectedCell
            if (clickedParent.classList.contains("datatable-cell")) {
                selectedCell = clickedParent
            } else if (clickedElement.classList.contains("datatable-cell")) {
                selectedCell = clickedElement
            }

            if (selectedCell) {

                // OPEN A LINK if the cell contains an URL
                const cellValue = selectedCell.innerText
                if (cellValue && cellValue.match(kiss.tools.regex.url)) {
                    createMenu({
                        items: [{
                            text: txtTitleCase("#open link"),
                            icon: "fas fa-external-link-alt",
                            action: () => window.open(cellValue)
                        }]
                    }).render().showAt(event.pageX + 10, event.pageY + 10)
                }

                // Exclude some cells from being selected
                const classes = selectedCell.classList
                if (nonSelectableCells.some(cell => classes.contains(cell))) {
                    return event
                }

                selectedCell.setAttribute("tabindex", "0")
                selectedCell.focus()
                selectedCell.classList.add("datatable-cell-selected")

                // Check is the record is locked and if it's an editable cell
                const recordId = clickedElement.closest(".datatable-row").getAttribute("recordId")
                const record = await this.collection.getRecord(recordId)
                const isEditable = (record.isLocked) ? false : this._cellIsEditable(selectedCell)

                if (!isEditable) {
                    selectedCell.classList.add("datatable-cell-selected-locked")
                } else {
                    // Manage keyboard
                    selectedCell.onkeydown = (event) => {
                        if (!["Escape"].includes(event.key)) this._cellSwitchToEditMode(selectedCell)
                        selectedCell.classList.remove("datatable-cell-selected")
                        selectedCell.classList.remove("datatable-cell-selected-locked")
                        selectedCell.blur()
                        selectedCell.removeAttribute("tabindex")
                        selectedCell.onkeydown = null
                    }
                }

                // Clean on exit
                selectedCell.onmouseleave = () => {
                    selectedCell.classList.remove("datatable-cell-selected")
                    selectedCell.classList.remove("datatable-cell-selected-locked")
                    selectedCell.blur()
                    selectedCell.removeAttribute("tabindex")
                    selectedCell.onmouseleave = null
                }
            }
        }

        // Sync horizontal scrolling between body and header
        this.datatableBody.onscroll = () => {
            this.datatableHeader.scrollLeft = this.datatableBody.scrollLeft
        }

        /*
         * VIRTUAL SCROLLING MANAGEMENT
         */

        //
        // Observe mousewheel event to scroll
        //
        this.onmousewheel = this.onwheel = (event) => {
            // Scroll must happen inside the datatable body
            if (!event.target.closest(".datatable-body-container")) return

            if (event.wheelDelta > 0) {
                this._virtualScrollUp()
            } else {
                this._virtualScrollDown()
            }

            // Update pager
            this._renderPagerIndex()
        }

        //
        // Observe touchmove event to scroll
        // TODO: prevent pull-to-refresh
        // TODO: allow smooth vertical & horizontal scroll
        //
        // this.ontouchstart = (e) => {
        //     this.startTouchY = e.touches[0].clientY
        // }

        // this.ontouchmove = (e) => {
        //     let currentY = e.changedTouches[0].clientY
        //     let deltaY = currentY - this.startTouchY

        //     if (deltaY > 0) {
        //         if (deltaY % 5 == 0) {
        //             e.preventDefault()
        //             this._virtualScrollUp()
        //         }
        //     } else if (deltaY < 0) {
        //         if (deltaY % 5 == 0) {
        //             e.preventDefault()
        //             this._virtualScrollDown()
        //         }
        //     }
        // }

        //
        // Enable onscroll event when clicking on the virtual scrollbar
        //
        this.datatableScrollerContainer.onmousedown = (event) => {
            this.preventScroll = false
        }

        //
        // Render the datatable at the correct row index when moving the virtual scrollbar
        //
        this.datatableScrollerContainer.onscroll = (event) => {
            if (this.preventScroll == true) return false

            // Clear our timeout throughout the scroll
            window.clearTimeout(this.isScrolling)

            // Set a timeout to run after scrolling ends, in order to smooth the rendering
            this.isScrolling = null

            this.isScrolling = setTimeout(() => {
                // Compute the scroll as a percentage of the total height
                let percent = event.target.scrollTop / (this.datatableScroller.offsetHeight - this.datatableBody.offsetHeight)

                // Deduce how many records to skip
                let recordIndex = Math.round((this.collection.count - this.limit) * percent)
                let newSkip = Math.min(recordIndex, this.collection.records.length - this.limit)

                // Re-render the datatable if the skip value has changed
                if (newSkip != this.skip) {
                    this.skip = Math.max(newSkip, 0)
                    this._render()
                }
            }, 10)
        }

        return this
    }

    /**
     * Initialize the copy to clipboard feature.
     * Allow to select a range of cells and copy their content to the clipboard.
     * 
     * @private
     * @ignore
     */
    _initCellsCopyToClipboard() {
        if (!this.canSelect) return
        
        const _this = this
        this.isSelecting = false
        this.isDrag = false
        this.startCell = null
        this.endCell = null
        this.selectedCells = []
        this.isScrolling = false
        this.scrollInterval = null

        this.datatableBody.onmousedown = (event) => {
            const clickedElement = event.target
            const clickedCell = clickedElement.closest(".datatable-cell")
            this.startCell = clickedCell

            if (clickedCell) {
                this.isSelecting = true
                this.isDrag = false
                this.selectedCells = [clickedCell]
                this.startCellData = {
                    rowIndex: this._cellGetRowIndex(clickedCell),
                    colIndex: this._cellGetColIndex(clickedCell)
                }
            }
        }

        this.datatableBody.onmouseover = (event) => {
            const HORIZONTAL_SCROLLZONE = 200
            const TOP_SCROLLZONE = 40
            const BOTTOM_SCROLLZONE = 80

            if (this.isSelecting) {
                this.isDrag = true
                const hoveredCell = event.target.closest(".datatable-cell")
                if (hoveredCell) {
                    this.endCell = hoveredCell
                    this.endCellData = {
                        rowIndex: this._cellGetRowIndex(hoveredCell),
                        colIndex: this._cellGetColIndex(hoveredCell)
                    }

                    this.selectedCells.forEach(cell => cell.classList.remove("datatable-cell-copied"))
                    this.selectedCells = _this._getCellsInRange(this.startCell, this.endCell)
                    this.selectedCells.forEach(cell => cell.classList.add("datatable-cell-copied"))
                }

                // Scroll if the mouse is near the limits of the datatable
                const datatableBounds = this.datatableBody.getBoundingClientRect()
                const mouseX = event.clientX
                const mouseY = event.clientY
        
                // right
                if ((mouseX > datatableBounds.right - HORIZONTAL_SCROLLZONE) && (mouseX < datatableBounds.right)) {
                    this._startHorizontalScrolling("right")
                }
                // left
                else if ((mouseX < datatableBounds.left + HORIZONTAL_SCROLLZONE) && (mouseX > datatableBounds.left)) {
                    this._startHorizontalScrolling("left")
                }
                // up
                else if ((mouseY < datatableBounds.top + TOP_SCROLLZONE) && (mouseY > datatableBounds.top)) {
                    this._startVerticalScrolling("up")
                }
                // down
                else if ((mouseY > datatableBounds.bottom - BOTTOM_SCROLLZONE) && (mouseY < datatableBounds.bottom)) {
                    this._startVerticalScrolling("down")
                }
                else {
                    this._stopHorizontalScrolling()
                }
            }
        }

        this.datatableBody.onmouseup = () => {
            this._stopHorizontalScrolling()

            if (this.isSelecting) {
                this.isSelecting = false

                if (this.isDrag) {
                    this._copySelectedCellsDataToClipboard()
                    this.selectedCells.forEach(cell => cell.classList.remove("datatable-cell-copied"))
                }
            }
        }

        this.datatableBody.onmouseleave = () => {
            this._stopHorizontalScrolling()

            if (this.isSelecting) {
                this.isSelecting = false

                if (this.isDrag) {
                    this._copySelectedCellsDataToClipboard()
                    this.selectedCells.forEach(cell => cell.classList.remove("datatable-cell-copied"))
                }
            }
        }
    }

    /**
     * Scroll horizontally when the mouse is near the limits of the datatable
     * 
     * @private
     * @ignore
     */
    _startHorizontalScrolling(direction) {
        if (this.isScrolling) return
        this.isScrolling = true
    
        this.scrollInterval = setInterval(() => {
            if (direction === "right") {
                this.datatableBody.scrollLeft += 10
            } else if (direction === "left") {
                this.datatableBody.scrollLeft -= 10
            }
        }, 10)
    }
    
    /**
     * Stop the horizontal scrolling
     * 
     * @private
     * @ignore
     */
    _stopHorizontalScrolling() {
        this.isScrolling = false
        clearInterval(this.scrollInterval)
    }
    
    /**
     * Scroll vertically when the mouse is near the limits of the datatable
     * 
     * @private
     * @ignore
     */
    _startVerticalScrolling(direction) {
        if (this.isScrolling) return
        this.isScrolling = true
    
        this.scrollInterval = setInterval(() => {
            if (direction === "up") {
                this._virtualScrollUp()
            } else if (direction === "down") {
                this._virtualScrollDown()
            }
        }, 30)
    }

    /**
     * Initialize subscriptions to PubSub
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initSubscriptions() {
        super._initSubscriptions()

        const viewModelId = this.modelId.toUpperCase()

        // React to database mutations
        this.subscriptions = this.subscriptions.concat([
            subscribe("EVT_DB_INSERT:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData)),
            subscribe("EVT_DB_UPDATE:" + viewModelId, (msgData) => this._updateOneAndReload(msgData)),
            subscribe("EVT_DB_DELETE:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData)),
            subscribe("EVT_DB_INSERT_MANY:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData, 2000)),
            subscribe("EVT_DB_UPDATE_MANY:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData, 2000)),
            subscribe("EVT_DB_DELETE_MANY:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData, 2000)),
            subscribe("EVT_DB_UPDATE_BULK", (msgData) => this._updateManyAndReload(msgData))
        ])

        return this
    }

    /**
     * Update a single record then reload the view if required
     * 
     * @private
     * @ignore
     * @param {object} msgData - The original pubsub message
     */
    async _updateOneAndReload(msgData) {
        const sortFields = this.sort.map(sort => Object.keys(sort)[0])
        const filterFields = kiss.db.mongo.getFilterFields(this.filter)

        let groupHasChanged = false
        let sortHasChanged = false
        let filterHasChanged = false

        let updates = msgData.data
        for (let fieldId of Object.keys(updates)) {
            if (this.group.indexOf(fieldId) != -1) groupHasChanged = true
            if (sortFields.indexOf(fieldId) != -1) sortHasChanged = true
            if (filterFields.indexOf(fieldId) != -1) filterHasChanged = true

            let newValue = updates[fieldId]
            this._cellSetValue(msgData.id, fieldId, newValue)
        }

        if (sortHasChanged || filterHasChanged || groupHasChanged) {
            this._reloadWhenNeeded(msgData)
        }
    }

    /**
     * Update multiple records then reload the view
     * 
     * @private
     * @ignore
     * @param {object} msgData - The original pubsub message
     */
    async _updateManyAndReload(msgData) {
        const sortFields = this.sort.map(sort => Object.keys(sort)[0])
        const filterFields = kiss.db.mongo.getFilterFields(this.filter)

        let groupHasChanged = false
        let sortHasChanged = false
        let filterHasChanged = false

        let operations = msgData.data
        operations.forEach(operation => {
            if (operation.modelId == this.modelId) {
                for (let fieldId of Object.keys(operation.updates)) {
                    if (this.group.indexOf(fieldId) != -1) groupHasChanged = true
                    if (sortFields.indexOf(fieldId) != -1) sortHasChanged = true
                    if (filterFields.indexOf(fieldId) != -1) filterHasChanged = true

                    let newValue = operation.updates[fieldId]
                    this._cellSetValue(operation.recordId, fieldId, newValue)
                }
            }
        })

        if (sortHasChanged || filterHasChanged || groupHasChanged) {
            this._reloadWhenNeeded(msgData)
        }
    }

    /**
     * Re-render the virtual scrollbar when the datatable is re-connected to the DOM
     * 
     * @private
     * @ignore
     */
    _afterConnected() {
        super._afterConnected()
        this._hideScroller()
        this._renderScroller()
    }

    /**
     * Initialize the default width in rem, which depend on the field type
     * 
     * @private
     * @ignore
     * @eturns this
     */
    _initColumnsDefaultWidth() {
        this.defaultColumnWidth = {
            text: 18,
            number: 18,
            date: 18,
            select: 18,
            textarea: 35,
            checkbox: 10,
            color: 10,
            icon: 10,
            attachment: 15,
            directory: 20,
            firstColumn: (kiss.screen.isMobile) ? 5 : 9,
            default: 18
        }
        return this
    }

    /**
     * Scroll up by one line with the virtual scroller
     * Remove the last row and insert a new one at the beginning
     * 
     * @private
     * @ignore
     */
    _virtualScrollUp() {
        if ((this.skip - 1) < 0) return
        this.skip -= 1
        this.lastIndex = Math.min(this.skip + this.limit - 1, this.collection.records.length)

        this.datatableBody.lastChild.remove()
        this.datatableBody.insertBefore(this._renderRowDiv(this.skip), this.datatableBody.children[0])

        this.datatableBody1stColumn.lastChild.remove()
        this.datatableBody1stColumn.insertBefore(this._renderRowDiv1stColumn(this.skip), this.datatableBody1stColumn.children[0])

        // Sync the virtual scrollbar position
        this._renderScrollerPosition()
    }

    /**
     * Scroll up by one line with the virtual scroller
     * Remove the last row and insert a new one at the beginning
     * 
     * @private
     * @ignore
     */
    _virtualScrollDown() {
        if ((this.lastIndex + 1) >= this.collection.records.length) return
        this.skip += 1
        this.lastIndex = Math.min(this.skip + this.limit - 1, this.collection.records.length)

        this.datatableBody.children[0].remove()
        this.datatableBody.appendChild(this._renderRowDiv(this.lastIndex))

        this.datatableBody1stColumn.children[0].remove()
        this.datatableBody1stColumn.appendChild(this._renderRowDiv1stColumn(this.lastIndex))

        // Sync the virtual scrollbar position
        this._renderScrollerPosition()
    }

    /**
     * Open the column menu to:
     * - sort asc | desc
     * - edit field properties
     * 
     * @private
     * @ignore
     * @param {string} fieldId
     * @param {object} columnMenu - The menu HTMLElement
     * @param {object} event - The original event that opened the column menu
     */
    _showColumnMenu(fieldId, columnMenu, event) {
        const field = this.model.getField(fieldId)
        const column = this.columns.find(column => column.id == fieldId)
        const isGrouped = this.group.length > 0
        const colorableFields = ["text", "textarea", "number", "date"]
        const isColorable = colorableFields.includes(field.type) || (field.type == "lookup" && colorableFields.includes(field.lookup.type)) || (field.type == "summary" && colorableFields.includes(field.summary.type))
        const isNumeric = kiss.tools.isNumericField(field)
        const canBeAggregated = isNumeric && isGrouped

        // Action
        let columnActions = [
            // Sort ASC
            {
                icon: "fas fa-arrow-up",
                text: txtTitleCase("sort ascending"),
                action: async () => {
                    await this.sortByField(fieldId, "asc")
                    this.showSortWindow()
                }
            },
            // Sort DESC
            {
                icon: "fas fa-arrow-down",
                text: txtTitleCase("sort descending"),
                action: async () => {
                    await this.sortByField(fieldId, "desc")
                    this.showSortWindow()
                }
            },
            (this.canEditField && isColorable) ? "-" : "",
            // Column color
            {
                hidden: !isColorable,
                icon: "fas fa-palette",
                text: txtTitleCase("column color"),
                action: async () => {
                    this.showColorWindow(column)
                }
            },
            // Remove column color
            {
                hidden: !this.canEditField || !isColorable,
                icon: "fas fa-times",
                text: txtTitleCase("remove color"),
                action: async () => {
                    if (!column.color) return
                    delete column.color
                    this._render()
                    this.updateConfig({
                        config: {
                            columns: this.columns
                        }
                    })
                }
            }
        ]

        // Actions for the field: edit / delete
        if (this.canEditField && !field.isFromPlugin && !field.isSystem) {

            // Separator
            columnActions.splice(0, 0, "-")

            // Delete the field
            if (!field.primary) {
                columnActions.splice(0, 0, {
                    icon: "fas fa-trash",
                    iconColor: "var(--red)",
                    text: txtTitleCase("delete this field"),
                    action: () => {
                        // Open a confirmation window to delete the field
                        const deleteDialog = createDialog({
                            type: "danger",
                            title: txtTitleCase("delete a field"),
                            message: txtTitleCase("#delete field warning"),
                            buttonOKPosition: "left",
                            action: async () => {
                                this.model.deleteField(fieldId)
                                deleteDialog.close()
                                this.reload()
                            }
                        })
                    }
                })
            }

            // Edit the field properties
            columnActions.splice(0, 0, {
                icon: "fas fa-edit",
                text: txtTitleCase("edit this field"),
                action: async () => this._showColumnSetup(fieldId)
            })
        }

        // Aggregation options
        if (canBeAggregated) {

            // Separator
            columnActions.push("-")

            // Sum
            columnActions.push({
                text: txtTitleCase("#summary sum"),
                icon: "fas fa-chart-bar",
                action: async () => {
                    column.summary = "sum"
                    this._render()
                    this.updateConfig({
                        config: {
                            columns: this.columns
                        }
                    })
                }
            })

            // Average
            columnActions.push({
                text: txtTitleCase("#summary avg"),
                icon: "fas fa-tachometer-alt",
                action: async () => {
                    column.summary = "avg"
                    this._render()
                    this.updateConfig({
                        config: {
                            columns: this.columns
                        }
                    })
                }
            })

            // No aggregation
            columnActions.push({
                text: txtTitleCase("#no summary"),
                icon: "fas fa-ban",
                action: async () => {
                    delete column.summary
                    this._render()
                    this.updateConfig({
                        config: {
                            columns: this.columns
                        }
                    })
                }
            })
        }

        createMenu({
            top: columnMenu.getBoundingClientRect().y - 10,
            left: columnMenu.getBoundingClientRect().x - 10,
            items: columnActions
        }).render()
    }

    /**
     * Set up a column (= opens the field property window)
     * 
     * @ignore
     * @param {string} [fieldId] - Field id to set up. Creates a new field if no param.
     */
    _showColumnSetup(fieldId) {
        kiss.context.dockFieldProperties = false

        kiss.router.updateUrlHash({
            fieldId: (fieldId) ? fieldId : ""
        })

        kiss.views.show("model-field")
    }

    /**
     * Adjust image thumbnail size according to the row height
     * 
     * @private
     * @ignore
     */
    _setThumbSize() {
        if (this.rowHeight <= this.defaultRowHeight) {
            this.thumbSize = "s"
        } else {
            this.thumbSize = "m"
        }
    }

    /**
     * 
     * SIZE MANAGEMENT
     * 
     */

    /**
     * Adjust the component width
     * 
     * @ignore
     * @param {(number|string|function)} [width] - The width to set
     */
    _setWidth() {
        let newWidth = this._computeSize("width")

        setTimeout(() => {
            this.style.width = newWidth
            this.datatable.style.width = this.clientWidth.toString() + "px"
        }, 50)
    }

    /**
     * Adjust the components height
     * 
     * @private
     * @ignore
     * @param {(number|string|function)} [height] - The height to set
     */
    _setHeight() {
        let newHeight = this._computeSize("height")
        this.style.height = this.datatable.style.height = newHeight
    }

    /**
     * Compute the maximum number of rows that can fit in the datatable, then set the "limit" param.
     * The limit depends on the global datatable height minus:
     * - the datatable toolbar
     * - the datatable header
     * 
     * @private
     * @ignore
     */
    _setLimit() {
        if (!this.isConnected) return

        let tableHeight = this.offsetHeight
        let headerHeight = $("datatable-header:" + this.id).offsetHeight
        let toolbarHeight = $("datatable-toolbar:" + this.id).offsetHeight
        let bodyHeight = tableHeight - toolbarHeight - headerHeight
        this.limit = Math.floor(bodyHeight / (kiss.tools.remToPx(this.rowHeight) + 1))
        if (kiss.screen.isMobile) this.limit = this.limit - 1 // Keep a margin for Mobile UI
    }

    /**
     * 
     * RENDERING THE TABLE
     * 
     */

    /**
     * Show N records, starting from the current position (given by the "skip" property)
     *
     * @private
     * @ignore
     * @param {number} size - Positive number for next page, and negative for previous page
     * 
     * @example
     * this._renderPage(-50)
     */
    _renderPage(size) {
        // If we've reach the beginning or the end of the recordset => exit!
        if ((size < 0 && this.skip == 0) || (size > 0) && ((this.skip + size) >= this.collection.count)) return

        // Update the number of records to skip
        this.skip = ((this.skip + 2 * size) >= this.collection.count) ? (this.skip = this.collection.count - size) : this.skip + size
        this.skip = Math.max(this.skip, 0)

        // Render
        this._render()

        // Adjust the virtual scroller position according to the new "skip" value
        this._renderScrollerPosition()
    }

    /**
     * Render the pagination index.
     * Display, for example: 0 - 50 / 1000
     * 
     * @private
     * @ignore
     */
    _renderPagerIndex() {
        if (!this.isConnected) return

        if (kiss.screen.isMobile && kiss.screen.isVertical()) {
            // Compact version for mobile phones
            $("pager-index:" + this.id).innerHTML = Math.min(this.collection.count, (this.skip + this.limit)) + " / " + this.collection.count
        } else {
            $("pager-index:" + this.id).innerHTML = (this.skip + 1) + " - " + Math.min(this.collection.count, (this.skip + this.limit)) + " / " + this.collection.count
        }
    }

    /**
     * Render the datatable
     * 
     * @private
     * @ignore
     * @returns this
     */
    _render() {
        // kiss.tools.timer.start()

        // Reset 1st column
        this.datatableHeader1stColumn.innerHTML = ""
        this.datatableBody1stColumn.innerHTML = ""

        // Filters out hidden and deleted columns
        this.visibleColumns = this.columns.filter(column => column.hidden != true && column.deleted != true)

        this._prepareCellRenderers()
            ._renderHeader()
            ._renderBody()

        // kiss.tools.timer.show("Datatable rendered!")
        return this
    }

    /**
     * Render the datatable header.
     * 
     * @private
     * @ignore
     * @returns this
     */
    _renderHeader() {
        // 1st column header
        let firstCell = document.createElement("div")
        firstCell.setAttribute("id", "header-1stColumn")
        firstCell.setAttribute("col", "-1")
        firstCell.classList.add("datatable-column-header", "datatable-column-header-1st")
        firstCell.style.width = firstCell.style.minWidth = this.defaultColumnWidth.firstColumn + "rem"
        firstCell.innerHTML =
            `<span id='toggle-selection' class='datatable-header-checkbox ${(this.canSelect) ? "datatable-header-checkbox-off" : ""}'></span>` + // Selection checkbox
            "<span id='header-resizer-1st-column' class='datatable-column-header-resizer'>&nbsp</span>" // Column resizer

        this.datatableHeader1stColumn.appendChild(firstCell)

        // Other columns headers
        this._columnsAdjustWidthFromLocalStorage()
        this.datatableHeader.innerHTML =
            this.visibleColumns.map(this._renderColumnHeader.bind(this)).join("") +
            `<span class="datatable-column-header datatable-header-last-column">${(this.canAddField) ? `<span class="fas fa-plus"></span>` : ""}</span>` // Button to create a new column

        return this
    }

    /**
     * Render the datatable body
     * 
     * Tech note: we don't use string litterals to build the HTML because it's slower than native String concatenation
     * 
     * @private
     * @ignore
     * @returns this
     */
    _renderBody() {
        // Adjust sizes
        this._initRowHeight()
        this._columnsSetFirstColumnWidth(this.defaultColumnWidth.firstColumn)

        // Build table BODY
        let table = ""
        let firstColumn = ""
        this.startIndex = Math.max(0, this.skip)
        this.lastIndex = Math.min(this.skip + this.limit, this.collection.records.length)

        if (this.collection.group.length === 0) {
            // Rendering without grouping
            for (let rowIndex = this.startIndex; rowIndex < this.lastIndex; rowIndex++) {
                let record = this.collection.records[rowIndex]

                firstColumn += "<div col=\"-1\" row=\"" + rowIndex + "\" recordId=\"" + record.id + "\" class=\"datatable-cell-1st\" style=\"width: " + this.defaultColumnWidth.firstColumn + "rem; min-width: " + this.defaultColumnWidth.firstColumn + "rem\">"
                firstColumn += this._renderRowContent1stColumn(record, rowIndex)
                firstColumn += "</div>"

                table += "<div row=\"" + rowIndex + "\" recordId=\"" + record.id + "\" class=\"datatable-row\">"
                table += this._renderRowContent(record, rowIndex)
                table += "</div>"
            }
        } else {
            // Rendering with grouping
            let nbOfRows = 0

            for (let rowIndex = this.skip;
                (nbOfRows < this.limit) && (rowIndex < this.collection.records.length); rowIndex++) {
                let record = this.collection.records[rowIndex]

                if (record.$type == "group") {
                    firstColumn += "<div col=\"-1\" row=\"" + rowIndex + "\" class=\"datatable-group datatable-group-level-" + record.$groupLevel + "\" style=\"width: " + this.defaultColumnWidth.firstColumn + "rem; min-width: " + this.defaultColumnWidth.firstColumn + "rem\">"
                    firstColumn += this._renderRowGroupContent1stColumn(record)
                    firstColumn += "</div>"

                    table += "<div row=\"" + rowIndex + "\" groupLevel=\"" + record.$groupLevel + "\" class=\"datatable-group-row\">"
                    table += this._renderRowGroupContent(record)
                    table += "</div>"
                } else {
                    firstColumn += "<div col=\"-1\" row=\"" + rowIndex + "\" recordId=\"" + record.id + "\" class=\"datatable-cell-1st\" style=\"width: " + this.defaultColumnWidth.firstColumn + "rem; min-width: " + this.defaultColumnWidth.firstColumn + "rem\">"
                    firstColumn += this._renderRowContent1stColumn(record, rowIndex)
                    firstColumn += "</div>"

                    table += "<div row=\"" + rowIndex + "\" recordId=\"" + record.id + "\" class=\"datatable-row\">"
                    table += this._renderRowContent(record, rowIndex)
                    table += "</div>"
                }
                nbOfRows++
            }
        }

        // Inject the table into the DOM
        this.datatableBody.innerHTML = table

        // Inject the table 1st column into the DOM
        this.datatableBody1stColumn.innerHTML = firstColumn

        // Update the pager index
        this._renderPagerIndex()

        // Highlight the selected rows
        this._renderSelection()

        // Add the virtual scroller
        this._renderScroller()

        // Show / hide empty icon
        this._renderEmptyIcon()

        return this
    }

    /**
     * Show an "empty" icon if there are no records to render
     * 
     * @private
     * @ignore
     */
    _renderEmptyIcon() {
        if (this.collection.records.length == "0") {
            this.datatableBodyContainer.classList.add("datatable-body-container-empty")
        } else {
            this.datatableBodyContainer.classList.remove("datatable-body-container-empty")
        }
    }

    /**
     * Render a single row of the datatable
     * 
     * @private
     * @ignore
     * @param {number} rowIndex
     * @returns {HTMLDivElement} The div containing the row
     */
    _renderRowDiv(rowIndex) {
        let record = this.collection.records[rowIndex]

        // Fork if it's a grouping row
        if (record.$type == "group") return this._renderRowGroupDiv(record, rowIndex)

        // Build the div
        let newRow = document.createElement("div")
        newRow.setAttribute("row", rowIndex)
        newRow.setAttribute("recordid", record.id)
        newRow.classList.add("datatable-row")

        // Apply the style "selected" if the row has been selected
        // TODO: optimization => apply the "selected" style for all selected rows *after* the datatable has been fully rendered
        let isSelected = !(this.selectedRecords.indexOf(record.id) == -1)
        if (isSelected) newRow.classList.add("datatable-row-selected")

        // Inject row content (= cells) into the div
        newRow.innerHTML = this._renderRowContent(record, rowIndex)
        return newRow
    }

    /**
     * Render the 1st cell of a single row of the datatable
     * 
     * @private
     * @ignore
     * @param {number} rowIndex
     * @returns {HTMLDivElement} The div containing the cell
     */
    _renderRowDiv1stColumn(rowIndex) {
        let record = this.collection.records[rowIndex]

        // Fork if it's a grouping row
        if (record.$type == "group") return this._renderRowGroupDiv1stColumn(record, rowIndex)

        let firstCell = document.createElement("div")
        firstCell.setAttribute("col", "-1")
        firstCell.setAttribute("row", rowIndex)
        firstCell.setAttribute("recordid", record.id)
        firstCell.classList.add("datatable-cell-1st")
        firstCell.style.width = firstCell.style.minWidth = this.defaultColumnWidth.firstColumn + "rem"

        // Apply the style "selected" if the row has been selected
        // TODO: possible optimization => apply the "selected" style for all selected rows *after* the datatable has been fully rendered
        let isSelected = !(this.selectedRecords.indexOf(record.id) == -1)

        firstCell.innerHTML = this._renderRowContent1stColumn(record, rowIndex, isSelected)
        return firstCell
    }

    /**
     * Render the content of a single row of the datatable.
     * 
     * @private
     * @ignore
     * @param {number} record - The record to render in this row
     * @param {number} rowIndex
     * @returns {string} Html source for a row
     */
    _renderRowContent(record, rowIndex) {
        let row = ""
        for (let colIndex = 0, length = this.visibleColumns.length; colIndex < length; colIndex++) {
            let column = this.visibleColumns[colIndex]
            let value = column.renderer({
                value: record[column.id],
                record,
                config: {
                    rowIndex,
                    colIndex,
                    thumbSize: this.thumbSize
                }
            })
            row += `<div col=${colIndex} class="datatable-cell datatable-type-${column.type}" style="${this._columnsConvertWidthToStyle(column.width)}; ${(column.color) ? `color: ${column.color}` : ""}">` + value + "</div>"
        }

        row += "<div class='datatable-cell datatable-cell-blank'></div>"
        return row
    }

    /**
     * Render the content of the 1st cell of a single row of the datatable.
     * 
     * The 1st cell of the row includes:
     * - a selection checkbox
     * - the row number
     * - a button to expand the record and see it in a form
     * 
     * @private
     * @ignore
     * @param {number} record - The record to render in this row
     * @param {number} rowIndex
     * @param {boolean} [isSelected] - If true, render the row with its "selected" appearence
     * @returns {string} Html source for a row
     */
    _renderRowContent1stColumn(record, rowIndex, isSelected) {
        return ((this.canSelect) ? "<span class=\"datatable-row-checkbox datatable-row-checkbox-" + ((isSelected) ? "on" : "off") + "\"></span>" : "") + // Selection checkbox
            "<span class=\"datatable-row-number\">" + ((record.$index + 1) || Number(rowIndex + 1)) + "</span>" + // Row number
            "<span class=\"datatable-row-action " + this.iconAction + "\"></span>" // Row action button
    }

    /**
     * Render a single *group* row of the datatable.
     * 
     * @private
     * @ignore
     * @param {object} record
     * @param {number} rowIndex 
     */
    _renderRowGroupDiv(record, rowIndex) {
        let newRow = document.createElement("div")
        newRow.setAttribute("row", rowIndex)
        newRow.classList.add("datatable-group-row")
        newRow.innerHTML = this._renderRowGroupContent(record)
        return newRow
    }

    /**
     * Render the first cell of a single *group* row of the datatable.
     * 
     * @private
     * @ignore
     * @param {object} record
     * @param {number} rowIndex 
     */
    _renderRowGroupDiv1stColumn(record, rowIndex) {
        let firstCell = document.createElement("div")
        firstCell.setAttribute("col", "-1")
        firstCell.setAttribute("row", rowIndex)
        firstCell.classList.add("datatable-group", "datatable-group-level-" + record.$groupLevel)
        firstCell.style.width = firstCell.style.minWidth = this.defaultColumnWidth.firstColumn + "rem"
        firstCell.innerHTML = this._renderRowGroupContent1stColumn(record)
        return firstCell
    }

    /**
     * Render the content of a single *group* row of the datatable.
     * 
     * @private
     * @ignore
     * @param {object} record 
     * @returns {string} Html source for a *group* row
     */
    _renderRowGroupContent(record) {
        let row = ""
        for (let colIndex = 0, length = this.visibleColumns.length; colIndex < length; colIndex++) {
            const column = this.visibleColumns[colIndex]
            const field = this.model.getField(column.id)
            const precision = (field && field.precision) || 0
            const unit = (field && field.unit) || ""

            let cellRawValue = record[column.id]

            if (cellRawValue !== undefined) {
                const aggregationType = column.summary || "summary"
                const aggregationSettings = `<span class='fas fa-caret-down datatable-group-summary'><span>${txtTitleCase("#" + aggregationType)}</span></span>`
                cellRawValue = (aggregationType != "summary") ? cellRawValue[aggregationType].format(precision) + " " + unit : " "
                row += "<div col=\"" + colIndex + "\" class=\"datatable-group-cell\" style=\"" + this._columnsConvertWidthToStyle(column.width) + "\">" + aggregationSettings + cellRawValue + "</div>"
            } else {
                row += "<div col=\"" + colIndex + "\" class=\"datatable-group-cell\" style=\"" + this._columnsConvertWidthToStyle(column.width) + "\"></div>"
            }
        }

        row += "<div class='datatable-cell datatable-cell-blank'></div>"
        return row
    }

    /**
     * Render the content of the 1st cell of a single *group* row of the datatable.
     * 
     * @private
     * @ignore
     * @param {object} record 
     * @returns {string} Html source for a *group* row
     */
    _renderRowGroupContent1stColumn(record) {
        // Get group field
        let groupFieldId = this.collection.group[record.$groupLevel]
        let groupColumn = this.getColumn(groupFieldId)

        // Check if it's a collapsed group
        let groupClass = (this.collection.collapsedGroups.includes(record.$groupId)) ? "datatable-group-collapsed" : "datatable-group-expanded"

        // The 1st cell of the row includes:
        // - an icon to expand/collapse the group
        // - the group hierarchy (ex: 1.3.7)
        // - the group name
        let groupRawValue = record.$name
        let groupCellValue = (groupColumn) ? groupColumn.renderer({
            value: groupRawValue,
            record,
            config: {
                thumbSize: this.thumbSize
            }
        }) : "..."

        return "<span class='" + groupClass + "'></span>" + // Icon to expand/collapse the group
            ((this.showGroupHierarchy) ? "<span class='datatable-group-hierarchy'>" + record.$groupId + "</span>" : "") + // Group hierarchy
            groupCellValue + "&nbsp;&nbsp;(" + record.$size + ")" // Group name
    }

    /**
     * Render a single column header.
     * 
     * @private
     * @ignore
     * @param {object} column - The column config
     * @param {number} index - The column index
     * @returns {string} Html source for a column header
     */
    _renderColumnHeader(column, index) {
        // Try to get local column config from localStorage, in case it exists
        let localColumnWidthStyle = this._columnsConvertWidthToStyle(column.width)
        let localColumnTitleWidthStyle = this._columnsConvertWidthToStyle(column.width - this.resizerWidth)

        // Try to get column type icon
        let columnTitle = column.title
        if (this.showColumnType) {
            const fieldType = kiss.global.fieldTypes.find(fieldType => fieldType.value == column.type)
            const icon = (fieldType) ? fieldType.icon : ""
            if (icon) columnTitle = `<i class="${icon} datatable-column-header-icon"></i>${column.title}`
        }

        // Build the final template for the column header
        return /*html*/ `<div id="header-${column.id}" col="${index}" class="datatable-column-header" style="${localColumnWidthStyle}">
                    <span
                        id="header-title-${column.id}"
                        class="datatable-column-header-title"
                        draggable="true"
                        ondragstart="this.closest('a-datatable')._columnsMoveWithdragAndDrop('dragstart', event, this)"
                        ondragover="this.closest('a-datatable')._columnsMoveWithdragAndDrop('dragover', event, this)"
                        ondragleave="this.closest('a-datatable')._columnsMoveWithdragAndDrop('dragleave', event, this)"
                        ondrop="this.closest('a-datatable')._columnsMoveWithdragAndDrop('drop', event, this)"
                        style="${localColumnTitleWidthStyle}"
                    >
                    ${columnTitle}
                    </span>
                    <span id="header-properties-for:${column.id}" class="datatable-column-header-properties fas fa-chevron-down">&nbsp</span>
                    <span id="header-resizer-for:${column.id}" class="datatable-column-header-resizer">&nbsp</span>
                </div>`.removeExtraSpaces()
    }

    /**
     * Prepare renderers for special column types:
     * - number
     * - date
     * - textarea
     * - ...
     * 
     * @private
     * @ignore
     * @returns this
     */
    _prepareCellRenderers() {
        this.columns.forEach(column => {
            if (column.renderer) return

            switch (column.type) {
                case "number":
                case "date":
                case "textarea":
                case "aiTextarea":
                case "richTextField":
                case "select":
                case "directory":
                case "checkbox":
                case "slider":
                case "rating":
                case "color":
                case "icon":
                case "attachment":
                case "aiImage":
                case "selectViewColumn":
                case "password":
                case "link":
                    column.renderer = kiss.fields.renderers[this.model.id][column.id]
                    break
                case "button":
                    column.renderer = this._prepareCellRendererForButtons(column)
                    break
                default:
                    column.renderer = kiss.fields.defaultRenderer
            }
        })

        return this
    }

    /**
     * Define the column renderer for fields which type is "button"
     * 
     * @private
     * @ignore
     */
    _prepareCellRendererForButtons(column) {
        // Normalize column ids
        let colIndex = "column_" + kiss.tools.shortUid()
        if (!column.id) column.id = colIndex

        // Normalize column titles to a string
        column.title = column.text || txtTitleCase("action")

        return function ({
            record,
            config
        }) {
            return `
                <center>
                    <span id="column-button-${config.rowIndex}-${config.colIndex}" class="a-button datatable-cell-button" ${(column.button.tip) ? `onmouseover="this.attachTip('${column.button.tip}')"` : ""} onclick="this.getComponent()._rowTriggerButtonAction('${config.rowIndex}', '${column.id}', '${record.id}')">
                        ${ (column.button.icon) ? `<span class="button-icon ${column.button.icon}"></span>` : "" }
                        ${ (column.button.text) ? `<span class="button-text">${column.button.text}</span>` : "" }
                    </span>
                </center>`.removeExtraSpaces()
        }
    }

    /**
     * Preview an attachment
     * 
     * @private
     * @ignore
     * @param {object} event 
     * @param {string} fieldId 
     */
    _cellPreviewAttachment(event, fieldId) {
        const attachmentId = event.target.id
        const cell = event.target.closest(".datatable-cell")
        const record = this._cellGetRecord(cell)
        const cellAttachments = record[fieldId]
        createPreviewWindow(cellAttachments, attachmentId)
    }

    /**
     * Render the virtual scrollbar
     * 
     * @private
     * @ignore
     */
    _renderScroller() {
        // getBoundingClientRect is a bit behind the dom rendering
        setTimeout(() => {
            this.datatableScrollerContainer.style.top = kiss.tools.pxToRem(this.datatableBody.getBoundingClientRect().top) + "rem"
            this.datatableScrollerContainer.style.left = kiss.tools.pxToRem(this.getBoundingClientRect().right - this.datatableScrollerContainer.offsetWidth) + "rem"
            this._showScroller()
        }, 50)

        // Set the virtual scrollbar height within the container.
        // Setting it bigger than the container forces the browser to generate a real scrollbar.
        this.datatableScrollerContainer.style.height = kiss.tools.pxToRem(this.datatableBody.offsetHeight - 10) + "rem"
        this.datatableScroller.style.height = Math.min(this.collection.count * (this.rowHeight), 10000) + "rem"
    }

    /**
     * Show the virtual scroller
     * 
     * @private
     * @ignore
     */
    _showScroller() {
        if (this.showScroller !== false) {
            setTimeout(() => {
                this.datatableScrollerContainer.style.visibility = "visible"
            }, 0)
        }
    }

    /**
     * Hide the virtual scroller
     * 
     * @private
     * @ignore
     */
    _hideScroller() {
        this.datatableScrollerContainer.style.visibility = "hidden"
    }

    /**
     * Sync the virtual scrollbar position with the current datatable "skip" value
     * 
     * @private
     * @ignore
     */
    _renderScrollerPosition() {
        let percent = this.skip / (this.collection.records.length - this.limit)
        let topPosition = Math.round((this.datatableScroller.offsetHeight - this.datatableBody.offsetHeight) * percent)
        this.preventScroll = true // Disable onscroll event to avoid echo
        this.datatableScrollerContainer.scrollTop = topPosition
    }

    /**
     * Highlight the records that are selected in the rendered page
     * 
     * @private
     * @ignore
     */
    _renderSelection() {
        if (!this.selectedRecords) return

        this.selectedRecords.forEach(recordId => {
            let rowIndexes = this._rowGetAllIndexes(recordId)
            rowIndexes.forEach(rowIndex => this._rowSelect(rowIndex))
        })
    }

    /**
     * Restore the selection of the rendered page.
     * First clean the existing selection that might be obsolete,
     * then add the active selection.
     * 
     * @private
     * @ignore
     */
    _renderSelectionRestore() {
        this.getSelection()
        this._renderBody()
    }

    /**
     * Render the toolbar
     * 
     * @private
     * @ignore
     */
    _renderToolbar() {

        // If the toolbar is already rendered, we just update it
        if (this.isToolbarRendered) {
            this._groupUpdateGroupingFields()
            return
        }

        // New record creation button
        createButton({
            hidden: !this.canCreateRecord,
            class: "datatable-create-record",
            target: "create:" + this.id,
            text: this.config.createRecordText || this.model.name.toTitleCase(),
            icon: "fas fa-plus",
            iconColor: this.color,
            borderWidth: "0.3rem",
            borderRadius: "3.2rem",
            maxWidth: (kiss.screen.isMobile && kiss.screen.isVertical()) ? "16rem" : null,
            action: async () => this.createRecord(this.model)
        }).render()

        // Actions button
        createButton({
            hidden: this.showActions === false,
            target: "actions:" + this.id,
            tip: txtTitleCase("actions"),
            icon: "fas fa-bolt",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this._buildActionMenu()
        }).render()

        // Column selection button
        createButton({
            hidden: !this.canSelectFields,
            target: "select:" + this.id,
            tip: txtTitleCase("#display fields"),
            icon: "fas fa-bars fa-rotate-90",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this.showFieldsWindow()
        }).render()

        // Sorting button
        createButton({
            hidden: !this.canSort,
            target: "sort:" + this.id,
            tip: txtTitleCase("to sort"),
            icon: "fas fa-sort",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this.showSortWindow()
        }).render()

        // Filtering button
        createButton({
            hidden: !this.canFilter,
            target: "filter:" + this.id,
            tip: txtTitleCase("to filter"),
            icon: "fas fa-filter",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this.showFilterWindow()
        }).render()

        // Layout button
        createButton({
            hidden: !this.showLayoutButton,
            target: "layout:" + this.id,
            tip: {
                text: txtTitleCase("layout"),
                minWidth: "10rem"
            },
            icon: "fas fa-ellipsis-v",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this._buildLayoutMenu()
        }).render()

        // Column creation button
        createButton({
            hidden: !this.canAddField,
            target: "add:" + this.id,
            tip: txtTitleCase("add a column"),
            icon: "fas fa-plus",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this._showColumnSetup()
        }).render()

        // Grouping
        let groupingFields = this._groupGetModelFields()
        let groupingFieldValues = []

        this.collection.group.forEach(fieldId => {
            let groupingField = groupingFields.find(field => field.value == fieldId)
            if (groupingField) groupingFieldValues.push(groupingField.value)
        })

        createSelect({
            hidden: !this.canGroup,
            target: "group:" + this.id,
            id: "grouping-field:" + this.id,
            label: txtTitleCase("group by"),
            multiple: true,
            allowClickToDelete: true,
            options: groupingFields,
            minWidth: "20rem",
            maxHeight: () => kiss.screen.current.height - 200,
            optionsColor: this.color,
            value: groupingFieldValues,
            styles: {
                "this": "align-items: center;",
                "field-label": "white-space: nowrap;",
                "field-select": "white-space: nowrap;",
            },
            events: {
                change: async function (event) {
                    let groupFields = this.getValue()

                    // Restrict to 6 grouping fields
                    if (groupFields.length > 6) {
                        let fieldGroupSelect = $(this.id)
                        fieldGroupSelect.value = fieldGroupSelect.getValue().slice(0, 6)
                        fieldGroupSelect._renderValues()

                        createDialog({
                            type: "message",
                            title: txtTitleCase("seriously"),
                            icon: "fas fa-exclamation-triangle",
                            message: txtTitleCase("#too many groups"),
                            buttonOKText: txtTitleCase("#understood")
                        })
                        return
                    }

                    // Publish the "grouping" event
                    let viewId = this.id.split(":")[1]
                    publish("EVT_VIEW_GROUPING:" + viewId, groupFields)
                }
            }
        }).render()

        // Expand button
        this.buttonExpand = createButton({
            hidden: (!this.showGroupButtons || this.collection.group.length === 0),

            target: "expand:" + this.id,
            tip: txtTitleCase("expand all"),
            icon: "far fa-plus-square",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this.expandAll()
        }).render()

        // Collapse button
        this.buttonCollapse = createButton({
            hidden: (!this.showGroupButtons || this.collection.group.length === 0),

            target: "collapse:" + this.id,
            tip: txtTitleCase("collapse all"),
            icon: "far fa-minus-square",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this.collapseAll()
        }).render()

        // View refresh button
        if (!kiss.screen.isMobile) {
            createButton({
                target: "refresh:" + this.id,
                tip: txtTitleCase("refresh"),
                icon: "fas fa-undo-alt",
                iconColor: this.color,
                width: "3.2rem",
                events: {
                    click: () => this.reload()
                }
            }).render()
        }

        // Button to switch the hierarchy numbers
        // TODO: disabled at the moment: move the button to the setup menu
        this.buttonShowHierarchy = createCheckbox({
            hidden: true,
            // hidden: (this.collection.group.length === 0) || (this.showGroupHierarchy === false),

            target: "hierarchy:" + this.id,
            tip: txtTitleCase("show group hierarchy"),
            iconOff: "fas fa-list-ol",
            iconOn: "fas fa-list-ol",
            iconColorOn: this.color,
            checked: this.showGroupHierarchy,
            events: {
                change: (event) => {
                    this.showGroupHierarchy = event.target.getValue()
                    this._render()
                }
            }
        }).render()

        // Search button
        createButton({
            hidden: !this.canSearch,
            target: "search:" + this.id,
            icon: "fas fa-search",
            iconColor: this.color,
            width: "3.2rem",
            events: {
                click: () => this.showSearchBar()
            }
        }).render()

        // Pager first
        createButton({
            hidden: kiss.screen.isMobile && kiss.screen.isVertical(),
            target: "pager-first:" + this.id,
            icon: "fas fa-step-backward",
            iconColor: this.color,
            width: "3.2rem",
            events: {
                click: () => this.showFirstPage()
            }
        }).render()

        // Pager previous
        createButton({
            target: "pager-previous:" + this.id,
            icon: "fas fa-chevron-left",
            iconColor: this.color,
            width: "3.2rem",
            events: {
                click: () => this.showPreviousPage()
            }
        }).render()

        // Pager next
        createButton({
            target: "pager-next:" + this.id,
            icon: "fas fa-chevron-right",
            iconColor: this.color,
            width: "3.2rem",
            events: {
                click: () => this.showNextPage()
            }
        }).render()

        // Pager last
        createButton({
            hidden: kiss.screen.isMobile && kiss.screen.isVertical(),
            target: "pager-last:" + this.id,
            icon: "fas fa-step-forward",
            iconColor: this.color,
            width: "3.2rem",
            events: {
                click: () => this.showLastPage()
            }
        }).render()

        this._buildCustomButtons()

        // Flag the toolbar as "rendered", so that the method _renderToolbar() is idempotent
        this.isToolbarRendered = true
    }

    /**
     * 
     * ROWS API
     * 
     */

    /**
     * Check / Uncheck a row with the row checkbox.
     * 
     * Important: a record can be displayed multiple times in the datatable (if it's part of multiple groups).
     * For this reason, we need to update all the rows that display the record, and not only the one that has been clicked.
     * 
     * @private
     * @ignore
     * @param {integer} rowIndex - The row number in the view
     */
    _rowToggleSelect(rowIndex) {
        let checkbox = this._rowGetCheckbox(rowIndex)
        let recordId = checkbox.parentNode.getAttribute("recordId")

        let rowIndexes = this._rowGetAllIndexes(recordId)
        let isSelected = (this.selectedRecords.indexOf(recordId) != -1)

        if (isSelected) {
            rowIndexes.forEach(rowIndex => this._rowDeselect(rowIndex))
            kiss.selection.delete(this.id, recordId)
        } else {
            rowIndexes.forEach(rowIndex => this._rowSelect(rowIndex))
            kiss.selection.insertOne(this.id, recordId)
        }

        // Update the datatable
        this.selectedRecords = kiss.selection.get(this.id)
        return recordId
    }

    /**
     * Select a row, and add it to the collection selection.
     * The index is relative to the page (the row 0 can be the nth record in the collection).
     * 
     * @private
     * @ignore
     * @param {number} rowIndex - The row number in the current page
     */
    _rowSelect(rowIndex) {
        // Update the checkbox
        let checkbox = this._rowGetCheckbox(rowIndex)
        if (!checkbox) return

        checkbox.classList.add("datatable-row-checkbox-on")
        checkbox.classList.remove("datatable-row-checkbox-off")

        // Highlight the selected row
        let row = this.datatableBody.querySelector("[row=\"" + rowIndex + "\"]")
        row.classList.add("datatable-row-selected")
    }

    /**
     * Deselect a row, and remove it from the collection selection.
     * The index is relative to the page (the row 0 can be the nth record in the collection).
     * 
     * @private
     * @ignore
     * @param {number} rowIndex - The row number in the current page
     */
    _rowDeselect(rowIndex) {
        // Update the checkbox
        let checkbox = this._rowGetCheckbox(rowIndex)
        if (!checkbox) return

        checkbox.classList.add("datatable-row-checkbox-off")
        checkbox.classList.remove("datatable-row-checkbox-on")

        // Remove the highlight on the selected row
        let row = this.datatableBody.querySelector("[row=\"" + rowIndex + "\"]")
        row.classList.remove("datatable-row-selected")
    }

    /**
     * Highlight a row
     * 
     * @private
     * @ignore
     * @param {number} rowIndex - The row index to highlight
     */
    _rowHighlight(rowIndex) {
        let row = this.querySelector("[row=\"" + rowIndex + "\"]")
        if (!row) return

        row.classList.add("datatable-row-selected")
    }

    /**
     * Trigger the action defined in a column which type is "button"
     * 
     * @private
     * @ignore
     * @param {number} rowIndex 
     * @param {number} colId 
     * @param {string} recordId 
     */
    async _rowTriggerButtonAction(rowIndex, colId, recordId) {
        const column = this.columns.get(colId)
        let record = this.collection.records[rowIndex]
        if (column.button.action) await column.button.action(rowIndex, colId, recordId, record)
    }

    /**
     * Get the checkbox used to select/deselect a row.
     * The index is relative to the page (the row 0 can be the nth record in the collection).
     * 
     * @private
     * @ignore
     * @param {integer} rowIndex
     * @returns {HTMLElement} The checkbox input element
     */
    _rowGetCheckbox(rowIndex) {
        return this.datatableBody1stColumn.querySelector("[row=\"" + rowIndex + "\"]").querySelector(".datatable-row-checkbox")
    }

    /**
     * Get the index of a record in the active page.
     * 
     * @private
     * @ignore
     * @param {string} recordId
     * @returns {integer} The row index, or null if it wasn't found in the page
     */
    _rowGetIndex(recordId) {
        let row = this.datatableBody.querySelector("div[recordId='" + recordId + "']")
        if (row) return row.getAttribute("row")
        else return null
    }

    /**
     * Find the index of a record in the datatable (including hidden rows)
     * 
     * @private
     * @ignore
     * @param {string} recordId
     * @returns {number} The index of the record in the datatable, or -1 if not found
     */
    _rowFindIndex(recordId) {
        return this.collection.records.findIndex(record => record.id == recordId)
    }

    /**
     * Find all the indexes of a record in the active page.
     * 
     * @private
     * @ignore
     * @param {string} recordId
     * @returns {integer} The row index, or null if it wasn't found in the page
     */
    _rowGetAllIndexes(recordId) {
        let rows = this.datatableBody.querySelectorAll("div[recordId='" + recordId + "']")
        if (rows) return Array.from(rows).map(row => row.getAttribute("row"))
        else return null
    }

    /**
     * Get the row height config stored locally
     * 
     * @private
     * @ignore
     */
    _getRowHeightFromLocalStorage() {
        const localStorageId = "config-view-datatable-" + this.id + "-row-height"
        const rowHeight = localStorage.getItem(localStorageId)
        if (!rowHeight) return this.defaultRowHeight
        return Number(rowHeight)
    }

    /**
     * 
     * COLUMNS MANAGEMENT
     * 
     */

    /**
     * Save the width of a column in the localStorage
     * 
     * @private
     * @ignore
     * @param {string} columnId - Id of the column to resize
     * @param {number} newWidth - New column width, in rem
     */
    _columnsSetWidth(columnId, newWidth) {
        let localStorageId

        // 1st column
        if (columnId == "1stColumn") {
            localStorage.setItem("config-view-datatable-" + this.id + "-1st-column", newWidth)
            return
        }

        // Other columns: get the column config and update it
        let columnIndex = this.columns.findIndex(column => column.id == columnId)
        if (newWidth <= 1) newWidth = 1
        this.columns[columnIndex].width = newWidth

        // Save new column size locally
        localStorageId = "config-view-datatable-" + this.id + "-columns"
        localStorage.setItem(localStorageId, JSON.stringify(this.columns))
    }

    /**
     * Drag and drop a column
     * 
     * @private
     * @ignore
     * @param {string} phase - dragstart | dragover | dragleave | drop
     * @param {object} event - The drag Event: dragStart | dragOver | dragLeave | drop
     * @param {object} element - The DOM element which is dragged
     */
    _columnsMoveWithdragAndDrop(phase, event, element) {
        let target = event.target
        let targetCenterX = null
        let colIndex = target.closest("div").getAttribute("col")
        let columnCells = Array.from(this.querySelectorAll("div[col='" + colIndex + "']"))

        switch (phase) {
            case "dragstart":
                // Store the column to be moved
                this.sourceColumnId = target.id.split("title-")[1]
                break

            case "dragover":
                // Adjust target column style to show where to drop the column
                targetCenterX = target.offsetLeft + target.clientWidth / 2

                if (event.x < targetCenterX) {
                    columnCells.forEach(cell => {
                        cell.classList.remove("datatable-column-dragover-right")
                        cell.classList.add("datatable-column-dragover-left")
                    })
                } else {
                    columnCells.forEach(cell => {
                        cell.classList.remove("datatable-column-dragover-left")
                        cell.classList.add("datatable-column-dragover-right")
                    })
                }
                event.preventDefault()
                return false

            case "dragleave":
                // Restore style of header and column
                columnCells.forEach(cell => {
                    cell.classList.remove("datatable-column-dragover-left")
                    cell.classList.remove("datatable-column-dragover-right")
                })
                break

            case "drop":
                event.stopPropagation()

                // Restore style of header and column
                columnCells.forEach(cell => {
                    cell.classList.remove("datatable-column-dragover-left")
                    cell.classList.remove("datatable-column-dragover-right")
                })

                // Perform the drop action
                targetCenterX = target.offsetLeft + target.clientWidth / 2
                let position = (event.x < targetCenterX) ? "before" : "after"
                this._columnsMove(this.sourceColumnId, target.id.split("title-")[1], position)
                break
        }
    }

    /**
     * Resize a column
     * 
     * @private
     * @ignore
     */
    _columnsResizeWithDragAndDrop(event, element) {
        // Get column cells
        let columnId = element.parentNode.id.split("header-")[1] // headers id are built like: header-columnId
        let colIndex = element.parentNode.getAttribute("col")
        let columnCells = Array.from(this.querySelectorAll("div[col='" + colIndex + "']"))

        // Get column header elements
        let columnHeader = element.parentNode
        let columnHeaderTitle = columnHeader.children[0]

        columnHeader.mouseStartX = event.x
        let currentWidth = columnHeader.clientWidth
        let newWidth

        //  Set minimum column size
        let columnMinSize = (columnId == "1stColumn") ? 9 : 5

        // !!!
        // TODO: memory leak to solve here => listeners seem to not be garbage collected properly
        // !!!
        document.onmousemove = (event) => {
            let _event = event

            setTimeout(() => {
                newWidth = kiss.tools.pxToRem(currentWidth + _event.x - columnHeader.mouseStartX)
                if (newWidth > columnMinSize) {
                    // Resize the header
                    columnHeader.style.minWidth = columnHeader.style.width = newWidth + "rem"
                    columnHeaderTitle.style.minWidth = columnHeaderTitle.style.width = (newWidth - this.resizerWidth) + "rem"

                    // Resize the column
                    columnCells.forEach(cell => cell.style.width = cell.style.minWidth = newWidth + "rem")

                    if (columnId == "1stColumn") this._columnsSetFirstColumnWidth(newWidth)
                }
            }, 1)
        }

        // Remove listeners
        document.onmouseup = () => {
            this._columnsSetWidth(columnId, Math.max(columnMinSize, newWidth))
            document.onmousemove = null
            document.onmouseup = null
        }
    }

    /**
     * Convert a numeric width into a style
     * 
     * @private
     * @ignore
     * @param {number} width 
     * @returns {string} The style - Example: style="width: 215px; min-width: 215px"
     */
    _columnsConvertWidthToStyle(width) {
        return "width: " + width + "rem; min-width: " + width + "rem;"
    }

    /**
     * Resize the datatable first column, used to display:
     * - selection checkboxes
     * - group names, when the view is grouped by a field
     * 
     * @private
     * @ignore
     * @param {number} newWidth - The new width, in rem
     */
    _columnsSetFirstColumnWidth(newWidth) {
        this.defaultColumnWidth.firstColumn = newWidth
        this.datatableHeader1stColumn.style.minWidth = newWidth + "rem"
        this.datatableBody1stColumn.style.minWidth = newWidth + "rem"
    }

    /**
     * Adjust columns according to a local configuration stored in the localStorage.
     * If a configuration is found for a specific column, then it is applied.
     * Otherwise, a DEFAULT_WIDTH width is applied.
     * 
     * @private
     * @ignore
     */
    _columnsAdjustWidthFromLocalStorage() {
        // Adjust 1st column width
        let localStorageId = "config-view-datatable-" + this.id + "-1st-column"
        let firstColumnWidth = localStorage.getItem(localStorageId)
        this.defaultColumnWidth.firstColumn = (firstColumnWidth || this.defaultColumnWidth.firstColumn)

        // Adjust other columns width
        localStorageId = "config-view-datatable-" + this.id + "-columns"
        let localColumns = JSON.parse(localStorage.getItem(localStorageId))

        this.columns = this.columns.map(column => {
            const defaultColumnWidth = this.defaultColumnWidth[column.type] || this.defaultColumnWidth.default
            column.width = column.width || defaultColumnWidth

            if (localColumns) {
                // Check if there is a matching column in the local config
                let localColumn = localColumns.find(localColumn => localColumn.id == column.id)

                // If the local column has a width, then adjust the datatable column accordingly
                if (localColumn && localColumn.width) column.width = localColumn.width
            }
            return column
        })
    }

    /**
     * Set the column aggregation type for grouped views
     * 
     * @private
     * @ignore
     * @param {number} colIndex
     * @param {number} x - x position to display the menu
     * @param {number} Y - y position to display the menu
     */
    _columnsSetAggregationType(column, x, y) {
        createMenu({
                items: [{
                        text: txtTitleCase("sum"),
                        icon: "fas fa-chart-bar",
                        action: async () => {
                            column.summary = "sum"
                            this._render()
                            this.updateConfig({
                                config: {
                                    columns: this.columns
                                }
                            })
                        }
                    },
                    {
                        text: txtTitleCase("average"),
                        icon: "fas fa-tachometer-alt",
                        action: async () => {
                            column.summary = "avg"
                            this._render()
                            this.updateConfig({
                                config: {
                                    columns: this.columns
                                }
                            })
                        }
                    },
                    {
                        text: txtTitleCase("#no summary"),
                        icon: "fas fa-ban",
                        action: async () => {
                            delete column.summary
                            this._render()
                            this.updateConfig({
                                config: {
                                    columns: this.columns
                                }
                            })
                        }
                    },
                ]
            })
            .render()
            .showAt(x, y)
    }

    /**
     * 
     * ACCESS TO CELLS
     * 
     */

    /**
     * Set new data into a cell.
     * Apply the existing cell renderer, if any.
     * This method is always triggered asynchronously in the background by a collection change.
     * 
     * @private
     * @ignore
     * @param {string} recordId - Target record id
     * @param {string} fieldId - Target field id
     * @param {*} value - Value to set
     */
    _cellSetValue(recordId, fieldId, value) {
        try {
            // Get the column config
            const colIndex = this.visibleColumns.findIndex(column => (column.id == fieldId))
            if (colIndex == -1) return
            const column = this.visibleColumns[colIndex]

            // Get the record (for specific renderers that needs more than the field value to be computed)
            const record = this.collection.getRecord(recordId)

            // Find all the rows that match this record
            const rowIndexes = this._rowGetAllIndexes(recordId)

            // For each of these rows, we update the right cell value
            rowIndexes.forEach(rowIndex => {
                const row = this.datatableBody.querySelector("div[row='" + rowIndex + "']")
                const cell = row.querySelector("div[col='" + colIndex + "']")
                cell.innerHTML = column.renderer({
                    value,
                    record,
                    config: {
                        rowIndex,
                        colIndex,
                        thumbSize: this.thumbSize
                    }
                })
            })
        } catch (err) {
            log("kiss.ui - datatable - Couldn't set the cell value", 4, err)
        }
    }

    /**
     * Set the value of a checkbox cell
     * 
     * @private
     * @ignore
     * @param {string} recordId - Target record id
     * @param {string} fieldId - Target field id
     */
    async _cellSetCheckboxValue(recordId, fieldId) {
        let record = this.collection.getRecord(recordId)
        let currentCellValue = record[fieldId] || false
        await record.updateFieldDeep(fieldId, !currentCellValue)
    }

    /**
     * Set the value of a rating cell
     * 
     * @private
     * @ignore
     * @param {string} recordId - Target record id
     * @param {string} fieldId - Target field id
     * @param {event} event
     */
    async _cellSetRatingValue(recordId, fieldId, event) {
        if (!event.target.classList.contains("rating")) return

        let record = this.collection.getRecord(recordId)
        let currentCellValue = record[fieldId]
        const index = event.target.getAttribute("index")
        const newValue = Number(index) + 1

        if (newValue != currentCellValue) await record.updateFieldDeep(fieldId, newValue)
    }

    /**
     * Get the next cell up, down, left or right, starting from the current position
     * If the next cell found is *not* editable, then return null
     * 
     * @private
     * @ignore
     * @param {HTMLDivElement} cell - the current cell
     * @param {string} direction - up|down|left|right
     * @returns {HTMLDivElement|null}
     */
    _cellGetNext(cell, direction) {
        let shift = {
            up: {
                x: 0,
                y: -1
            },
            down: {
                x: 0,
                y: 1
            },
            left: {
                x: -1,
                y: 0
            },
            right: {
                x: 1,
                y: 0
            }
        }

        // Compute the next coordinates according to the direction
        let rowIndex = this._cellGetRowIndex(cell) + shift[direction].y
        let colIndex = this._cellGetColIndex(cell) + shift[direction].x

        let row = this.datatableBody.querySelector("div[row='" + rowIndex + "']")
        if (!row) return null
        if (row.className == "datatable-group-row") return null

        let nextCell = row.querySelector("div[col='" + colIndex + "']")
        if (!nextCell) return null

        // TODO: check cell security => if no access, then return null as well
        if (this._cellIsEditable(nextCell)) {
            return null
        } else {
            return nextCell
        }
    }

    /**
     * 
     * Simple helpers to get cell properties and data
     * 
     * @private
     * @ignore
     */
    _cellGetRowIndex(cell) {
        return Number(cell.parentNode.getAttribute("row"))
    }

    _cellGetColIndex(cell) {
        return Number(cell.getAttribute("col"))
    }

    _cellGetRecordId(cell) {
        let rowIndex = this._cellGetRowIndex(cell)
        return this.collection.records[rowIndex].id
    }

    _cellGetRecordData(cell) {
        let rowIndex = this._cellGetRowIndex(cell)
        return this.collection.records[rowIndex]
    }

    _cellGetRecord(cell) {
        let recordId = this._cellGetRecordId(cell)
        return this.collection.getRecord(recordId)
    }

    _cellGetFieldId(cell) {
        let col = cell.getAttribute("col")
        let colHeader = this.datatableHeader.querySelector("div[col='" + col + "']")
        return colHeader.id.split("header-")[1]
    }

    _cellGetColumn(cell) {
        let colId = this._cellGetFieldId(cell)
        return this.columns.get(colId)
    }

    _cellIsEditable(cell) {
        const fieldId = this._cellGetFieldId(cell)
        const field = this.model.getField(fieldId)

        if (field.computed) return false
        if (field.readOnly) return false
        if (field.type == "lookup" || field.type == "summary") return false
        if (field.acl) {
            const acl = field.acl.update
            return (acl !== false)
        }
        return true
    }

    _cellGetText(cell) {
        let textContent = ""
    
        function extractText(node) {
            if (node.nodeType === Node.TEXT_NODE) {
                textContent += node.textContent.trim()
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                if (node.tagName === "BR") {
                    textContent += "\n"
                } else {
                    node.childNodes.forEach(child => extractText(child))
                }
            }
        }
        extractText(cell)

        if (textContent.includes("\n") || textContent.includes('"')) {
            textContent = `"${textContent.replace(/"/g, '""')}"`
        }
    
        return textContent
    }

    _getCellsInRange(startCell, endCell) {
        const startRowIndex = parseInt(startCell.closest(".datatable-row").getAttribute("row"), 10)
        const endRowIndex = parseInt(endCell.closest(".datatable-row").getAttribute("row"), 10)

        const startColIndex = parseInt(startCell.getAttribute("col"), 10)
        const endColIndex = parseInt(endCell.getAttribute("col"), 10)

        const rangeStartRow = Math.min(startRowIndex, endRowIndex)
        const rangeEndRow = Math.max(startRowIndex, endRowIndex)

        const rangeStartCol = Math.min(startColIndex, endColIndex)
        const rangeEndCol = Math.max(startColIndex, endColIndex)

        const cells = []
        for (let rowIndex = rangeStartRow; rowIndex <= rangeEndRow; rowIndex++) {
            const row = this.querySelector(`.datatable-row[row="${rowIndex}"]`)

            if (row && !row.classList.contains("datatable-group-row")) {
                for (let colIndex = rangeStartCol; colIndex <= rangeEndCol; colIndex++) {
                    const cell = row.querySelector(`.datatable-cell[col="${colIndex}"]`)
                    if (cell) cells.push(cell)
                }
            }
        }
        return cells
    }

    /**
     * Copy the selection to the clipboard
     */
    async _copySelectedCellsDataToClipboard() {
        let clipboardData = ""
        let records = []

        const startIndex = Math.min(this.startCellData.rowIndex, this.endCellData.rowIndex)
        const endIndex = Math.max(this.startCellData.rowIndex, this.endCellData.rowIndex)
        const startColIndex = Math.min(this.startCellData.colIndex, this.endCellData.colIndex)
        const endColIndex = Math.max(this.startCellData.colIndex, this.endCellData.colIndex)

        for (let rowIndex = startIndex; rowIndex <= endIndex; rowIndex++) {
            records.push(this.collection.records[rowIndex])
        }

        records = records.filter(record => record.$type != "group")

        for (const record of records) {
            const recordData = await record.getData({
                convertNames: true
            })

            for (let colIndex = startColIndex; colIndex <= endColIndex; colIndex++) {
                const column = this.visibleColumns[colIndex]
                let value = recordData[column.id]
                value = this.formatValueForClipboard(column, value)
                clipboardData += value + "\t"
            }

            clipboardData += "\n"
        }

        kiss.tools.copyTextToClipboard(clipboardData)
        createNotification(txtTitleCase("copied to clipboard"))
    }

    /**
     * Copy the selected rows to the clipboard
     */
    async _copySelectedRowsDataToClipboard() {
        let clipboardData = ""
        const records = this.getSelectedRecords()

        for (const record of records) {
            const recordData = await record.getData({
                convertNames: true
            })

            for (const column of this.visibleColumns) {
                let value = recordData[column.id]
                value = this.formatValueForClipboard(column, value)
                clipboardData += value + "\t"
            }

            clipboardData += "\n"
        }

        kiss.tools.copyTextToClipboard(clipboardData)
        createNotification(txtTitleCase("copied to clipboard"))
    }      

    /**
     * Open a linked record from a cell
     * 
     * @private
     * @ignore
     * @param {string} fieldId
     * @param {string} recordId 
     */
    async _cellOpenLinkedRecord(fieldId, recordId) {
        const record = this.collection.getRecord(recordId)
        if (!record) return

        const links = await kiss.data.relations.getLinksAndRecords(record.model.id, record.id, fieldId)
        const foreignRecords = links.map(link => link.record)

        // No linked records
        if (links.length == 0) {
            const field = record.model.getField(fieldId)
            const foreignModelId = field.link.modelId
            const foreignModel = kiss.app.models[foreignModelId]
            const foreignModelName = foreignModel.namePlural
            return createNotification(txtTitleCase("#no links", null, {
                table: foreignModelName
            }))
        }

        const field = this.model.getField(fieldId)
        const foreignModel = kiss.app.models[field.link.modelId]

        if (links.length == 1) {
            // Single record, we open the form
            const foreignRecord = foreignModel.create(foreignRecords[0])
            this.selectRecord(foreignRecord)
        } else {
            // Multiple records, we open the window to select a record
            kiss.context.records = foreignRecords
            createRecordSelectionWindow(foreignModel, fieldId, foreignRecords, null, {
                canSelect: false
            })
        }
    }

    /**
     * 
     * CELL IN-PLACE EDITING
     * 
     */

    /**
     * Switch a cell to EDIT MODE
     * 
     * @private
     * @ignore
     * @param {HTMLDivElement} cell - The cell to edit
     */
    async _cellSwitchToEditMode(cell, event) {
        const _this = this
        let updateOnBlur = true

        cell.onkeydown = null

        // Get main cell infos
        const record = this._cellGetRecord(cell)
        const recordId = record.id
        const fieldId = this._cellGetFieldId(cell)
        const field = this.model.getField(fieldId)
        const fieldType = field.type
        const column = this.getColumn(fieldId)

        // Exit if its a special cell
        const cellType = column.type
        if (["attachment", "aiImage", "button", "custom"].indexOf(cellType) != -1) return

        // Fields generated by plugins are static
        if (column.isFromPlugin) return

        // Cache the initial value, html, and style, to be able to roll back to it, in case we cancel the cell edition
        const fieldInitialValue = record[fieldId] || ""
        const cellInitialStyle = cell.getAttribute("style")

        // Exit if it's a computed or readOnly cell
        if (field.computed || field.readOnly) return

        // Open the record for some specific field types
        if (fieldType == "link") return await this.selectRecordById(recordId)

        // It's a checkbox: directly switch the state
        if (fieldType == "checkbox") return this._cellSetCheckboxValue(recordId, fieldId)

        // It's a checkbox: directly switch the state
        if (fieldType == "rating") return this._cellSetRatingValue(recordId, fieldId, event)

        // Open a dialog to edit <textarea>
        if (fieldType == "textarea" || fieldType == "aiTextarea") return this._cellEditTextarea(cell, field, fieldInitialValue)

        // Open a dialog to edit <richtextfield>
        if (fieldType == "textarea" || fieldType == "richTextField") return this._cellEditRichText(cell, field, fieldInitialValue)

        // Open a dialog to edit <select> and <select view column>
        if (fieldType == "select" || fieldType == "selectViewColumn") return this._cellEditSelect(cell, field)

        // Open a dialog to edit <select view columns>
        if (fieldType == "selectViewColumns") return this._cellEditSelectViewColumns(cell, field)

        // Open a dialog to edit <directory>
        if (fieldType == "directory") return this._cellEditSelect(cell, field)

        // Open a palette to edit <color>
        if (fieldType == "color") return this._cellEditColor(cell, field)

        // Open a palette to edit <icon>
        if (fieldType == "icon") return this._cellEditIcon(cell, field)

        let cellWidth = kiss.tools.pxToRem(cell.clientWidth) + "rem"
        let cellHeight = kiss.tools.pxToRem(cell.clientHeight) + "rem"

        // Create a new input field inside the cell
        let inputId = "input-" + recordId + "-" + fieldId
        const dataType = (["number", "rating", "slider"].includes(field.type)) ? "number" : field.type
        const cellValue = (typeof fieldInitialValue == "string") ? fieldInitialValue.escapeHtml() : fieldInitialValue
        cell.innerHTML = `<input class="datatable-cell-edited" id="${inputId}" type="${dataType}" value="${cellValue}">`
        let fieldInput = $(inputId)

        // Adjust the cell and field styles so that the field occupies the whole space inside the cell
        cell.style.width = fieldInput.style.width = cellWidth
        cell.style.height = fieldInput.style.height = cellHeight

        // Adjust field style
        fieldInput.style.border = "none"
        fieldInput.style.padding = "var(--datacomponent-cell-padding)"
        fieldInput.style.color = "var(--datacomponent-cell)"
        fieldInput.style.background = "var(--datacomponent-input-background)"

        // Set focus and auto-edit content
        fieldInput.focus()
        fieldInput.select()

        /**
         * Observe key events for in-cell edition
         */
        fieldInput.onkeydown = await async function (event) {
            updateOnBlur = true // By default, we update a cell if we loose focus, like in Excel
            let editNextCell = false

            // SHIFT+TAB
            if (event.shiftKey && event.key == "Tab") {
                editNextCell = "left"
            }
            // TAB
            else if (event.key == "Tab") {
                editNextCell = "right"
            }
            // ENTER
            else if (event.key == "Enter") {
                editNextCell = "down"
            }
            // ESCAPE (= reset modifications)
            else if (event.key == "Escape") {
                updateOnBlur = false
                this.reset()
            }

            // Edit the next cell
            if (editNextCell) {
                updateOnBlur = false
                event.stop()

                const result = this.updateCell()
                if (!result) return false

                const nextCell = _this._cellGetNext(cell, editNextCell)
                if (nextCell) _this._cellSwitchToEditMode(nextCell)
            }
        }

        // Update on cell exiting
        fieldInput.updateCell = async function () {

            // Entry validation
            let success = kiss.tools.validateValue(fieldType, field, this.value)
            if (!success) {
                createNotification(txtTitleCase("#fields incorrect value"))
                this.reset()
                return false
            }

            const newValue = (fieldType == "number") ? Number(this.value) : this.value

            if (newValue != fieldInitialValue) {
                // cell.showLoading({
                //     size: 16
                // })

                // Update the record in the database using the db. This will:
                // - overwrite the same cell with the same value, if the request was OK
                // - rollback to another value, if the request was not OK (for example if the user didn't have enough rights)
                success = await record.updateFieldDeep(fieldId, newValue)

                // Rollback the value in case the operation is forbidden
                if (!success) {
                    this.value = fieldInitialValue
                    this.reset()
                }

                // cell.hideLoading()
            } else {
                this.reset()
            }
        }

        // Remove input field on exiting & restore cell style
        fieldInput.reset = function () {
            try {
                cell.removeAttribute("style")
                cell.setAttribute("style", cellInitialStyle)
                cell.innerHTML = column.renderer({
                    value: fieldInitialValue
                })
            } catch (err) {
                log("kiss.ui - datatable - Couldn't restore the cell value", 4, err)
            }
        }

        // Save or discard the changes when exiting the field
        fieldInput.onblur = async function () {
            if (updateOnBlur) this.updateCell()
        }
    }

    /**
     * Edit a textarea cell
     * 
     * @private
     * @ignore
     * @param {object} cell
     * @param {object} field
     * @param {string} initialValue 
     */
    _cellEditTextarea(cell, field, initialValue) {
        const column = this._cellGetColumn(cell)

        createPanel({
            id: "panel-edit-textarea",
            title: txtTitleCase("edit field"),
            icon: "fas fa-edit",
            headerBackgroundColor: this.color,
            closable: true,
            modal: true,
            draggable: true,
            width: "66rem",
            height: "66rem",
            align: "center",
            verticalAlign: "center",

            layout: "vertical",
            items: [
                // Textarea
                {
                    id: "datatable-edit-textarea",
                    type: "textarea",
                    label: column.title,
                    labelPosition: "top",
                    value: initialValue,
                    required: field.required,
                    minLength: field.minLength,
                    maxLength: field.maxLength,
                    fieldWidth: "100%",
                    fieldHeight: "100%",
                    flex: 1
                },
                // Buttons
                {
                    layout: "horizontal",

                    defaultConfig: {
                        type: "button",
                        flex: 1,
                        margin: "0 0.5rem"
                    },

                    items: [
                        // Cancel
                        {
                            text: txtUpperCase("cancel"),
                            icon: "fas fa-times",
                            action: () => {
                                $("panel-edit-textarea").doNotModifyValue = true
                                $("panel-edit-textarea").close()
                            }
                        },
                        // OK
                        {
                            text: txtUpperCase("ok"),
                            icon: "fas fa-check",
                            color: "var(--green)",
                            iconColor: "var(--green)",
                            action: () => $("panel-edit-textarea").close()
                        }
                    ]
                }
            ],
            events: {
                // Update value on exit
                onclose: () => {
                    if ($("panel-edit-textarea").doNotModifyValue) return

                    // Exit if the value didn't change
                    const textarea = $("datatable-edit-textarea")
                    let newTextareaValue = textarea.getValue()
                    if (newTextareaValue == initialValue) return

                    // Validate new value
                    const success = textarea.validate()
                    if (!success) {
                        createNotification(txtTitleCase("#fields incorrect value"))
                        return
                    }

                    // Otherwise update the record
                    let record = this._cellGetRecord(cell)
                    record.updateFieldDeep(field.id, newTextareaValue)
                },
                // Restore value on escape
                onkeydown: function (event) {
                    if (event.key != "Escape") return

                    $("datatable-edit-textarea").setValue(initialValue)
                    $("panel-edit-textarea").doNotModifyValue = true
                    this.close()
                }
            },
            methods: {
                load: () => setTimeout(() => $("datatable-edit-textarea").focus(), 100)
            }
        }).render()
    }

    /**
     * Edit a textarea cell
     * 
     * @private
     * @ignore
     * @param {object} cell
     * @param {object} field
     * @param {string} initialValue 
     */
    _cellEditRichText(cell, field, initialValue) {
        const column = this._cellGetColumn(cell)

        createPanel({
            id: "panel-edit-richtext",
            title: txtTitleCase("edit field"),
            icon: "fas fa-edit",
            headerBackgroundColor: this.color,
            closable: true,
            modal: true,
            draggable: true,
            width: "66rem",
            height: "66rem",
            align: "center",
            verticalAlign: "center",

            layout: "vertical",
            items: [{
                    layout: "vertical",
                    overflowY: "auto",
                    flex: 1,
                    items: [
                        // Rich text field
                        {
                            id: "datatable-edit-richtext",
                            type: "richTextField",
                            label: column.title,
                            labelPosition: "top",
                            value: initialValue,
                            required: field.required,
                            fieldWidth: "100%",
                            flex: 1
                        }
                    ]
                },

                // Buttons
                {
                    layout: "horizontal",
                    margin: "1rem 0 0 0",

                    defaultConfig: {
                        type: "button",
                        flex: 1,
                        margin: "0 0.5rem"
                    },

                    items: [
                        // Cancel
                        {
                            text: txtUpperCase("cancel"),
                            icon: "fas fa-times",
                            action: () => {
                                $("panel-edit-richtext").doNotModifyValue = true
                                $("panel-edit-richtext").close()
                            }
                        },
                        // OK
                        {
                            text: txtUpperCase("ok"),
                            icon: "fas fa-check",
                            color: "var(--green)",
                            iconColor: "var(--green)",
                            action: () => $("panel-edit-richtext").close()
                        }
                    ]
                }
            ],
            events: {
                // Update value on exit
                onclose: () => {
                    if ($("panel-edit-richtext").doNotModifyValue) return

                    // Exit if the value didn't change
                    const textarea = $("datatable-edit-richtext")
                    let newTextareaValue = textarea.getValue()
                    if (newTextareaValue == initialValue) return

                    // Validate new value
                    const success = textarea.validate()
                    if (!success) {
                        createNotification(txtTitleCase("#fields incorrect value"))
                        return
                    }

                    // Otherwise update the record
                    let record = this._cellGetRecord(cell)
                    record.updateFieldDeep(field.id, newTextareaValue)
                },
                // Restore value on escape
                onkeydown: function (event) {
                    if (event.key != "Escape") return

                    $("datatable-edit-richtext").setValue(initialValue)
                    $("panel-edit-richtext").doNotModifyValue = true
                    this.close()
                }
            },
            methods: {
                load: () => setTimeout(() => $("datatable-edit-richtext").focus(), 100)
            }
        }).render()
    }

    /**
     * Edit a color cell
     * 
     * @private
     * @ignore
     * @param {string} cell
     * @param {object} field
     */
    _cellEditColor(cell, field) {
        let record = this._cellGetRecord(cell)
        let initialValue = record[field.id]

        const picker = createPanel({
            modal: true,
            header: false,
            width: "70.5rem",
            align: "center",
            verticalAlign: "center",
            items: [{
                type: "colorPicker",
                value: initialValue,
                selectorBorderRadius: "3.2rem",
                events: {
                    change: function () {
                        let color = this.getValue()
                        record.updateFieldDeep(field.id, color)
                        picker.close()
                    }
                }
            }]
        }).render()
    }

    /**
     * Edit an icon cell
     * 
     * @private
     * @ignore
     * @param {string} cell
     * @param {object} field
     */
    _cellEditIcon(cell, field) {
        let record = this._cellGetRecord(cell)
        let initialValue = record[field.id]

        const picker = createPanel({
            modal: true,
            header: false,
            width: "67.5rem",
            align: "center",
            verticalAlign: "center",
            items: [{
                type: "iconPicker",
                value: initialValue,
                autoFocus: true,
                icons: kiss.webfonts.all,
                selectorBorderRadius: "3.2rem",
                height: "66rem",
                events: {
                    change: function () {
                        let icon = this.getValue()
                        record.updateFieldDeep(field.id, icon)
                        picker.close()
                    }
                }
            }]
        }).render()
    }

    /**
     * Edit a select cell
     * 
     * @private
     * @ignore
     * @param {object} cell
     * @param {object} field
     */
    _cellEditSelect(cell, field) {
        const record = this._cellGetRecord(cell)
        const column = this._cellGetColumn(cell)
        let initialValue = record[field.id]

        createPanel({
            id: "panel-edit-select",
            title: column.title,
            headerBackgroundColor: this.color,
            modal: true,
            draggable: true,
            width: "66rem",
            align: "center",
            verticalAlign: "center",

            layout: "vertical",
            items: [
                // Select
                {
                    id: field.id,
                    type: field.type,
                    value: initialValue,
                    required: field.required,

                    fieldWidth: "100%",
                    maxHeight: "40rem",
                    flex: 1,

                    options: field.options,
                    users: (field.users === false) ? false : true,
                    groups: (field.groups === false) ? false : true,
                    roles: field.roles,
                    multiple: field.multiple,
                    template: field.template,
                    min: field.min,
                    max: field.max,
                    interval: field.interval,
                    allowClickToDelete: field.multiple,
                    allowSwitchOnOff: field.multiple,
                    allowValuesNotInList: field.allowValuesNotInList,

                    // Options for <Select View Column> field
                    viewId: field.viewId,
                    fieldId: field.fieldId
                },

                // Buttons
                {
                    layout: "horizontal",

                    defaultConfig: {
                        type: "button",
                        flex: 1,
                        margin: "0 0.5rem"
                    },

                    items: [
                        // Cancel
                        {
                            text: txtUpperCase("cancel"),
                            icon: "fas fa-times",
                            action: () => {
                                $("panel-edit-select").doNotModifyValue = true
                                $("panel-edit-select").close()
                            }
                        },
                        // OK
                        {
                            text: txtUpperCase("ok"),
                            icon: "fas fa-check",
                            color: "var(--green)",
                            iconColor: "var(--green)",
                            action: () => $("panel-edit-select").close()
                        }
                    ]
                }
            ],
            events: {
                // Update value on exit
                onclose: () => {
                    if ($("panel-edit-select").doNotModifyValue) return
                    const selectField = $(field.id)

                    // Exit if the value didn't change
                    let newValue = selectField.getValue()
                    if (newValue == initialValue) return

                    // Validate new value
                    const success = selectField.validate()
                    if (!success) {
                        createNotification(txtTitleCase("this field is required"))
                        return
                    }

                    // Update the record
                    record.updateFieldDeep(field.id, newValue)
                },
                // Abort with 'Escape' key
                onkeydown: function (event) {
                    if (event.key != "Escape") return

                    $(field.id).setValue(initialValue)
                    $("panel-edit-select").doNotModifyValue = true
                    this.close()
                }
            }
        }).render()
    }

    /**
     * Edit a <select view columns> cell
     * 
     * @private
     * @ignore
     * @param {object} cell
     * @param {object} field
     */
    async _cellEditSelectViewColumns(cell, field) {
        const selectedRecord = this._cellGetRecord(cell)
        const viewRecord = await kiss.app.collections.view.findOne(field.viewId)
        const viewModel = kiss.app.models[viewRecord.modelId]

        // Build the datatable
        const datatable = createDatatable({
            collection: viewModel.collection,
            sort: viewRecord.sort,
            filter: viewRecord.filter,
            group: viewRecord.group,

            canEdit: false,
            canAddField: false,
            canEditField: false,
            canCreateRecord: false,
            showActions: false,
            columns: viewRecord.config.columns,
            color: viewModel.color,
            height: () => "calc(100vh - 20rem)",

            methods: {
                selectRecord: async function (record) {
                    const fieldId = field.fieldId[0]
                    const otherFieldIds = field.fieldId.slice(1)

                    let mapping = otherFieldIds.map(viewFieldId => {
                        let label = viewModel.getField(viewFieldId).label
                        let localField = selectedRecord.model.getFieldByLabel(label) || {}
                        return {
                            label,
                            id: localField.id,
                            viewFieldId
                        }
                    }).filter(map => map.id)

                    let update = {}
                    update[field.id] = record[fieldId]
                    mapping.forEach(map => update[map.id] = record[map.viewFieldId])

                    await selectedRecord.updateDeep(update)
                    this.closest("a-panel").close()
                }
            }
        })

        // Build the panel to embed the datatable
        createPanel({
            modal: true,
            closable: true,

            // Header
            title: "<b>" + viewModel.namePlural + "</b>",
            icon: viewModel.icon,
            headerBackgroundColor: viewModel.color,

            // Size and layout
            display: "flex",
            layout: "vertical",
            width: () => "calc(100vw - 20rem)",
            height: () => "calc(100vh - 20rem)",
            align: "center",
            verticalAlign: "center",
            autoSize: true,

            items: [datatable]
        }).render()
    }

    /**
     * 
     * OTHER MISC METHODS
     * 
     */

    /**
     * Render the menu to change datatable layout
     * 
     * @private
     * @ignore
     */
    async _buildLayoutMenu() {
        let buttonLeftPosition = $("layout:" + this.id).offsetLeft
        let buttonTopPosition = $("layout:" + this.id).offsetTop

        createMenu({
            top: buttonTopPosition,
            left: buttonLeftPosition,
            items: [
                // Title
                txtTitleCase("cell size"),
                "-",
                // Change row height to  COMPACT
                {
                    icon: "fas fa-circle",
                    iconSize: "0.2rem",
                    text: txtTitleCase("compact"),
                    action: () => {
                        this.rowHeight = 3
                        this.setRowHeight(this.rowHeight)
                    }
                },
                // Change row height to NORMAL
                {
                    icon: "fas fa-circle",
                    iconSize: "0.6rem",
                    text: txtTitleCase("normal"),
                    action: () => {
                        this.rowHeight = this.defaultRowHeight
                        this.setRowHeight(this.rowHeight)
                    }
                },
                // Change row height to MEDIUM
                {
                    icon: "fas fa-circle",
                    iconSize: "1rem",
                    text: txtTitleCase("medium"),
                    action: () => {
                        this.rowHeight = 8
                        this.setRowHeight(this.rowHeight)
                    }
                },
                // Change row height to TALL
                {
                    icon: "fas fa-circle",
                    iconSize: "1.4rem",
                    text: txtTitleCase("tall"),
                    action: () => {
                        this.rowHeight = 12
                        this.setRowHeight(this.rowHeight)
                    }
                },
                // Change row height to VERY TALL
                {
                    icon: "fas fa-circle",
                    iconSize: "1.8rem",
                    text: txtTitleCase("very tall"),
                    action: () => {
                        this.rowHeight = 16
                        this.setRowHeight(this.rowHeight)
                    }
                },
                "-",
                // Reset columns width
                {
                    icon: "fas fa-undo-alt",
                    text: txtTitleCase("#reset view params"),
                    action: () => this.resetLocalViewParameters()
                }
            ]
        }).render()
    }

    /**
     * Add custom buttons to the toolbar.
     * Buttons can be inserted at a custom position.
     * 
     * @private
     * @ignore
     * 
     * @example
     * const customButtons = [{
     *  position: 1,
     *  text: "Button 1",
     *  action: () => {console.log("Hello")}
     * }, {
     *  position: 5,
     *  text: "Button 5",
     *  action: () => {console.log("World")}
     * }]
     * 
     * createDatatable({
     *  //... your datatable config here
     *  buttons: customButtons
     * })
     */
    async _buildCustomButtons() {
        if (!this.buttons) return
        this.buttons.forEach(button => {
            const newButton = createButton(button)
            const position = button.position || 1
            const target = this.datatableToolbar.children[position]
            this.datatableToolbar.insertBefore(newButton, target)
        })
    }

    /**
     * Show quick tips to onboard the user and explaind the basics
     */
    showTutorial() {
        setTimeout(() => {
            kiss.tools.highlightElements([{
                    element: document.body.querySelector(".datatable-header-last-column"),
                    text: txtTitleCase("#add field help")
                },
                {
                    element: document.body.querySelector(".datatable-create-record"),
                    text: txtTitleCase("#create record help")
                },
                {
                    element: document.body.querySelector(".datatable-row-action"),
                    text: txtTitleCase("#open form help")
                }
            ], () => {
                createDialog({
                    title: txtTitleCase("#quick tips"),
                    message: txtTitleCase("#replay tips"),
                    buttonOKText: txtTitleCase("yes"),
                    buttonCancelText: txtTitleCase("no"),
                    action: () => this.showTutorial()
                })
            })
        }, 200)

        delete kiss.context.onboard
    }
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-datatable", kiss.ui.Datatable)

/**
 * Shorthand to create a new Datatable. See [kiss.ui.Datatable](kiss.ui.Datatable.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createDatatable = (config) => document.createElement("a-datatable").init(config)

;/** 
 * 
 * The **Kanban** derives from [DataComponent](kiss.ui.DataComponent.html).
 * 
 * It's a [powerful kanban](https://kissjs.net/#ui=start&section=kanban) with the following features:
 * - choosing the fields to display in the cards
 * - multi-fields sorting
 * - complex filtering with combination of AND/OR filters
 * - mutli-level grouping
 * - virtual scrolling which also works with grouped data
 * 
 * @param {object} config
 * @param {Collection} config.collection - The data source collection
 * @param {object} [config.record] - Record to persist the view configuration into the db
 * @param {object[]} [config.columns] - Where each column is: {title: "abc", type: "text|number|integer|float|date|button", id: "fieldId", button: {config}, renderer: function() {}}
 * @param {string} [config.color] - Hexa color code. Ex: #00aaee
 * @param {boolean} [config.showToolbar] - false to hide the toolbar (default = true)
 * @param {boolean} [config.showActions] - false to hide the custom actions menu (default = true)
 * @param {boolean} [config.showLayoutButton] - false to hide the button to adjust the layout (default = true)
 * @param {boolean} [config.canSearch] - false to hide the search button (default = true)
 * @param {boolean} [config.canSort] - false to hide the sort button (default = true)
 * @param {boolean} [config.canFilter] - false to hide the filter button (default = true)
 * @param {boolean} [config.canGroup] - false to hide the group button (default = true)
 * @param {boolean} [config.canSelectFields] - Can we select the fields (= columns) to display in the kanban? (default = true)
 * @param {boolean} [config.canCreateRecord] - Can we create new records from the kanban?
 * @param {boolean} [config.createRecordText] - Optional text to insert in the button to create a new record, instead of the default model's name
 * @param {object[]} [config.actions] - Array of menu actions, where each menu entry is: {text: "abc", icon: "fas fa-check", action: function() {}}
 * @param {number|string} [config.width]
 * @param {number|string} [config.height]
 * @returns this
 * 
 * ## Generated markup
 * ```
 * <a-kanban class="a-kanban">
 *      <div class="kanban-toolbar">
 *          <!-- Kanban toolbar items -->
 *      </div>
 *      <div class="kanban-header-container">
 *          <div class="kanban-header">
 *              <!-- Header columns -->
 *          </div>
 *      </div>
 *      <div class="kanban-body-container">
 *          <div class="kanban-body">
 *              <!-- Body columns -->
 *          </div>
 *      </div>
 * </a-kanban>
 * ```
 */
kiss.ui.Kanban = class Kanban extends kiss.ui.DataComponent {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const myKanban = document.createElement("a-kanban").init(config)
     * ```
     * 
     * Or use the shorthand for it:
     * ```
     * const myKanban = createKanban({
     *   id: "my-kanban",
     *   color: "#00aaee",
     *   collection: kiss.app.collections["contact"],
     * 
     *   // We can define a menu with custom actions
     *   actions: [
     *       {
     *           text: "Group by status",
     *           icon: "fas fa-sort",
     *           action: () => $("my-kanban").groupBy(["Status"])
     *       }
     *   ],
     *   
     *   // We can add custom methods, and also override default ones
     *   methods: {
     * 
     *      // Override the createRecord method
     *      createRecord(model) {
     *          // Create a record from this model
     *          console.log(model)
     *      },
     * 
     *      // Override the selectRecord method
     *      selectRecord(record) {
     *          // Show the clicked record
     *          console.log(record)
     *      },
     * 
     *      sayHello: () => console.log("Hello"),
     *   }
     * })
     * 
     * myKanban.render()
     * ```
     */
    constructor() {
        super()
    }

    /**
     * Generates a Kanban from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config) {
        // This component must be resized with its parent container
        config.autoSize = true

        // Init the parent DataComponent
        super.init(config)

        // Options
        this.showToolbar = (config.showToolbar !== false)
        this.showActions = (config.showActions !== false)
        this.showLayoutButton = (config.showLayoutButton !== false)
        this.canSearch = (config.canSearch !== false)
        this.canSort = (config.canSort !== false)
        this.canFilter = (config.canFilter !== false)
        this.canGroup = (config.canGroup !== false)
        this.canSelectFields = (config.canSelectFields !== false)
        this.actions = config.actions || []
        this.buttons = config.buttons || []
        this.color = config.color || "#00aaee"
        this.defaultColumnWidth = 28 // in rem

        // Build kanban skeletton markup
        let id = this.id
        this.innerHTML = /*html*/
            `<div class="kanban">
                <div id="kanban-toolbar:${id}" class="kanban-toolbar">
                    <div id="create:${id}"></div>
                    <div id="actions:${id}"></div>
                    <div id="select:${id}"></div>
                    <div id="sort:${id}"></div>
                    <div id="filter:${id}"></div>
                    <div id="group:${id}"></div>
                    <div id="refresh:${id}"></div>
                    <div id="search-field:${id}"></div>
                    <div id="search:${id}"></div>
                    <div class="spacer"></div>
                    <div id="layout:${id}"></div>
                </div>

                <div class="kanban-header-container">
                    <div id="kanban-header:${id}" class="kanban-header"></div>
                </div>

                <div class="kanban-body-container">
                    <div id="kanban-body:${id}" class="kanban-body"></div>
                </div>
            </div>`.removeExtraSpaces()

        // Set kanban components
        this.kanban = this.querySelector(".kanban")
        this.kanbanToolbar = this.querySelector(".kanban-toolbar")
        this.kanbanHeaderContainer = this.querySelector(".kanban-header-container")
        this.kanbanHeader = this.querySelector(".kanban-header")
        this.kanbanBodyContainer = this.querySelector(".kanban-body-container")
        this.kanbanBody = this.querySelector(".kanban-body")

        this._initColumns(config.columns)
            ._initSize(config)
            ._initElementsVisibility()
            ._initEvents()
            ._initSubscriptions()

        return this
    }

    /**
     * 
     * KANBAN METHODS
     * 
     */

    /**
     * Load data into the kanban.
     * 
     * Remark:
     * - rendering time is proportional to the number of cards and visible fields (cards x fields)
     * - rendering takes an average of 0.03 millisecond per card on an Intel i7-4790K
     * 
     * @ignore
     */
    async load() {
        try {
            log(`kiss.ui - Kanban ${this.id} - Loading collection <${this.collection.id} (changed: ${this.collection.hasChanged})>`)

            // Apply filter, sort, group, projection
            // Priority is given to local config, then to the passed collection, then to default
            this.collection.filter = this.filter
            this.collection.filterSyntax = this.filterSyntax
            this.collection.sort = this.sort
            this.collection.sortSyntax = this.sortSyntax
            this.collection.group = this.group
            this.collection.projection = this.projection
            this.collection.groupUnwind = this.groupUnwind

            // Load records
            await this.collection.find()

            // Render the kanban toolbar
            this._renderToolbar()

        } catch (err) {
            log(err)
            log(`kiss.ui - Kanban ${this.id} - Couldn't load data properly`)
        }
    }

    /**
     * Generic method to refresh / re-render the view
     * 
     * Note: used in dataComponent (parent class) showSearchBar method.
     * This method is invoked to refresh the view after a full-text search has been performed
     */
    refresh() {
        this._render()
    }

    /**
     * Move a card to a new column.
     * This is equivalent to changing the value of a field.
     * 
     * @param {string} recordId 
     * @param {string} fieldId 
     * @param {string} value
     */
    moveCardToColumn(recordId, fieldId, value) {
        const record = this.collection.getRecord(recordId)
        const currentValue = record[fieldId]
        const color = this._getCategoryColor(fieldId, value)

        let message
        if (value !== undefined && value !== "") {
            message = txtTitleCase("#move card") + ` <span class="fas fa-circle kanban-column-header-icon" style="color: ${color}"></span><b>${value}</b> ?`
        } else {
            message = txtTitleCase("#move card") + ` <span class="fas fa-circle kanban-column-header-icon" style="color: #cccccc"></span><b>${txtTitleCase("#no category")}</b> ?`
        }
        createDialog({
            title: currentValue + " → " + value,
            icon: "fas fa-clipboard-check",
            type: "dialog",
            message,
            action: async () => {
                const loadingId = kiss.loadingSpinner.show()
                await this.collection.updateOne(recordId, {
                    [fieldId]: value
                })
                kiss.loadingSpinner.hide(loadingId)
                await this.reload()

                createNotification(txtTitleCase("#card moved") + " " + value)
                // const card = this.querySelector(`.kanban-record[recordid="${recordId}"]`)
                // setTimeout(() => this.jumpToCard(card), 1000)
            }
        })
    }

    /**
     * TODO: WORK IN PROGRESS - FOCUSING ON THE DRAGGED CARD
     */
    jumpToCard(card) {
        kiss.global.kanbanScrollStop = true
        const container = card.closest(".kanban-column-container")
        const cardPosition = card.getBoundingClientRect()
        const containerPosition = container.getBoundingClientRect()
        const relativeTop = cardPosition.top - containerPosition.top + container.scrollTop
        container.scrollTop = relativeTop - 20
    }

    scrollToCard(card) {
        kiss.global.kanbanScrollStop = true
        let attempts = 0

        function scroll() {
            card.scrollIntoView({
                block: "end",
                inline: "end",
                // behavior: "auto"
            });

            setTimeout(() => {
                const cardPosition = card.getBoundingClientRect()
                const isCardInView = (
                    cardPosition.top >= 0 &&
                    cardPosition.bottom <= (window.innerHeight || document.documentElement.clientHeight)
                )

                if (!isCardInView && attempts < 5) {
                    attempts++
                    scroll()
                } else kiss.global.kanbanScrollStop = false
            }, 300)
        }
        scroll()
    }

    /**
     * Switch to search mode
     * 
     * Show/hide only the necessary buttons in this mode.
     */
    switchToSearchMode() {
        if (kiss.screen.isMobile) {
            $("create:" + this.id).hide()
            $("search:" + this.id).hide()
        }
    }

    /**
     * Reset search mode
     */
    resetSearchMode() {
        if (kiss.screen.isMobile) {
            $("create:" + this.id).show()
            $("search:" + this.id).show()
        }
    }

    /**
     * Update the kanban color (toolbar buttons + modal windows)
     * 
     * @param {string} newColor
     */
    async setColor(newColor) {
        this.color = newColor
        Array.from(this.kanbanToolbar.children).forEach(item => {
            if (item && item.firstChild && item.firstChild.type == "button") item.firstChild.setIconColor(newColor)
        })
    }

    /**
     * Show the window just under the sorting button
     */
    showSortWindow() {
        let sortButton = $("sort:" + this.id)
        const box = sortButton.getBoundingClientRect()
        super.showSortWindow(box.left, box.top + 40, this.color)
    }

    /**
     * Show the window just under the fields selector button
     */
    showFieldsWindow() {
        let selectionButton = $("select:" + this.id)
        const box = selectionButton.getBoundingClientRect()
        super.showFieldsWindow(box.left, box.top + 40, this.color)
    }

    /**
     * Show the window just under the filter button
     */
    showFilterWindow() {
        super.showFilterWindow(null, null, this.color)
    }

    /**
     * Update the kanban size (recomputes its width and height functions)
     */
    updateLayout() {
        if (this.isConnected) {
            this._setWidth()
            this._setHeight()
            this._render()
        }
    }

    /**
     * Set the kanban column width
     * 
     * @param {number} width - The column width in pixels
     */
    setColumnWidth(width) {
        this.columnWidth = width
        document.documentElement.style.setProperty("--kanban-column-width", this.columnWidth + "rem")

        // Save new row height locally
        const localStorageId = "config-view-kanban-" + this.id + "-column-width"
        localStorage.setItem(localStorageId, this.columnWidth)
        this.reload()
    }

    /**
     * Reset all the columns to their default width
     */
    async resetColumnsWidth() {
        this.columnWidth = this.defaultColumnWidth
        document.documentElement.style.setProperty("--kanban-column-width", this.columnWidth + "rem")

        const localStorageId = "config-view-kanban-" + this.id + "-column-width"
        localStorage.removeItem(localStorageId)
    }

    /**
     * Set header visibility
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initElementsVisibility() {
        if (this.showToolbar === false) this.kanbanToolbar.style.display = "none"
        return this
    }

    /**
     * Initialize kanban sizes
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initSize(config) {
        if (config.width) {
            this._setWidth()
        } else {
            this.style.width = this.config.width = "100%"
        }

        if (config.height) {
            this._setHeight()
        } else {
            this.style.height = this.config.height = "100%"
        }
        return this
    }

    /**
     * Init the columns width according to local settings and/or config.
     * If the kanban is displayed on a mobile device, the column width is set to the screen width.
     * 
     * @private
     * @ignore
     */
    _initColumnWidth(config = {}) {
        const isMobile = kiss.screen.isMobile
        const isPortrait = kiss.screen.isVertical()

        if (isMobile && isPortrait) {
            this.columnWidth = kiss.screen.current.width - 20
            this.columnWidth = kiss.tools.pxToRem(this.columnWidth)
            document.documentElement.style.setProperty("--kanban-column-width", this.columnWidth + "rem")
        } else {
            this.columnWidth = this.columnWidth || config.columnWidth || this._getColumnsWidthFromLocalStorage()
            document.documentElement.style.setProperty("--kanban-column-width", this.columnWidth + "rem")
        }
    }

    /**
     * Initialize all kanban events
     * 
     * @private
     * @ignore
     * @eturns this
     */
    _initEvents() {

        // Clicked somewhere in the kanban
        this.onclick = async (event) => {
            const clickedElement = event.target
            const card = clickedElement.closest(".kanban-record")
            const cardButton = clickedElement.closest(".kanban-record-button")

            // Clicked on a card button to switch card to another column
            if (cardButton) {
                event.stop()

                const recordId = card.getAttribute("recordid")
                const column = card.closest(".kanban-column-container")
                const columnValue = column.getAttribute("value")
                const fieldId = column.getAttribute("fieldid")
                const field = this.model.getField(fieldId)
                if (!field) return

                return createMenu({
                    title: txtTitleCase("#move card"),
                    icon: "fas fa-exchange-alt",
                    items: field.options
                        .filter(option => option.value != columnValue)
                        .map(option => {
                            return {
                                text: option.value,
                                icon: "fas fa-circle",
                                iconColor: option.color,
                                action: () => this.moveCardToColumn(recordId, fieldId, option.value)
                            }
                        })
                }).render()
            }

            // Open a record
            if (card) {
                const recordId = card.getAttribute("recordid")
                const record = await this.collection.getRecord(recordId)
                await this.selectRecord(record)
            }
        }

        // Clicked on a column resizer
        this.kanbanHeader.onmousedown = (event) => {
            const clickedElement = event.target
            if (clickedElement.classList.contains("kanban-column-header-resizer")) {
                this._columnsResizeWithDragAndDrop(event, clickedElement)
            }
        }

        return this
    }

    /**
     * Initialize subscriptions to PubSub
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initSubscriptions() {
        super._initSubscriptions()

        const viewModelId = this.modelId.toUpperCase()

        // React to database mutations
        this.subscriptions = this.subscriptions.concat([
            subscribe("EVT_DB_INSERT:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData)),
            subscribe("EVT_DB_UPDATE:" + viewModelId, (msgData) => this._updateOneAndReload(msgData)),
            subscribe("EVT_DB_DELETE:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData)),
            subscribe("EVT_DB_INSERT_MANY:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData, 2000)),
            subscribe("EVT_DB_UPDATE_MANY:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData, 2000)),
            subscribe("EVT_DB_DELETE_MANY:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData, 2000)),
            subscribe("EVT_DB_UPDATE_BULK", (msgData) => this._reloadWhenNeeded(msgData, 2000))
        ])

        return this
    }

    /**
     * Update a single record then reload the view if required
     * 
     * @private
     * @ignore
     * @param {object} msgData - The original pubsub message
     */
    async _updateOneAndReload(msgData) {
        const sortFields = this.sort.map(sort => Object.keys(sort)[0])
        const filterFields = kiss.db.mongo.getFilterFields(this.filter)

        let groupHasChanged = false
        let sortHasChanged = false
        let filterHasChanged = false

        let updates = msgData.data
        for (let fieldId of Object.keys(updates)) {
            if (this.group.indexOf(fieldId) != -1) groupHasChanged = true
            if (sortFields.indexOf(fieldId) != -1) sortHasChanged = true
            if (filterFields.indexOf(fieldId) != -1) filterHasChanged = true
        }

        this._updateRecord(msgData.id)

        if (sortHasChanged || filterHasChanged || groupHasChanged) {
            this.reload()
        }
    }

    /**
     * Update a single record of the kanban.
     * 
     * @private
     * @ignore
     * @param {string} recordId 
     */
    _updateRecord(recordId) {
        const record = this.collection.getRecord(recordId)
        const recordNode = document.querySelector(`.kanban-record[recordid="${recordId}"]`)

        if (recordNode) {
            const replacementNode = document.createElement("div")
            const recordIndex = recordNode.getAttribute("row")
            replacementNode.setAttribute("row", recordIndex)
            replacementNode.classList.add("kanban-record")
            replacementNode.innerHTML = this._renderRecordAsCard(record, recordIndex)
            recordNode.parentNode.replaceChild(replacementNode, recordNode)
            replacementNode.setAttribute("recordid", recordId)
        }
    }

    /**
     * Initialize the Cards drag and drop
     * 
     * @private
     * @ignore
     */
    _enableDragAndDrop() {
        // Autoscroll management when dragging a card close to the edge of the screen
        let autoScrollInterval
        const kanbanContainer = document.querySelector('.kanban-body-container')
        const scrollSpeed = 20
        const threshold = 100

        function autoScroll(mouseX) {
            clearInterval(autoScrollInterval)
            autoScrollInterval = setInterval(() => {
                if (mouseX < kanbanContainer.getBoundingClientRect().left + threshold) {
                    requestAnimationFrame(() => kanbanContainer.scrollLeft = kanbanContainer.scrollLeft - scrollSpeed)
                } else if (mouseX > kiss.screen.current.width - threshold) {
                    requestAnimationFrame(() => kanbanContainer.scrollLeft = kanbanContainer.scrollLeft + scrollSpeed)
                }
            }, 10)
        }

        const stopAutoScroll = () => clearInterval(autoScrollInterval)

        // Drag and drop helpers
        const getColumns = () => document.querySelectorAll(".kanban-column-container")
        const resetColumns = () => getColumns().forEach(column => column.classList.remove("kanban-column-highlight"))
        const resetColumn = (column) => column.classList.remove("kanban-column-highlight")
        const highlightColumn = (column) => column.classList.add("kanban-column-highlight")

        // Drag and drop events
        const dndEvents = {
            ondragstart: (event) => {
                const kanbanColumn = event.target.closest(".kanban-column-container")
                kiss.context.draggedValue = kanbanColumn.getAttribute("value")
                kiss.context.draggedRecordId = event.target.getAttribute("recordid")
            },

            ondragover: (event) => {
                event.preventDefault()
                resetColumns()
                const kanbanColumn = event.target.closest(".kanban-column-container")
                if (!kanbanColumn) return
                const value = kanbanColumn.getAttribute("value")
                if (value == kiss.context.draggedValue) return
                highlightColumn(kanbanColumn)
                autoScroll(event.clientX);
            },

            ondrop: (event) => {
                event.preventDefault()
                resetColumns()
                const kanbanColumn = event.target.closest(".kanban-column-container")
                if (!kanbanColumn) return

                const columnValue = kanbanColumn.getAttribute("value")
                if (columnValue == kiss.context.draggedValue) return

                const recordId = kiss.context.draggedRecordId
                const fieldId = kanbanColumn.getAttribute("fieldid")
                const value = kanbanColumn.getAttribute("value")
                this.moveCardToColumn(recordId, fieldId, value)
                stopAutoScroll()
            },

            ondragleave: (event) => {
                const kanbanColumn = event.target.closest(".kanban-column-container")
                if (!kanbanColumn) return
                resetColumn(event.target)
            }
        }

        document.querySelectorAll('.kanban-column-container').forEach(kanbanColumn => {
            Object.assign(kanbanColumn, dndEvents)
        })

        document.querySelectorAll('.kanban-record').forEach(kanbanCard => {
            kanbanCard.draggable = true
            kanbanCard.ondragstart = dndEvents.ondragstart
            kanbanCard.ondragend = stopAutoScroll
        })
    }

    /**
     * Adjust the component width
     * 
     * @ignore
     * @param {(number|string|function)} [width] - The width to set
     */
    _setWidth() {
        let newWidth = this._computeSize("width")

        setTimeout(() => {
            this.style.width = newWidth
            this.kanban.style.width = this.clientWidth.toString() + "px"
        }, 50)
    }

    /**
     * Adjust the components height
     * 
     * @private
     * @ignore
     * @param {(number|string|function)} [height] - The height to set
     */
    _setHeight() {
        let newHeight = this._computeSize("height")
        this.style.height = this.kanban.style.height = newHeight
    }

    /**
     * Get the columns width config stored locally
     * 
     * @private
     * @ignore
     */
    _getColumnsWidthFromLocalStorage() {
        const localStorageId = "config-view-kanban-" + this.id + "-column-width"
        const columnWidth = localStorage.getItem(localStorageId)
        if (!columnWidth) return this.defaultColumnWidth
        return Number(columnWidth)
    }

    /**
     * 
     * DATA GROUPING MANAGEMENT
     * 
     */

    /**
     * Group data by a list of fields
     * 
     * @private
     * @ignore
     * @param {string[]} groupFields - Array of fields to group by.
     */
    async _dataGroupBy(groupFields) {
        // Generates the groups, then get the grouped records
        await this.collection.groupBy(groupFields)
        this._render()

        // Save the new group config
        this.group = groupFields
        await this.updateConfig({
            group: this.group
        })
    }

    /**
     * 
     * RENDERING THE KANBAN
     * 
     */

    /**
     * Render the kanban
     * 
     * @private
     * @ignore
     * @returns this
     */
    _render() {
        // Adjust size
        this._initColumnWidth()

        // Filters out hidden and deleted columns
        this.visibleColumns = this.columns.filter(column => column.hidden != true && column.deleted != true)

        // Render body
        this._renderKanbanBody()
        this._observeCards()
        this._enableDragAndDrop()

        return this
    }

    /**
     * Observe the cards to render them only when they are visible
     * 
     * @private
     * @ignore
     */
    _observeCards() {
        const kanbanColumnContainers = this.querySelectorAll('.kanban-column-container')
        kanbanColumnContainers.forEach(container => {
            container.onscroll = () => {
                if (kiss.global.kanbanScrollStop) return

                clearTimeout(this.scrollTimeout)
                this.scrollTimeout = setTimeout(() => this._renderDetailsOfVisibleCards(), 10)
                // requestAnimationFrame(() => this._renderDetailsOfVisibleCards())
            }
        })

        this.kanbanBodyContainer.onscroll = () => {
            clearTimeout(this.scrollTimeout)
            this.scrollTimeout = setTimeout(() => this._renderDetailsOfVisibleCards(), 10)
            // requestAnimationFrame(() => this._renderDetailsOfVisibleCards())
            this.kanbanHeaderContainer.scrollLeft = this.kanbanBodyContainer.scrollLeft
        }

        this._renderDetailsOfVisibleCards()
    }

    /**
     * Render the details of the visible cards
     * 
     * @private
     * @ignore
     */
    _renderDetailsOfVisibleCards() {
        const _this = this
        const collection = this.collection

        requestAnimationFrame(() => {
            document.querySelectorAll(".kanban-record").forEach(card => {
                if (_this._isElementVisible(card)) {
                    const isRendered = card.getAttribute("rendered")
                    if (isRendered == "true") return

                    const recordId = card.getAttribute("recordid")
                    const rowIndex = card.getAttribute("row")
                    const record = collection.getRecord(recordId)
                    const cardContent = _this._renderRecordAsCard(record, rowIndex)
                    const cardElement = _this.querySelector('.kanban-record[recordid="' + recordId + '"]')

                    cardElement.innerHTML = cardContent
                    cardElement.setAttribute("rendered", "true")
                }
            })
        })
    }

    /**
     * Check if an element is partly visible in the viewport
     * 
     * @private
     * @ignore
     */
    _isElementVisible(el) {
        const rect = el.getBoundingClientRect()
        const windowHeight = (window.innerHeight || document.documentElement.clientHeight)
        const windowWidth = (window.innerWidth || document.documentElement.clientWidth)
        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) >= 0)
        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) >= 0)
        return (vertInView && horInView)
    }

    /**
     * Render the kanban body
     * 
     * Tech note: we don't use string litterals to build the HTML because it's slower than native String concatenation
     * 
     * @private
     * @ignore
     */
    _renderKanbanBody() {
        let cardIndex = 0
        let kanbanHeader = ""
        let kanban = ""

        if (this.collection.group.length === 0) {
            // No group: can't render a Kanban view
            kanban = `<div class="kanban-help">${txtTitleCase("#kanban help")}</div>`

            this.kanbanHeaderContainer.style.display = "none"
            this.kanbanBodyContainer.classList.remove("kanban-body-container-empty")

        } else {

            let lastCellType = "group"

            for (let rowIndex = 0; rowIndex < this.collection.records.length; rowIndex++) {
                let record = this.collection.records[rowIndex]

                if (record.$type == "group" && record.$groupLevel == 0) {
                    cardIndex = 0
                    if (lastCellType == "record") { // Close the last column container
                        kanban += "</div>"
                    }

                    lastCellType = "group"

                    // Group header
                    kanbanHeader += this._renderKanbanHeader(record, rowIndex)

                    // Group container
                    kanban += this._renderKanbanColumnContainer(record, rowIndex)

                } else if (record.$type == "group") {

                    // Sub-category
                    kanban += "<div class=\"kanban-column-category\">" + record.$groupId + " - " + record.$name + "</div>"

                } else {
                    cardIndex++
                    lastCellType = "record"

                    // Regular row
                    kanban += this._renderKanbanCardContainer(record, cardIndex)
                }

                // Close the last column container
                if (rowIndex == this.collection.records.length - 1) {
                    kanban += "</div>"
                }
            }

            // Show / hide "empty" icon and header
            if (this.collection.records.length == "0") {
                this.kanbanBodyContainer.classList.add("kanban-body-container-empty")
                this.kanbanHeaderContainer.style.display = "none"
            } else {
                this.kanbanBodyContainer.classList.remove("kanban-body-container-empty")
                this.kanbanHeaderContainer.style.display = "flex"
            }
        }

        this.kanbanHeader.innerHTML = kanbanHeader
        this.kanbanBody.innerHTML = kanban
    }

    /**
     * Render the content of a Kanban header
     * 
     * @private
     * @ignore
     * @param {object} record 
     * @returns {string} Html source for the column header
     */
    _renderKanbanHeader(record, rowIndex) {
        const color = this._getCategoryColor(this.collection.group[0], record.$name)

        let row = "<div row=\"" + rowIndex + "\" class=\"kanban-column-header\">"
        if (record.$name !== undefined && record.$name !== "") {
            row += `<span class="fas fa-circle kanban-column-header-icon" style="color: ${color}"></span>`
            row += `<div>${record.$name} (${record.$size})</div>`
        } else {
            row += `<span class="fas fa-circle kanban-column-header-icon" style="color: #cccccc"></span>`
            row += `<div>${txtTitleCase("#no category")} (${record.$size})</div>`
        }
        row += "</div>"
        return row
    }

    /**
     * Get the color of a category, if any
     * 
     * @param {string} groupFieldId 
     * @param {*} columnValue 
     * @returns {string} The color of the category
     */
    _getCategoryColor(groupFieldId, columnValue) {
        const field = this.model.getField(groupFieldId)
        const options = field.options || []
        const option = options.find(option => option.value == columnValue)
        return (option) ? option.color : "#cccccc"
    }

    /**
     * Render a Kanban column
     * 
     * @param {object} record 
     * @param {number} rowIndex 
     * @returns {string} Html source for Kanban column container
     */
    _renderKanbanColumnContainer(record, rowIndex) {
        const groupFieldId = this.group[0]
        const value = record.$name
        return "<div row=\"" + rowIndex + "\" fieldid=\"" + groupFieldId + "\" value=\"" + value + "\" class=\"kanban-column-container\">"
    }

    /**
     * Render a single row of the kanban
     * 
     * @private
     * @ignore
     * @param {number} rowIndex
     * @returns {HTMLDivElement} The div containing the row
     */
    _renderKanbanCardContainer(record, cardIndex) {
        return "<div row=\"" + cardIndex + "\" class=\"kanban-record\" recordid=\"" + record.id + "\"></div>"
    }

    /**
     * Render a single record as a Card for 1 week view
     * 
     * @private
     * @ignore
     * @param {object} record
     * @returns {string} Html for a single record
     */
    _renderRecordAsCard(record, index) {
        let recordHtml = "<span class=\"kanban-record-index\">" + index + "</span>"

        this.columns
            .filter(column => column.hidden !== true)
            .forEach(column => {
                let field = this.model.getField(column.id)
                if (!field) return
                
                if (["password", "link"].includes(field.type)) return

                let value = record[column.id]
                if (!value && value !== false && value !== 0) return

                let valueHtml = this._renderSingleValue(field, value, record)
                recordHtml += /*html*/ `
                    <div class="kanban-record-field">
                        <div class="kanban-record-label">${field.label} ${(field.unit) ? `(${field.unit})` : ""}</div>
                        <div class="kanban-record-value">${valueHtml}</div>
                    </div>
                `.removeExtraSpaces()
            })

        if (kiss.screen.isMobile) {
            recordHtml += /*html*/ `
                <div class="a-button kanban-record-button">
                    <span class="kanban-record-button-icon fas fa-exchange-alt"></span>
                    ${txtTitleCase("#move card")}
                </div>
            `.removeExtraSpaces()
        }

        return recordHtml
    }

    /**
     * Render a single value inside a card
     * 
     * @private
     * @ignore
     * @param {object} field - Field to render
     * @param {*} value - Field value
     * @param {object} record - The record, useful for custom renderers
     * @returns {string} Html for the value
     */
    _renderSingleValue(field, value, record) {
        const renderer = kiss.fields.renderers[this.model.id][field.id]
        const type = kiss.fields.getFieldType(field)

        switch (type) {
            case "date":
            case "textarea":
            case "aiTextarea":
            case "select":
            case "directory":
            case "checkbox":
            case "rating":
            case "color":
            case "icon":
            case "attachment":
            case "aiImage":
            case "selectViewColumn":
                return renderer({
                    value,
                    record
                })

            case "number":
            case "slider":
                return renderer({
                    value,
                    record,
                    config: {
                        unit: false
                    }
                })
            default:
                return value
        }
    }

    /**
     * Render the toolbar
     * 
     * @private
     * @ignore
     */
    _renderToolbar() {
        // If the toolbar is already rendered, we just update it
        if (this.isToolbarRendered) {
            this._groupUpdateGroupingFields()
            return
        }

        // New record creation button
        createButton({
            hidden: !this.canCreateRecord,
            class: "kanban-create-record",
            target: "create:" + this.id,
            text: this.config.createRecordText || this.model.name.toTitleCase(),
            icon: "fas fa-plus",
            iconColor: this.color,
            borderWidth: 3,
            borderRadius: "3.2rem",
            maxWidth: (kiss.screen.isMobile && kiss.screen.isVertical()) ? "16rem" : null,
            action: async () => this.createRecord(this.model)
        }).render()

        // Actions button
        createButton({
            hidden: this.showActions === false,
            target: "actions:" + this.id,
            tip: txtTitleCase("actions"),
            icon: "fas fa-bolt",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this._buildActionMenu()
        }).render()

        // Column selection button
        createButton({
            hidden: !this.canSelectFields,
            target: "select:" + this.id,
            tip: txtTitleCase("#display fields"),
            icon: "fas fa-bars fa-rotate-90",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this.showFieldsWindow()
        }).render()

        // Sorting button
        createButton({
            hidden: !this.canSort,
            target: "sort:" + this.id,
            tip: txtTitleCase("to sort"),
            icon: "fas fa-sort",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this.showSortWindow()
        }).render()

        // Filtering button
        createButton({
            hidden: !this.canFilter,
            target: "filter:" + this.id,
            tip: txtTitleCase("to filter"),
            icon: "fas fa-filter",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this.showFilterWindow()
        }).render()

        // Layout button
        createButton({
            hidden: !this.showLayoutButton,
            target: "layout:" + this.id,
            tip: {
                text: txtTitleCase("layout"),
                minWidth: "10rem"
            },
            icon: "fas fa-ellipsis-v",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this._buildLayoutMenu()
        }).render()

        // Grouping
        let groupingFields = this._groupGetModelFields({
            excludeSystemFields: true,
            excludePluginFields: true
        })
        let groupingFieldValues = []

        this.collection.group.forEach(fieldId => {
            let groupingField = groupingFields.find(field => field.value == fieldId)
            if (groupingField) groupingFieldValues.push(groupingField.value)
        })

        createSelect({
            hidden: !this.canGroup,
            target: "group:" + this.id,
            id: "grouping-field:" + this.id,
            label: txtTitleCase("group by"),
            multiple: true,
            allowClickToDelete: true,
            options: groupingFields,
            minWidth: "20rem",
            maxHeight: () => kiss.screen.current.height - 200,
            optionsColor: this.color,
            value: groupingFieldValues,
            styles: {
                "this": "align-items: center;",
                "field-label": "white-space: nowrap;",
                "field-select": "white-space: nowrap;",
            },
            events: {
                change: async function (event) {
                    let groupFields = this.getValue()

                    // Restrict to 6 grouping fields
                    if (groupFields.length > 6) {
                        let fieldGroupSelect = $(this.id)
                        fieldGroupSelect.value = fieldGroupSelect.getValue().slice(0, 6)
                        fieldGroupSelect._renderValues()

                        createDialog({
                            type: "message",
                            title: txtTitleCase("seriously"),
                            icon: "fas fa-exclamation-triangle",
                            message: txtTitleCase("#too many groups"),
                            buttonOKText: txtTitleCase("#understood")
                        })
                        return
                    }

                    // Publish the "grouping" event
                    let viewId = this.id.split(":")[1]
                    publish("EVT_VIEW_GROUPING:" + viewId, groupFields)
                }
            }
        }).render()

        // View refresh button
        if (!kiss.screen.isMobile) {
            createButton({
                target: "refresh:" + this.id,
                tip: txtTitleCase("refresh"),
                icon: "fas fa-undo-alt",
                iconColor: this.color,
                width: "3.2rem",
                events: {
                    click: () => this.reload()
                }
            }).render()
        }

        // Search button
        createButton({
            hidden: !this.canSearch,
            target: "search:" + this.id,
            icon: "fas fa-search",
            iconColor: this.color,
            width: "3.2rem",
            events: {
                click: () => this.showSearchBar()
            }
        }).render()

        // Flag the toolbar as "rendered", so that the method _renderToolbar() is idempotent
        this.isToolbarRendered = true
    }

    /**
     * 
     * OTHER MISC METHODS
     * 
     */

    /**
     * Render the menu to change kanban layout
     * 
     * @private
     * @ignore
     */
    async _buildLayoutMenu() {
        let buttonLeftPosition = $("layout:" + this.id).offsetLeft
        let buttonTopPosition = $("layout:" + this.id).offsetTop

        createMenu({
            top: buttonTopPosition,
            left: buttonLeftPosition,
            items: [
                // Title
                txtTitleCase("cell size"),
                "-",
                // Change row height to  COMPACT
                {
                    icon: "fas fa-circle",
                    iconSize: "0.2rem",
                    text: txtTitleCase("compact"),
                    action: () => {
                        this.columnWidth = 25
                        this.setColumnWidth(this.columnWidth)
                    }
                },
                // Change row height to NORMAL
                {
                    icon: "fas fa-circle",
                    iconSize: "0.6rem",
                    text: txtTitleCase("normal"),
                    action: () => {
                        this.columnWidth = this.defaultColumnWidth
                        this.setColumnWidth(this.columnWidth)
                    }
                },
                // Change row height to MEDIUM
                {
                    icon: "fas fa-circle",
                    iconSize: "1rem",
                    text: txtTitleCase("medium"),
                    action: () => {
                        this.columnWidth = 35
                        this.setColumnWidth(this.columnWidth)
                    }
                },
                // Change row height to TALL
                {
                    icon: "fas fa-circle",
                    iconSize: "1.4rem",
                    text: txtTitleCase("tall"),
                    action: () => {
                        this.columnWidth = 40
                        this.setColumnWidth(this.columnWidth)
                    }
                },
                // Change row height to VERY TALL
                {
                    icon: "fas fa-circle",
                    iconSize: "1.8rem",
                    text: txtTitleCase("very tall"),
                    action: () => {
                        this.columnWidth = 45
                        this.setColumnWidth(this.columnWidth)
                    }
                },
                "-",
                // Reset columns width
                {
                    icon: "fas fa-undo-alt",
                    text: txtTitleCase("#reset view params"),
                    action: () => this.resetLocalViewParameters()
                }
            ]
        }).render()
    }
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-kanban", kiss.ui.Kanban)

/**
 * Shorthand to create a new Kanban. See [kiss.ui.Kanban](kiss.ui.Kanban.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createKanban = (config) => document.createElement("a-kanban").init(config)

;/** 
 * 
 * The **List** derives from [DataComponent](kiss.ui.DataComponent.html).
 * 
 * ------------- WORK IN PROGRESS ------------
 * 
 * @ignore
 * 
 * @param {object} config
 * @param {boolean} [config.startOnMonday]
 * @param {boolean} [config.showWeekend]
 * @param {string} [config.date]
 * @param {string} config.dateField
 * @param {string} [config.timeField]
 * @param {Collection} config.collection - The data source collection
 * @param {object} [config.record] - Record to persist the view configuration into the db
 * @param {object[]} [config.columns] - Where each column is: {title: "abc", type: "text|number|integer|float|date|button", id: "fieldId", button: {config}, renderer: function() {}}
 * @param {string} [config.color] - Hexa color code. Ex: #00aaee
 * @param {boolean} [config.showToolbar] - false to hide the toolbar (default = true)
 * @param {boolean} [config.showActions] - false to hide the custom actions menu (default = true)
 * @param {boolean} [config.canFilter] - false to hide the filter button (default = true)
 * @param {boolean} [config.canEdit] - Can we edit the cells?
 * @param {boolean} [config.canCreateRecord] - Can we create new records from the list?
 * @param {object[]} [config.actions] - Array of menu actions, where each menu entry is: {text: "abc", icon: "fas fa-check", action: function() {}}
 * @param {object[]} [config.buttons] - Array of custom buttons, where each button is: {position: 3, text: "button 3", icon: "fas fa-check", action: function() {}}
 * @param {number|string} [config.width]
 * @param {number|string} [config.height]
 * @returns this
 * 
 * ## Generated markup
 * ```
 * <a-list class="a-list">
 *      <div class="list-toolbar">
 *          <!-- List toolbar items -->
 *      </div>
 *      <div class="list-body">
 *          <!-- List entries here -->
 *      </div>
 * </a-list>
 * ```
 */
kiss.ui.List = class List extends kiss.ui.DataComponent {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the 3 following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const myList = document.createElement("a-list").init(config)
     * ```
     * 
     * Or use the shorthand for it:
     * ```
     * const myList = createList({
     *   id: "my-list",
     *   color: "#00aaee",
     *   collection: kiss.app.collections["meetings"],
     *   
     *   // We can add custom methods, and also override default ones
     *   methods: {
     * 
     *      // Override the createRecord method
     *      createRecord(model) {
     *          // Create a record from this model
     *          console.log(model)
     *      },
     * 
     *      // Override the selectRecord method
     *      selectRecord(record) {
     *          // Show the clicked record
     *          console.log(record)
     *      },
     * 
     *      sayHello: () => console.log("Hello"),
     *   }
     * })
     * 
     * myList.render()
     * ```
     */
    constructor() {
        super()
    }

    /**
     * Generates a List from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config) {
        // This component must be resized with its parent container
        config.autoSize = true

        // Init the parent DataComponent
        super.init(config)

        // If a record is binded to persist the view configuration,
        // we take the view parameters from this record
        if (this.record) {
            this.id = this.record.id
            this.name = this.record.name
            this._initColumns(this.record.config.columns)
        } else {
            this.id = config.id || kiss.tools.shortUid()
            this.name = config.name
            this._initColumns(config.columns)
        }

        // Display options
        this.showToolbar = (config.showToolbar !== false)
        this.showActions = (config.showActions !== false)
        this.canSearch = (config.canSearch !== false)
        this.canFilter = (config.canFilter !== false)
        this.color = config.color || "#00aaee"

        // Behaviour options
        this.canCreateRecord = !!config.canCreateRecord
        this.actions = config.actions || []
        this.buttons = config.buttons || []

        // Build list skeletton markup
        let id = this.id
        this.innerHTML =
            /*html*/
            `<div id="list-toolbar:${id}" class="list-toolbar">
                <div id="create:${id}"></div>
                <div id="actions:${id}"></div>
                <div id="setup:${id}"></div>
                <div id="select:${id}"></div>
                <div id="filter:${id}"></div>
                <div class="spacer"></div>
                <div id="title:${id}" class="list-title"></div>
                <div class="spacer"></div>
                <div id="pager-index:${id}" class="list-toolbar-pager-index"></div>
                <div id="pager-mode:${id}"></div>
                <div id="pager-previous:${id}"></div>
                <div id="pager-next:${id}"></div>
                <div id="layout:${id}"></div>
                <div id="refresh:${id}"></div>
            </div>
            <div id="list-body:${id}" class="list-body">`.removeExtraSpaces()

        // Set list components
        this.list = this.querySelector(".list")
        this.listToolbar = this.querySelector(".list-toolbar")
        this.listBody = this.querySelector(".list-body")

        // Set toolbar visibility
        if (this.showToolbar == false) this.listToolbar.style.display = "none"

        this._initEvents()
        this._initSubscriptions()

        return this
    }

    /**
     * Initialize subscriptions to PubSub
     * 
     * TODO: don't reload the view when records are inserted/deleted/updated outside of the current viewport
     * 
     * @private
     * @ignore
     */
    _initSubscriptions() {
        super._initSubscriptions()

        const viewModelId = this.modelId.toUpperCase()

        this.subscriptions = this.subscriptions.concat([
            // React to database mutations
            subscribe("EVT_DB_INSERT:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData)),
            subscribe("EVT_DB_UPDATE:" + viewModelId, (msgData) => this._updateOneAndReload(msgData)),
            subscribe("EVT_DB_DELETE:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData)),
            subscribe("EVT_DB_INSERT_MANY:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData, 2000)),
            subscribe("EVT_DB_UPDATE_MANY:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData, 2000)),
            subscribe("EVT_DB_DELETE_MANY:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData, 2000)),
            subscribe("EVT_DB_UPDATE_BULK", (msgData) => this._reloadWhenNeeded(msgData, 2000))
        ])
    }

    /**
     * Initialize all list events
     * 
     * @private
     * @ignore
     */
    _initEvents() {
        this.onclick = async (event) => {
            const clickedElement = event.target
            const recordElement = clickedElement.closest(".list-record")
            if (!recordElement) return

            if (recordElement.classList.contains("list-record")) {
                const recordId = recordElement.getAttribute("recordid")
                const record = await this.collection.getRecord(recordId)
                await this.selectRecord(record)
                return event
            }
        }
    }

    /**
     * Load data into the list.
     * 
     * @private
     * @ignore
     */
    async load() {
        try {
            log(`kiss.ui - List ${this.id} - Loading collection <${this.collection.id} (changed: ${this.collection.hasChanged})>`)

            this.collection.filter = this.filter
            this.collection.filterSyntax = this.filterSyntax
            await this.collection.find({}, true)

            this._renderToolbar()
            this._renderBody()

        } catch (err) {
            log(err)
            log(`kiss.ui - List ${this.id} - Couldn't load data properly`)
        }
    }

    /**
     * Reload the data and re-render
     */
    async reload() {
        await this.load()
        this._initColumns()
        this._render()
    }

    /**
     * Update the list layout
     */
    updateLayout() {
        if (this.isConnected) {
            this._render()
        }
    }

    /**
     * Update the list color (toolbar buttons + modal windows)
     * 
     * @param {string} newColor
     */
    async setColor(newColor) {
        this.color = newColor
        Array.from(this.listToolbar.children).forEach(item => {
            if (item && item.firstChild && item.firstChild.type == "button") item.firstChild.setIconColor(newColor)
        })
        this._render()
    }

    /**
     * Render the list for 2, 3 or 6 weeks
     * 
     * @private
     * @ignore
     * @param {number} numberOfWeeks - 1 to 6 (month)
     * @param {boolean} expanded - If true, display large items in the list
     * @returns this
     */
    _render() {
        this._renderBody()
    }

    /**
     * Render records inside the list
     * 
     * @private
     * @ignore
     * @param {boolean} expanded - If true, display large items in the list
     */
    _renderBody() {
        let html
        this.collection.records.forEach(record => {
            html += `<div class="list-record" recordid="${record.id}">${record.id}</div>`
        })
        this.listBody.innerHTML = html
    }

    /**
     * Render a single value inside a card
     * 
     * @private
     * @ignore
     * @param {object} field - Field to render
     * @param {*} value - Field value
     * @param {object} value - The record, useful for custom renderers
     * @returns {string} Html for the value
     */    
    _renderSingleValue(field, value, record) {
        const renderer = kiss.fields.renderers[this.model.id][field.id]
        const type = kiss.fields.getFieldType(field)

        switch (type) {
            case "number":
            case "date":
            case "textarea":
            case "aiTextarea":
            case "select":
            case "directory":
            case "checkbox":
            case "slider":
            case "rating":
            case "color":
            case "icon":
            case "attachment":
            case "aiImage":
            case "selectViewColumn":
                return renderer({value, record, view: this})
            default:
                return value
        }
    }

    /**
     * Update a single record then reload the view if required.
     * 
     * @private
     * @ignore
     * @param {object} msgData - The original pubsub message
     */
    async _updateOneAndReload(msgData) {
        const filterFields = kiss.db.mongo.getFilterFields(this.filter)
        let filterHasChanged = false

        let updates = msgData.data
        for (let fieldId of Object.keys(updates)) {
            if (filterFields.indexOf(fieldId) != -1) filterHasChanged = true
        }

        this._updateRecord(msgData.id)

        if (filterHasChanged) {
            this._reloadWhenNeeded(msgData, 2000)
        }
    }

    /**
     * Update a single record of the list.
     * 
     * Does nothing if the record is not displayed on the active page.
     * 
     * @private
     * @ignore
     * @param {string} recordId 
     */
    _updateRecord(recordId) {
        const record = this.collection.getRecord(recordId)
        const recordNode = document.querySelector(`.list-record[recordid="${recordId}"]`)

        if (recordNode) {
            const replacementNode = document.createElement("div")
            replacementNode.classList.add("list-record")
            replacementNode.style.borderColor = this.model.color
            replacementNode.innerHTML = "TEST" //this._renderRecordAsCard(record)
            recordNode.parentNode.replaceChild(replacementNode, recordNode)
            replacementNode.setAttribute("recordid", recordId)
        }
    }

    /**
     * Render the toolbar
     * 
     * @private
     * @ignore
     */
    _renderToolbar() {
        if (this.isToolbarRendered) return
        this.isToolbarRendered = true

        // New record creation button
        createButton({
            hidden: !this.canCreateRecord,
            class: "list-create-record",
            target: "create:" + this.id,
            text: this.model.name.toTitleCase(),
            icon: "fas fa-plus",
            iconColor: this.color,
            borderWidth: "3px",
            borderRadius: "32px",
            action: async () => this.createRecord(this.model)
        }).render()

        // Column selection button
        createButton({
            target: "select:" + this.id,
            tip: txtTitleCase("#display fields"),
            icon: "fas fa-bars fa-rotate-90",
            iconColor: this.color,
            width: 32,
            action: () => this.showFieldsWindow()
        }).render()

        // Filtering button
        createButton({
            hidden: !this.canFilter,
            target: "filter:" + this.id,
            tip: txtTitleCase("to filter"),
            icon: "fas fa-filter",
            iconColor: this.color,
            width: 32,
            action: () => this.showFilterWindow()
        }).render()

        // Pager previous
        createButton({
            target: "pager-previous:" + this.id,
            icon: "fas fa-chevron-left",
            iconColor: this.color,
            width: 32,
            events: {
                click: () => {
                }
            }
        }).render()

        // Pager next
        createButton({
            target: "pager-next:" + this.id,
            icon: "fas fa-chevron-right",
            iconColor: this.color,
            width: 32,
            events: {
                click: () => {
                }
            }
        }).render()

        // View refresh button
        if (!kiss.screen.isMobile) {
            createButton({
                target: "refresh:" + this.id,
                icon: "fas fa-undo-alt",
                iconColor: this.color,
                width: 32,
                events: {
                    click: () => this.reload()
                }
            }).render()
        }
    }
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-list", kiss.ui.List)

/**
 * Shorthand to create a new List. See [kiss.ui.List](kiss.ui.List.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createList = (config) => document.createElement("a-list").init(config)

;/** 
 * 
 * The **Timeline** derives from [DataComponent](kiss.ui.DataComponent.html).
 * 
 * It's a [powerful timeline](https://kissjs.net/#ui=start&section=timeline) with the following features:
 * - many range of periods (1 week, 2 weeks, 3 weeks, 1 month, 2 months, 3 months, 4 months, 6 months, 1 year)
 * - panning left and right to navigate in time
 * - choosing the fields to display in the bars
 * - choosing the field to display in the first column
 * - choosing the field to use as the start date
 * - choosing the field to use as the end date
 * - choosing the field to use as the color of the bars
 * - multi-fields sorting
 * - complex filtering with combination of AND/OR filters
 * - mutli-level grouping
 * - virtual scrolling which also works with grouped data
 * 
 * @param {object} config
 * @param {string} [config.date] - The initial date to display in the timeline (default = today)
 * @param {string} [config.titleField] - The field to use as the title for the first column (default = first text field found in the model, or the record id if no text field was found)
 * @param {boolean} [config.startDateField] - The field to use as the start date for the timeline (default = first date field found in the model, or the creation date if no date field was found)
 * @param {boolean} [config.endDateField] - The field to use as the end date for the timeline (default = second date field found in the model, or the modification date if no date field was found)
 * @param {string} [config.period] - "1 week" | "2 weeks" | "3 weeks" | "1 month" (default) | "2 months" | "3 months" | "4 months" | "6 months" | "1 year"
 * @param {boolean} [config.colorField] - The field to use as the color for the timeline (default = none)
 * @param {Collection} config.collection - The data source collection
 * @param {object} [config.record] - Record to persist the view configuration into the db
 * @param {object[]} [config.columns] - Where each column is: {title: "abc", type: "text|number|integer|float|date|button", id: "fieldId", button: {config}, renderer: function() {}}
 * @param {string} [config.color] - Hexa color code. Ex: #00aaee
 * @param {string} [config.rowHeight] - CSS row height in rem. Important! Use rem and not pixels. Ex: 4rem
 * @param {boolean} [config.showColumnType] - true to display an icon in the header indicating the column type (default = false)
 * @param {boolean} [config.showToolbar] - false to hide the toolbar (default = true)
 * @param {boolean} [config.showPagerIndex] - false to hide the pager index (default = true)
 * @param {boolean} [config.showScroller] - false to hide the virtual scroller (default = true)
 * @param {boolean} [config.showActions] - false to hide the custom actions menu (default = true)
 * @param {boolean} [config.showLayoutButton] - false to hide the button to adjust the layout (default = true)
 * @param {boolean} [config.showGroupButtons] - false to hide the button to expand/collapse groups (default = true)
 * @param {boolean} [config.canSearch] - false to hide the search button (default = true)
 * @param {boolean} [config.canSelect] - false to hide the selection checkboxes (default = true)
 * @param {boolean} [config.canSort] - false to hide the sort button (default = true)
 * @param {boolean} [config.canFilter] - false to hide the filter button (default = true)
 * @param {boolean} [config.canGroup] - false to hide the group button (default = true)
 * @param {boolean} [config.canSelectFields] - Can we select the fields (= columns) to display in the table? (default = true)
 * @param {boolean} [config.canChangePeriod] - false to hide the possibility to change period (1 month, 2 weeks...) (default = true)
 * @param {boolean} [config.canCreateRecord] - Can we create new records from the timeline?
 * @param {boolean} [config.createRecordText] - Optional text to insert in the button to create a new record, instead of the default model's name
 * @param {boolean} [config.iconAction] - Font Awesome icon class to display the "open record" symbol. Defaults to "far fa-file-alt"
 * @param {object[]} [config.actions] - Array of menu actions, where each menu entry is: {text: "abc", icon: "fas fa-check", action: function() {}}
 * @param {number|string} [config.width]
 * @param {number|string} [config.height]
 * @returns this
 * 
 * ## Generated markup
 * ```
 * <a-timeline class="a-timeline">
 *      <div class="timeline-toolbar">
 *          <!-- Timeline toolbar items -->
 *      </div>
 *      <div class="timeline-header-container">
 *          <div class="timeline-header-1st-column">
 *              <!-- Header 1st column -->
 *          </div>
 *          <div class="timeline-header">
 *              <!-- Header other columns -->
 *          </div>
 *      </div>
 *      <div class="timeline-body-container">
 *          <div class="timeline-body-1st-column">
 *              <!-- Body 1st column -->
 *          </div>
 *          <div class="timeline-body">
 *              <!-- Body other columns -->
 *          </div>
 *      </div>
 *      <div class="timeline-virtual-scroller-container">
 *          <div class="timeline-virtual-scroller"></div>
 *      </div>
 * </a-timeline>
 * ```
 */
kiss.ui.Timeline = class Timeline extends kiss.ui.DataComponent {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const myTimeline = document.createElement("a-timeline").init(config)
     * ```
     * 
     * Or use the shorthand for it:
     * ```
     * const myTimeline = createTimeline({
     *   id: "my-table",
     *   color: "#00aaee",
     *   collection: kiss.app.collections["projects"],
     *   
     *   // Params that are specific to the timeline
     *   startDateField: "projectStartDate",
     *   endDateField: "projectEndDate",
     *   titleField: "projectName",
     *   period: "1 month",
     * 
     *   // Columns must match the Model's fields
     *   columns: [
     *       {
     *           id: "firstName", // Must match the model's field id
     *           type: "text",
     *           title: "First name",
     *       },
     *       {
     *           id: "lastName",
     *           type: "text",
     *           title: "Last name",
     *       },
     *       {
     *           id: "birthDate",
     *           type: "date",
     *           title: "Birth date"
     *       }
     *   ],
     * 
     *   // We can define a menu with custom actions
     *   actions: [
     *       {
     *           text: "Group by country and city",
     *           icon: "fas fa-sort",
     *           action: () => $("my-table").groupBy(["Country", "City"])
     *       }
     *   ],
     *   
     *   // We can add custom methods, and also override default ones
     *   methods: {
     * 
     *      // Override the createRecord method
     *      createRecord(model) {
     *          // Create a record from this model
     *          console.log(model)
     *      },
     * 
     *      // Override the selectRecord method
     *      selectRecord(record) {
     *          // Show the clicked record
     *          console.log(record)
     *      },
     * 
     *      sayHello: () => console.log("Hello"),
     *   }
     * })
     * 
     * myTimeline.render()
     * ```
     */
    constructor() {
        super()
    }

    /**
     * Generates a Timeline from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config) {
        // This component must be resized with its parent container
        config.autoSize = true

        // Init the parent DataComponent
        super.init(config)

        // Options
        this.showColumnType = !!config.showColumnType
        this.showToolbar = (config.showToolbar !== false)
        this.showPagerIndex = (config.showPagerIndex !== false)
        this.showScroller = (config.showScroller !== false)
        this.showActions = (config.showActions !== false)
        this.showSetup = (config.showSetup !== false)
        this.showLayoutButton = (config.showLayoutButton !== false)
        this.showGroupButtons = (config.showGroupButtons !== false)
        this.canSearch = (config.canSearch !== false)
        this.canSort = (config.canSort !== false)
        this.canFilter = (config.canFilter !== false)
        this.canGroup = (config.canGroup !== false)
        this.color = config.color || "#00aaee"
        this.iconAction = config.iconAction || "far fa-file-alt"
        this.canSelect = (config.canSelect !== false)
        this.canSelectFields = (config.canSelectFields !== false)
        this.canChangePeriod = (config.canChangePeriod !== false)
        this.actions = config.actions || []

        this.defaultRowHeight = 4 // in rem
        this.firstColumnWidth = 10 // in tem
        this.resizerWidth = 1.5 // in rem
        this.defaultDayWidth = 50 // in pixels

        // Build timeline skeletton markup
        let id = this.id
        this.innerHTML =
            /*html*/
            `<div class="timeline">
                <div id="timeline-toolbar:${id}" class="timeline-toolbar">
                    <div id="search-field:${id}"></div>
                    <div id="create:${id}"></div>
                    <div id="actions:${id}"></div>
                    <div id="setup:${id}"></div>
                    <div id="select:${id}"></div>
                    <div id="sort:${id}"></div>
                    <div id="filter:${id}"></div>
                    <div id="group:${id}"></div>
                    <div id="collapse:${id}"></div>
                    <div id="expand:${id}"></div>
                    <div id="refresh:${id}"></div>
                    <div id="search:${id}"></div>
                    <div id="hierarchy:${id}"></div>
                    <div id="explode:${id}"></div>
                    <div class="spacer"></div>
                    <div id="pager-index:${id}" class="timeline-toolbar-pager-index"></div>
                    <div id="pager-mode:${id}"></div>
                    <div id="pager-previous:${id}"></div>
                    <div id="pager-next:${id}"></div>
                    <div id="pager-today:${id}"></div>
                    <div id="layout:${id}"></div>
                </div>

                <div class="timeline-header-container">
                    <div class="timeline-header-1st-column"></div>
                    <div id="timeline-header:${id}" class="timeline-header"></div>
                </div>

                <div class="timeline-body-container">
                    <div class="timeline-body-1st-column"></div>
                    <div id="timeline-body:${id}" class="timeline-body"></div>
                </div>

                <div class="timeline-virtual-scroller-container">
                    <div class="timeline-virtual-scroller"></div>
                </div>
            </div>`.removeExtraSpaces()

        // Set timeline components
        this.timeline = this.querySelector(".timeline")
        this.timelineToolbar = this.querySelector(".timeline-toolbar")
        this.timelineHeader = this.querySelector(".timeline-header")
        this.timelineHeaderContainer = this.querySelector(".timeline-header-container")
        this.timelineBody = this.querySelector(".timeline-body")
        this.timelineBodyContainer = this.querySelector(".timeline-body-container")
        this.timelineHeader1stColumn = this.querySelector(".timeline-header-1st-column")
        this.timelineBody1stColumn = this.querySelector(".timeline-body-1st-column")
        this.timelineScrollerContainer = this.querySelector(".timeline-virtual-scroller-container")
        this.timelineScroller = this.querySelector(".timeline-virtual-scroller")
        this.timelinePagerIndex = this.querySelector(".timeline-toolbar-pager-index")

        this._initTexts()
            ._initColumns(config.columns)
            ._initSize(config)
            ._initTimelineParams(config)
            ._initElementsVisibility()
            ._initEvents()
            ._initSubscriptions()

        return this
    }

    /**
     * 
     * TIMELINE METHODS
     * 
     */

    /**
     * Load data into the timeline.
     * 
     * @ignore
     */
    async load() {
        try {
            log(`kiss.ui - Timeline ${this.id} - Loading collection <${this.collection.id} (changed: ${this.collection.hasChanged})>`)

            // Apply filter, sort, group, projection
            // Priority is given to local config, then to the passed collection, then to default
            this.collection.filter = this.filter
            this.collection.filterSyntax = this.filterSyntax
            this.collection.sort = this.sort
            this.collection.sortSyntax = this.sortSyntax
            this.collection.group = this.group
            this.collection.projection = this.projection
            this.collection.groupUnwind = this.groupUnwind

            // Load records
            await this.collection.find()

            // Hide the virtual scroller while the timeline is being built
            this._hideScroller()

            // Try to adjust columns width from local config
            this._columnsAdjustWidthFromLocalStorage()

            // Get the selected records
            this.getSelection()

            // Render the timeline toolbar
            this._renderToolbar()

            // Get paging params (skip & limit)
            this.skip = 0
            this._setLimit()

            // Re-compute all the sizes + render
            this.updateLayout()

        } catch (err) {
            log(`kiss.ui - Timeline ${this.id} - Couldn't load data properly`)
        }
    }

    /**
     * Display the timeline one day before
     * 
     * @returns this
     */
    previous() {
        let shift = 1
        if (this.period == "1 year") shift = 2
        let previousDate = kiss.formula.ADJUST_DATE(this.startDate, 0, 0, -shift, 0, 0, 0, "date")
        this.date = new Date(previousDate)
        return this._render()
    }

    /**
     * Display the timeline one day after
     * 
     * @returns this
     */
    next() {
        let shift = 1
        if (this.period == "1 year") shift = 2
        let nextDate = kiss.formula.ADJUST_DATE(this.startDate, 0, 0, shift, 0, 0, 0, "date")
        this.date = new Date(nextDate)
        return this._render()
    }

    /**
     * Generic method to refresh / re-render the view
     * 
     * Note: used in dataComponent (parent class) showSearchBar method.
     * This method is invoked to refresh the view after a full-text search has been performed
     */
    refresh() {
        this._render()
    }

    /**
     * Update the timeline size (recomputes its width and height functions)
     */
    updateLayout() {
        if (this.isConnected) {
            this._setWidth()
            this._setHeight()
            this._setLimit()
            this._renderPagerIndex()
            this._render()
            this._renderSelectionRestore()
        }
    }
    
    /**
     * Update the timeline color (toolbar buttons + modal windows)
     * 
     * @param {string} newColor
     */
    async setColor(newColor) {
        this.color = newColor
        Array.from(this.timelineToolbar.children).forEach(item => {
            if (item && item.firstChild && item.firstChild.type == "button") item.firstChild.setIconColor(newColor)
        })
    }

    /**
     * Highlight a chosen record
     * 
     * @param {string} recordId 
     */
    highlightRecord(recordId) {
        let index = this.goToRecord(recordId)
        if (index != -1) this._rowHighlight(index)
    }

    /**
     * Scroll to a chosen record
     * 
     * @param {string} recordId
     * @returns {number} The index of the found record, or -1 if not found
     */
    goToRecord(recordId) {
        let index = this._rowFindIndex(recordId)
        if (index != -1) this.goToIndex(index)
        return index
    }

    /**
     * Scroll to a chosen index
     * 
     * @param {number} index
     */
    goToIndex(index) {
        this.skip = index
        this._render()
    }

    /**
     * Show the window to setup the timeline:
     * - source field for the first column
     * - source start date field
     * - source end date field
     * - prefered layout (1 month, 2 months, ...)
     */
    showSetupWindow() {
        const dateFields = this.model.getFieldsByType("date")
            .filter(field => !field.deleted)
            .map(field => {
                return {
                    value: field.id,
                    label: field.label.toTitleCase()
                }
            })

        const titleFields = this.model.fields
            .filter(field => !field.deleted)
            .map(field => {
                return {
                    value: field.id,
                    label: field.label.toTitleCase()
                }
            })

        const selectFields = this.model.getFieldsByType("select")
            .filter(field => !field.deleted)
            .map(field => {
                return {
                    value: field.id,
                    label: field.label.toTitleCase()
                }
            })          

        createPanel({
            icon: "fas fa-align-left",
            title: txtTitleCase("setup the timeline"),
            headerBackgroundColor: this.color,
            modal: true,
            draggable: true,
            closable: true,
            align: "center",
            verticalAlign: "center",
            width: "40rem",

            defaultConfig: {
                labelPosition: "top",
                optionsColor: this.color
            },

            items: [
                // Source start date field
                {
                    type: "select",
                    id: "timeline-startDatefield:" + this.id,
                    label: txtTitleCase("#timeline start date"),
                    options: dateFields,
                    maxHeight: () => kiss.screen.current.height - 200,
                    value: this.startDateField,
                    events: {
                        change: async function () {
                            let startDateField = this.getValue()
                            let viewId = this.id.split(":")[1]
                            publish("EVT_VIEW_SETUP:" + viewId, {
                                startDateField
                            })
                        }
                    }
                },
                // Source end date field
                {
                    type: "select",
                    id: "timeline-endDateField:" + this.id,
                    label: txtTitleCase("#timeline end date"),
                    options: dateFields,
                    maxHeight: () => kiss.screen.current.height - 200,
                    value: this.endDateField,
                    events: {
                        change: async function () {
                            let endDateField = this.getValue()
                            let viewId = this.id.split(":")[1]
                            publish("EVT_VIEW_SETUP:" + viewId, {
                                endDateField
                            })
                        }
                    }
                },
                // Source title field
                {
                    type: "select",
                    id: "timeline-titleField:" + this.id,
                    label: txtTitleCase("#timeline title field"),
                    options: titleFields,
                    maxHeight: () => kiss.screen.current.height - 200,
                    value: this.titleField,
                    events: {
                        change: async function () {
                            let titleField = this.getValue()
                            let viewId = this.id.split(":")[1]
                            publish("EVT_VIEW_SETUP:" + viewId, {
                                titleField
                            })
                        }
                    }
                },
                // Source color field
                {
                    type: "select",
                    id: "timeline-colorField:" + this.id,
                    label: txtTitleCase("#timeline color field"),
                    options: selectFields,
                    maxHeight: () => kiss.screen.current.height - 200,
                    value: this.colorField,
                    events: {
                        change: async function () {
                            let colorField = this.getValue()
                            let viewId = this.id.split(":")[1]
                            publish("EVT_VIEW_SETUP:" + viewId, {
                                colorField
                            })
                        }
                    }
                },
                // Default period
                {
                    type: "select",
                    id: "timeline-period:" + this.id,
                    label: txtTitleCase("#timeline period"),
                    options: [
                        {
                            label: "1 " + txtTitleCase("week"),
                            value: "1 week"
                        },
                        {
                            label: "2 " + txtTitleCase("weeks"),
                            value: "2 weeks"
                        },
                        {
                            label: "3 " + txtTitleCase("weeks"),
                            value: "3 weeks"
                        },
                        {
                            label: "1 " + txtTitleCase("month"),
                            value: "1 month"
                        },
                        {
                            label: "2 " + txtTitleCase("months"),
                            value: "2 months"
                        },                        
                        {
                            label: "3 " + txtTitleCase("months"),
                            value: "3 months"
                        },
                        {
                            label: "4 " + txtTitleCase("months"),
                            value: "4 months"
                        },
                        {
                            label: "6 " + txtTitleCase("months"),
                            value: "6 months"
                        },
                        {
                            label: "1 " + txtTitleCase("year"),
                            value: "1 year"
                        },
                    ],
                    value: this.period || "1 month",
                    events: {
                        change: async function () {
                            let period = this.getValue()
                            let viewId = this.id.split(":")[1]
                            publish("EVT_VIEW_SETUP:" + viewId, {
                                period
                            })
                        }
                    }
                }                
            ]
        }).render()
    }

    /**
     * Show the window just under the sorting button
     */
    showSortWindow() {
        let sortButton = $("sort:" + this.id)
        const box = sortButton.getBoundingClientRect()
        super.showSortWindow(box.left, box.top + 40, this.color)
    }

    /**
     * Show the window just under the fields selector button
     */
    showFieldsWindow() {
        let selectionButton = $("select:" + this.id)
        const box = selectionButton.getBoundingClientRect()
        super.showFieldsWindow(box.left, box.top + 40, this.color)
    }

    /**
     * Show the window just under the filter button
     */
    showFilterWindow() {
        super.showFilterWindow(null, null, this.color)
    }

    /**
     * Set the timeline row height
     * 
     * @param {number} height - The row height in pixels
     */
    setRowHeight(height) {
        this.rowHeight = height
        document.documentElement.style.setProperty("--datacomponent-cell-height", this.rowHeight + "rem")
        document.documentElement.style.setProperty("--datacomponent-group-cell-height", this.rowHeight + "rem")

        // Save new row height locally
        const localStorageId = "config-view-timeline-" + this.id + "-row-height"
        localStorage.setItem(localStorageId, this.rowHeight)
        this.reload()
    }

    /**
     * Switch to search mode
     * 
     * Show/hide only the necessary buttons in this mode.
     */
    switchToSearchMode() {
        if (kiss.screen.isMobile) {
            $("create:" + this.id).hide()
            $("search:" + this.id).hide()
            $("expand:" + this.id).hide()
            $("collapse:" + this.id).hide()
        }
    }

    /**
     * Reset search mode
     */
    resetSearchMode() {
        if (kiss.screen.isMobile) {
            $("create:" + this.id).show()
            $("search:" + this.id).show()
            $("expand:" + this.id).show()
            $("collapse:" + this.id).show()
        }
    }

    /**
     * Re-render the virtual scrollbar when the timeline is re-connected to the DOM
     * 
     * @private
     * @ignore
     */
    _afterConnected() {
        super._afterConnected()
        this._hideScroller()
        this._renderScroller()
    }    

    /**
     * Init the localized texts
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initTexts() {
        this.months = [
            txtTitleCase("january"),
            txtTitleCase("february"),
            txtTitleCase("march"),
            txtTitleCase("april"),
            txtTitleCase("may"),
            txtTitleCase("june"),
            txtTitleCase("july"),
            txtTitleCase("august"),
            txtTitleCase("september"),
            txtTitleCase("october"),
            txtTitleCase("november"),
            txtTitleCase("december")
        ]

        this.weekDays = [
            txtTitleCase("sunday"),
            txtTitleCase("monday"),
            txtTitleCase("tuesday"),
            txtTitleCase("wednesday"),
            txtTitleCase("thursday"),
            txtTitleCase("friday"),
            txtTitleCase("saturday")
        ]

        if (kiss.screen.isMobile && kiss.screen.isVertical()) {
            this.months = this.months.map(month => month.substring(0, 4) + ".")
        }

        return this
    }

    /**
     * Initialize all timeline events
     * 
     * @private
     * @ignore
     */
    _initEvents() {
        // Drag the timeline left and right
        let startX
        let isDragging = false
        
        const handleMouseMove = (e) => {
            if (isDragging) {
                let currentX = e.clientX
                let diffX = currentX - startX
                const threshold = Math.max(this.dayWidth, 30)
        
                if (diffX > threshold) {
                    this.previous()
                    startX = currentX
                } else if (diffX < -threshold) {
                    this.next()
                    startX = currentX
                }
            }
        }
        
        function handleMouseUp(e) {
            isDragging = false
            document.removeEventListener('mousemove', handleMouseMove)
            document.removeEventListener('mouseup', handleMouseUp)
        }
        
        this.timelineBody.addEventListener('mousedown', function(e) {
            e.preventDefault()
            startX = e.clientX
            isDragging = true
            document.addEventListener('mousemove', handleMouseMove)
            document.addEventListener('mouseup', handleMouseUp)
        })

        // Clicked on the checkbox to deselect all records
        this.timelineHeader1stColumn.onclick = (event) => {
            if (event.target.classList.contains("timeline-header-checkbox")) {
                this.toggleSelection()
            }
        }

        // Clicked on the 1st column resizer
        this.timelineHeader1stColumn.onmousedown = (event) => {
            const clickedElement = event.target
            if (clickedElement.classList.contains("timeline-column-header-resizer")) {
                this._columnsResizeWithDragAndDrop(event, clickedElement)
            }
        }

        // Clicked somewhere in the timeline
        this.onclick = async (event) => {
            const clickedElement = event.target
            const clickedParent = clickedElement.parentNode

            // SELECT / DESELECT A ROW
            // = clicked on the checkbox to select a record
            if (clickedElement.classList.contains("timeline-row-checkbox")) {
                const rowIndex = clickedParent.getAttribute("row")
                this._rowToggleSelect(rowIndex)
                return event
            }

            // SELECT A RECORD (GENERALLY TO OPEN IT AS A FORM)
            // = clicked on the 1st column cell to expand a record and display it as a form
            if (Array.from(clickedParent.classList).concat(Array.from(clickedElement.classList)).indexOf("timeline-cell-1st") != -1) {
                const cell = clickedElement.closest("div")
                const recordId = cell.getAttribute("recordid")
                const record = await this.collection.getRecord(recordId)
                await this.selectRecord(record)
                return event
            }

            // EXPAND / COLLAPSE A GROUP
            // = clicked on a group section
            if (clickedParent.classList.contains("timeline-group-row")) {
                const rowIndex = clickedParent.getAttribute("row")
                const record = this.collection.records[Number(rowIndex)]
                const groupId = record.$groupId
                const groupLevel = record.$groupLevel

                this._groupToggle(groupId, groupLevel, rowIndex)
                return event
            }

            // = clicked on the group expand/collapse
            const clickedGroup = clickedElement.closest(".timeline-group")
            if (clickedGroup) {
                const rowIndex = clickedGroup.getAttribute("row")
                const record = this.collection.records[Number(rowIndex)]
                const groupId = record.$groupId
                const groupLevel = record.$groupLevel

                this._groupToggle(groupId, groupLevel, rowIndex)
                return event
            }

            // OPEN A RECORD
            if ((clickedElement.classList.contains("timeline-cell")) || clickedParent.classList.contains("timeline-cell")) {
                const row = clickedElement.closest(".timeline-row")
                const recordId = row.getAttribute("recordid")
                const record = await this.collection.getRecord(recordId)
                await this.selectRecord(record)
                return event
            }
        }

        // Sync horizontal scrolling between body and header
        this.timelineBody.onscroll = () => {
            this.timelineHeader.scrollLeft = this.timelineBody.scrollLeft
        }

        /*
         * VIRTUAL SCROLLING MANAGEMENT
         */

        //
        // Observe mousewheel event to scroll
        //
        this.onmousewheel = this.onwheel = (event) => {
            // Scroll must happen inside the timeline body
            if (!event.target.closest(".timeline-body-container")) return

            if (event.wheelDelta > 0) {
                this._virtualScrollUp()
            } else {
                this._virtualScrollDown()
            }

            // Sync the virtual scrollbar position
            this._renderScrollerPosition()

            // Update pager
            this._renderPagerIndex()
        }

        //
        // Enable onscroll event when clicking on the virtual scrollbar
        //
        this.timelineScrollerContainer.onmousedown = (event) => {
            this.preventScroll = false
        }

        //
        // Render the timeline at the correct row index when moving the virtual scrollbar
        //
        this.timelineScrollerContainer.onscroll = (event) => {
            if (this.preventScroll == true) return false

            // Clear our timeout throughout the scroll
            window.clearTimeout(this.isScrolling)

            // Set a timeout to run after scrolling ends, in order to smooth the rendering
            this.isScrolling = null

            this.isScrolling = setTimeout(() => {
                // Compute the scroll as a percentage of the total height
                let percent = event.target.scrollTop / (this.timelineScroller.offsetHeight - this.timelineBody.offsetHeight)

                // Deduce how many records to skip
                let recordIndex = Math.round((this.collection.count - this.limit) * percent)
                let newSkip = Math.floor(Math.min(recordIndex, this.collection.records.length - this.limit))

                // Re-render the timeline if the skip value has changed
                if (newSkip != this.skip) {
                    this.skip = Math.max(newSkip, 0)
                    this._render()
                }
            }, 10)
        }

        return this
    }

    /**
     * Initialize subscriptions to PubSub
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initSubscriptions() {
        super._initSubscriptions()

        const viewModelId = this.modelId.toUpperCase()

        this.subscriptions = this.subscriptions.concat([
            // Local events (not coming from websocket)
            subscribe("EVT_VIEW_SETUP:" + this.id, (msgData) => this._updateConfig(msgData)),

            // React to database mutations
            subscribe("EVT_DB_INSERT:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData)),
            subscribe("EVT_DB_UPDATE:" + viewModelId, (msgData) => this._updateOneAndReload(msgData)),
            subscribe("EVT_DB_DELETE:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData)),
            subscribe("EVT_DB_INSERT_MANY:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData, 2000)),
            subscribe("EVT_DB_UPDATE_MANY:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData, 2000)),
            subscribe("EVT_DB_DELETE_MANY:" + viewModelId, (msgData) => this._reloadWhenNeeded(msgData, 2000)),
            subscribe("EVT_DB_UPDATE_BULK", (msgData) => this._reloadWhenNeeded(msgData, 2000))
        ])

        return this
    }

    /**
     * Define the specific timeline params:
     * - the initial date
     * - start date field used to display the timeline
     * - end date field used to display the timeline
     * - title field used to display in the first column
     * - displayed period (1 month, 2 months...)
     * 
     * @private
     * @ignore
     * @param {object} config - {date, startDateField, endDateField, titleField, period, colorField}
     * @eturns this
     */
    _initTimelineParams(config) {
        this.date = this.config.date || new Date()
        if (typeof this.date == "string") this.date = new Date(this.date)

        if (this.record) {
            this.startDateField = config.startDateField || this.record.config.startDateField
            this.endDateField = config.endDateField || this.record.config.endDateField
            this.titleField = config.titleField || this.record.config.titleField
            this.colorField = config.colorField || this.record.config.colorField
            this.period = config.period || this.record.config.period || "1 month"

        } else {
            this.startDateField = config.startDateField || this.config.startDateField
            this.endDateField = config.endDateField || this.config.endDateField
            this.titleField = config.titleField || this.config.titleField
            this.colorField = config.colorField || this.config.colorField
            this.period = config.period || this.config.period || "1 month"
        }

        // Defaults to the first date field, or the creation date if no date field was found
        if (!this.startDateField) {
            let modelDateFields = this.model.getFieldsByType(["date"])
            if (modelDateFields.length != 0) {
                this.startDateField = modelDateFields[0].id
            } else {
                this.startDateField = "createdAt"
            }
        }

        // Defaults to the second date field, or the modification date if no date field was found
        if (!this.endDateField) {
            let modelDateFields = this.model.getFieldsByType(["date"])
            if (modelDateFields.length > 1) {
                this.endDateField = modelDateFields[1].id
            } else {
                this.endDateField = "updatedAt"
            }
        }

        // Defaults to the first text field, or the record id if no text field was found
        if (!this.titleField) {
            let modelTextFields = this.model.getFieldsByType(["text"])
            if (modelTextFields.length != 0) {
                this.titleField = modelTextFields[0].id
            } else {
                this.titleField = "id"
            }
        }

        this.periods = {
            "1 week": 7,
            "2 weeks": 14,
            "3 weeks": 21,
            "1 month": 31,
            "2 months": 61,
            "3 months": 92,
            "4 months": 122,
            "6 months": 182,
            "1 year": 365
        }

        return this
    }

    /**
     * Set header, toolbar and scroller visibility
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initElementsVisibility() {
        if (this.showToolbar === false) this.timelineToolbar.style.display = "none"
        if (this.showScroller === false) this.timelineScrollerContainer.style.display = "none"
        if (this.showPagerIndex === false) this.timelinePagerIndex.style.display = "none"
        return this
    }

    /**
     * Initialize timeline sizes
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initSize(config) {
        this._initRowHeight(config)

        if (config.width) {
            this._setWidth()
        } else {
            this.style.width = this.config.width = `calc(100%)`
        }

        if (config.height) {
            this._setHeight()
        } else {
            this.style.height = this.config.height = `calc(100% - 1rem)`
        }
        return this
    }

    /**
     * Init the row height according to local settings and/or config
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initRowHeight(config = {}) {
        this.rowHeight = config.rowHeight || this._getRowHeightFromLocalStorage()
        document.documentElement.style.setProperty("--datacomponent-cell-height", this.rowHeight + "rem")
        document.documentElement.style.setProperty("--datacomponent-group-cell-height", this.rowHeight + "rem")
        return this
    }

    /**
     * Init the day width according to local settings and/or config
     * 
     * @private
     * @ignore
     * @param {object} config 
     * @returns this
     */
    _initDayWidth(config = {}) {
        this.dayWidth = config.dayWidth || this._computeDayWidth()
        document.documentElement.style.setProperty("--timeline-day-width", this.dayWidth + "px")
        return this
    }

    /**
     * Set the timeline day width
     * 
     * @private
     * @ignore
     * @param {number} height - The day width in pixels
     */
    _setDayWidth(width) {
        this.dayWidth = width
        this._render()
    }

    /**
     * Generates a simple day id
     * 
     * @private
     * @ignore
     * @param {number} day
     * @param {number} month
     * @param {number} year
     * @returns {string} String like "2023-07-17"
     */
    _getDayId(day, month, year) {
        return year + "-" + (month + "").padStart(2, "0") + "-" + (day + "").padStart(2, "0")
    }

    /**
     * Compute the day width according to the current screen width and the number of days to display
     * 
     * @private
     * @ignore
     * @returns {number} The day width in pixels
     */
    _computeDayWidth() {
        return Math.max(this._getBodyWidth() / this.periods[this.period], 5)
    }

    /**
     * Get the current timeline body width, depending on the screen width and the position of the timeline
     * 
     * @private
     * @ignore
     * @returns {number} The body width in pixels
     */
    _getBodyWidth() {
        return kiss.screen.current.width - this.timelineBody.getBoundingClientRect().left
    }

    /**
     * Get the number of days to display in the timeline
     * 
     * @private
     * @ignore
     * @returns {number} The number of days
     */
    _getNumberOfDays() {
        return Math.floor(this._getBodyWidth() / this.dayWidth)
    }

    /**
     * Update a single record then reload the view if required
     * 
     * @private
     * @ignore
     * @param {object} msgData - The original pubsub message
     */
    async _updateOneAndReload(msgData) {
        const sortFields = this.sort.map(sort => Object.keys(sort)[0])
        const filterFields = kiss.db.mongo.getFilterFields(this.filter)

        let groupHasChanged = false
        let sortHasChanged = false
        let filterHasChanged = false

        let updates = msgData.data
        for (let fieldId of Object.keys(updates)) {
            if (this.group.indexOf(fieldId) != -1) groupHasChanged = true
            if (sortFields.indexOf(fieldId) != -1) sortHasChanged = true
            if (filterFields.indexOf(fieldId) != -1) filterHasChanged = true

            this._updateRecord(msgData.id)
        }

        if (sortHasChanged || filterHasChanged || groupHasChanged) {
            this._reloadWhenNeeded(msgData)
        }
    }

    /**
     * Update a single record of the timeline.
     * 
     * Does nothing if the record is not displayed on the active page.
     * 
     * @private
     * @ignore
     * @param {string} recordId
     */
    _updateRecord(recordId) {
        const record = this.collection.getRecord(recordId)
        const recordNode = document.querySelector(`.timeline-row[recordid="${recordId}"]`)
        if (recordNode) recordNode.innerHTML = this._renderRowContent(record)
    }

    /**
     * Update the timeline configuration in the database
     * 
     * @private
     * @ignore
     * @param {object} newConfig 
     */
    async _updateConfig(newConfig) {
        if (newConfig.hasOwnProperty("startDateField")) this.startDateField = newConfig.startDateField
        if (newConfig.hasOwnProperty("endDateField")) this.endDateField = newConfig.endDateField
        if (newConfig.hasOwnProperty("titleField")) this.titleField = newConfig.titleField
        if (newConfig.hasOwnProperty("colorField")) this.colorField = newConfig.colorField
        if (newConfig.hasOwnProperty("period")) this.period = newConfig.period

        this._initTexts()
        this._render()

        let currentConfig
        if (this.record) {
            currentConfig = this.record.config
        }
        else {
            currentConfig = {
                startDateField: this.startDateField,
                endDateField: this.endDateField,
                titleField: this.titleField,
                colorField: this.colorField,
                period: this.period,
                columns: this.columns
            }
        }

        let config = Object.assign(currentConfig, newConfig)
        await this.updateConfig({
            config
        })
    }    

    /**
     * Scroll up by one line with the virtual scroller
     * Remove the last row and insert a new one at the beginning
     * 
     * @private
     * @ignore
     */
    _virtualScrollUp() {
        if (this.skip == 0) return
        this.skip -= 1
        this.lastIndex = Math.min(this.skip + this.limit - 1, this.collection.records.length)
        this.timelineBody.lastChild.remove()
        this.timelineBody.insertBefore(this._renderRowDiv(this.skip), this.timelineBody.children[0])
        this.timelineBody1stColumn.lastChild.remove()
        this.timelineBody1stColumn.insertBefore(this._renderRowDiv1stColumn(this.skip), this.timelineBody1stColumn.children[0])
    }

    /**
     * Scroll up by one line with the virtual scroller
     * Remove the last row and insert a new one at the beginning
     * 
     * @private
     * @ignore
     */
    _virtualScrollDown() {
        if ((this.lastIndex + 1) >= this.collection.records.length) return
        this.skip += 1
        this.lastIndex = Math.min(this.skip + this.limit - 1, this.collection.records.length)
        this.timelineBody.children[0].remove()
        this.timelineBody.appendChild(this._renderRowDiv(this.lastIndex))
        this.timelineBody1stColumn.children[0].remove()
        this.timelineBody1stColumn.appendChild(this._renderRowDiv1stColumn(this.lastIndex))
    }

    /**
     * 
     * SIZE MANAGEMENT
     * 
     */

    /**
     * Adjust the component width
     * 
     * @ignore
     * @param {(number|string|function)} [width] - The width to set
     */
    _setWidth() {
        let newWidth = this._computeSize("width")

        setTimeout(() => {
            this.style.width = newWidth
            this.timeline.style.width = this.clientWidth.toString() + "px"
        }, 50)
    }

    /**
     * Adjust the components height
     * 
     * @private
     * @ignore
     * @param {(number|string|function)} [height] - The height to set
     */
    _setHeight() {
        let newHeight = this._computeSize("height")
        this.style.height = this.timeline.style.height = newHeight
    }

    /**
     * Compute the maximum number of rows that can fit in the timeline, then set the "limit" param.
     * The limit depends on the global timeline height minus:
     * - the timeline toolbar
     * - the timeline header
     * 
     * @private
     * @ignore
     */
    _setLimit() {
        if (!this.isConnected) return

        let tableHeight = this.offsetHeight
        let headerHeight = $("timeline-header:" + this.id).offsetHeight
        let toolbarHeight = $("timeline-toolbar:" + this.id).offsetHeight
        let bodyHeight = tableHeight - toolbarHeight - headerHeight
        this.limit = Math.floor(bodyHeight / (kiss.tools.remToPx(this.rowHeight) + 1))
        if (kiss.screen.isMobile) this.limit = this.limit - 1 // Keep a margin for Mobile UI
    }

    /**
     * 
     * RENDERING THE TABLE
     * 
     */

    /**
     * Render the pagination index.
     * Display, for example: 0 - 50 / 1000
     * 
     * @private
     * @ignore
     */
    _renderPagerIndex() {
        if (!this.isConnected) return

        if (kiss.screen.isMobile && kiss.screen.isVertical()) {
            // Compact version for mobile phones
            $("pager-index:" + this.id).innerHTML = Math.min(this.collection.count, (this.skip + this.limit)) + " / " + this.collection.count
        } else {
            $("pager-index:" + this.id).innerHTML = (this.skip + 1) + " - " + Math.min(this.collection.count, (this.skip + this.limit)) + " / " + this.collection.count
        }
    }

    /**
     * Render the timeline
     * 
     * @private
     * @ignore
     * @returns this
     */
    _render() {
        // kiss.tools.timer.start()

        // Reset 1st column
        this.timelineHeader1stColumn.innerHTML = ""
        this.timelineBody1stColumn.innerHTML = ""

        // Filters out hidden and deleted columns
        this.visibleColumns = this.columns.filter(column => column.hidden != true && column.deleted != true)

        this._initDayWidth(this.config)
            ._columnsSetFirstColumnWidth(this.firstColumnWidth)
            ._renderHeader()
            ._renderHeaderToday()
            ._renderBody()

        // kiss.tools.timer.show("Timeline rendered!")
        return this
    }

    /**
     * Render the timeline header
     * 
     * @private
     * @ignore
     * @returns this
     */
    _renderHeader() {
        // 1st column header
        let firstCell = document.createElement("div")
        firstCell.setAttribute("id", "header-1stColumn")
        firstCell.setAttribute("col", "-1")
        firstCell.classList.add("timeline-column-header", "timeline-column-header-1st")
        firstCell.style.width = firstCell.style.minWidth = this.firstColumnWidth + "rem"
        firstCell.innerHTML =
            `<span id='toggle-selection' class='timeline-header-checkbox ${(this.canSelect) ? "timeline-header-checkbox-off" : ""}'></span>` + // Selection checkbox
            `<span id='header-resizer-1st-column' class='fas fa-arrows-alt-h timeline-column-header-resizer'></span>` // Column resizer

        this.timelineHeader1stColumn.appendChild(firstCell)

        // Other columns headers
        const numberOfDays = this._getNumberOfDays()
        const htmlForDays = this._renderHeaderDays(numberOfDays)
        const htmlForMonths = this._renderHeaderMonths()

        this.timelineHeader.innerHTML = /*html*/ `
            <div>
                <span class="timeline-header-months">
                    ${htmlForMonths}
                </span>
                <span class="timeline-header-days">
                    ${htmlForDays}
                </span>
            </div>`

        return this
    }

    /**
     * Render the days of the timeline header
     * 
     * @private
     * @ignore
     * @returns {string} Html source for the days
     */
    _renderHeaderDays(max) {
        this.numberOfDays = 0
        let html = ""
        this.startDate = new Date(this.date)
        this.startDate.setHours(0, 0, 0, 0)
        let currentDate = this.startDate

        for (let i = 1; i <= max; i++) {
            this.numberOfDays++
            currentDate = new Date(kiss.formula.ADJUST_DATE(currentDate, 0, 0, 1, 0, 0, 0))

            const day = currentDate.getDate()
            const month = currentDate.getMonth()
            const year = currentDate.getFullYear()
            const dayId = this._getDayId(day, month + 1, year)
            const currentDay = currentDate.getDay()
            const dayLetter = this.weekDays[currentDay][0]

            // Week-end => Alternate background color
            let dayClass = ""
            if (currentDay == 0 || currentDay == 6) dayClass = "timeline-header-weekend"

            // Adjust the cell content according to the day width
            if (this.dayWidth > kiss.tools.remToPx(3)) {
                // Large cells
                html += `<div id="${dayId}" style="min-width: ${this.dayWidth}px" class="timeline-header-day ${dayClass}">
                    <div>${dayLetter}</div><div>${day}</div>    
                </div>`
            }
            else if (this.dayWidth > kiss.tools.remToPx(2)) {
                // Medium cells
                html += `<div id="${dayId}" style="min-width: ${this.dayWidth}px" class="timeline-header-day ${dayClass}">
                    <div style="font-size: 0.8rem">${day}</div>
                </div>`
            }
            else {
                // Small cells
                html += `<div id="${dayId}" style="min-width: ${this.dayWidth}px" class="timeline-header-day ${dayClass}">
                </div>`
            }
        }

        this.endDate = currentDate
        return html
    }

    /**
     * Render the months of the timeline header
     * 
     * @private
     * @ignore
     * @returns {string} Html source for the months
     */
    _renderHeaderMonths() {
        let html = ""
        let currentDate = this.startDate
        let currentMonth = currentDate.getMonth()
        let currentYear = currentDate.getFullYear()
        
        while (currentDate <= this.endDate) {
            let lastDayOfMonth = new Date(currentYear, currentMonth + 1, 0)
            if (lastDayOfMonth > this.endDate) lastDayOfMonth = this.endDate
    
            let daysInMonthDisplayed = (lastDayOfMonth - currentDate) / (1000 * 60 * 60 * 24) + 1
            let monthWidth = daysInMonthDisplayed * this.dayWidth
            if (monthWidth > 120) {
                // Full month, like "January 2023"
                html += `<div style="width: ${monthWidth}px; color: ${this.color}" class="timeline-header-month">${this.months[currentMonth]} ${currentYear}</div>`
            }
            else if (monthWidth > 50) {
                // Short month, like "01 / 2023"
                html += `<div style="width: ${monthWidth}px; color: ${this.color}" class="timeline-header-month">${(currentMonth + 1).toString().padStart(2, "0")} / ${currentYear}</div>`
            }
            else {
                // Very short month, like "01"
                html += `<div style="width: ${monthWidth}px; color: ${this.color}" class="timeline-header-month">${(currentMonth + 1).toString().padStart(2, "0")}</div>`
            }
    
            currentDate = new Date(currentYear, currentMonth + 1, 1)
            currentMonth = currentDate.getMonth()
            currentYear = currentDate.getFullYear()
        }
    
        return html
    }

    /**
     * Highlight today
     * 
     * @private
     * @ignore
     * @returns this
     */
    _renderHeaderToday() {
        let today = new Date().toISO()
        let todayCell = $(today)
        if (!todayCell) return this

        todayCell.style.color = "#ffffff"
        todayCell.style.backgroundColor = this.color
        return this
    }       

    /**
     * Render the content of a single row of the timeline.
     * 
     * @private
     * @ignore
     * @param {number} record - The record to render in this row
     * @returns {string} Html source for a row
     */
    _renderRowContent(record) {
        let startDate = record[this.startDateField]
        let endDate = record[this.endDateField]
        if (!startDate || !endDate) return ""

        startDate = new Date(startDate)
        endDate = new Date(endDate)

        if (isNaN(startDate) || isNaN(endDate)) return ""

        startDate = startDate.toISO()
        endDate = endDate.toISO()

        let recordHtml = ""
        const blockWidth = this._computeBlockWidth(startDate, endDate)

        if (blockWidth.middle != 0) {
            const blockColor = this._computeBlockColor(record)
            recordHtml = /*html*/
                `<div class="timeline-cell-data" style="background-color: ${blockColor}">
                    ${this._renderRecord(record).filter(value => value).join(" ● ")}
                </div>`
        }

        return `<div class="timeline-cell" style="width: ${blockWidth.start}px;"></div>
                <div class="timeline-cell" style="width: ${blockWidth.middle}px;">${recordHtml}</div>
                <div class="timeline-cell" style="width: ${blockWidth.end}px;"></div>`
    }

    /**
     * Render a single record as a Card for 1 week view
     * 
     * @private
     * @ignore
     * @param {object} record
     * @returns {string} Html for a single record
     */
    _renderRecord(record) {
        return this.columns
            .filter(column => column.hidden !== true)
            .map(column => {
                let field = this.model.getField(column.id)
                if (!field) return
                if (["attachment", "aiImage", "password", "link"].includes(field.type)) return

                let value = record[column.id]
                if (!value && value !== false && value !== 0) return

                let valueHtml = this._renderSingleValue(field, value, record)
                return valueHtml
            })
    }

    /**
     * Render a single value inside a card
     * 
     * @private
     * @ignore
     * @param {object} field - Field to render
     * @param {*} value - Field value
     * @param {object} record - The record, useful for custom renderers
     * @returns {string} Html for the value
     */
    _renderSingleValue(field, value, record) {
        const renderer = kiss.fields.renderers[this.model.id][field.id]
        let type = kiss.fields.getFieldType(field)

        switch (type) {
            case "number":
            case "date":
            case "select":
            case "directory":
            case "checkbox":
            case "rating":
            case "selectViewColumn":
                return renderer({
                    value,
                    record
                })

            case "textarea":
            case "richTextField":
                return renderer({
                    value,
                    record,
                    config: {
                        nobr: true
                    }
                })
            default:
                return value
        }
    }

    /**
     * Render the timeline body
     * 
     * Tech note: we don't use string litterals to build the HTML because it's slower than native String concatenation
     * 
     * @private
     * @ignore
     * @returns this
     */
    _renderBody() {
        let table = ""
        let firstColumn = ""
        this.startIndex = Math.max(0, this.skip)
        this.lastIndex = Math.min(this.skip + this.limit - 1, this.collection.records.length)

        if (this.collection.group.length === 0) {
            // Rendering without grouping
            for (let rowIndex = this.startIndex; rowIndex < this.lastIndex; rowIndex++) {
                let record = this.collection.records[rowIndex]
                firstColumn += "<div col=\"-1\" row=\"" + rowIndex + "\" recordId=\"" + record.id + "\" class=\"timeline-cell-1st\" style=\"width: " + this.firstColumnWidth + "rem; min-width: " + this.firstColumnWidth + "rem\">"
                firstColumn += this._renderRowContent1stColumn(record, rowIndex)
                firstColumn += "</div>"

                table += "<div row=\"" + rowIndex + "\" recordId=\"" + record.id + "\" class=\"timeline-row\">"
                table += this._renderRowContent(record)
                table += "</div>"
            }
        } else {
            // Rendering with grouping
            let nbOfRows = 0

            for (let rowIndex = this.skip;
                (nbOfRows < this.limit) && (rowIndex < this.collection.records.length); rowIndex++) {
                let record = this.collection.records[rowIndex]

                if (record.$type == "group") {
                    firstColumn += "<div col=\"-1\" row=\"" + rowIndex + "\" class=\"timeline-group timeline-group-level-" + record.$groupLevel + "\" style=\"width: " + this.firstColumnWidth + "rem; min-width: " + this.firstColumnWidth + "rem\">"
                    firstColumn += this._renderRowGroupContent1stColumn(record)
                    firstColumn += "</div>"

                    table += "<div row=\"" + rowIndex + "\" groupLevel=\"" + record.$groupLevel + "\" class=\"timeline-group-row\">"
                    table += this._renderRowGroupContent(record)
                    table += "</div>"
                } else {
                    firstColumn += "<div col=\"-1\" row=\"" + rowIndex + "\" recordId=\"" + record.id + "\" class=\"timeline-cell-1st\" style=\"width: " + this.firstColumnWidth + "rem; min-width: " + this.firstColumnWidth + "rem\">"
                    firstColumn += this._renderRowContent1stColumn(record, rowIndex)
                    firstColumn += "</div>"

                    table += "<div row=\"" + rowIndex + "\" recordId=\"" + record.id + "\" class=\"timeline-row\">"
                    table += this._renderRowContent(record)
                    table += "</div>"
                }
                nbOfRows++
            }
        }

        // Inject the table into the DOM
        this.timelineBody.innerHTML = table

        // Inject the table 1st column into the DOM
        this.timelineBody1stColumn.innerHTML = firstColumn

        // Update the pager index
        this._renderPagerIndex()

        // Highlight the selected rows
        this._renderSelection()

        // Add the virtual scroller
        this._renderScroller()

        // Show / hide empty icon
        this._renderEmptyIcon()

        return this
    }

    /**
     * Show an "empty" icon if there are no records to render
     * 
     * @private
     * @ignore
     */
    _renderEmptyIcon() {
        if (this.collection.records.length == "0") {
            this.timelineBodyContainer.classList.add("timeline-body-container-empty")
            this.timelineHeaderContainer.style.display = "none"
        } else {
            this.timelineBodyContainer.classList.remove("timeline-body-container-empty")
            this.timelineHeaderContainer.style.display = "flex"
        }
    }

    /**
     * Render a single row of the timeline
     * 
     * @private
     * @ignore
     * @param {number} rowIndex
     * @returns {HTMLDivElement} The div containing the row
     */
    _renderRowDiv(rowIndex) {
        let record = this.collection.records[rowIndex]

        // Fork if it's a grouping row
        if (record.$type == "group") return this._renderRowGroupDiv(record, rowIndex)

        // Build the div
        let newRow = document.createElement("div")
        newRow.setAttribute("row", rowIndex)
        newRow.setAttribute("recordid", record.id)
        newRow.classList.add("timeline-row")

        // Apply the style "selected" if the row has been selected
        // TODO: optimization => apply the "selected" style for all selected rows *after* the timeline has been fully rendered
        let isSelected = !(this.selectedRecords.indexOf(record.id) == -1)
        if (isSelected) newRow.classList.add("timeline-row-selected")

        // Inject row content (= cells) into the div
        newRow.innerHTML = this._renderRowContent(record)
        return newRow
    }

    /**
     * Render the 1st cell of a single row of the timeline
     * 
     * @private
     * @ignore
     * @param {number} rowIndex
     * @returns {HTMLDivElement} The div containing the cell
     */
    _renderRowDiv1stColumn(rowIndex) {
        let record = this.collection.records[rowIndex]

        // Fork if it's a grouping row
        if (record.$type == "group") return this._renderRowGroupDiv1stColumn(record, rowIndex)

        let firstCell = document.createElement("div")
        firstCell.setAttribute("col", "-1")
        firstCell.setAttribute("row", rowIndex)
        firstCell.setAttribute("recordid", record.id)
        firstCell.classList.add("timeline-cell-1st")
        firstCell.style.width = firstCell.style.minWidth = this.firstColumnWidth + "rem"

        // Apply the style "selected" if the row has been selected
        let isSelected = !(this.selectedRecords.indexOf(record.id) == -1)

        firstCell.innerHTML = this._renderRowContent1stColumn(record, rowIndex, isSelected)
        return firstCell
    }

    /**
     * Render the content of the 1st cell of a single row of the timeline.
     * 
     * The 1st cell of the row includes:
     * - a selection checkbox
     * - the row number
     * - a button to expand the record and see it in a form
     * 
     * @private
     * @ignore
     * @param {number} record - The record to render in this row
     * @param {number} rowIndex
     * @param {boolean} [isSelected] - If true, render the row with its "selected" appearence
     * @returns {string} Html source for a row
     */
    _renderRowContent1stColumn(record, rowIndex, isSelected) {
        return ((this.canSelect) ? "<span class=\"timeline-row-checkbox timeline-row-checkbox-" + ((isSelected) ? "on" : "off") + "\"></span>" : "") + // Selection checkbox
            "<span class=\"timeline-row-number\">" + ((record.$index + 1) || Number(rowIndex + 1)) + " ● </span>" + // Row number
            "<span class=\"timeline-row-title\">" + record[this.titleField] + "</span>" // Row data
    }

    /**
     * Render a single *group* row of the timeline.
     * 
     * @private
     * @ignore
     * @param {object} record
     * @param {number} rowIndex 
     */
    _renderRowGroupDiv(record, rowIndex) {
        let newRow = document.createElement("div")
        newRow.setAttribute("row", rowIndex)
        newRow.classList.add("timeline-group-row")
        newRow.innerHTML = this._renderRowGroupContent(record)
        return newRow
    }

    /**
     * Render the first cell of a single *group* row of the timeline.
     * 
     * @private
     * @ignore
     * @param {object} record
     * @param {number} rowIndex 
     */
    _renderRowGroupDiv1stColumn(record, rowIndex) {
        let firstCell = document.createElement("div")
        firstCell.setAttribute("col", "-1")
        firstCell.setAttribute("row", rowIndex)
        firstCell.classList.add("timeline-group", "timeline-group-level-" + record.$groupLevel)
        firstCell.style.width = firstCell.style.minWidth = this.firstColumnWidth + "rem"
        firstCell.innerHTML = this._renderRowGroupContent1stColumn(record)
        return firstCell
    }

    /**
     * Render the content of a single *group* row of the timeline.
     * 
     * @private
     * @ignore
     * @param {object} record 
     * @returns {string} Html source for a *group* row
     */
    _renderRowGroupContent(record) {
        return "<div class=\"timeline-group-id\">" + record.$groupId + ". " + record.$name + "</div>"
    }

    /**
     * Render the content of the 1st cell of a single *group* row of the timeline.
     * 
     * @private
     * @ignore
     * @param {object} record 
     * @returns {string} Html source for a *group* row
     */
    _renderRowGroupContent1stColumn(record) {
        // Get group field
        let groupFieldId = this.collection.group[record.$groupLevel]
        let field = this.model.getField(groupFieldId)

        // Check if it's a collapsed group
        let groupClass = (this.collection.collapsedGroups.includes(record.$groupId)) ? "timeline-group-collapsed" : "timeline-group-expanded"

        // The 1st cell of the row includes:
        // - an icon to expand/collapse the group
        // - the group name
        let groupRawValue = record.$name
        let groupCellValue = this._renderSingleValue(field, groupRawValue, record)

        return "<span class='" + groupClass + "'></span>" + // Icon to expand/collapse the group
            groupCellValue + "&nbsp;&nbsp;(" + record.$size + ")" // Group name and count
    }

    /**
     * Compute the color of a block according to the colorField
     * 
     * @private
     * @ignore
     * @param {object} record 
     * @returns {string} The color in hexadecimal format, like "#ff0000"
     */
    _computeBlockColor(record) {
        let colorValue = this.model.color
        const colorField = (this.colorField) ? this.model.getField(this.colorField) : null
        if (colorField) {
            colorValue = record[this.colorField]
            if (colorField.type == "select") {
                colorValue = colorField.options.find(option => option.value == colorValue)
                colorValue = (colorValue) ? colorValue.color : this.model.color
            }
        }
        return colorValue
    }

    /**
     * Compute the size of a timeline "block" according to the start and end dates.
     * 
     * A block has 3 parts:
     * - the start part
     * - the middle part (the main content of the block, like a card or a record)
     * - the end part
     * 
     * @private
     * @ignore
     * @param {date} startDate 
     * @param {date} endDate 
     * @returns {object} An object with 3 properties defining each part width: start, middle, end
     */
    _computeBlockWidth(startDate, endDate) {
        const bodyWidth = this.numberOfDays * this.dayWidth
        const unit = bodyWidth / this.numberOfDays

        const startDifference = kiss.formula.DAYS_DIFFERENCE(this.startDate, startDate)
        const endDifference = kiss.formula.DAYS_DIFFERENCE(endDate, this.endDate)

        let startX = startDifference * unit
        if (startX < 0) startX = 0
        else if (startX > bodyWidth) startX = bodyWidth

        let endX = bodyWidth - endDifference * unit
        if (endX < 0) endX = 0
        else if (endX > bodyWidth) endX = bodyWidth

        const startBlockWidth = Math.max(Math.floor(startX), 0)
        const middleBlockWidth = Math.max(Math.floor(endX - startX), 0)
        const endBlockWidth = Math.max(Math.floor(bodyWidth - endX), 0)

        return {
            start: startBlockWidth,
            middle: middleBlockWidth,
            end: endBlockWidth
        }
    }

    /**
     * Render the virtual scrollbar
     * 
     * @private
     * @ignore
     */
    _renderScroller() {
        // getBoundingClientRect is a bit behind the dom rendering
        setTimeout(() => {
            this.timelineScrollerContainer.style.top = kiss.tools.pxToRem(this.timelineBody.getBoundingClientRect().top) + "rem"
            this.timelineScrollerContainer.style.left = kiss.tools.pxToRem(this.getBoundingClientRect().right - this.timelineScrollerContainer.offsetWidth) + "rem"
            this._showScroller()
        }, 50)

        // Set the virtual scrollbar height within the container.
        // Setting it bigger than the container forces the browser to generate a real scrollbar.
        this.timelineScrollerContainer.style.height = kiss.tools.pxToRem(this.timelineBody.offsetHeight - 10) + "rem"
        this.timelineScroller.style.height = Math.min(this.collection.count * (this.rowHeight), 10000) + "rem"
    }

    /**
     * Show the virtual scroller
     * 
     * @private
     * @ignore
     */
    _showScroller() {
        if (this.showScroller !== false) {
            setTimeout(() => {
                this.timelineScrollerContainer.style.visibility = "visible"
            }, 0)
        }
    }

    /**
     * Hide the virtual scroller
     * 
     * @private
     * @ignore
     */
    _hideScroller() {
        this.timelineScrollerContainer.style.visibility = "hidden"
    }

    /**
     * Sync the virtual scrollbar position with the current timeline "skip" value
     * 
     * @private
     * @ignore
     */
    _renderScrollerPosition() {
        let percent = this.skip / (this.collection.records.length - this.limit)
        let topPosition = Math.round((this.timelineScroller.offsetHeight - this.timelineBody.offsetHeight) * percent)
        this.preventScroll = true // Disable onscroll event to avoid echo
        this.timelineScrollerContainer.scrollTop = topPosition
    }

    /**
     * Highlight the records that are selected in the rendered page
     * 
     * @private
     * @ignore
     */
    _renderSelection() {
        if (!this.selectedRecords) return

        this.selectedRecords.forEach(recordId => {
            let rowIndexes = this._rowGetAllIndexes(recordId)
            rowIndexes.forEach(rowIndex => this._rowSelect(rowIndex))
        })
    }

    /**
     * Restore the selection of the rendered page.
     * First clean the existing selection that might be obsolete,
     * then add the active selection.
     * 
     * @private
     * @ignore
     */
    _renderSelectionRestore() {
        this.getSelection()
        this._renderBody()
    }

    /**
     * Render the toolbar
     * 
     * @private
     * @ignore
     */
    _renderToolbar() {

        // If the toolbar is already rendered, we just update it
        if (this.isToolbarRendered) {
            this._groupUpdateGroupingFields()
            return
        }

        // New record creation button
        createButton({
            hidden: !this.canCreateRecord,
            class: "timeline-create-record",
            target: "create:" + this.id,
            text: this.config.createRecordText || this.model.name.toTitleCase(),
            icon: "fas fa-plus",
            iconColor: this.color,
            borderWidth: 3,
            borderRadius: "3.2rem",
            maxWidth: (kiss.screen.isMobile && kiss.screen.isVertical()) ? "16rem" : null,
            action: async () => this.createRecord(this.model)
        }).render()

        // Actions button
        createButton({
            hidden: this.showActions === false,
            target: "actions:" + this.id,
            tip: txtTitleCase("actions"),
            icon: "fas fa-bolt",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this._buildActionMenu()
        }).render()

        // Setup the timeline
        createButton({
            hidden: !this.showSetup,
            target: "setup:" + this.id,
            tip: txtTitleCase("setup the timeline"),
            icon: "fas fa-cog",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this.showSetupWindow()
        }).render()

        // Column selection button
        createButton({
            hidden: !this.canSelectFields,
            target: "select:" + this.id,
            tip: txtTitleCase("#display fields"),
            icon: "fas fa-bars fa-rotate-90",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this.showFieldsWindow()
        }).render()

        // Sorting button
        createButton({
            hidden: !this.canSort,
            target: "sort:" + this.id,
            tip: txtTitleCase("to sort"),
            icon: "fas fa-sort",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this.showSortWindow()
        }).render()

        // Filtering button
        createButton({
            hidden: !this.canFilter,
            target: "filter:" + this.id,
            tip: txtTitleCase("to filter"),
            icon: "fas fa-filter",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this.showFilterWindow()
        }).render()

        // Layout button
        createButton({
            hidden: !this.showLayoutButton,
            target: "layout:" + this.id,
            tip: {
                text: txtTitleCase("layout"),
                minWidth: "10rem"
            },
            icon: "fas fa-ellipsis-v",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this._buildLayoutMenu()
        }).render()

        // Grouping
        let groupingFields = this._groupGetModelFields()
        let groupingFieldValues = []

        this.collection.group.forEach(fieldId => {
            let groupingField = groupingFields.find(field => field.value == fieldId)
            if (groupingField) groupingFieldValues.push(groupingField.value)
        })

        createSelect({
            hidden: !this.canGroup,
            target: "group:" + this.id,
            id: "grouping-field:" + this.id,
            label: txtTitleCase("group by"),
            multiple: true,
            allowClickToDelete: true,
            options: groupingFields,
            minWidth: "20rem",
            maxHeight: () => kiss.screen.current.height - 200,
            optionsColor: this.color,
            value: groupingFieldValues,
            styles: {
                "this": "align-items: center;",
                "field-label": "white-space: nowrap;",
                "field-select": "white-space: nowrap;",
            },
            events: {
                change: async function (event) {
                    let groupFields = this.getValue()

                    // Restrict to 6 grouping fields
                    if (groupFields.length > 6) {
                        let fieldGroupSelect = $(this.id)
                        fieldGroupSelect.value = fieldGroupSelect.getValue().slice(0, 6)
                        fieldGroupSelect._renderValues()

                        createDialog({
                            type: "message",
                            title: txtTitleCase("seriously"),
                            icon: "fas fa-exclamation-triangle",
                            message: txtTitleCase("#too many groups"),
                            buttonOKText: txtTitleCase("#understood")
                        })
                        return
                    }

                    // Publish the "grouping" event
                    let viewId = this.id.split(":")[1]
                    publish("EVT_VIEW_GROUPING:" + viewId, groupFields)
                }
            }
        }).render()

        // Expand button
        this.buttonExpand = createButton({
            hidden: (!this.showGroupButtons || this.collection.group.length === 0),

            target: "expand:" + this.id,
            tip: txtTitleCase("expand all"),
            icon: "far fa-plus-square",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this.expandAll()
        }).render()

        // Collapse button
        this.buttonCollapse = createButton({
            hidden: (!this.showGroupButtons || this.collection.group.length === 0),

            target: "collapse:" + this.id,
            tip: txtTitleCase("collapse all"),
            icon: "far fa-minus-square",
            iconColor: this.color,
            width: "3.2rem",
            action: () => this.collapseAll()
        }).render()

        // View refresh button
        if (!kiss.screen.isMobile) {
            createButton({
                target: "refresh:" + this.id,
                tip: txtTitleCase("refresh"),
                icon: "fas fa-undo-alt",
                iconColor: this.color,
                width: "3.2rem",
                events: {
                    click: () => this.reload()
                }
            }).render()
        }

        // Search button
        createButton({
            hidden: !this.canSearch,
            target: "search:" + this.id,
            icon: "fas fa-search",
            iconColor: this.color,
            width: "3.2rem",
            events: {
                click: () => this.showSearchBar()
            }
        }).render()

        // Pager display mode
        if (this.canChangePeriod) {
            let _this = this
            createSelect({
                target: "pager-mode:" + this.id,
                id: "pager-mode:" + this.id,
                options: [{
                        label: "1 " + txt("year"),
                        value: "1 year"
                    }, {
                        label: "6 " + txt("months"),
                        value: "6 months"
                    }, {
                        label: "4 " + txt("months"),
                        value: "4 months"
                    }, {
                        label: "3 " + txt("months"),
                        value: "3 months"
                    }, {
                        label: "2 " + txt("months"),
                        value: "2 months"
                    }, {
                        label: "1 " + txt("month"),
                        value: "1 month"
                    },
                    {
                        label: "3 " + txt("weeks"),
                        value: "3 weeks"
                    },
                    {
                        label: "2 " + txt("weeks"),
                        value: "2 weeks"
                    },
                    {
                        label: "1 " + txt("week"),
                        value: "1 week"
                    }
                ],
                optionsColor: this.color,
                value: this.period || "1 month",
                fieldWidth: "15rem",
                styles: {
                    "this": "align-items: center;",
                    "field-label": "white-space: nowrap;",
                    "field-select": "white-space: nowrap;",
                },
                events: {
                    change: async function () {
                        _this.period = this.getValue()
                        const numberOfDays = _this.periods[_this.period]
                        const bodyWidth = _this._getBodyWidth()
                        const newDayWidth = Math.floor(bodyWidth / numberOfDays)
                        _this._setDayWidth(newDayWidth)
                    }
                }
            }).render()
        }

        // Pager previous
        createButton({
            target: "pager-previous:" + this.id,
            icon: "fas fa-chevron-left",
            iconColor: this.color,
            width: "3.2rem",
            events: {
                click: () => {
                    this.date = new Date(kiss.formula.ADJUST_DATE(this.startDate, 0, 0, -this.numberOfDays, 0, 0, 0))
                    this._render()
                }
            }
        }).render()

        // Pager next
        createButton({
            target: "pager-next:" + this.id,
            icon: "fas fa-chevron-right",
            iconColor: this.color,
            width: "3.2rem",
            events: {
                click: () => {
                    this.date = new Date(kiss.formula.ADJUST_DATE(this.startDate, 0, 0, this.numberOfDays, 0, 0, 0))
                    this._render()
                }
            }
        }).render()

        // Pager today
        const todayButton = {
            target: "pager-today:" + this.id,
            icon: "fas fa-stop",
            iconColor: this.color,
            events: {
                click: () => {
                    this.date = new Date()
                    this._render()
                }
            }
        }
        if (!kiss.screen.isMobile) todayButton.text = txtTitleCase("today")
        createButton(todayButton).render()

        // Flag the toolbar as "rendered", so that the method _renderToolbar() is idempotent
        this.isToolbarRendered = true
    }

    /**
     * 
     * ROWS API
     * 
     */

    /**
     * Check / Uncheck a row with the row checkbox.
     * 
     * @private
     * @ignore
     * @param {integer} rowIndex - The row number in the view
     */
    _rowToggleSelect(rowIndex) {
        let checkbox = this._rowGetCheckbox(rowIndex)
        let recordId = checkbox.parentNode.getAttribute("recordId")

        let rowIndexes = this._rowGetAllIndexes(recordId)
        let isSelected = (this.selectedRecords.indexOf(recordId) != -1)

        if (isSelected) {
            rowIndexes.forEach(rowIndex => this._rowDeselect(rowIndex))
            kiss.selection.delete(this.id, recordId)
        } else {
            rowIndexes.forEach(rowIndex => this._rowSelect(rowIndex))
            kiss.selection.insertOne(this.id, recordId)
        }

        // Update the timeline
        this.selectedRecords = kiss.selection.get(this.id)
        return recordId
    }

    /**
     * Select a row, and add it to the collection selection.
     * The index is relative to the page (the row 0 can be the nth record in the collection).
     * 
     * @private
     * @ignore
     * @param {number} rowIndex - The row number in the current page
     */
    _rowSelect(rowIndex) {
        // Update the checkbox
        let checkbox = this._rowGetCheckbox(rowIndex)
        if (!checkbox) return
        checkbox.classList.add("timeline-row-checkbox-on")
        checkbox.classList.remove("timeline-row-checkbox-off")

        // Highlight the selected row
        let row = this.timelineBody.querySelector("[row=\"" + rowIndex + "\"]")
        row.classList.add("timeline-row-selected")
    }

    /**
     * Deselect a row, and remove it from the collection selection.
     * The index is relative to the page (the row 0 can be the nth record in the collection).
     * 
     * @private
     * @ignore
     * @param {number} rowIndex - The row number in the current page
     */
    _rowDeselect(rowIndex) {
        // Update the checkbox
        let checkbox = this._rowGetCheckbox(rowIndex)
        checkbox.classList.add("timeline-row-checkbox-off")
        checkbox.classList.remove("timeline-row-checkbox-on")

        // Remove the highlight on the selected row
        let row = this.timelineBody.querySelector("[row=\"" + rowIndex + "\"]")
        row.classList.remove("timeline-row-selected")
    }

    /**
     * Highlight a row
     * 
     * @private
     * @ignore
     * @param {number} rowIndex - The row index to highlight
     */
    _rowHighlight(rowIndex) {
        let row = this.querySelector("[row=\"" + rowIndex + "\"]")
        row.classList.add("timeline-row-selected")
    }

    /**
     * Get the checkbox used to select/deselect a row.
     * The index is relative to the page (the row 0 can be the nth record in the collection).
     * 
     * @private
     * @ignore
     * @param {integer} rowIndex
     * @returns {HTMLElement} The checkbox input element
     */
    _rowGetCheckbox(rowIndex) {
        return this.timelineBody1stColumn.querySelector("[row=\"" + rowIndex + "\"]").querySelector(".timeline-row-checkbox")
    }

    /**
     * Find the index of a record in the timeline (including hidden rows)
     * 
     * @private
     * @ignore
     * @param {string} recordId
     * @returns {number} The index of the record in the timeline, or -1 if not found
     */
    _rowFindIndex(recordId) {
        return this.collection.records.findIndex(record => record.id == recordId)
    }

    /**
     * Find all the indexes of a record in the active page.
     * 
     * @private
     * @ignore
     * @param {string} recordId
     * @returns {integer} The row index, or null if it wasn't found in the page
     */
    _rowGetAllIndexes(recordId) {
        let rows = this.timelineBody.querySelectorAll("div[recordId='" + recordId + "']")
        if (rows) return Array.from(rows).map(row => row.getAttribute("row"))
        else return null
    }

    /**
     * Get the row height config stored locally
     * 
     * @private
     * @ignore
     */
    _getRowHeightFromLocalStorage() {
        const localStorageId = "config-view-timeline-" + this.id + "-row-height"
        const rowHeight = localStorage.getItem(localStorageId)
        if (!rowHeight) return this.defaultRowHeight
        return Number(rowHeight)
    }

    /**
     * 
     * COLUMNS MANAGEMENT
     * 
     */

    /**
     * Save the width of the 1st column in the localStorage
     * 
     * @private
     * @ignore
     * @param {number} newWidth - New column width
     */
    _columnsSetWidth(newWidth) {
        localStorage.setItem("config-view-timeline-" + this.id + "-1st-column", newWidth)
    }

    /**
     * Resize the 1st column
     * 
     * @private
     * @ignore
     */
    _columnsResizeWithDragAndDrop(event, element) {
        let columnMinSize = 10

        // Get column cells
        let colIndex = element.parentNode.getAttribute("col")
        let columnCells = Array.from(this.querySelectorAll("div[col='" + colIndex + "']"))

        // Get column header elements
        let columnHeader = element.parentNode
        let columnHeaderTitle = columnHeader.children[0]
        columnHeader.mouseStartX = event.x
        let currentWidth = columnHeader.clientWidth
        let newWidth

        // !!!
        // TODO: memory leak to solve here => listeners seem to not be garbage collected properly
        // !!!
        document.onmousemove = (event) => {
            let _event = event

            setTimeout(() => {
                newWidth = kiss.tools.pxToRem(currentWidth + _event.x - columnHeader.mouseStartX)
                if (newWidth > columnMinSize) {
                    columnHeader.style.minWidth = columnHeader.style.width = newWidth + "rem"
                    columnHeaderTitle.style.minWidth = columnHeaderTitle.style.width = (newWidth - this.resizerWidth) + "rem"
                    columnCells.forEach(cell => cell.style.width = cell.style.minWidth = newWidth + "rem")
                    this._columnsSetFirstColumnWidth(newWidth)
                }
            }, 1)
        }

        // Remove listeners & re-render
        document.onmouseup = () => {
            this._columnsSetWidth(Math.max(columnMinSize, newWidth))
            document.onmousemove = null
            document.onmouseup = null
            this._render()
        }
    }

    /**
     * Resize the timeline first column, used to display:
     * - selection checkboxes
     * - group names, when the view is grouped by a field
     * 
     * @private
     * @ignore
     * @param {number} newWidth
     * @returns this
     */
    _columnsSetFirstColumnWidth(newWidth) {
        this.firstColumnWidth = newWidth
        this.timelineHeader1stColumn.style.minWidth = newWidth + "rem"
        this.timelineBody1stColumn.style.minWidth = newWidth + "rem"
        return this
    }

    /**
     * Adjust 1st column width from a local configuration stored in the localStorage.
     * If a configuration is found for a specific column, then it is applied.
     * Otherwise, a DEFAULT_WIDTH width is applied.
     * 
     * @private
     * @ignore
     * @returns this
     */
    _columnsAdjustWidthFromLocalStorage() {
        let localStorageId = "config-view-timeline-" + this.id + "-1st-column"
        let firstColumnWidth = localStorage.getItem(localStorageId)
        this.firstColumnWidth = (firstColumnWidth || this.firstColumnWidth)
        return this
    }

    /**
     * 
     * OTHER MISC METHODS
     * 
     */

    /**
     * Render the menu to change timeline layout
     * 
     * @private
     * @ignore
     */
    async _buildLayoutMenu() {
        let buttonLeftPosition = $("layout:" + this.id).offsetLeft
        let buttonTopPosition = $("layout:" + this.id).offsetTop

        createMenu({
            top: buttonTopPosition,
            left: buttonLeftPosition,
            items: [
                // Title
                txtTitleCase("cell size"),
                "-",
                // Change row height to  COMPACT
                {
                    icon: "fas fa-circle",
                    iconSize: "0.2rem",
                    text: txtTitleCase("compact"),
                    action: () => {
                        this.rowHeight = 3
                        this.setRowHeight(this.rowHeight)
                    }
                },
                // Change row height to NORMAL
                {
                    icon: "fas fa-circle",
                    iconSize: "0.6rem",
                    text: txtTitleCase("normal"),
                    action: () => {
                        this.rowHeight = this.defaultRowHeight
                        this.setRowHeight(this.rowHeight)
                    }
                },
                // Change row height to MEDIUM
                {
                    icon: "fas fa-circle",
                    iconSize: "1rem",
                    text: txtTitleCase("medium"),
                    action: () => {
                        this.rowHeight = 8
                        this.setRowHeight(this.rowHeight)
                    }
                },
                // Change row height to TALL
                {
                    icon: "fas fa-circle",
                    iconSize: "1.4rem",
                    text: txtTitleCase("tall"),
                    action: () => {
                        this.rowHeight = 12
                        this.setRowHeight(this.rowHeight)
                    }
                },
                // Change row height to VERY TALL
                {
                    icon: "fas fa-circle",
                    iconSize: "1.8rem",
                    text: txtTitleCase("very tall"),
                    action: () => {
                        this.rowHeight = 16
                        this.setRowHeight(this.rowHeight)
                    }
                },
                "-",
                // Reset columns width
                {
                    icon: "fas fa-undo-alt",
                    text: txtTitleCase("#reset view params"),
                    action: () => this.resetLocalViewParameters()
                }
            ]
        }).render()
    }
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-timeline", kiss.ui.Timeline)

/**
 * Shorthand to create a new Timeline. See [kiss.ui.Timeline](kiss.ui.Timeline.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createTimeline = (config) => document.createElement("a-timeline").init(config)

;/**
 * 
 * !!! IN PROGRESS - NOT IMPLEMENTED YET !!!
 * 
 * # class TreeList
 * 
 * The TreeList component build a hierarchical list of UL / LI elements from a JSON config object.
 * The config should have the following properties:
 * 
 * @ignore
 * @param {object[]} tree - a an array of object literals that have at least a "name" and "children" property (see example below)
 * @param {function} [folderRenderer] - Optional function to render the content of a *folder* node. Should include at least the node name. Example: fn = node => `<span>${node.name}</span>`
 * @param {function} [leafRenderer] - Same as folderRenderer, but to render the content of a *leaf* node
 * @param {object} methods - All the custom methods for your treelist.
 * 
 * - The Component custom methods can be called from the UL & LI inner elements using this.getComponent() to reach the top-level Component
 * - The 'onLeafClick' and 'onFolderClick' methods are used by default at the LU / LI level
 * 
 * Example of leafRenderer that calls an openMenu method of the Component:
 * leafRenderer = (node) => `${node.name}<span class="tree-leaf-menu" onclick="this.getComponent().openMenu(event, this)"></span>`
 * 
 * @example
 * {
 *      id: "myTreeList",
 *      tree: [ {id: "id1", name: "name1", children: [...]}, {id: "id2", name: "name2", children: [...]} ],
 *      folderRenderer: node => `<span>${node.name}</span>`,
 *      leafRenderer: node => `<span>${node.name}</span>`,
 *      methods: {
 *          onFolderClick: function(event, node) {
 *              console.log("You clicked on the folder " + node.id)
 *              event.stop() // Prevent event bubbling
 *          },
 *          onLeafClick: function(event, node) {
 *              console.log("You clicked on the leaf " + node.id)
 *              event.stop() // Prevent event bubbling
 *          },
 *          openMenu: function(event, node) {
 *              console.log("You've clicked on the menu icon " + node.id)
 *              event.stop() // Prevent event bubbling
 *          }
 *      }
 */
kiss.ui.TreeList = class TreeList extends kiss.ui.Component {
    constructor() {
        super()
    }

    /**
     * Generates a TreeList from a JSON config
     * 
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config) {
        super.init(config)

        // Default function to render a *Folder* node
        const defaultFolderRenderer = (node) => `${node.name}`

        // Default function to render a *Leaf* node
        const defaultLeafRenderer = (node) => `${node.name}`

        // Explore tree and create html
        const buildTreeList = function (tree, fnFolderRenderer, fnLeafRenderer) {

            let html = '<ul class="tree">'
            tree.forEach(node => {
                let isFolder = ((node.items) && (node.items.length != 0))

                if (isFolder == true) {
                    // Render a folder node
                    html += `<li id="${node.id || uid()}" class="tree-folder tree-folder-open" onclick="this.getComponent().onFolderClick(event, this)"><div onclick="this.parentNode.switch()">` + fnFolderRenderer(node) + "</div>"
                } else {
                    // Render a leaf node
                    html += `<li id="${node.id || uid()}" class="tree-leaf" onclick="this.getComponent().onLeafClick(event, this)"><div>` + fnLeafRenderer(node) + "</div>"
                }

                // If it's folder, we call the function recursively to render the children
                if (isFolder) html += buildTreeList(node.items, fnFolderRenderer, fnLeafRenderer)

                html += "</li>"
            })
            html += "</ul>"
            return html
        }

        // Insert the html into the node
        this.innerHTML = buildTreeList(config.tree, config.folderRenderer || defaultFolderRenderer, config.leafRenderer || defaultLeafRenderer)

        // Bind events
        //this._bindEvents(this.config.events)

        return this
    }
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-treelist", kiss.ui.TreeList)

/**
 * Shorthand to create a new TreeList. See [kiss.ui.TreeList](kiss.ui.TreeList.html)
 * 
 * @ignore
 * @param {object} config
 * @returns HTMLElement
 */
const createTreeList = (config) => document.createElement("a-treelist").init(config)

/**
 * HTMLLIElement.switch
 * 
 * Allow to expand / collapse all the children UL nodes of a hierarchical list
 * 
 * @returns this
 */
 HTMLLIElement.prototype.switch = function () {
    // Switch LI element between open & closed class
    this._toggleClass("tree-folder-open")
    this._toggleClass("tree-folder-closed")

    // Display / hide children UL
    this.children.forEach(function (node) {
        if (node.nodeName == "UL") {
            if (node.style.display == "none") {
                node.style.display = "block"
            } else {
                node.style.display = "none"
            }
        }
    })
    return this
}

;/**
 * 
 * The Button derives from [Component](kiss.ui.Component.html).
 * 
 * Its a standard clickable button with an icon.
 * 
 * @param {object} config
 * @param {function} [config.action] Action to perform when clicked. Shortcut for config.events.onclick
 * @param {string} [config.text]
 * @param {string} [config.tip] - Tip displayed when hovering the button
 * @param {string} [config.textAlign]
 * @param {string} [config.fontSize]
 * @param {string} [config.fontWeight]
 * @param {string} [config.color]
 * @param {string} [config.colorHover]
 * @param {string} [config.icon]
 * @param {string} [config.iconHover]
 * @param {string} [config.iconSize]
 * @param {string} [config.iconColor]
 * @param {string} [config.iconColorHover]
 * @param {string} [config.iconShadow]
 * @param {string} [config.iconShadowHover]
 * @param {string} [config.iconPosition] Use "top" to put the icon at the top
 * @param {string} [config.iconPadding]
 * @param {string} [config.iconMargin]
 * @param {string} [config.background]
 * @param {string} [config.backgroundColor]
 * @param {string} [config.backgroundColorHover]
 * @param {string} [config.boxShadow]
 * @param {string} [config.boxShadowHover]
 * @param {string} [config.cursor]
 * @param {string} [config.position]
 * @param {string} [config.top]
 * @param {string} [config.left]
 * @param {string} [config.right]
 * @param {string} [config.float]
 * @param {string} [config.display]
 * @param {string} [config.flex]
 * @param {string|number} [config.width]
 * @param {string|number} [config.minWidth]
 * @param {string|number} [config.maxWidth]
 * @param {string|number} [config.height]
 * @param {string|number} [config.minHeight]
 * @param {string|number} [config.maxHeight]
 * @param {string} [config.margin]
 * @param {string} [config.padding]
 * @param {string} [config.border]
 * @param {string} [config.borderStyle]
 * @param {string} [config.borderWidth]
 * @param {string} [config.borderColor]
 * @param {string} [config.borderColorHover]
 * @param {string} [config.borderRadius]
 * @param {string} [config.overflow]
 * @param {string} [config.overflowX]
 * @param {string} [config.overflowY]
 * @param {number} [config.zIndex]
 * @param {boolean} [config.draggable]
 * @returns this
 * 
 * ## Generated markup
 * ```
 * <a-button class="a-button">
 *  <span class="button-icon font-awesome-icon-class"></span>
 *  <span class="button-text"></span>
 * </a-button>
 * ```
 */
kiss.ui.Button = class Button extends kiss.ui.Component {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the 3 following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const myButton = document.createElement("a-button").init(config)
     * ```
     * 
     * Or use the shorthand for it:
     * ```
     * const myButton = createButton({
     *  text: "Click me!",
     *  icon: "fas fa-check",
     *  action: () => console.log("click!")
     * })
     * 
     * myButton.render()
     * ```
     * 
     * Or directly declare the config inside a container component:
     * ```
     * const myPanel = createPanel({
     *   title: "My panel",
     *   items: [
     *       {
     *           type: "button",
     *           text: "Click me!",
     *           icon: "fas fa-check",
     *           action: () => console.log("click!")
     *       }
     *   ]
     * })
     * myPanel.render()
     * ```
     */
    constructor() {
        super()
    }

    /**
     * Generates a Button from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config = {}) {
        super.init(config)

        // Template
        this.icon = config.icon || ""
        this.text = config.text || ""
        this.text = this.text.replaceAll("\n", "<br>")

        this.innerHTML = `
            ${ (config.icon) ? `<span id="button-icon-${this.id}" class="button-icon ${this.icon}"></span>` : "" }
            ${ (config.text) ? `<span id="button-text-${this.id}" class="button-text">${this.text}</span>` : "" }`.removeExtraSpaces()

        // Set properties
        this.buttonIcon = this.querySelector(".button-icon") || {}
        this.buttonText = this.querySelector(".button-text") || {}

        this._setProperties(config, [
            [
                ["draggable"],
                [this]
            ],
            [
                ["display", "flex", "alignItems", "justifyContent", "position", "float", "top", "left", "right", "width", "minWidth", "maxWidth", "height", "minHeight", "maxHeight", "margin", "padding", "background", "backgroundColor", "border", "borderColor", "borderRadius", "borderStyle", "borderWidth", "boxShadow", "cursor", "zIndex"],
                [this.style]
            ],
            [
                ["color", "fontSize", "fontWeight", "textAlign"],
                [this.buttonText.style]
            ],
            [
                ["iconSize=fontSize", "iconColor=color", "iconPadding=padding", "iconMargin=margin", "iconShadow=textShadow"],
                [this.buttonIcon.style]
            ]
        ])

        // Set the default display mode that will be restored by the show() method
        this.displayMode = "inline-flex"

        // Bind action to onclick
        if (config.action) this.onclick = config.action

        // Build hover events
        if (config.iconHover) this._createHoverListener("iconHover", config.iconHover, "_setHoverIcon", "_resetIcon")
        if (config.colorHover) this._createHoverListener("colorHover", config.colorHover, "_setHoverColor", "_resetColor")
        if (config.iconColorHover) this._createHoverListener("iconColorHover", config.iconColorHover, "_setHoverIconColor", "_resetIconColor")
        if (config.iconShadowHover) this._createHoverListener("iconShadowHover", config.iconShadowHover, "_setHoverIconShadow", "_resetIconShadow")
        if (config.boxShadowHover) this._createHoverListener("boxShadowHover", config.boxShadowHover, "_setHoverBoxShadow", "_resetBoxShadow")
        if (config.borderColorHover) this._createHoverListener("borderColorHover", config.borderColorHover, "_setHoverBorderColor", "_resetBorderColor")
        if (config.backgroundColorHover) this._createHoverListener("backgroundColorHover", config.backgroundColorHover, "_setHoverBackgroundColor", "_resetBackgroundColor")

        // Force the button's hover to reset after click
        // @note: this is necessary in situations where the "click" hides the view which contains the button, and sends the button to cache in its wrong "hover" state.
        this.onmouseup = () => {
            if (config.colorHover) this._resetColor()
            if (config.iconColorHover) this._resetIconColor()
            if (config.iconShadowHover) this._resetIconShadow()
            if (config.boxShadowHover) this._resetBoxShadow()
            if (config.borderColorHover) this._resetBorderColor()
            if (config.backgroundColorHover) this._resetBackgroundColor()
        }

        if (config.icon) {
            // Define the width of the icon area, to be able to center it properly
            // The width of the icon span should be equal to the height of the button in order to create a regular square and center icons within it
            this.buttonIcon.style.width = (config.height) ? this._computeSize("height") : "var(--button-height)"

            // Change flex flow if depending on the icon position
            this.iconPosition = config.iconPosition || "left"

            const flow = {
                top: "column",
                left: "row",
                bottom: "column-reverse",
                right: "row-reverse"
            }
            this.style.flexFlow = flow[this.iconPosition]
        }

        return this
    }

    /**
     * Change the text of the button
     * 
     * @param {string} text - The new button text
     * @returns this
     * 
     * @example
     * myButton.setText("Click here")
     */
    setText(text = "") {
        text = text.replaceAll("\n", "<br>")
        this.config.text = text
        this.buttonText.innerText = text
        return this
    }

    /**
     * Change the icon of the button
     * 
     * @param {string} iconClass - The new Font Awesome icon class
     * @returns this
     * 
     * @example
     * myButton.setIcon("fas fa-check")
     */
    setIcon(iconClass) {
        this.config.icon = iconClass
        this.icon.split(" ").forEach(className => this.buttonIcon.classList.remove(className))
        this.icon = iconClass
        this.icon.split(" ").forEach(className => this.buttonIcon.classList.add(className))
        return this
    }

    /**
     * Change the color of the text
     * 
     * @param {string} color - The new color, in hexa format
     * @returns this
     * 
     * @example
     * myButton.setColor("#00aaee")
     */
    setColor(color) {
        this.config.color = color
        if ((this.buttonText) && (this.buttonText.style)) this.buttonText.style.color = color
        return this
    }

    /**
     * Change the background color of the text
     * 
     * @param {string} color - The new color, in hexa format
     * @returns this
     * 
     * @example
     * myButton.setBackgroundColor("#00aaee")
     */
    setBackgroundColor(color) {
        this.config.backgroundColor = this.style.backgroundColor = color
        return this
    }

    /**
     * Change the color of the icon
     * 
     * @param {string} color - The new color, in hexa format
     * @returns this
     * 
     * @example
     * myButton.setIconColor("#00aaee")
     */
    setIconColor(color) {
        this.config.iconColor = color
        if (this.config.icon) this.buttonIcon.style.color = color
        return this
    }

    /**
     * Change the color of the border
     * 
     * @param {string} color - The new color, in hexa format
     * @returns this
     * 
     * @example
     * myButton.setBorderColor("#00aaee")
     */
    setBorderColor(color) {
        this.config.borderColor = color
        this.style.borderColor = color
        return this
    }

    /**
     * Manage HOVER for backgroundColor, color, and icon color
     * 
     * @private
     * @ignore
     */
    _createHoverListener(propertyName, propertyValue, setMethod, resetMethod) {
        this[propertyName] = propertyValue
        this.addEventListener("mouseenter", this[setMethod])
        this.addEventListener("mouseleave", this[resetMethod])
    }

    // Color
    _setHoverColor() {
        if (!this.buttonText) return
        this.currentColor = this.buttonText.style.color
        this.buttonText.style.color = this.colorHover
    }

    _resetColor() {
        this.buttonText.style.color = this.currentColor
    }

    // Icon
    _setHoverIcon() {
        if (!this.icon) return
        this.currentIcon = this.icon
        this.setIcon(this.config.iconHover)
    }

    _resetIcon() {
        this.setIcon(this.currentIcon)
    }

    // Icon color
    _setHoverIconColor() {
        if (!this.buttonIcon) return
        this.currentIconColor = this.buttonIcon.style.color
        this.buttonIcon.style.color = this.iconColorHover
    }

    _resetIconColor() {
        this.buttonIcon.style.color = this.currentIconColor
    }

    // Icon shadow
    _setHoverIconShadow() {
        if (!this.buttonIcon) return
        this.currentIconShadow = this.buttonIcon.style.textShadow
        this.buttonIcon.style.textShadow = this.iconShadowHover
    }

    _resetIconShadow() {
        this.buttonIcon.style.textShadow = this.currentIconShadow
    }    

    // Shadow
    _setHoverBoxShadow() {
        this.currentShadow = this.style.boxShadow
        this.style.boxShadow = this.boxShadowHover
    }

    _resetBoxShadow() {
        this.style.boxShadow = this.currentShadow
    }

    // Border color
    _setHoverBorderColor() {
        this.currentBorderColor = this.style.borderColor
        this.style.borderColor = this.borderColorHover
    }

    _resetBorderColor() {
        this.style.borderColor = this.currentBorderColor
    }

    // Background color
    _setHoverBackgroundColor() {
        this.currentBackgroundColor = this.style.backgroundColor
        this.style.backgroundColor = this.backgroundColorHover
    }

    _resetBackgroundColor() {
        this.style.backgroundColor = this.currentBackgroundColor
    }
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-button", kiss.ui.Button)

/**
 * Shorthand to create a new Button. See [kiss.ui.Button](kiss.ui.Button.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createButton = (config) => document.createElement("a-button").init(config)

;/**
 * 
 * The Dialog box is just a Panel with pre-defined items:
 * - OK button
 * - Cancel button, except when dialog type = "message"
 * - Field to input a value if type = "input" or "select"
 * - Clicking on the OK button triggers the specified action.
 * - Clicking on the Cancel button close the dialog.
 * 
 * @param {object|string} config - Configuration object, or a simple text to display in the dialog box
 * @param {string} [config.id] - optional id in case you need to manage this dialog by id
 * @param {string} config.type - dialog | message | danger | input | select. Default = "dialog"
 * @param {string} config.message
 * @param {string} config.textAlign - use "center" to center the text in the dialog box
 * @param {function} config.action - Function called if the user clicks on the OK button. The function receives the input value if the dialog type is "input"
 * @param {object[]} [config.options] - Only for "select" type: define the list of options. 
 * @param {boolean} [config.multiple] - Only for "select" type: allow to select multiple options.
 * @param {boolean} [config.users] - Only for "directory" type: allow to select users
 * @param {boolean} [config.groups] - Only for "directory" type: allow to select groups
 * @param {boolean} [config.roles] - Only for "directory" type: allow to select roles
 * @param {boolean} [config.autoClose] - if true (default), the window is closed on validation. If false, the window is closed only if the <action> function returns true.
 * @param {string} [config.icon] - Header icon
 * @param {string} [config.header] - set to false to hide the header
 * @param {string} [config.headerHeight]
 * @param {string} [config.headerColor]
 * @param {string} [config.headerBackgroundColor]
 * @param {string} [config.title]
 * @param {string} [config.buttonOKPosition] - "left" | "right" (default = "right")
 * @param {string} [config.buttonOKText] - Text of the "OK" button. Default = "OK"
 * @param {string} [config.buttonCancelText] - Text of the "Cancel" button. Default = "Cancel"
 * @param {string|boolean} [config.iconOK] - Icon of the "OK" button, or false to hide the icon
 * @param {string|boolean} [config.iconCancel] - Icon of the "Cancel" button, or false to hide the icon
 * @param {string} [config.colorOK] - Hexa color code of the OK button
 * @param {string} [config.colorCancel] - Hexa color code of the Cancel button
 * @param {string} [config.noOK] - If true, hide the OK button
 * @param {string} [config.noCancel] - If true, hide the Cancel button
 * @param {string|number} [config.top]
 * @param {string|number} [config.left]
 * @param {string|number} [config.width]
 * @param {string|number} [config.height]
 * @param {string} [config.animation] - Check [component's animations](https://kissjs.net/doc/out/kiss.ui.component#setAnimation)
 * @returns this
 * 
 * @example
 * // Display a simple message box: it only has an OK button
 * createDialog({
 *  message: "Your asset is ready"
 * })
 * 
 * // Same thing, using just a text as argument
 * createDialog("Your asset is ready")
 * 
 * // Display a dialog box: it has OK and Cancel buttons
 * createDialog({
 *  type: "dialog",
 *  message: "Do you want to do that?",
 *  action: () => console.log("You've done that!")
 * })
 * 
 * // Display a danger box: OK button and header are red + exclamation icon
 * createDialog({
 *  type: "danger",
 *  message: "Do you want to delete the database?",
 *  action: () => console.log("You've deleted the database!")
 * })
 * 
 * // Display a dialog box with an input field: the callback catches the entered value
 * createDialog({
 *  type: "input",
 *  message: "Please enter your name:",
 *  action: (enteredValue) => console.log("You've entered " + enteredValue)
 * })
 * 
 * // Display a dialog box with a select field: the callback catches the selected values in an array
 * createDialog({
 *  type: "select",
 *  message: "Please select your items:",
 *  multiple: true, // Allow to select multiple options
 *  options: ["Item A", "Item B", "Item C"],
 *  action: (enteredValues) => console.log("You've entered " + enteredValues.join(" / "))
 * })
 */
kiss.ui.Dialog = class Dialog {
    /**
     * You can create a Dialog using the class or using the shorthand:
     * ```
     * // Using kiss namespace
     * new kiss.ui.Dialog(config)
     * 
     * // Using the class
     * new Dialog(config)
     * 
     * // Using the shorthand
     * createDialog(config)
     * ```
     * 
     * @param {object} config 
     * @returns this
     */
    constructor(config) {
        const isMobile = kiss.screen.isMobile
        const dialogId = config.id || kiss.tools.shortUid()
        
        if (typeof config == "string") {
            config = {
                type: "message",
                message: config
            }
        }

        const dialogType = config.type || "dialog"

        if (config.textAlign == "center") {
            config.message = `<center>${config.message}</center>`
        }

        config.message = (config.message || "").replaceAll("\n", "<br>")

        if (config.type == "danger") {
            config.icon = "fas fa-exclamation-triangle"
            config.headerBackgroundColor = "var(--background-red)"
            config.colorOK = "var(--red)"
            config.colorCancel = "var(--green)"
        }

        // OK button
        const buttonOK = {
            hidden: (config.noOK == true),

            type: "button",
            text: config.buttonOKText || txtTitleCase("ok"),
            icon: (config.iconOK === false) ? false : (config.iconOK || "fas fa-check"),
            iconColor: config.colorOK || null,
            flex: 1,
            styles: {
                "this": (config.colorOK) ? "border-color: " + config.colorOK : ""
            },
            events: {
                click: async function () {
                    $(dialogId).validate()
                }
            }
        }

        // CANCEL button
        const buttonCancel = {
            hidden: (dialogType == "message" || config.noCancel == true),

            type: "button",
            text: config.buttonCancelText || txtTitleCase("cancel"),
            icon: (config.iconCancel === false) ? false : (config.iconCancel || "fas fa-times"),
            iconColor: config.colorCancel || null,
            flex: 1,
            styles: {
                "this": (config.colorCancel) ? "border-color: " + config.colorCancel : ""
            },
            events: {
                click: function () {
                    this.closest("a-panel").close()
                }
            }
        }

        // Dialog box
        let dialogConfig = {
            id: dialogId,
            class: "panel-dialog",
            top: config.top || null,
            left: config.left || null,
            width: (isMobile) ? "100%" : (config.width || null),
            height: (isMobile) ? "100%" : (config.height || null),
            borderRadius: (isMobile) ? "0 0 0 0" : "",
            align: "center",
            verticalAlign: "center",

            modal: true,
            draggable: true,
            closable: !(config.closable === false),
            animation: config.animation || null,
            zIndex: 1,

            header: (config.header !== false),
            title: config.title || "",
            icon: config.icon || "fas fa-info-circle",
            headerHeight: config.headerHeight,
            headerBackgroundColor: config.headerBackgroundColor || "#00aaee",

            items: [

                // MESSAGE
                (dialogType == "message" || dialogType == "dialog" || dialogType == "danger") ? {
                    type: "html",
                    width: "100%",
                    padding: "3.2rem",
                    html: config.message
                } : null,

                // INPUT FIELD
                (dialogType == "input") ? {
                    id: "input-box-field",
                    type: "text",
                    label: config.message,
                    labelPosition: "top",
                    width: "100%",
                    fieldWidth: "100%",
                    value: config.defaultValue || ""
                } : null,

                // SELECT FIELD
                (dialogType == "select") ? {
                    id: "input-box-field",
                    type: "select",
                    label: config.message,
                    labelPosition: "top",
                    width: "100%",
                    value: config.defaultValue || "",
                    multiple: !!config.multiple,
                    options: config.options || [],
                    allowValuesNotInList: false
                } : null,

                // DIRECTORY FIELD
                (dialogType == "directory") ? {
                    id: "input-box-field",
                    type: "directory",
                    label: config.message,
                    labelPosition: "top",
                    width: "100%",
                    value: config.defaultValue || "",
                    multiple: !!config.multiple,
                    users: (config.users === false) ? false : true,
                    groups: (config.groups === false) ? false : true,
                    roles: !!config.roles,
                    allowValuesNotInList: false
                } : null,

                // BUTTONS
                {
                    layout: "horizontal",
                    margin: "1rem 0 0 0",

                    defaultConfig: {
                        margin: "0.5rem"
                    },
                    items: (config.buttonOKPosition == "left") ? [buttonOK, buttonCancel] : [buttonCancel, buttonOK]
                }
            ],

            // Manage the keyboard shortcuts
            // - Enter to validate
            // - Esc to cancel
            events: {
                onkeydown(event) {
                    if (event.key == "Escape") {
                        this.close()
                    } else if (event.key == "Enter") {
                        this.validate()
                    }
                }
            },

            methods: {
                // Focus the panel or the input field so that keyboard events can be listened to
                _afterRender() {
                    if (dialogType == "input") {
                        setTimeout(() => $("input-box-field").focus(), 100)
                    } else {
                        setTimeout(() => this.panelBody.focus(), 100)
                    }
                },

                // Clicked on the OK button
                async validate() {
                    if (config.action) {
                        // If there is an action to handle the entered value
                        const newValue = ((dialogType == "input") || (dialogType == "select") || (dialogType == "directory")) ? $("input-box-field").getValue() : true
                        const result = await config.action(newValue)
                        if ((config.autoClose == null) || (config.autoClose == true) || (result == true)) this.close()
                    } else {
                        // Otherwise, just close
                        this.close()
                    }
                }
            }
        }

        // Optionally methods
        if (config.methods) Object.assign(dialogConfig.methods, config.methods)

        // Optionally bind events
        if (config.events) Object.assign(dialogConfig.events, config.events)

        // Generate the dialog using a Panel
        let dialog = createPanel(dialogConfig).render()

        return dialog
    }
}

/**
 * Shorthand to create a new Dialog window. See [kiss.ui.Dialog](kiss.ui.Dialog.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createDialog = (config) => new kiss.ui.Dialog(config)

;/**
 * 
 * The HTML component derives from [Component](kiss.ui.Component.html).
 * 
 * It's a simple component to encapsulate html.
 * 
 * @param {object} config
 * @param {object} config.html - The HTML content
 * @param {string} [config.position]
 * @param {string} [config.top]
 * @param {string} [config.left]
 * @param {string} [config.right]
 * @param {string} [config.float]
 * @param {string} [config.display]
 * @param {string} [config.flex]
 * @param {string} [config.flexFlow]
 * @param {string} [config.flexWrap]
 * @param {string} [config.alignItems]
 * @param {string} [config.justifyContent]
 * @param {string} [config.textAlign]
 * @param {string|number} [config.width]
 * @param {string|number} [config.minWidth]
 * @param {string|number} [config.maxWidth]
 * @param {string|number} [config.height]
 * @param {string|number} [config.minHeight]
 * @param {string|number} [config.maxHeight]
 * @param {string} [config.margin]
 * @param {string} [config.padding]
 * @param {string} [config.color]
 * @param {string} [config.background]
 * @param {string} [config.backgroundColor]
 * @param {string} [config.border]
 * @param {string} [config.borderStyle]
 * @param {string} [config.borderWidth]
 * @param {string} [config.borderColor]
 * @param {string} [config.borderRadius]
 * @param {string} [config.boxShadow]
 * @param {string} [config.overflow]
 * @param {string} [config.overflowX]
 * @param {string} [config.overflowY]
 * @param {number} [config.zIndex]
 * @param {string} [config.cursor]
 * @returns this
 * 
 * ## Generated markup
 * ```
 * <a-html class="a-html">
 * </a-html>
 * ```
 */
kiss.ui.Html = class Html extends kiss.ui.Component {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the 3 following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const myHtml = document.createElement("a-html").init(config)
     * ```
     * 
     * Or use the shorthand for it:
     * ```
     * const myHtml = createHtml({
     *   html: "Hello!"
     * })
     * 
     * myHtml.render()
     * ```
     * 
     * Or directly declare the config inside a container component:
     * ```
     * const myPanel = createPanel({
     *   title: "My panel",
     *   items: [
     *       {
     *           type: "html",
     *           html: "Hello!"
     *       }
     *   ]
     * })
     * 
     * myPanel.render()
     * ```
     */
    constructor() {
        super()
    }

    /**
     * Generates an HTML block from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config) {
        super.init(config)

        this.innerHTML = config.html || ""

        this._setProperties(config, [
            [
                ["display", "flex", "flexFlow", "flexFlow", "flexWrap", "alignItems", "justifyContent", "textAlign", "width", "minWidth", "maxWidth", "height", "minHeight", "maxHeight", "overflow", "overflowX", "overflowY", "padding", "margin", "position", "top", "left", "right", "float", "color", "fontSize", "fontWeight", "background", "backgroundColor", "boxShadow", "zIndex", "border", "borderStyle", "borderWidth", "borderColor", "borderRadius", "cursor"],
                [this.style]
            ]
        ])

        return this
    }

    /**
     * Set the content of the Html component
     * 
     * @param {string} html
     * @returns this
     */
    setInnerHtml(html) {
        this.config.html = html
        this.innerHTML = html
        return this
    }

    /**
     * Get the content of the Html component
     * 
     * @returns {string} The html content
     */
    getInnerHtml() {
        return this.innerHTML
    }

    /**
     * Set the element's width
     * 
     * @param {*} width - A valid CSS width value
     * @returns this
     */
    setWidth(width) {
        this.config.width = width
        this.style.width = this._computeSize("width", width)
        return this
    }

    /**
     * Set the element's height
     * 
     * @param {*} height - A valid CSS height value
     * @returns this
     */
    setHeight(height) {
        this.config.height = height
        this.style.height = this._computeSize("height", height)
        return this
    }     
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-html", kiss.ui.Html)

/**
 * Shorthand to create a new Html. See [kiss.ui.Html](kiss.ui.Html.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createHtml = (config) => document.createElement("a-html").init(config)

;/**
 * 
 * The Image component derives from [Component](kiss.ui.Component.html).
 * 
 * @param {object} config
 * @param {string} config.src
 * @param {string} [config.alt]
 * @param {string} [config.objectFit] - fill (default) | contain | cover | scale-down | none
 * @param {string} [config.position]
 * @param {string} [config.top]
 * @param {string} [config.left]
 * @param {string} [config.right]
 * @param {string} [config.float]
 * @param {string} [config.display]
 * @param {string|number} [config.width]
 * @param {string|number} [config.height]
 * @param {string} [config.margin]
 * @param {string} [config.padding]
 * @param {string} [config.border]
 * @param {string} [config.borderStyle]
 * @param {string} [config.borderWidth]
 * @param {string} [config.borderColor]
 * @param {string} [config.borderRadius]
 * @param {string} [config.boxShadow]
 * @param {number} [config.zIndex]
 * @param {boolean} [config.draggable]
 * @param {string} [config.cursor]
 * @returns this
 * 
 * ## Generated markup
 * ```
 * <a-image class="a-image">
 *  <img class="image-content">
 * </a-image>
 * ```
 */
kiss.ui.Image = class Image extends kiss.ui.Component {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the 3 following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const myImage = document.createElement("a-image").init(config)
     * ```
     * 
     * Or use the shorthand for it:
    * ```
    * const myImage = createImage({
    *  src: "./logo.png",
    *  alt: "Company logo"
    * })
    * 
    * myImage.render()
    * ```
    * 
    * Or directly declare the config inside a container component:
    * ```
    * const myPanel = createPanel({
    *   title: "My panel",
    *   items: [
    *       {
    *           type: "image",
    *           src: "./logo.png",
    *           alt: "Company logo"
    *       }
    *   ]
    * })
    * myPanel.render()
    * ```
    */
    constructor() {
        super()
    }

    /**
     * Generates an Image from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config) {
        super.init(config)

        // Template
        this.innerHTML = `<img id="image-content-${this.id}" src="${config.src}" ${(config.alt) ? `alt="${config.alt}"` : ""} class="image-content" loading="lazy">`

	    // Attach event to handle token/session renewal
	    kiss.session.setupImg(this.querySelector('img'))

        // Set properties
        this.imageContent = this.querySelector(".image-content")

        this._setProperties(config, [
            [
                ["draggable"],
                [this]
            ],            
            [
                ["minWidth", "minHeight", "width", "height","margin", "position", "top", "left", "right", "float", "boxShadow", "zIndex", "border", "borderStyle", "borderWidth", "borderColor", "borderRadius"],
                [this.style]

            ],
            [
                ["minWidth", "minHeight", "width", "height", "padding", "cursor", "objectFit"],
                [this.imageContent.style]
            ]
        ])

        return this
    }

    /**
     * Set the src of the Image component
     * 
     * @param {string} src
     * @returns this
     */
    setValue(src) {
        this.config.src = src
        this.imageContent.src = src
        return this
    }

    /**
     * Get the src of the Image component
     * 
     * @returns {string} The image src
     */
    getValue() {
        return this.imageContent.src
    }

    /**
     * Set the image's width
     * 
     * @param {*} width - A valid CSS width value
     * @returns this
     */
    setWidth(width) {
        this.config.width = width
        this.style.width = this._computeSize("width", width)
        return this
    }

    /**
     * Set the image's height
     * 
     * @param {*} height - A valid CSS height value
     * @returns this
     */
    setHeight(height) {
        this.config.height = height
        this.style.height = this._computeSize("height", height)
        return this
    }      
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-image", kiss.ui.Image)

/**
 * Shorthand to create a new Image. See [kiss.ui.Image](kiss.ui.Image.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createImage = (config) => document.createElement("a-image").init(config)

;/**
 * 
 * The Menu derives from [Component](kiss.ui.Component.html).
 * 
 * The menu contains a list of items where each items is:
 * ```
 * {
 *      text: "Do this",
 *      icon: "fas fa-cog", // Font awesome icon class
 *      iconSize: "40px", // Optional icon size
 *      iconColor: "#00aaee", // Optional icon color
 *      action: () => {} // Function to execute when the menu is clicked
 * }
 * ```
 * 
 * @param {object} config
 * @param {object[]|string[]} config.items - The array of menu entries
 * @param {boolean} config.closeOnClick - Set to false if the menu should not be closed after an entry is clicked. Default to true
 * @param {boolean} config.closeOnExit - Set to false if the menu should not be closed after exiting. Default to true
 * @param {string} [config.classModifier] - Custom class to apply to the menu and menu items
 * @param {string} [config.top]
 * @param {string} [config.left]
 * @param {string|number} [config.width]
 * @param {string|number} [config.maxWidth]
 * @param {string|number} [config.height]
 * @param {string|number} [config.maxHeight]
 * @param {string} [config.color]
 * @param {string} [config.background]
 * @param {string} [config.backgroundColor]
 * @param {string} [config.padding]
 * @param {string} [config.border]
 * @param {string} [config.borderStyle]
 * @param {string} [config.borderWidth]
 * @param {string} [config.borderColor]
 * @param {string} [config.borderRadius]
 * @param {string} [config.boxShadow]
 * @returns this
 * 
 * ## Generated markup
 * ```
 * <a-menu class="a-menu">
 * 
 *  <!-- For each menu item -->
 *  <div class="menu-item classModifier">
 *      <span class="menu-item-icon classModifier"></span>
 *      <span class="menu-item-text classModifier"></span>
 *  </div>
 * 
 *  <!-- For each menu separator -->
 *  <div class="menu-separator"></div>
 * 
 * </a-menu>
 * ```
 */
kiss.ui.Menu = class Menu extends kiss.ui.Component {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the 3 following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const myMenu = document.createElement("a-menu").init(config)
     * ```
     * 
     * Or use the shorthand for it:
     * ```
     * const myMenu = createMenu({
     *  items: [
     *      "This is a title", // Simple text is considered a title
     *      {
     *          icon: "fas fa-check",
     *          text: "Do this",
     *          action: () => {...}
     *      },
     *      "-", // Menu separator
     *      {
     *          hidden: !canSeeThisEntry, // It's possible to hide a menu entry using the hidden property
     *          icon: "fas fa-cube",
     *          text: "Do that",
     *          action: () => {...}
     *      },
     *      "Parameters:", // Text entries are processed as section titles inside the menu
     *      {
     *          icon: "fas fa-circle",
     *          iconSize: "32px", // It's possible to alter the default icon size
     *          iconColor: "#00aaee", // It's possible to alter the default icon color
     *          text: "Do that",
     *          action: () => {...}
     *      }
     *  ]
     * })
     * 
     * myMenu.render().showAt(100, 100) // Display the menu at position 100, 100
     * ```
     */
    constructor() {
        super()
    }

    /**
     * Generates an Menu from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config) {
        super.init(config)

        // Define a class modifier
        const altClass = config.classModifier || ""

        // Template for a single menu item
        let defaultMenuItemRenderer = function (config) {
            const iconSize = (config.iconSize) ? `font-size: ${config.iconSize};` : ""
            const iconColor = (config.iconColor) ? `color: ${config.iconColor}` : ""
            const iconStyle = (iconSize || iconColor) ? `style="${iconSize} ${iconColor}"` : ""

            return `
                ${(typeof config != "string")
                    ? `<div class="menu-item ${altClass}">
                            <span class="menu-item-icon ${altClass}"><i ${iconStyle} class="${config.icon}"></i></span>
                            <span class="menu-item-text ${altClass}">${config.text}</span>
                        </div>`
                    : ((config == "-") ? `<div class="menu-separator"></div>` : `<div class="menu-section">${config}</div>`)
                }`.removeExtraSpaces()
        }

        // Template for the complete menu which contains the menu items
        this.visibleItems = config.items.filter(item => item.hidden != true && item != null && item != "")
        
        // Add a header to close the menu for mobile UI
        this.innerHTML = (!kiss.screen.isMobile) ? "" : /*html*/`
            <span class="a-menu-mobile-close fas fa-chevron-left" onclick="this.closest('a-menu').close()"></span>
        `

        this.innerHTML += this.visibleItems.map(item => {
            const itemRenderer = item.itemRenderer || defaultMenuItemRenderer
            return itemRenderer(item)
        }).join("")

        // Set properties
        this.style.position = "absolute"
        this.style.display = "block"
        this.style.zIndex = 10000
        this.menuItems = this.querySelectorAll(".menu-item, .menu-separator, .menu-section")

        // Prevent menu from overflowing the viewport height
        if (!config.maxHeight) config.maxHeight = () => kiss.screen.current.height - 20

        // Apply configs
        this._setProperties(config, [
            [
                ["padding", "top", "left", "bottom", "right", "width", "minWidth", "maxWidth", "height", "minHeight", "maxHeight", "color", "background", "backgroundColor", "border", "borderStyle", "borderWidth", "borderColor", "borderRadius", "boxShadow", "zIndex"],
                [this.style]
            ],
            [
                ["itemBackground=background"],
                Array.from(this.menuItems).map(menuItem => menuItem.style) // Apply to all menu sub-items
            ]
        ])

        // Auto closing (default to true)
        if (config.closeOnClick !== false) config.closeOnClick = true

        // Bind menu item actions to DOM nodes 'onclick' event
        let menu = this
        for (let i = 0; i < this.menuItems.length; i++) {
            if (typeof menu.visibleItems[i] != "string") this.menuItems[i].onclick = function (event) {
                if (config.closeOnClick) menu.close()
                menu.visibleItems[i].action(event)
            }
        }

        // Remove menu on exit
        if (config.closeOnExit !== false) this.onmouseleave = () => this.close()

        // Set a default animation
        this.setAnimation(config.animation || {
            name: "zoomIn",
            speed: "light"
        })

        return this
    }

    /**
     * Close the menu (remove it from the DOM)
     */
    close() {
        kiss.views.remove(this.id)
    }

    /**
     * Ensure the menu is 100% visible inside the viewport
     * 
     * @private
     * @ignore
     */
    _afterRender() {
        kiss.tools.moveToViewport(this)
    }
}

/**
 * Close all menus when clicking outside of menu
 */
document.addEventListener('mousedown', function(event) {
    const menu = document.querySelector('a-menu')
    if (!menu) return

    const rect = menu.getBoundingClientRect()
    const x = event.clientX
    const y = event.clientY

    if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) return

    const menus = Array.from(document.querySelectorAll("a-menu"))
    menus.forEach(menu => menu.close())        
})

// Create a Custom Element and add a shortcut to create it
customElements.define("a-menu", kiss.ui.Menu)

/**
 * Shorthand to create a new Menu. See [kiss.ui.Menu](kiss.ui.Menu.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createMenu = (config) => document.createElement("a-menu").init(config)

;/**
 * 
 * Display a notification that disapears automatically (after 1 second by default)
 * 
 * @param {object} config
 * @param {string} config.message
 * @param {string} [config.background] - Background color. Default = #000000
 * @param {string} [config.color] - Font color. Default = #ffffff
 * @param {string} [config.fontFamily] - Font family. Default = Arial
 * @param {string} [config.fontWeight] - Font weight. Default = normal
 * @param {number} [config.top] - Top position. Default = 100
 * @param {string|number} [config.width]
 * @param {string|number} [config.height]
 * @param {string|number} [config.padding] - Default 10px
 * @param {number} [config.duration] - Duration in milliseconds. Default = 1000
 * @returns this
 */
kiss.ui.Notification = class Notification {
    /**
     * You can create a Notification using the class or using the shorthand:
     * ```
     * // Using kiss namespace
     * new kiss.ui.Notification(config)
     * 
     * // Using the shorthand
     * createNotification(config)
     * ```
     * 
     * @param {object} config 
     * @returns this
     * 
     * @example
     * // Text with options
     * createNotification({
     *  message: "You've completed your task!",
     *  top: 500,
     *  duration: 2000
     * })
     * 
     * // Simple text
     * createNotification("Hello world")
     */
    constructor(config) {

        let message = (typeof config == "string") ? config : config.message || ""
        message = message.replaceAll("\n", "<br>")

        const notificationConfig = {
            top: (config.top === undefined) ? "10rem" : config.top,
            width: config.width,
            height: config.height,
            padding: config.padding,
            position: "fixed",
            header: false,
            class: "a-notification",
            styles: {
                this: ""
            },
            animation: {
                name: config.setAnimation || "slideInDown",
                speed: "faster"
            },
            items: [{
                type: "html",
                width: "100%",
                html: message
            }]
        }

        // Apply styles
        if (config.background) notificationConfig.styles.this = `background: ${config.background}; border-color: ${config.background}`
        if (config.color) notificationConfig.styles.this += `; color: ${config.color}`
        if (config.fontFamily) notificationConfig.styles.this += `; font-family: ${config.fontFamily}`
        if (config.fontWeight) notificationConfig.styles.this += `; font-weight: ${config.fontWeight}`

        // Horizontal alignement
        if (config.hasOwnProperty("left")) {
            notificationConfig.left = config.left
        }
        else {
            notificationConfig.align = "center"
        }
        
        const notification = createPanel(notificationConfig).render()

        setTimeout(() => {
            notification.setAnimation({
                name: "fadeOut",
                speed: "faster",
                callback: () => {
                    if (notification) notification.close()
                }
            })
        }, (config.duration || 2000))

        // Keep history of messages
        // kiss.global.notifications = (kiss.global.notifications || []).concat({
        //     createdAt: new Date().toISOString(),
        //     message
        // })

        return notification
    }
}

/**
 * Shorthand to create a new Notification. See [kiss.ui.Notification](kiss.ui.Notification.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createNotification = (config) => new kiss.ui.Notification(config)

;/**
 * 
 * The Spacer component derives from [Component](kiss.ui.Component.html).
 * 
 * It's a simple empty element used as a spacer in the layout.
 * It can be useful to take advantage of the CSS flex layout system, or if you need to fill some space.
 * 
 * @param {object} config
 * @param {string} [config.display]
 * @param {string} [config.flex]
 * @param {string|number} [config.width]
 * @param {string|number} [config.height]
 * @returns this
 * 
 * ## Generated markup
 * ```
 * <a-spacer class="a-spacer">
 * </a-spacer>
 * ```
 */
kiss.ui.Spacer = class Spacer extends kiss.ui.Component {
   /**
    * The only use case is when you need to set space between elements without using margins:
    * ```
    * const myPanel = createPanel({
    *   title: "My panel",
    *   display: "flex",
    *   flexFlow: column,
    *   items: [
    *       {
    *           type: "html",
    *           html: "Block 1",
    *           flex: 1
    *       },
    *       {
    *           type: "spacer",
    *           flex: 0.5
    *       },
    *       {
    *           type: "html",
    *           html: "Block 2",
    *           flex: 1
    *       },
    *       {
    *           type: "spacer",
    *           height: "32px"
    *       },
    *       {
    *           type: "html",
    *           html: "Block 3",
    *           flex: 1
    *       }
    *   ]
    * })
    * myPanel.render()
    * ```
    */    
    constructor() {
        super()
    }

    /**
     * Generates an simple spacer DIV from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config) {
        super.init(config)

        this.style.display = "block"

        // Set properties
        this._setProperties(config, [
            [
                ["display", "width", "height", "flex"],
                [this.style]
            ]
        ])

        return this
    }
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-spacer", kiss.ui.Spacer)
const createSpacer = (config) => document.createElement("a-spacer").init(config)

;/**
 * 
 * Display a tip that follows the mouse cursor.
 * The tip is just a floating <Html> component that moves with the cursor.
 * 
 * @param {object} config
 * @param {string} config.text - Tip text
 * @param {string} [config.textAlign] - ex: "center"
 * @param {string} [config.target] - DOM target insertion point
 * @param {number} [tipConfig.x] - Optional static x
 * @param {number} [tipConfig.Y] - Optional static y
 * @param {object} [config.deltaX] - X position difference from the cursor position
 * @param {object} [config.deltaY] - Y position difference from the cursor position
 * @param {object} [config.minWidth]
 * @param {object} [config.maxWidth]
 * @returns this
 */
kiss.ui.Tip = class Tip {
    /**
     * You can create a Tip using the class, the shorthand, the HTMLElement "attachTip" method, or the "tip" property of KissJS components:
     * ```
     * // Using kiss namespace
     * new kiss.ui.Tip(config)
     * 
     * // Using the class
     * new Tip(config)
     * 
     * // Using the shorthand
     * createTip({
     *  target: "your_element_id",
     *  text: "your tip text",
     *  deltaX: 0,
     *  deltaY: 20
     * })
     * 
     * // You can also directly attach a tip to any HTMLElement or KissJS component like this:
     * myHTMLElementOrKissComponent.attachTip({
     *  text: "your tip text",
     *  deltaX: 0,
     *  deltaY: 20
     * })
     * 
     * // Finally, KissJS components have a "tip" property to attach a tip automatically:
     * const myTextField = createField({
     *  type: "textarea",
     *  label: "Comments",
     *  tip: "Please, tell us about what you think"
     * })
     * 
     * const myButton = createButton({
     *  icon: "fas fa-rocket",
     *  tip: "Click to launch the rocket!"
     * })
     * ```
     */
    constructor(config) {
        const tipId = uid()
        const targetElement = config.target
        const deltaX = config.deltaX || 0
        const deltaY = config.deltaY || 20
        const minWidth = config.minWidth || "5rem"
        const maxWidth = config.maxWidth || "30rem"
        const message = config.text.replaceAll("\n", "<br>")

        return createHtml({
            id: tipId,
            position: "absolute",
            display: "block",
            zIndex: 50000,
            class: "a-tip",
            minWidth,
            maxWidth,

            html: (config.textAlign) ? `<div style="width: 100%; text-align: ${config.textAlign}">${message}</div>` : message,

            methods: {
                /**
                 * When the tip is rendered, the component triggers this load method.
                 * We track the mousemove event at the document level.
                 * Note that it will overwrite other onmousemove events, if any.
                 */
                load() {                    
                    // Make the tip follow the mouse cursor
                    document.addEventListener("mousemove", this.showTip)

                    // Display the tip on the target when entering it
                    targetElement.onmouseenter = () => this.render()

                    // Hide the tip and destroy the document.mousemove event when leaving the target
                    targetElement.onmouseleave = () => this.hideTip()

                    // Hide the tip and destroy the document.mousemove event when the target is deleted
                    targetElement._beforeDelete = () => this.hideTip()
                }, 
                
                hideTip() {
                    document.removeEventListener("mousemove", this.showTip)
                    this.remove()
                },

                detach() {
                    document.removeEventListener("mousemove", this.showTip)
                    targetElement.onmouseenter = null
                    targetElement.onmouseleave = null
                    this.remove()
                },

                showTip(event) {
                    if (!event) return
                    const element = $(tipId)
                    element.showAt(config.x || event.pageX + deltaX, config.y || event.pageY + deltaY)
                }
            }
        })
    }
}

/**
 * Shorthand to create a new Tip. See [kiss.ui.Tip](kiss.ui.Tip.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createTip = (config) => new kiss.ui.Tip(config)

;/**
 * 
 * The Attachment derives from [Component](kiss.ui.Component.html).
 * 
 * It allow to manipulate files:
 * - upload files
 * - preview uploaded files
 * - delete files
 * 
 * @param {object} config
 * @param {string} [config.label]
 * @param {string} [config.buttonText] - Text of the upload button. Defaults to "attach files"
 * @param {object[]} [config.value] - Default value
 * @param {string} [config.layout] - "" (default) | "thumbnails" | "thumbnails-large"
 * @param {boolean} [config.allowLayout] - true (default) to display the buttons to change the layout
 * @param {boolean} [config.multiple] - TODO: true to enable multi-select
 * @param {boolean} [config.readOnly]
 * @param {boolean} [config.disabled] - TODO
 * @param {boolean} [config.required] - TODO
 * @param {string} [config.margin]
 * @param {string} [config.padding]
 * @returns this
 * 
 * ## Generated markup
 * The field is a composition of various elements:
 * - a span for the field label
 * - a span for the button to upload new files, which includes a span for the button icon
 * - a div to display the gallery of thumbnails
 * 
 * ```
 * <a-attachment class="a-attachment">
 *   <span class="field-label"></span>
 *   <span class="a-button attachment-button field-upload-button">
 *       <span class="fas fa-paperclip attachment-icon"></span> Attach files
 *   </span>
 *   <div class="field-attachment-gallery">
 *   </div>
 * </a-attachment>
 * ```
 */
kiss.ui.Attachment = class Attachment extends kiss.ui.Component {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the 3 following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const myAttachment = document.createElement("a-attachment").init(config)
     * ```
     * 
     * Or use the shorthand for it:
     * ```
     * const myAttachment = createAttachment({
     *  label: "My uploaded files",
     *  multiple: true
     * })
     * 
     * myAttachment.render()
     * ```
     * 
     * Or directly declare the config inside a container component:
     * ```
     * const myPanel = createPanel({
     *   title: "My panel",
     *   items: [
     *       {
     *          type: "attachment",
     *          label: "My uploaded files",
     *          multiple: true
     *       }
     *   ]
     * })
     * myPanel.render()
     * ```
     */
    constructor() {
        super()
    }

    /**
     * Generates a Select field from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config = {}) {
        super.init(config)

        this.value = config.value || []
        this.multiple = (config.multiple === false) ? false : true
        this.readOnly = !!config.readOnly

        // The component only works with arrays
        if (!Array.isArray(this.value)) this.value = []

        // Template
        this.innerHTML =
            `${(config.label) ? `<span id="field-label-${this.id}" class="field-label">
                    ${ (this.isLocked()) ? this.locker : "" }
                    ${ config.label || "" }
                    ${ (this.isRequired()) ? this.asterisk : "" }
                </span>` : "" }

                ${(!this.readOnly)
                    ? `<span class="a-button field-attachment-button field-upload-button">
                        <span class="fas fa-paperclip field-attachment-icon"></span>
                        ${config.buttonText || txtTitleCase("attach files")}
                    </span>`
                    : ""}
                
                <span class="field-attachment-layout">
                    <span class="a-button field-attachment-button display-as-list fas fa-th-list"></span>
                    <span class="a-button field-attachment-button display-as-thumbnails fas fa-th-large"></span>
                    <span class="a-button field-attachment-button display-as-thumbnails-large fas fa-stop"></span>
                </span>

                <div class="field-attachment-gallery"></div>
             `.removeExtraSpaces()

        this.label = this.querySelector(".field-label")
        this.fieldValues = this.querySelector(".field-attachment-gallery")
        this.uploadButton = this.querySelector(".field-upload-button")
        this.layoutButtons = this.querySelector(".field-attachment-layout")

        // Set properties
        this._setProperties(config, [
            [
                ["margin", "padding"],
                [this.style]
            ]
        ])

        // Set the default display mode
        this.displayMode = "flex"

        // Get the layout: list or thumbnails
        this._initLayout()

        // Add field base class
        this.classList.add("a-attachment")
        // if (this.readOnly) this.classList.add("field-attachment-read-only")

        // Bind the field to a record, if any
        if (config.record) this._bindRecord(config.record)

        // Render values after a short delay to not interfer with form rendering
        setTimeout(() => this._renderValues(), 200)

        this._initClickEvent()

        return this
    }

    /**
     * Handle click event
     * 
     * @private
     * @ignore
     */
    _initClickEvent() {
        this.onclick = function (event) {
            if (event.target.classList.contains("field-upload-button")) {
                this.showUploadWindow()
            } else if (event.target.classList.contains("display-as-list")) {
                this.renderAs("list")
            } else if (event.target.classList.contains("display-as-thumbnails")) {
                this.renderAs("thumbnails")
            }  else if (event.target.classList.contains("display-as-thumbnails-large")) {
                this.renderAs("thumbnails-large")
            }
        }
    }

    /**
     * Render the attachments in different modes:
     * - list
     * - thumbnails
     * - large thumbnails
     * 
     * @param {string} mode - "list" | "thumbnails" | "thumbnails-large"
     */
    renderAs(mode) {
        if (mode == "list") {
            localStorage.removeItem("config-layout-" + this.id)
            mode = ""
        }
        else {
            localStorage.setItem("config-layout-" + this.id, mode)
            mode = "-" + mode
        }
        
        this._initLayout()
        this._setItemClass("item", "field-attachment-item" + mode)
        this._setItemClass("preview", "field-attachment-preview" + mode)
        this._setItemClass("filename", "field-attachment-filename" + mode)
    }

    /**
     * @private
     * @ignore
     */
    _getItemsByRole(role) {
        return Array.from(this.querySelectorAll(`[role="${role}"]`))
    }

    /**
     * @private
     * @ignore
     */
    _setItemClass(role, classname) {
        const items = this._getItemsByRole(role)
        items.forEach(item => {
            item.classList.remove("field-attachment-" + role)
            item.classList.remove("field-attachment-" + role + "-thumbnails")
            item.classList.remove("field-attachment-" + role + "-thumbnails-large")
            item.classList.add(classname)
        })
    }

    /**
     * Switch 2 classes of an element
     * 
     * @private
     * @ignore
     */    
    _switchClass(fromClass, toClass, large) {
        Array.from(this.querySelectorAll(".field-attachment-item")).forEach(element => {
            element.classList.remove(fromClass)
            element.classList.add(toClass)
        })
    }

    /**
     * Display the upload window of the attachment field
     * 
     * @param {number} [maxSize] - The maximum size of the file to upload, in bytes. Defaults to 0 (no limit)
     */
    showUploadWindow(maxSize = 0) {
        createFileUploadWindow({
            modelId: this.record?.model.id,
            recordId: this.record?.id,
            fieldId: this.id,
            maxSize
        })
    }

    /**
     * Bind the field to a record
     * (this subscribes the field to react to database changes)
     * 
     * @private
     * @ignore
     * @param {object} record
     * @returns this
     */
    _bindRecord(record) {
        this.record = record
        this.modelId = record.model.id
        this.recordId = record.id

        if (record[this.id]) {
            this.value = this.initialValue = record[this.id]
        }

        // React to changes on a single record of the binded model
        this.subscriptions.push(
            subscribe("EVT_DB_UPDATE:" + this.modelId.toUpperCase(), (msgData) => {
                if ((msgData.modelId == this.modelId) && (msgData.id == this.recordId)) {
                    const updates = msgData.data
                    this._updateField(updates)
                }
            })
        )

        // React to changes on multiple records of the binded Model
        this.subscriptions.push(
            subscribe("EVT_DB_UPDATE_BULK", (msgData) => {
                const operations = msgData.data
                operations.forEach(operation => {
                    if ((operation.modelId == this.modelId) && (operation.recordId == this.recordId)) {
                        const updates = operation.updates
                        this._updateField(updates)
                    }
                })
            })
        )

        return this
    }

    /**
     * Updates the field value internally, just to render the new value
     * 
     * @private
     * @ignore
     * @param {*} updates 
     */
    _updateField(updates) {
        if (this.id in updates) {
            const newValue = updates[this.id]
            if (newValue) {
                this.value = newValue
                this._renderValues()
                if (this.onchange) this.onchange(newValue)
            }
        }
    }    

    /**
     * Set the field value
     * 
     * @param {object[]} newValues - The new field value
     * @param {boolean} [rawUpdate] - If true, it doesn't update the associated record and doesn't trigger "change" event 
     * @returns this
     */
    setValue(newValues, rawUpdate) {
        newValues = [].concat(newValues)

        if (rawUpdate) return this._updateValue(newValues, rawUpdate)

        if (this.record) {
            // If the field is connected to a record, we update the database
            this.record.updateFieldDeep(this.id, newValues).then(success => {
                if (success) {
                    this._updateValue(newValues)
                    this.initialValue = newValues
                } else {
                    // Rollback the initial value if the update failed (ACL)
                    this._updateValue(this.initialValue)
                }
            })
        } else {
            this._updateValue(newValues)
        }

        return this
    }

    /**
     * Clear the field value
     * 
     * @returns this
     */
    clearValue() {
        this.setValue([])
        return this
    }

    /**
     * Update the field's value
     * 
     * @private
     * @ignore
     * @param {object[]} newValues
     * @param {boolean} [rawUpdate]
     * @returns this
     */
    _updateValue(newValues, rawUpdate) {
        this.value = newValues
        this._renderValues()
        if (this.onchange && !rawUpdate) this.onchange(newValues)
        return this
    }

    /**
     * Get the field value
     * 
     * @returns {string[]} - The field value
     */
    getValue() {
        return this.value || []
    }

    /**
     * Reset the field value
     * 
     * @returns this
     */
    resetValue() {
        this.value = []
        this._renderValues()
        return this
    }

    /**
     * Get the field label
     * 
     * @returns {string}
     */
    getLabel() {
        return this?.label?.innerText || ""
    }

    /**
     * Set the field label
     * 
     * @param {string} newLabel
     * @returns this
     */
    setLabel(newLabel) {
        if (!this.label) return

        this.config.label = newLabel
        this.label.innerText = newLabel
        return this
    }

    /**
     * Validate the field (always true because Attachment fields can't have wrong values)
     * 
     * @returns {boolean}
     */
    validate() {
        return true
    }

    /**
     * Restore the layout (list or thumbnails)
     * 
     * @private
     * @ignore
     */
    _initLayout() {
        this.layout = localStorage.getItem("config-layout-" + this.id)
        if (!this.layout) this.layout = this.config.layout || ""
    }

    /**
     * Render the current value(s) of the widget.
     * 
     * @private
     * @ignore
     */
    _renderValues() {
        // Empty value
        if ((this.value == "") || (this.value == null) || (this.value == "undefined") || (this.value[0] == null) || (this.value[0] == "")) {
            this.fieldValues.innerHTML = ""
            this.fieldValues.style.display = "none"
            this.layoutButtons.style.display = "none"
            if (this.uploadButton) this.uploadButton.style.display = "inline-flex"
            return
        }

        // The component accepts values that are not arrays, but it only works with arrays internally
        if (!Array.isArray(this.value)) this.value = [this.value]

        this.fieldValues.innerHTML = this.value.map((file, i) => {
            return this._renderValue(file, i)

        }).join("")

        this.fieldValues.style.display = "flex"
        if (this.config.allowLayout !== false) {
            this.layoutButtons.style.display = "inline-block"
        }
        else {
            this.layoutButtons.style.display = "none"
        }

        // Hide the upload button if the field is not "multiple" and the value is not empty
        if (this.multiple === false && this.getValue().length > 0) this.uploadButton.style.display = "none"

        // All files that don't have a public URL will be handled by a specific and authenticated download link
        kiss.session.setupDownloadLink(...this.fieldValues.querySelectorAll('a[download]'))
        kiss.session.setupImg(...this.fieldValues.querySelectorAll('img'))
    }

    /**
     * Render a single file
     * 
     * @private
     * @ignore
     */
    _renderValue(file, i) {
        if (!file.path) return ""
        const isPublic = (file.accessReaders && Array.isArray(file.accessReaders) && file.accessReaders.includes("*"))
        const lockIcon = (isPublic) ? "fas fa-lock-open" : "fas fa-lock"
        const layout = (this.layout.includes("thumbnails")) ? "-" + this.layout : ""

        let preview
        let filePath = kiss.tools.createFileURL(file)
        let fileThumbnail = kiss.tools.createFileURL(file, "m")
        const fileExtension = file.path.split(".").pop().toLowerCase()

        if (["jpg", "jpeg", "png", "gif", "webp"].indexOf(fileExtension) != -1) {
            // Image
            preview = `<img role="preview" public="${isPublic}" class="field-attachment-preview${layout}" src="${fileThumbnail}" loading="lazy"></img>`
        } else {
            // Other
            const {
                icon,
                color
            } = kiss.tools.fileToIcon(fileExtension)
            preview = `<span role="preview" style="color: ${color}" class="fas ${icon} field-attachment-preview${layout}"></span>`
        }

        return /*html*/ `
                <div role="item" class="field-attachment-item${layout}" id="${file.id}" onclick="this.closest('.a-attachment')._previewAttachment(event)">
                    <div class="field-attachment-preview-container">${preview}</div>
                    <span role="filename" class="field-attachment-filename${layout}">${file.filename}</span>
                    <span class="field-attachment-buttons">
                        <span class="field-attachment-filesize">${file.size.toFileSize()}</span>
                        <span style="flex:1"></span>
                        ${(this.readOnly) ? "" : `<span class="field-attachment-delete fas fa-trash" index="${i}" onclick="$('${this.id}')._deleteFile(event, '${file.id}')"></span>`}
                        ${(this.readOnly) ? "" : `<span class="field-attachment-access ${lockIcon}" index="${i}" onclick="$('${this.id}')._switchFileACL(event, '${file.id}')"></span>`}
                        <a href="${filePath}" download public="${isPublic}" target="_blank"><span class="field-attachment-download far fa-arrow-alt-circle-down"></span></a>
                    </span>
                </div>`

        // Add this line *inside* the div to show the file menu icon
        // <span class="field-attachment-menu fas fa-ellipsis-v" index="${i}" onclick="$('${this.id}')._openFileMenu(event, '${file.id}')"></span>     
    }

    /**
     * !Not used yet
     * Open a menu with the file operations
     * 
     * @private
     * @ignore
     * @param {*} event 
     * @param {string} fileId 
     */
    _openFileMenu(event, fileId) {
        event.stop()

        const currentValues = this.getValue()
        const file = currentValues.get(fileId)
        const ACL = (file.accessReaders.includes("*")) ? "private" : "public"
        const lockIcon = (ACL == "public") ? "fas fa-lock-open" : "fas fa-lock"

        createMenu({
            top: event.clientY - 10,
            left: event.clientX - 10,
            items: [{
                icon: lockIcon,
                text: txtTitleCase("#update file ACL", null, {
                    access: txtUpperCase(ACL)
                }),
                action: async () => {
                    const response = await kiss.ajax.request({
                        url: "/updateFileACL",
                        method: "patch",
                        showLoading: true,
                        body: JSON.stringify({
                            modelId: this.modelId,
                            recordId: this.recordId,
                            fieldId: this.id,
                            file,
                            ACL
                        })
                    })

                    if (response.success) {
                        const message = "<center>" + txtTitleCase("#updating ACL") + "<br><b>" + txtUpperCase(ACL)
                        createNotification({
                            message,
                            duration: 2000
                        })
                    }                    
                }
            }]
        }).render()
    }

    /**
     * Preview an attachment
     * 
     * @private
     * @ignore
     * @param {object} event
     * @param {string} fieldId 
     */
    _previewAttachment(event) {

        // Exit if clicked on the download link
        if ([...event.target.classList].includes("field-attachment-download")) return

        const itemClass = (this.layout) ? ".field-attachment-item-" + this.layout : ".field-attachment-item"
        const attachmentId = event.target.closest(itemClass).id
        const cellAttachments = this.getValue()

        if (this.record) {
            createPreviewWindow(cellAttachments, attachmentId, this.record.id, this.id)
        }
        else {
            createPreviewWindow(cellAttachments, attachmentId)
        }

        // Add a button to switch the display mode in the preview window
        // This allows to view the file on the right side of the screen
        // while keeping the form on the left side
        if (this.record) {
            if ($("preview-window").panelCustomIcons.children.length > 0) return

            $("preview-window").addHeaderIcon(            {
                hidden: (kiss.screen.isMobile && kiss.screen.isVertical()),
                icon: "fas fa-columns",
                tip: txtTitleCase("#preview mode"),
                action: () => $("preview-window").switchDisplayMode()
            })
        }
    }

    /**
     * Switch a file ACL between public and private
     * 
     * @private
     * @ignore
     * @param {*} event 
     * @param {string} fileId 
     */
    async _switchFileACL(event, fileId) {
        event.stop()
        if (kiss.session.isOffline()) return

        const currentValues = this.getValue()
        const file = currentValues.get(fileId)
        const newACL = (file.accessReaders && Array.isArray(file.accessReaders) && file.accessReaders.includes("*")) ? "private" : "public"

        const response = await kiss.ajax.request({
            url: "/updateFileACL",
            method: "patch",
            showLoading: true,
            body: JSON.stringify({
                modelId: this.modelId,
                recordId: this.recordId,
                fieldId: this.id,
                file,
                ACL: newACL
            })
        })

        if (response.success) {
            const message = "<center>" + txtTitleCase("#updating ACL") + "<br><b>" + txtUpperCase(newACL)
            createNotification({
                message,
                duration: 2000
            })
        }
    }

    /**
     * Delete a file from the attachment field
     * 
     * @private
     * @ignore
     * @param {object} event
     * @param {string} fileId 
     */
    _deleteFile(event, fileId) {
        event.stop()
        if (kiss.session.isOffline()) return

        createDialog({
            type: "danger",
            title: txtTitleCase("deleting a file"),
            message: txtTitleCase("#warning delete file"),
            buttonOKPosition: "left",

            action: async () => {
                let currentValues = this.getValue()
                let newValues = currentValues.removeById(fileId)

                // Delete the file from the "file" collection
                const fileCollection = kiss.app.collections.file

                const loadingId = kiss.loadingSpinner.show()
                const response = await fileCollection.deleteOne(fileId)

                // Update the field value if the file could be physically deleted
                if (response.success) {
                    this.setValue(newValues)
                }
                kiss.loadingSpinner.hide(loadingId)
            }
        })
    }
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-attachment", kiss.ui.Attachment)

/**
 * Shorthand to create a new File Uploader field. See [kiss.ui.Attachment](kiss.ui.Attachment.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createAttachment = (config) => document.createElement("a-attachment").init(config)

;/**
 * 
 * The Checkbox derives from [Component](kiss.ui.Component.html).
 * 
 * Provides a customizable checkbox.
 * 
 * @param {object} config
 * @param {string} config.label
 * @param {string} [config.labelWidth]
 * @param {string} [config.labelPosition] - left | right | top | bottom
 * @param {string} [config.labelAlign] - left | right
 * @param {string} [config.color]
 * @param {string} [config.fontSize]
 * @param {string} [config.shape] - check | square | circle | switch | star
 * @param {string} [config.iconSize]
 * @param {string} [config.iconOn]
 * @param {string} [config.iconOff]
 * @param {string} [config.iconColorOn]
 * @param {string} [config.iconColorOff]
 * @param {string} [config.formula]
 * @param {boolean} [config.checked] - Default state - Can use "checked" or "value" indifferently
 * @param {boolean} [config.value] - Default state - Can use "checked" or "value" indifferently
 * @param {string|number} [config.width]
 * @param {string|number} [config.height]
 * @param {string} [config.margin]
 * @param {string} [config.padding]
 * @param {boolean} [config.readOnly]
 * @param {boolean} [config.disabled]
 * @returns this
 * 
 * ## Generated markup
 * ```
 * <a-checkbox class="a-checkbox">
 *  <label class="field-label"></label>
 *  <span class="field-checkbox-icon font-awesome-icon-class"></span>
 *  <input type="checkbox" class="field-checkbox">
 * </a-checkbox>
 * ```
 */
kiss.ui.Checkbox = class Checkbox extends kiss.ui.Component {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the 3 following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const myCheckbox = document.createElement("a-checkbox").init(config)
     * ```
     * 
     * Or use the shorthand for it:
     * ```
     * const myCheckbox = createCheckbox({
     *  text: "Check me!",
     *  shape: "switch"
     * })
     * 
     * myCheckbox.render()
     * ```
     * 
     * Or directly declare the config inside a container component:
     * ```
     * const myPanel = createPanel({
     *   title: "My panel",
     *   items: [
     *       {
     *           type: "checkbox",
     *           text: "Check me!",
     *           shape: "switch"
     *       }
     *   ]
     * })
     * myPanel.render()
     * ```
     */
    constructor() {
        super()
    }

    /**
     * Generates a Checkbox from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config) {
        super.init(config)

        const id = this.id

        // Checkbox shape
        config.shape = config.shape || "square"
        const iconClasses = this.getIconClasses()
        const defaultIconOn = iconClasses[config.shape]["on"]
        const defaultIconOff = iconClasses[config.shape]["off"]

        // Accept "value" or "checked" as default value to keep it uniform with all other field types
        let isChecked = config.checked || config.value

        // Overwrite default value if the field is binded to a record
        // (default value must not override record's value)
        if (config.record && config.record[this.id] !== undefined) isChecked = config.record[this.id]

        this.iconOn = config.iconOn || defaultIconOn
        this.iconOff = config.iconOff || defaultIconOff
        this.iconColorOn = config.iconColorOn || "#20c933"
        this.iconColorOff = config.iconColorOff || "#aaaaaa"
        const defaultIcon = (isChecked == true) ? this.iconOn : this.iconOff
        const defaultIconColor = (isChecked == true) ? this.iconColorOn : this.iconColorOff

        // Disable the field if it's readOnly
        this.readOnly = !!config.readOnly || !!config.computed
        if (this.readOnly) config.disabled = true
        
        // Template
        this.innerHTML = /*html*/
            `${(config.label) ? `<label id="field-label-${id}" for="${id}" class="field-label">
                    ${ (this.isLocked()) ? this.locker : "" }
                    ${ config.label || "" }
                    ${ (this.isRequired()) ? this.asterisk : "" }
                </label>` : "" }

                <span id="" style="color: ${defaultIconColor}" class="field-checkbox-icon ${defaultIcon} ${(this.readOnly) ? "field-checkbox-read-only" : ""}"></span>
                <input type="checkbox" id="${id}" name="${id}" ${(isChecked) ? `checked="${isChecked}"` : ""} class="field-checkbox" ${(config.disabled == true) ? "disabled" : ""}>
            `.removeExtraSpaces()

        // Set properties
        this.label = this.querySelector(".field-label")
        this.field = this.querySelector(".field-checkbox")
        this.icon = this.querySelector(".field-checkbox-icon")

        // Other W3C properties
        this._setProperties(config, [
            [
                ["draggable"],
                [this]
            ],
            [
                ["width", "height", "display", "margin", "padding", "flex"],
                [this.style]
            ],
            [
                ["value"],
                [this.field]
            ],
            [
                ["fieldWidth=width", "height=lineHeight", "iconSize=fontSize"],
                [this.icon.style]
            ],
            [
                ["color", "fontSize", "labelAlign=textAlign", "labelFlex=flex"],
                [this?.label?.style]
            ]
        ])

        // Set the default display mode that will be restored by the show() method
        this.displayMode = "flex"

        // Manage label and field layout according to label position
        this.style.flexFlow = "row"

        // Listen to click events if the field is *not* disabled or *readonly*
        if (config.disabled != true && !this.readOnly) {
            this.icon.onclick = () => {
                this.field.checked = !this.field.checked
                this.setValue(this.field.checked)
            }
        }

        // Label setup
        if (config.label) {
            // Label width
            if (config.labelWidth) this.setLabelWidth(config.labelWidth)

            // Label position
            this.config.labelPosition = config.labelPosition || "left"
            this.setLabelPosition(config.labelPosition)

            // Listen to click events if the field is *not* disabled or *readOnly*
            if (config.disabled != true) this.label.onclick = this.icon.onclick
        }

        // Add field base class
        this.classList.add("a-field")

        // Bind the field to a record, if any
        if (config.record) this._bindRecord(config.record)

        // Render default value
        this._renderValues()

        return this
    }

    /**
     * Get the icon classes for each checkbox shape
     * 
     * @returns {object}
     */
    getIconClasses() {
        return {
            check: {
                on: "far fa-check-square",
                off: "far fa-square"
            },            
            square: {
                on: "far fa-check-square",
                off: "far fa-square"
            },
            circle: {
                on: "far fa-check-circle",
                off: "far fa-circle"
            },
            switch: {
                on: "fas fa-toggle-on",
                off: "fas fa-toggle-off"
            },
            star: {
                on: "fas fa-star",
                off: "far fa-star"
            }
        }
    }    

    /**
     * Bind the field to a record
     * (this subscribes the field to react to database changes)
     * 
     * @private
     * @ignore
     * @param {object} record
     * @returns this
     */
    _bindRecord(record) {
        this.record = record
        this.modelId = record.model.id
        this.recordId = record.id

        if (record[this.id]) {
            this.field.checked = this.initialValue = record[this.id]
        }

        // React to changes on a single record of the binded model
        this.subscriptions.push(
            subscribe("EVT_DB_UPDATE:" + this.modelId.toUpperCase(), (msgData) => {
                if ((msgData.modelId == this.modelId) && (msgData.id == this.recordId)) {
                    const updates = msgData.data
                    this._updateField(updates)
                }
            })
        )

        // React to changes on multiple records of the binded Model
        this.subscriptions.push(
            subscribe("EVT_DB_UPDATE_BULK", (msgData) => {
                const operations = msgData.data
                operations.forEach(operation => {
                    if ((operation.modelId == this.modelId) && (operation.recordId == this.recordId)) {
                        const updates = operation.updates
                        this._updateField(updates)
                    }
                })
            })
        )

        return this
    }

    /**
     * Updates the field value internally
     * 
     * @private
     * @ignore
     * @param {*} updates 
     */
    _updateField(updates) {
        if (this.id in updates) {
            const newValue = updates[this.id]
            if (newValue || (newValue === false)) {
                this.field.checked = newValue
                this._renderValues()
            }
        }
    }    

    /**
     * Render the current value(s) of the widget.
     * 
     * @private
     * @ignore
     */
    _renderValues() {
        const newState = this.field.checked
        const iconAdd = (newState == true) ? this.iconOn : this.iconOff
        const iconRemove = (newState == true) ? this.iconOff : this.iconOn
        iconRemove.split(" ").forEach(className => this.icon.classList.remove(className))
        iconAdd.split(" ").forEach(className => this.icon.classList.add(className))
        this.icon.style.color = (newState == true) ? this.iconColorOn : this.iconColorOff
    }

    /**
     * Set the field value
     * 
     * @param {boolean} newState - The new field value
     * @param {boolean} [rawUpdate] - If true, it doesn't update the associated record and doesn't trigger "change" event 
     * @returns this
     */
    setValue(newState, rawUpdate) {
        if (rawUpdate) return this._updateValue(newState, rawUpdate)

        if (this.record) {
            // If the field is connected to a record, we update the database
            this.record.updateFieldDeep(this.id, newState).then(success => {
                if (success) {
                    this._updateValue(newState)
                }
                else {
                    // Rollback the initial value if the update failed (ACL)
                    this._updateValue(this.initialValue)
                }
            })
        } else {
            this._updateValue(newState)
        }
        
        return this
    }

    /**
     * Clear the field value
     * 
     * @returns this
     */
    clearValue() {
        this.setValue(false)
        return this
    }    

    /**
     * Update the field's value internally
     * 
     * @private
     * @ignore
     * @param {boolean} newState
     * @param {boolean} [rawUpdate]
     * @returns this
     */
    _updateValue(newState, rawUpdate) {
        // const updateValue = (newState) => {
        //     this.field.checked = newState
        //     this._renderValues()
        //     this.dispatchEvent(new Event("change"))
        // }

        this.field.checked = newState
        this._renderValues()
        if (!rawUpdate) this.dispatchEvent(new Event("change"))
        return this
    }


    /**
     * Get the field value
     * 
     * @returns {boolean} - The field value
     */
    getValue() {
        return this.field.checked
    }

    /**
     * Validate the field (always true because Checkbox fields can't have wrong values)
     * 
     * @ignore
     * @returns {boolean}
     */
    validate() {
        return true
    }    

    /**
     * Toggle the value true / false
     */
    toggleValue() {
        this.setValue(!this.getValue())
    }

    /**
     * Get the field label
     * 
     * @returns {string}
     */
    getLabel() {
        return this?.label?.innerText || ""
    }

    /**
     * Set the field label
     * 
     * @param {string} newLabel
     * @returns this
     */
    setLabel(newLabel) {
        if (!this.label) return

        this.config.label = newLabel
        this.label.innerText = newLabel
        return this
    }

    /**
     * Set the field width
     * 
     * @param {*} width
     * @returns this
     */
    setWidth(width) {
        this.config.width = width
        this.style.width = this._computeSize("width", width)
        return this
    }

    /**
     * Set the input field width
     * 
     * @param {*} width
     * @returns this
     */
    setFieldWidth(width) {
        this.config.fieldWidth = width
        this.icon.style.width = this._computeSize("fieldWidth", width)
        return this
    } 

    /**
     * Set the label width
     * 
     * @param {*} width
     * @returns this
     */
    setLabelWidth(width) {
        this.config.labelWidth = width
        this.label.style.minWidth = this.label.style.maxWidth = this._computeSize("labelWidth")
        return this
    }

    /**
     * Get the label position
     * 
     * @returns {string} "left" | "right" | "top"
     */
    getLabelPosition() {
        return this.config.labelPosition
    }

    /**
     * Set label position
     * 
     * @param {string} position - "left" (default) | "right" | "top" | "bottom"
     * @returns this
     */
    setLabelPosition(position) {
        this.config.labelPosition = position

        switch (position) {
            case "top":
                this.style.flexFlow = "column"
                this.style.alignItems = "unset"
                this.icon.style.order = 1
                break
            case "bottom":
                this.style.flexFlow = "column"
                this.style.alignItems = "unset"
                this.icon.style.order = -1
                break
            case "right":
                this.style.flexFlow = "row"
                this.style.alignItems = "center"
                this.icon.style.order = -1
                break
            default:
                this.style.flexFlow = "row"
                this.style.alignItems = "center"
                this.icon.style.order = 1
        }
        return this
    }

    /**
     * Change the color of the checkbox icon
     * 
     * @param {string} color - The new color
     */
    setColor(color) {
        this.icon.style.color = color
    }
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-checkbox", kiss.ui.Checkbox)

/**
 * Shorthand to create a new Checkbox. See [kiss.ui.Checkbox](kiss.ui.Checkbox.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createCheckbox = (config) => document.createElement("a-checkbox").init(config)

;/**
 * 
 * The color field allows to pick a color and display its hexa color code.
 * 
 * @param {object} config
 * @param {string} [config.palette] - Use "default" to use the default HTML5 color palette, otherwise it will use KissJS custom palette.
 * @param {string} [config.value] - Initial color value
 * @param {boolean} [config.hideCode] - Set to true to hide the hexa color code
 * @param {string} [config.display]
 * @param {number|string} [config.width] - A number (in pixels) or any valid CSS value
 * @param {*} [config.minWidth] - A number (in pixels) or any valid CSS value
 * @param {*} [config.labelWidth] - A number (in pixels) or any valid CSS value
 * @param {*} [config.height] - A number (in pixels) or any valid CSS value
 * @param {*} [config.fieldWidth] - A number (in pixels) or any valid CSS value
 * @param {*} [config.fieldHeight] - A number (in pixels) or any valid CSS value
 * @param {*} [config.colorWidth] - Color selector width
 * @param {*} [config.colorHeight] - Color selector height
 * @param {string} [config.padding]
 * @param {string} [config.margin]
 * @param {string} [config.border]
 * @param {string} [config.borderStyle]
 * @param {string} [config.borderWidth]
 * @param {string} [config.borderColor]
 * @param {string} [config.borderRadius]
 * @param {string} [config.boxShadow]
 * @param {boolean} [config.readOnly]
 * @returns this
 * 
 * ## Generated markup
 * ```
 * <a-color class="a-color">
 *  <label class="field-label"></label>
 *  <div class="field-color-container">
 *      <div class="field-color-palette"></div>
 *      <div class="field-color-input"></div>
 *  </div>
 * </a-color
 * ```
 */
kiss.ui.Color = class Color extends kiss.ui.Component {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the 3 following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const myColorField = document.createElement("a-color").init(config)
     * ```
     * 
     * Or use the shorthand for it:
     * ```
     * const myColorField = createColorField({
     *  value: "#00aaee",
     *  height: "32px"
     * })
     * 
     * myColorField.render()
     * myColorField.getValue() // #00aaee
     * myColorField.setValue("#ff0000")
     * myColorField.getValue() // #ff0000
     * ```
     * 
     * Or directly declare the config inside a container component:
     * ```
     * const myPanel = createPanel({
     *   title: "My panel",
     *   items: [
     *       {
     *           type: "color",
     *           value: "#00aaee",
     *           width: "32px"
     *           height: "32px",
     *           hideCode: true
     *       }
     *   ]
     * })
     * myPanel.render()
     * ```
     */
    constructor() {
        super()
    }

    init(config) {
        super.init(config)

        // Overwrite default value if the field is binded to a record
        // (default value must not override record's value)
        if (config.record && config.record[this.id]) config.value = config.record[this.id]

        const id = this.id
        this.value = config.value || ""
        this.required = !!config.required
        this.readOnly = !!config.readOnly

        // Template
        this.innerHTML = /*html*/ `
            ${ (config.label) ? `<label id="field-label-${this.id}" for="${this.id}" class="field-label">
                ${ (this.isLocked()) ? this.locker : "" }
                ${ config.label || "" }
                 ${ (this.isRequired()) ? this.asterisk : "" }
            </label>` : "" }

            <div class="field-color-container ${(config.palette != "default") ? " field-color-container-custom " : " field-color-container-standard "} ${(config.readOnly) ? "field-input-read-only" : ""}">
                ${(config.palette != "default")
                    ? `<div class="field-color-palette field-color-palette-custom" style="background-color: ${this.value.trim()}"></div>`
                    : `<input class="field-color-palette field-color-palette-standard" type="color" value=${this.value}>`
                }
                ${(!config.hideCode) ? `<input type="text" autocomplete="off" ${(this.readOnly) ? " readonly " : ""} class="field-color-input" value="${this.value}"></input>` : ""}
            </div>
            `.removeExtraSpaces()

        this.label = this.querySelector(".field-label")
        this.fieldContainer = this.querySelector(".field-color-container")
        this.color = this.querySelector(".field-color-palette")
        this.field = this.querySelector(".field-color-input")

        // The width and height of the color zone is adjusted if the color code is displayed or not
        if (config.hideCode == true) this.color.style.width = this.color.style.height = "100%"

        // Set properties
        this._setProperties(config, [
            [
                ["draggable"],
                [this]
            ],
            [
                ["width", "height", "flex", "display", "margin", "padding"],
                [this.style]
            ],
            [
                ["fieldWidth=width", "fieldHeight=height", "fieldFlex=flex", "border", "borderStyle", "borderWidth", "borderColor", "borderRadius", "boxShadow"],
                [this.fieldContainer.style]
            ],
            [
                ["labelWidth=width", "labelAlign=textAlign", "labelFlex=flex"],
                [this.label?.style]
            ],
            [
                ["borderRadius", "colorWidth=minWidth", "colorHeight=minHeight"],
                [this.color.style]
            ]
        ])

        // Set the default display mode that will be restored by the show() method
        this.displayMode = "flex"

        // Manage label and field layout according to label position
        this.style.flexFlow = "row"

        if (config.label) {
            // Label width
            if (config.labelWidth) this.setLabelWidth(config.labelWidth)

            // Label position
            this.config.labelPosition = config.labelPosition || "left"
            this.setLabelPosition(config.labelPosition)
        }

        // Listen to click events if the field is *not* disabled or *readOnly* or *computed* or a default HTML5 palette (which listens to click by default)
        if (!this.readOnly && !config.disabled && !config.computed && config.palette != "default") {
            this.onclick = (event) => {
                const clickedElement = event.target.closest(".field-color-container")
                if (!clickedElement) return
                
                const picker = createPanel({
                    modal: true,
                    header: false,
                    width: "70.5rem",
                    align: "center",
                    verticalAlign: "center",
                    items: [{
                        type: "colorPicker",
                        value: $(id).getValue(),
                        palette: config.palette || kiss.global.palette,
                        selectorBorderRadius: "3.2rem",
                        height: "10rem",
                        events: {
                            change: function () {
                                let color = this.getValue()
                                $(id).setValue(color)
                                picker.close()
                            }
                        }
                    }]
                }).render()
            }
        }

        // Update color when we directly enter a color code inside the input field
        if (this.field) {
                this.field.onchange = (event) => {
                let color = event.target.value
                $(id).setValue(color)
            }
        }
        
        if (config.palette == "default") {
            // Lock default behavior and prevent the palette from diplaying
            if (this.readOnly) this.color.onclick = (event) => {event.stop()}

            // Update color when we exit the default color palette
            this.color.onchange = (event) => {
                let color = event.target.value
                $(id).setValue(color)
            }
        }

        // Bind the field to a record, if any
        if (config.record) this._bindRecord(config.record)

        // Render default value
        this._renderValues()

        return this
    }

    /**
     * Bind the field to a record
     * (this subscribes the field to react to database changes)
     * 
     * @private
     * @ignore
     * @param {object} record
     * @returns this
     */
    _bindRecord(record) {
        this.record = record
        this.modelId = record.model.id
        this.recordId = record.id

        if (record[this.id]) {
            this.value = this.initialValue = record[this.id]
        }

        // React to changes on a single record of the binded model
        this.subscriptions.push(
            subscribe("EVT_DB_UPDATE:" + this.modelId.toUpperCase(), (msgData) => {
                if ((msgData.modelId == this.modelId) && (msgData.id == this.recordId)) {
                    const updates = msgData.data
                    this._updateField(updates)
                }
            })
        )

        // React to changes on multiple records of the binded Model
        this.subscriptions.push(
            subscribe("EVT_DB_UPDATE_BULK", (msgData) => {
                const operations = msgData.data
                operations.forEach(operation => {
                    if ((operation.modelId == this.modelId) && (operation.recordId == this.recordId)) {
                        const updates = operation.updates
                        this._updateField(updates)
                    }
                })
            })
        )

        return this
    }

    /**
     * Updates the field value internally
     * 
     * @private
     * @ignore
     * @param {*} updates 
     */
    _updateField(updates) {
        if (this.id in updates) {
            this.value = updates[this.id]
            this._renderValues()
        }
    }    

    /**
     * Set the fieldl value
     * 
     * @param {string} color - Hex color like #aa00ee
     * @param {boolean} [rawUpdate] - If true, it doesn't update the associated record and doesn't trigger "change" event 
     * @returns this
     */
    setValue(color, rawUpdate) {
        if (color == this.getValue()) return

        if (rawUpdate) return this._updateValue(color, rawUpdate)

        if (this.record) {
            // If the field is connected to a record, we update the database
            this.record.updateFieldDeep(this.id, color).then(success => {
                if (success) {
                    this._updateValue(color)
                    this.initialValue = color
                }
                else {
                    // Rollback the initial value if the update failed (ACL)
                    this._updateValue(this.initialValue)
                }
            })
        }
        else {
            this._updateValue(color)
        }

        this.validate()

        if (this.config.palette == "default") {
            this.color.value = color
        }

        return this
    }

    /**
     * Clear the field value
     * 
     * @returns this
     */
    clearValue() {
        this.setValue("")
        return this
    }      

    /**
     * Update the field's value internally
     * 
     * @private
     * @ignore
     * @param {string} color
     * @param {boolean} [rawUpdate]
     * @returns this
     */
    _updateValue(color, rawUpdate) {
        // const updateValue = (color) => {
        //     this.value = color
        //     this._renderValues()
        //     this.dispatchEvent(new Event("change"))
        // }

        this.value = color
        this._renderValues()
        if (!rawUpdate) this.dispatchEvent(new Event("change"))
        return this
    }

    /**
     * Validate the field value against validation rules
     * 
     * @returns {boolean}
     */
    validate() {
        if (this.isHidden()) return true
        
        const isValid = kiss.tools.validateValue(this.type, this.config, this.value)
        if (isValid) {
            this.setValid()
        }
        else {
            this.setInvalid()
        }
        return isValid
    }

    /**
     * Remove the invalid style
     * 
     * @returns this
     */
    setValid() {
        this.isValid = true
        this.fieldContainer.classList.remove("field-input-invalid")
        return this
    }

    /**
     * Change the style when the field is invalid
     * 
     * @returns this
     */
    setInvalid() {
        log("kiss.ui - field.setInvalid - Invalid value for the field: " + this.config.label, 4)

        this.isValid = false
        this.fieldContainer.classList.add("field-input-invalid")
        return this
    }

    /**
     * Set the color
     * 
     * @private
     * @ignore
     * @param {string} color - Hex color
     */
    _renderValues() {
        const color = this.value || ""
        if (this.field) this.field.value = color
        this.color.style.background = (color == "#TRANSPARENT") ? "transparent" : color
    }

    /**
     * Get the field value
     * 
     * @returns {string} The field hex color value. Ex: #00aaee
     */
    getValue() {
        return this.value
    }

    /**
     * Set the field label
     * 
     * @param {string} newLabel
     * @returns this
     */
    setLabel(newLabel) {
        if (!this.label) return

        this.config.label = newLabel
        this.label.innerText = newLabel
        return this
    }

    /**
     * Get the field label
     * 
     * @returns {string}
     */
    getLabel() {
        return this?.label?.innerText || ""
    }

    /**
     * Set the field width
     * 
     * @param {*} width
     * @returns this
     */
    setWidth(width) {
        this.config.width = width
        this.style.width = this._computeSize("width", width)
        return this
    }

    /**
     * Set the color selector field width
     * 
     * @param {*} width
     * @returns this
     */
    setFieldWidth(width) {
        this.config.fieldWidth = width
        this.fieldContainer.style.width = this._computeSize("fieldWidth", width)
        return this
    }

    /**
     * Set the label width
     * 
     * @param {*} width
     * @returns this
     */
    setLabelWidth(width) {
        this.config.labelWidth = width
        this.label.style.minWidth = this.label.style.maxWidth = this._computeSize("labelWidth", width)
        return this
    }

    /**
     * Get the label position
     * 
     * @returns {string} "left" | "right" | "top"
     */
    getLabelPosition() {
        return this.config.labelPosition
    }

    /**
     * Set label position
     * 
     * @param {string} position - "left" (default) | "right" | "top" | "bottom"
     * @returns this
     */
    setLabelPosition(position) {
        this.config.labelPosition = position

        switch (position) {
            case "top":
                this.style.flexFlow = "column"
                this.fieldContainer.style.order = 1
                break
            case "bottom":
                this.style.flexFlow = "column"
                this.fieldContainer.style.order = -1
                break
            case "right":
                this.style.flexFlow = "row"
                this.fieldContainer.style.order = -1
                break
            default:
                this.style.flexFlow = "row"
                this.fieldContainer.style.order = 1
        }
        return this
    }
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-color", kiss.ui.Color)

/**
 * Shorthand to create a new Color field. See [kiss.ui.Color](kiss.ui.Color.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createColorField = (config) => document.createElement("a-color").init(config)

;/**
 * 
 * The ColorPicker derives from [Component](kiss.ui.Component.html).
 * It allows to pick a color from a pre-defined palette.
 * 
 * @param {object} config
 * @param {string} [config.value] - The default hexa color code. Ex: "#00aaee"
 * @param {string[]} [config.palette] - Custom color palette, for example: ["00aaee", "a1ed00", "ffffff", "000000"]
 * @param {function} [config.autoFocus] - Automatically scroll down to the selected color if true (default false)
 * @param {function} [config.action] - Function executed when a color is selected. Receives the selected hexa color code as an argument.
 * @param {object[]} [config.columns] - Number of columns to display the colors
 * @param {string} [config.iconSize] - Size of the icon displayed into the selected color. Ex: "16px"
 * @param {string} [config.selectorSize] - Should be greater than the icon size. Ex: "32px"
 * @param {string} [config.selectorBorderRadius] - Ex: "10px"
 * @param {string} [config.background]
 * @param {string} [config.backgroundColor]
 * @param {string} [config.backgroundColorSelected]
 * @param {string|number} [config.width]
 * @param {string|number} [config.height]
 * @param {string} [config.padding]
 * @param {string} [config.margin]
 * @param {string} [config.border]
 * @param {string} [config.borderStyle]
 * @param {string} [config.borderWidth]
 * @param {string} [config.borderColor]
 * @param {string} [config.borderRadius]
 * @param {string} [config.boxShadow]
 * @returns this
 * 
 * ## Generated markup
 * ```
 * <a-colorpicker class="a-colorpicker">
 * 
 *  <!-- For each color selector -->
 *  <span class="color-selector"></span>
 * 
 * </a-colorpicker>
 * ```
 */
kiss.ui.ColorPicker = class ColorPicker extends kiss.ui.Component {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the 3 following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const myColorPicker = document.createElement("a-colorpicker").init(config)
     * ```
     * 
     * Or use the shorthand for it:
     * ```
     * const myColorPicker = createColorPicker({
     *   value: "#00aaee", 
     *   columns: 10,
     *   action: (iconClass) => console.log(iconClass)
     * })
     * 
     * myColorPicker.render()
     * ```
     * 
     * Or directly declare the config inside a container component:
     * ```
     * const myPanel = createPanel({
     *   title: "My panel",
     *   items: [
     *       {
     *           type: "colorPicker",
     *           value: "#00aaee",
     *           columns: 10,
     *           action: (color) => console.log(color)
     *       }
     *   ]
     * })
     * myPanel.render()
     * ```
     */
    constructor() {
        super()
    }

    /**
     * Generates a color picker from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config = {}) {
        super.init(config)

        // Overwrite default value if the field is binded to a record
        // (default value must not override record's value)
        if (config.record && config.record[this.id]) config.value = config.record[this.id]

        this.value = config.value
        this.icon = config.icon || "fas fa-check"
        this.iconSize = config.iconSize || "1.6rem"
        this.selectorSize = config.selectorSize || "3.2rem"
        this.selectorBorderRadius = config.selectorBorderRadius || "0.5rem"
        this.columns = config.columns || 10000
        this.palette = config.palette || kiss.global.palette
        this.autoFocus = config.autoFocus

        // Bind the field to a record, if any
        if (config.record) this._bindRecord(config.record)

        // Special id used to track the right picker when there is more than one on the same page
        this.specialId = this.id.replace(new RegExp("-", "g"), "_")

        // Template
        this.innerHTML =
            this.palette.map((color, index) =>
                `<span id="${this.specialId}:color-#${color}"
                    class="color-selector"
                    style=
                    "
                        width: ${this.selectorSize};
                        height: ${this.selectorSize};
                        line-height: ${this.selectorSize};
                        font-size: ${this.iconSize};
                        background-color: #${color};
                        border-radius: ${this.selectorBorderRadius};
                    "
                >
                ${(this.value == "#" + color.toUpperCase()) ? `<span style="color: #ffffff" class="${this.icon} color-selector-selected"></span>` : ""}                
                </span>${((index + 1) % this.columns == 0) ? "<br>" : ""}`.removeExtraSpaces()
            ).join("")


        // Set properties
        this._setProperties(config, [
            [
                ["width", "height", "margin", "padding"],
                [this.style]
            ],
        ])

        // Set the default display mode that will be restored by the show() method
        this.displayMode = "inline-block"

        // Bind action to onclick
        this.onclick = (event) => {
            const colorPicker = event.target.closest(".color-selector")
            if (!colorPicker) return
            const color = colorPicker.id.split("-")[1]
            this.setValue(color)
            if (config.action) config.action(color)
        }

        return this
    }

    /**
     * Automatically set the focus on the selected icon 500ms after rendering, if the autoFocus option is enabled
     * 
     * @private
     * @ignore
     */
    _afterRender() {
        if (!this.autoFocus) return
        setTimeout(() => this.focus(), 500)
    }

    /**
     * Bind the field to a record
     * (this subscribes the field to react to database changes)
     * 
     * @private
     * @ignore
     * @param {object} record
     * @returns this
     */
    _bindRecord(record) {
        this.record = record
        this.modelId = record.model.id
        this.recordId = record.id

        if (record[this.id]) {
            this.value = this.initialValue = record[this.id]
        }

        // React to changes on a single record of the binded model
        this.subscriptions.push(
            subscribe("EVT_DB_UPDATE:" + this.modelId.toUpperCase(), (msgData) => {
                if ((msgData.modelId == this.modelId) && (msgData.id == this.recordId)) {
                    const updates = msgData.data
                    this._updateField(updates)
                }
            })
        )

        // React to changes on multiple records of the binded Model
        this.subscriptions.push(
            subscribe("EVT_DB_UPDATE_BULK", (msgData) => {
                const operations = msgData.data
                operations.forEach(operation => {
                    if ((operation.modelId == this.modelId) && (operation.recordId == this.recordId)) {
                        const updates = operation.updates
                        this._updateField(updates)
                    }
                })
            })
        )

        return this
    }
    
    /**
     * Updates the field value internally
     * 
     * @private
     * @ignore
     * @param {*} updates 
     */
    _updateField(updates) {
        if (this.id in updates) {
            this.value = updates[this.id]
            this._renderValues()
        }
    }    

    /**
     * Set a new color
     * 
     * @param {string} color - Hexa color code. Ex: #00aaee
     * @param {boolean} [rawUpdate] - If true, it doesn't update the associated record and doesn't trigger "change" event 
     * @returns this
     */
    setValue(color, rawUpdate) {
        if (color.toUpperCase() == this.getValue()) return

        if (rawUpdate) return this._updateValue(color, rawUpdate)

        if (this.record) {
            // If the field is connected to a record, we update the database
            this.record.updateFieldDeep(this.id, color).then(success => {
                if (success) {
                    this._updateValue(color)
                    this.initialValue = color
                }
                else {
                    // Rollback the initial value if the update failed (ACL)
                    this._updateValue(this.initialValue)
                }
            })
        } else {
            this._updateValue(color)
        }

        return this
    }

    /**
     * Clear the field value
     * 
     * @returns this
     */
    clearValue() {
        this.setValue("")
        return this
    }    

    /**
     * Update the field's value internally
     * 
     * @private
     * @ignore
     * @param {string} color
     * @param {boolean} [rawUpdate]
     * @returns this
     */
    _updateValue(color, rawUpdate) {
        this.value = color
        this._renderValues()
        if (!rawUpdate) this.dispatchEvent(new Event("change"))
        return this
    }    

    /**
     * Render the current value of the widget.
     * 
     * @private
     * @ignore
     */
    _renderValues() {
        const color = (this.value || "").toUpperCase()

        Array.from(this.children).forEach(colorSelector => {
            colorSelector.classList.remove("color-selector-selected")
            colorSelector.innerHTML = ""
        })

        let selectedColor = $(this.specialId + ":color-" + color)
        if (!selectedColor) return

        selectedColor.innerHTML = `<span style="color: #ffffff" class="${this.icon}"></span>`
        selectedColor.classList.add("color-selector-selected")
    }

    /**
     * Get the current selected color
     * 
     * @returns {string} Hexa color code. Ex: #00aaee
     */
    getValue() {
        return (this.value || "").toUpperCase()
    }

    /**
     * Validate the field (always true because ColorPicker fields can't have wrong values)
     * 
     * @ignore
     * @returns {boolean}
     */
    validate() {
        return true
    }

    /**
     * Set the field width
     * 
     * @param {*} width
     * @returns this
     */    
    setWidth(width) {
        this.config.width = width
        this.style.width = this._computeSize("width", width)
        return this
    }

    /**
     * Set the field height
     * 
     * @param {*} height
     * @returns this
     */    
    setHeight(height) {
        this.config.height = height
        this.style.height = this._computeSize("height", height)
        return this
    }

    /**
     * Scroll down to the selected color
     * 
     * @returns this
     */
    focus() {
        const selectedColor = this.querySelector(".color-selector-selected")
        if (!selectedColor) return

        if (selectedColor) setTimeout(() => {
            selectedColor.scrollIntoView({
                block: "center",
                behavior: "smooth"
            })
        }, 1)

        return this
    }
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-colorpicker", kiss.ui.ColorPicker)

/**
 * Shorthand to create a new ColorPicker. See [kiss.ui.ColorPicker](kiss.ui.ColorPicker.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createColorPicker = (config) => document.createElement("a-colorpicker").init(config)

;/**
 * 
 * The Field derives from [Component](kiss.ui.Component.html).
 * 
 * Build an input (text, number, date) or a textarea field with a label.
 * 
 * @param {object} config
 * @param {string} config.type - text | textarea | number | date | password
 * @param {*} [config.value] - Default value
 * @param {string} [config.label]
 * @param {number|string} [config.labelWidth] - A number (in pixels) or any valid CSS value
 * @param {number|string} [config.fieldWidth] - A number (in pixels) or any valid CSS value
 * @param {number|string} [config.fieldHeight] - A number (in pixels) or any valid CSS value
 * @param {number|string} [config.fieldPadding] - A number (in pixels) or any valid CSS value
 * @param {number} [config.fieldFlex]
 * @param {*} [config.fontSize]
 * @param {*} [config.lineHeight]
 * @param {string} [config.textAlign] - left | right
 * @param {string} [config.labelPosition] - left | right | top | bottom
 * @param {string} [config.labelAlign] - left | right
 * @param {number} [config.labelFlex]
 * @param {string} [config.formula] - For computed fields only
 * @param {string} [config.validationType] - Pre-built validation type: alpha | alphanumeric | email | url | ip
 * @param {string} [config.validationRegex] - Regexp
 * @param {function} [config.validationFunction] - Async function that must return true if the value is valid, false otherwise
 * @param {string} [config.validationMessage] - TODO
 * @param {string} [config.placeholder]
 * @param {boolean} [config.autocomplete] - set to "off" to disable native browser autocomplete feature. Default is "off"
 * @param {number} [config.minLength]
 * @param {number} [config.maxLength]
 * @param {} [config.maxHeight] - A number (in pixels) or any valid CSS value
 * @param {boolean} [config.readOnly]
 * @param {boolean} [config.disabled]
 * @param {boolean} [config.required]
 * @param {boolean} [config.draggable]
 * @param {string} [config.min] - (for number only)
 * @param {string} [config.max] - (for number only)
 * @param {number} [config.precision] - (for number only)
 * @param {string} [config.margin]
 * @param {string} [config.padding]
 * @param {string} [config.fontFamily] - Font used for the input field
 * @param {boolean} [config.rows] - For textarea only
 * @param {boolean} [config.cols] - For textarea only
 * @param {boolean} [config.autoGrow] - For textarea only
 * @param {string} [config.display] - flex | inline flex
 * @param {string} [config.overflow]
 * @param {string} [config.border]
 * @param {string} [config.borderStyle]
 * @param {string} [config.borderWidth]
 * @param {string} [config.borderColor]
 * @param {string} [config.borderRadius]
 * @param {string|number} [config.width]
 * @param {string|number} [config.height]
 * @returns this
 * 
 * ## Generated markup
 * For all input fields:
 * ```
 * <a-field class="a-field a-field">
 *  <label class="field-label"></label>
 *  <input type="text|number|date" class="field-input"></input>
 * </a-field>
 * ```
 * For textarea:
 * ```
 * <a-field class="a-field">
 *  <span class="field-label"></span>
 *  <textarea class="field-input"></textarea>
 * </a-field>
 * ```
 */
kiss.ui.Field = class Field extends kiss.ui.Component {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the 3 following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const myField = document.createElement("a-field").init(config)
     * ```
     * 
     * Or use a shorthand to create one the various field types:
     * ```
     * const myText = createTextField({
     *   label: "I'm a text field"
     * })
     * 
     * const myTextArea = createTextareaField({
     *   label: "I'm a long text field",
     *   cols: 100,
     *   rows: 10
     * })
     * 
     * const myNumber = createNumberField({
     *   label: "I'm a number field",
     *   value: 250,
     *   min: 0
     * })
     * 
     * const myDate = createDateField({
     *   label: "I'm a date field",
     *   value: new Date()
     * })
     * 
     * // You can also use the generic constructor, but then you'll have to specify the field type in the config, like this:
     * const myText = createField({
     *   type: "number", // <= Field type, which can be: text | textarea | number | date
     *   label: "foo",
     *   value: 123
     * })
     * 
     * ```
     * 
     * Or directly declare the config inside a container component:
     * ```
     * const myPanel = createPanel({
     *   title: "My panel",
     *   items: [
     *       {
     *           type: "text",
     *           label: "I'm a text"
     *       },
     *       {
     *           type: "number":
     *           label: "I'm a number"
     *       }
     *   ]
     * })
     * myPanel.render()
     * ```
     */
    constructor() {
        super()
    }

    /**
     * Generates a Field from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config) {
        super.init(config)
        const id = this.id

        // Overwrite default value if the field is binded to a record
        // (default value must not override record's value)
        if (config.record) config.value = config.record[this.id]

        // Force computed fields to be read-only
        config.readOnly = !!config.readOnly || !!config.computed

        if (this.type != "textarea" && this.type != "aiTextarea") {

            // Template for text, number, date
            this.innerHTML = `
                ${ (config.label) ? `<label id="field-label-${id}" for="${id}" class="field-label">
                    ${ (this.isLocked()) ? this.locker : "" }
                    ${ config.label || ""} ${(config.unit) ? " (" + config.unit + ")" : "" }
                    ${ (this.isRequired()) ? this.asterisk : "" }
                </label>` : "" }

                <input type="${this.type}" id="field-input-${id}" name="${id}" class="field-input ${(!!config.readOnly) ? "field-input-read-only" : ""}">
                `.removeExtraSpaces()

        } else {

            // Template for textarea
            this.innerHTML = `
                ${ (config.label) ? `<label id="field-label-${id}" for="${id}" class="field-label">
                    ${ (this.isLocked()) ? this.locker : "" }
                    ${ config.label || "" }
                    ${ (this.isRequired()) ? this.asterisk : "" }
                </label>` : "" }

                <textarea id="field-textarea-${id}" name="${id}" class="field-input field-input-textarea ${(!!config.readOnly) ? "field-input-read-only" : ""}"
                    ${(config.rows) ? `rows="${config.rows}"` : ""}
                    ${(config.cols) ? `cols="${config.cols}"` : ""}
                >${(config.value) ? config.value : ""}</textarea>
                `.removeExtraSpaces()
        }

        this.field = this.querySelector(".field-input")
        this.label = this.querySelector(".field-label")

        // Cancel max property if set to 0
        if (config.max == 0) delete config.max
        if (config.maxLength == 0) delete config.maxLength

        // Set properties
        this._setProperties(config, [
            [
                ["draggable"],
                [this]
            ],
            [
                ["width", "minWidth", "height", "flex", "display", "margin", "padding", "overflow"],
                [this.style]
            ],
            [
                ["value", "minLength", "maxLength", "min", "max", "placeholder", "readOnly", "disabled", "required", "autocomplete"],
                [this.field]
            ],
            [
                ["textAlign", "fontSize", "lineHeight", "fieldWidth=width", "fieldHeight=height", "fieldPadding=padding", "fieldFlex=flex", "maxHeight", "fontFamily", "border", "borderStyle", "borderWidth", "borderColor", "borderRadius", "boxShadow"],
                [this.field.style]
            ],
            [
                ["fontSize", "labelAlign=textAlign", "labelFlex=flex"],
                [this.label?.style]
            ]
        ])

        // Set the default display mode that will be restored by the show() method
        this.displayMode = "flex"

        // Manage label and field layout according to label position
        this.style.flexFlow = "row"

        if (config.label) {
            // Label width
            if (config.labelWidth) this.setLabelWidth(config.labelWidth)

            // Label position
            this.config.labelPosition = config.labelPosition || "left"
            this.setLabelPosition(config.labelPosition)
        }

        // Add field base class
        this.classList.add("a-field")

        // Propapate field changes
        this.field.onchange = (event) => {
            const newValue = event.target.value

            // Check if the value is valid before updating the database
            if (this.validate()) {
                this.setValue(newValue)
            }
        }

        // Attach focus and blur events, if any
        if (config.events) {
            if (config.events.focus) this.field.onfocus = config.events.focus
            else if (config.events.onfocus) this.field.onfocus = config.events.onfocus

            if (config.events.blur) this.field.onblur = config.events.blur
            else if (config.events.onblur) this.field.onblur = config.events.onblur
        }

        if (config.type == "number") {
            // Prevent number fields to be changed with arrow keys (and spam the update process)
            this.field.onkeydown = (event) => {
                if (event.key == "ArrowDown" || event.key == "ArrowUp") event.stop()
            }

        } else if (config.type == "textarea" && config.autoGrow) {
            // Auto-grow textarea field at startup
            this._initTextareaHeight()

        } else if (config.type == "text" && config.computed == true) {
            // URL field that are computed can be clicked to open the URL
            this.field.onclick = () => {
                const value = this.getValue()
                const urlRegex = new RegExp(`^(http(s?):\\/)?\\/(.)+$`)
                if (value && value.match(urlRegex)) window.open(value)
            }
        }

        // Auto-compose phone number on mobile devices
        this._initMobileAutoCompose()

        // Field validation
        this.isValid = true
        this._initValidationRules()

        // Bind the field to a record, if any
        if (config.record) this._bindRecord(config.record)

        return this
    }

    /**
     * Enables auto-composition for phone numbers, on Mobile devices
     * 
     * TODO: evaluate if it's useful to explicitly add a config option to define phone number fields
     * 
     * @private
     * @ignore
     */
    _initMobileAutoCompose() {
        if (!kiss.screen.isMobile) return
        if (!this.label) return
        if (this.config.type != "text" && this.config.type != "number") return

        const phoneLabels = ["telephone", "phone", "mobile", "tel."]
        if (!phoneLabels.some(phoneLabel => this.config.label.toLowerCase().includes(phoneLabel))) return
        this.label.onmousedown = () => window.location.href = "tel:" + this.getValue()
    }

    /**
     * Bind the field to a record
     * (this subscribes the field to react to database changes)
     * 
     * @private
     * @ignore
     * @param {object} record
     * @returns this
     */
    _bindRecord(record) {
        this.record = record
        this.modelId = record.model.id
        this.recordId = record.id

        if (record[this.id]) {
            this.field.value = this.initialValue = record[this.id]
        }

        // React to changes on a single record of the binded model
        this.subscriptions.push(
            subscribe("EVT_DB_UPDATE:" + this.modelId.toUpperCase(), (msgData) => {
                if ((msgData.modelId == this.modelId) && (msgData.id == this.recordId)) {
                    const updates = msgData.data
                    this._updateField(updates)
                }
            })
        )

        // React to changes on multiple records of the binded Model
        this.subscriptions.push(
            subscribe("EVT_DB_UPDATE_BULK", (msgData) => {
                const operations = msgData.data
                operations.forEach(operation => {
                    if ((operation.modelId == this.modelId) && (operation.recordId == this.recordId)) {
                        const updates = operation.updates
                        this._updateField(updates)
                    }
                })
            })
        )

        return this
    }

    /**
     * Updates the field value internally
     * 
     * @private
     * @ignore
     * @param {*} updates 
     */
    _updateField(updates) {
        if (this.id in updates) {
            const newValue = updates[this.id]
            if (newValue || (newValue === 0) || (newValue === "")) {
                this.field.value = newValue
            }
        }
    }

    /**
     * Init basic validation rules according to the following field parameters:
     * - validationType: a predefined regex
     * - validationRegex: a custom regex
     * - validationFormula: a javascript formula that must return true to be valid
     * 
     * So far, pre-defined validation types are:
     * - alpha
     * - alphanumeric
     * - email
     * - url
     * - ip
     * 
     * @private
     * @ignore
     */
    _initValidationRules() {
        this.required = this.config.required
        this.validationRegex = this.config.validationRegex
        this.validationType = this.config.validationType
        this.validationFormula = this.config.validationFormula

        this.field.onkeyup = () => {
            this.validate()

            // Auto grow textarea
            if (this.config.type == "textarea" && this.config.autoGrow) {
                this._updateTextareaHeight()
            }
        }

        // A required field is immediately invalid if it's empty
        if (this.required && this.field.value == "") this.isValid = false
    }

    /**
     * Init the height of the textarea at startup
     * 
     * @private
     * @ignore
     */
    _initTextareaHeight() {
        this._afterRender = () => this._updateTextareaHeight()
    }

    /**
     * Automatically grow the textarea to fit the content
     * 
     * @private
     * @ignore
     */
    _updateTextareaHeight() {
        this.field.style.height = this.field.scrollHeight + "px"
    }

    /**
     * Validate the field value and apply UI style accordingly
     * 
     * @returns {boolean} true is the field is valid, false otherwise
     */
    validate() {
        if (this.isHidden()) return true
        
        const isValid = kiss.tools.validateValue(this.type, this.config, this.field.value)
        if (isValid) {
            this.setValid()
        }
        else {
            this.setInvalid()
        }
        return isValid
    }

    /**
     * Set the field value
     * 
     * @param {string|number|date} newValue - The new field value
     * @param {boolean} [rawUpdate] - If true, it doesn't update the associated record and doesn't trigger "change" event 
     * @returns this
     */
    setValue(newValue, rawUpdate) {
        if (rawUpdate) {
            this.field.value = newValue
            return this
        }

        // Cast number field value
        if (this.getDataType() == "number" && newValue !== "") newValue = Number(newValue)

        if (this.record) {
            // If the field is connected to a record, we update the database
            this.record.updateFieldDeep(this.id, newValue).then(success => {

                // Rollback the initial value if the update failed (ACL)
                if (!success) {
                    this.field.value = this.initialValue || ""
                }
                else {
                    this.initialValue = newValue
                }
            })
        } else {
            // Otherwise, we just change the field value
            this.field.value = newValue
        }

        // If it's a textarea, we scroll down to the last row
        if (this.type == "textarea") this.field.scrollTop = this.field.scrollHeight

        return this
    }

    /**
     * Clear the field value
     * 
     * @returns this
     */
    clearValue() {
        this.setValue("")
        return this
    }

    /**
     * Get the field value.
     * 
     * @returns {string|number|date} - The field value
     */
    getValue() {
        const fieldType = this.getDataType()

        if (fieldType == "number") {
            return Number(this.field.value)
        } else {
            return this.field.value || ""
        }
    }

    /**
     * Get the data type of a field, depending on its configuration:
     * text => text
     * number => number
     * date => date
     * textarea => text
     * password => text
     * summary => data type of the foreign field
     * lookup => data type of the foreign field
     * 
     * @returns {string} The field data type: "text" | "number" | "date"
     */
    getDataType() {
        if (this.type == "summary") return this.config.summary.type
        if (this.type == "lookup") return this.config.lookup.type
        if (this.type == "textarea") return "text"
        if (this.type == "password") return "text"
        return this.type
    }

    /**
     * Set the field label
     * 
     * @param {string} newLabel
     * @returns this
     */
    setLabel(newLabel) {
        if (!this.label) return

        this.config.label = newLabel
        this.label.innerText = newLabel
        return this
    }

    /**
     * Get the field label
     * 
     * @returns {string}
     */
    getLabel() {
        return this?.label?.innerText || ""
    }

    /**
     * Set the field width
     * 
     * @param {*} width
     * @returns this
     */
    setWidth(width) {
        this.config.width = width
        this.style.width = this._computeSize("width", width)
        return this
    }

    /**
     * Set the input field width
     * 
     * @param {*} width
     * @returns this
     */
    setFieldWidth(width) {
        this.config.fieldWidth = width
        this.field.style.width = this._computeSize("fieldWidth", width)
        return this
    }

    /**
     * Set the label width
     * 
     * @param {*} width
     * @returns this
     */
    setLabelWidth(width) {
        this.config.labelWidth = width
        this.label.style.minWidth = this.label.style.maxWidth = this._computeSize("labelWidth", width)
        return this
    }

    /**
     * Get the label position
     * 
     * @returns {string} "left" | "right" | "top"
     */
    getLabelPosition() {
        return this.config.labelPosition
    }

    /**
     * Set label position
     * 
     * @param {string} position - "left" (default) | "right" | "top" | "bottom"
     * @returns this
     */
    setLabelPosition(position) {
        this.config.labelPosition = position

        switch (position) {
            case "top":
                this.style.flexFlow = "column"
                this.field.style.order = 1
                break
            case "bottom":
                this.style.flexFlow = "column"
                this.field.style.order = -1
                break
            case "right":
                this.style.flexFlow = "row wrap" // Allow Map field to be displayed correctly
                this.field.style.order = -1
                break
            default:
                this.style.flexFlow = "row wrap" // Allow Map field to be displayed correctly
                this.field.style.order = 1
        }
        return this
    }

    /**
     * Change the field default display mode
     * 
     * @param {string} [displayMode] - "flex" (default) | "inline-flex"
     */
    setDisplayMode(displayMode = "flex") {
        this.config.display = this.style.display = displayMode
    }

    /**
     * Give focus to the input field
     * 
     * @returns this
     */
    focus() {
        this.field.focus()
        return this
    }

    /**
     * Unset the focus of the input field
     * 
     * @returns this
     */
    blur() {
        this.field.blur()
        return this
    }

    /**
     * Reset the focus
     */
    resetFocus() {
        this.blur()
        setTimeout(() => this.focus(), 100)
    }

    /**
     * Remove the invalid style
     * 
     * @returns this
     */
    setValid() {
        this.isValid = true
        this.field.classList.remove("field-input-invalid")
        return this
    }

    /**
     * Change the style when the field is invalid
     * 
     * @returns this
     */
    setInvalid() {
        log("kiss.ui - field.setInvalid - Invalid value for the field: " + this.config.label, 4)

        this.isValid = false
        this.field.classList.add("field-input-invalid")
        return this
    }
}

// Create a Custom Element and add somes shortcuts to create the various field types
customElements.define("a-field", kiss.ui.Field)

/**
 * Shorthand to create a new Field. See [kiss.ui.Field](kiss.ui.Field.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createField = (config) => document.createElement("a-field").init(config)

/**
 * Shorthand to create a new **text** Field. See [kiss.ui.Field](kiss.ui.Field.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createTextField = (config) => document.createElement("a-field").init(Object.assign(config, {
    type: "text"
}))

/**
 * Shorthand to create a new **textarea** Field. See [kiss.ui.Field](kiss.ui.Field.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createTextareaField = (config) => document.createElement("a-field").init(Object.assign(config, {
    type: "textarea"
}))

/**
 * Shorthand to create a new **number** Field. See [kiss.ui.Field](kiss.ui.Field.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createNumberField = (config) => document.createElement("a-field").init(Object.assign(config, {
    type: "number"
}))

/**
 * Shorthand to create a new **date** Field. See [kiss.ui.Field](kiss.ui.Field.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createDateField = (config) => document.createElement("a-field").init(Object.assign(config, {
    type: "date"
}))

/**
 * Shorthand to create a new **password** Field. See [kiss.ui.Field](kiss.ui.Field.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createPasswordField = (config) => document.createElement("a-field").init(Object.assign(config, {
    type: "password"
}))

;/**
 * 
 * The icon field allows to pick an icon and display its Font Awesome code.
 * 
 * @param {object} config
 * @param {string} [config.value] - Initial icon value
 * @param {string[]} [config.icons] - Optional array of icon classes to use. Ex: ["fas fa-check", "fas fa-user"]
 * @param {string} [config.iconColor] - Icon color. Ex: "#ffffff"
 * @param {string} [config.iconBackground - Icon background. Ex: "#00aaee"
 * @param {string} [config.iconSize] - Icon size. Ex: "16px"
 * @param {string} [config.iconAlign] - Ex: "center"
 * @param {string} [config.iconPadding] - Ex: "3px"
 * @param {boolean} [config.hideCode] - Set to true to hide the Font Awesome code
 * @param {string} [config.display]
 * @param {number|string} [config.width] - A number (in pixels) or any valid CSS value
 * @param {string} [config.minWidth] - A number (in pixels) or any valid CSS value
 * @param {number|string} [config.height] - A number (in pixels) or any valid CSS value
 * @param {number|string} [config.padding] - A number (in pixels) or any valid CSS value
 * @param {number|string} [config.margin] - A number (in pixels) or any valid CSS value
 * @param {string} [config.border]
 * @param {string} [config.borderStyle]
 * @param {number|string} [config.borderWidth] - A number (in pixels) or any valid CSS value
 * @param {string} [config.borderColor]
 * @param {string} [config.borderRadius]
 * @param {string} [config.boxShadow]
 * @param {boolean} [config.readOnly]
 * @returns this
 * 
 * ## Generated markup
 * ```
 * <a-icon class="a-icon">
 *  <label class="field-label"></label>
 *  <div class="field-icon-container">
 *      <div class="field-icon-palette"></div>
 *      <div class="field-icon-input"></div>
 *  </div>
 * </a-icon
 * ```
 */
 kiss.ui.Icon = class Icon extends kiss.ui.Component {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the 3 following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const myIconField = document.createElement("a-icon").init(config)
     * ```
     * 
     * Or use the shorthand for it:
     * ```
     * const myIconField = createIconField({
     *  value: "fas fa-check",
     *  height: "32px"
     * })
     * 
     * myIconField.render()
     * myIconField.getValue() // fas fa-check
     * myIconField.setValue("fas fa-circle")
     * myIconField.getValue() // fas fa-circle
     * ```
     * 
     * Or directly declare the config inside a container component:
     * ```
     * const myPanel = createPanel({
     *   title: "My panel",
     *   items: [
     *       {
     *           type: "icon",
     *           value: "fas fa-check",
     *           width: "32px"
     *           height: "32px",
     *           hideCode: true
     *       }
     *   ]
     * })
     * myPanel.render()
     * ```
     */
    constructor() {
        super()
    }

    init(config) {
        super.init(config)

        // Overwrite default value if the field is binded to a record
        // (default value must not override record's value)
        if (config.record && config.record[this.id]) config.value = config.record[this.id]

        const id = this.id
        this.value = config.value || ""
        this.required = !!config.required

        // Template
        this.innerHTML =
            `${ (config.label) ? `<label id="field-label-${this.id}" for="${this.id}" class="field-label">
                ${ (this.isLocked()) ? this.locker : "" }
                ${ config.label || "" }
                ${ (this.isRequired()) ? this.asterisk : "" }
            </label>` : "" }

            <div class="field-icon-container ${(config.readOnly) ? "field-input-read-only" : ""}">
                <div class="field-icon-palette ${this.value}"></div>
                ${(!config.hideCode) ? `<input type="text" autocomplete="off" readonly class="field-icon-input" value="${this.value}"></input>` : ""}
            </div>                
            `.removeExtraSpaces()

        this.label = this.querySelector(".field-label")
        this.fieldContainer = this.querySelector(".field-icon-container")
        this.icon = this.querySelector(".field-icon-palette")
        this.field = this.querySelector(".field-icon-input")

        // The width and height of the icon zone is adjusted if the icon code is displayed or not
        if (config.hideCode == true) this.icon.style.width = this.icon.style.height = "100%"

        // Set properties
        this._setProperties(config, [
            [
                ["draggable"],
                [this]
            ],
            [
                ["width", "height", "flex", "display", "margin", "padding"],
                [this.style]
            ],
            [
                ["fieldWidth=width", "fieldHeight=height", "fieldFlex=flex", "border", "borderStyle", "borderWidth", "borderColor", "borderRadius", "boxShadow"],
                [this.fieldContainer.style]
            ],
            [
                ["labelAlign=textAlign", "labelFlex=flex"],
                [this.label?.style]
            ],
            [
                ["borderRadius", "iconSize=fontSize", "iconColor=color", "iconBackground=background", "iconAlign=textAlign", "iconPadding=padding"],
                [this.icon.style]
            ]
        ])

        // Set the default display mode that will be restored by the show() method
        this.displayMode = "flex"

        // Manage label and field layout according to label position
        this.style.flexFlow = "row"

        if (config.label) {
            // Label width
            if (config.labelWidth) this.setLabelWidth(config.labelWidth)

            // Label position
            this.config.labelPosition = config.labelPosition || "left"
            this.setLabelPosition(config.labelPosition)
        }

        // Listen to click events if the field is *not* disabled or *readOnly* or *computed*
        this.readOnly = !!config.readOnly
        if (!this.readOnly && !config.disabled && !config.computed) {

            // Open the icon palette on click
            this.onclick = (event) => {
                const clickedElement = event.target.closest(".field-icon-container")
                if (!clickedElement) return

                const picker = createPanel({
                    modal: true,
                    header: false,
                    width: "67.5rem",
                    align: "center",
                    verticalAlign: "center",
                    zIndex: 1000,
                    items: [{
                        type: "iconPicker",
                        value: $(id).getValue(),
                        icons: config.icons || kiss.webfonts.all,
                        selectorBorderRadius: "3.2rem",
                        height: "66rem",
                        maxHeight: "calc(100vh - 10rem)",
                        autoFocus: true,
                        events: {
                            change: function () {
                                let icon = this.getValue()
                                $(id).setValue(icon)
                                picker.close()
                            }
                        }
                    }]
                }).render()
            }
        }

        // Bind the field to a record, if any
        if (config.record) this._bindRecord(config.record)

        // Render default value
        this._renderValues()

        return this
    }

    /**
     * Bind the field to a record
     * (this subscribes the field to react to database changes)
     * 
     * @private
     * @ignore
     * @param {object} record
     * @returns this
     */
    _bindRecord(record) {
        this.record = record
        this.modelId = record.model.id
        this.recordId = record.id

        if (record[this.id]) {
            this.value = this.initialValue = record[this.id]
        }

        // React to changes on a single record of the binded model
        this.subscriptions.push(
            subscribe("EVT_DB_UPDATE:" + this.modelId.toUpperCase(), (msgData) => {
                if ((msgData.modelId == this.modelId) && (msgData.id == this.recordId)) {
                    const updates = msgData.data
                    this._updateField(updates)
                }
            })
        )

        // React to changes on multiple records of the binded Model
        this.subscriptions.push(
            subscribe("EVT_DB_UPDATE_BULK", (msgData) => {
                const operations = msgData.data
                operations.forEach(operation => {
                    if ((operation.modelId == this.modelId) && (operation.recordId == this.recordId)) {
                        const updates = operation.updates
                        this._updateField(updates)
                    }
                })
            })
        )

        return this
    }

    /**
     * Updates the field value internally
     * 
     * @private
     * @ignore
     * @param {*} updates 
     */
    _updateField(updates) {
        if (this.id in updates) {
            this.value = updates[this.id]
            this._renderValues()
        }
    }

    /**
     * Set the fieldl value
     * 
     * @param {string} icon - Font Awesome icon code like "fas fa-check"
     * @param {boolean} [rawUpdate] - If true, it doesn't update the associated record and doesn't trigger "change" event 
     * @returns this
     */
    setValue(icon, rawUpdate) {
        if (icon == this.getValue()) return

        if (rawUpdate) return this._updateValue(icon, rawUpdate)

        if (this.record) {
            // If the field is connected to a record, we update the database
            this.record.updateFieldDeep(this.id, icon).then(success => {
                if (success) {
                    this._updateValue(icon)
                    this.initialValue = icon
                }
                else {
                    // Rollback the initial value if the update failed (ACL)
                    this._updateValue(this.initialValue)
                }
            })
        }
        else {
            this._updateValue(icon)
        }

        this.validate()
        return this
    }

    /**
     * Clear the field value
     * 
     * @returns this
     */
    clearValue() {
        this.setValue("")
        return this
    }    

    /**
     * Update the field's value internally
     * 
     * @private
     * @ignore
     * @param {string} icon
     * @param {boolean} [rawUpdate]
     * @returns this
     */
    _updateValue(icon, rawUpdate) {
        // const updateValue = (icon) => {
        //     this.value = icon
        //     this._renderValues()
        //     this.dispatchEvent(new Event("change"))
        // }

        this.value = icon
        this._renderValues()
        if (!rawUpdate) this.dispatchEvent(new Event("change"))
        return this
    }

    /**
     * Validate the field value against validation rules
     * 
     * @returns {boolean}
     */
     validate() {
        if (this.isHidden()) return true
        
        const isValid = kiss.tools.validateValue(this.type, this.config, this.value)
        if (isValid) {
            this.setValid()
        }
        else {
            this.setInvalid()
        }
        return isValid
    }

    /**
     * Remove the invalid style
     * 
     * @returns this
     */
    setValid() {
        this.isValid = true
        this.fieldContainer.classList.remove("field-input-invalid")
        return this
    }

    /**
     * Change the style when the field is invalid
     * 
     * @returns this
     */
    setInvalid() {
        log("kiss.ui - field.setInvalid - Invalid value for the field: " + this.config.label, 4)

        this.isValid = false
        this.fieldContainer.classList.add("field-input-invalid")
        return this
    }

    /**
     * Set the icon
     * 
     * @private
     * @ignore
     */
    _renderValues() {
        const icon = this.value || ""
        if (this.field) this.field.value = icon
        
        this.icon.className = ""
        const classList = icon.split(" ").filter(className => className != "")
        this.icon.classList.add("field-icon-palette", ...classList)
    }    

    /**
     * Get the field value
     * 
     * @returns {string} Font Awesome icon code like "fas fa-check"
     */
    getValue() {
        return this.value
    }

    /**
     * Set the field label
     * 
     * @param {string} newLabel
     * @returns this
     */
    setLabel(newLabel) {
        if (!this.label) return

        this.config.label = newLabel
        this.label.innerText = newLabel
        return this
    }

    /**
     * Get the field label
     * 
     * @returns {string}
     */
    getLabel() {
        return this?.label?.innerText || ""
    }

    /**
     * Set the field width
     * 
     * @param {*} width
     * @returns this
     */
    setWidth(width) {
        this.config.width = width
        this.style.width = this._computeSize("width", width)
        return this
    }

    /**
     * Set the icon selector field width
     * 
     * @param {*} width
     * @returns this
     */
    setFieldWidth(width) {
        this.config.fieldWidth = width
        this.fieldContainer.style.width = this._computeSize("fieldWidth", width)
        return this
    }

    /**
     * Set the label width
     * 
     * @param {*} width
     * @returns this
     */
    setLabelWidth(width) {
        this.config.labelWidth = width
        this.label.style.minWidth = this.label.style.maxWidth = this._computeSize("labelWidth", width)
        return this
    }

    /**
     * Get the label position
     * 
     * @returns {string} "left" | "right" | "top"
     */
    getLabelPosition() {
        return this.config.labelPosition
    }

    /**
     * Set label position
     * 
     * @param {string} position - "left" (default) | "right" | "top" | "bottom"
     * @returns this
     */
    setLabelPosition(position) {
        this.config.labelPosition = position

        switch (position) {
            case "top":
                this.style.flexFlow = "column"
                this.fieldContainer.style.order = 1
                break
            case "bottom":
                this.style.flexFlow = "column"
                this.fieldContainer.style.order = -1
                break
            case "right":
                this.style.flexFlow = "row"
                this.fieldContainer.style.order = -1
                break
            default:
                this.style.flexFlow = "row"
                this.fieldContainer.style.order = 1
        }
        return this
    }
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-icon", kiss.ui.Icon)

/**
 * Shorthand to create a new Icon field. See [kiss.ui.Icon](kiss.ui.Icon.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createIconField = (config) => document.createElement("a-icon").init(config)

;/**
 * 
 * The IconPicker derives from [Component](kiss.ui.Component.html).
 * It allows to pick an icon.
 * At the moment, KissJS is using Font Awesome free icons.
 * 
 * @param {object} config
 * @param {string} [config.value] - The default icon class name. Ex: "fas fa-check"
 * @param {string[]} [config.icons] - Optional array of icon classes to use. Ex: ["fas fa-check", "fas fa-user"]
 * @param {function} [config.autoFocus] - Automatically scroll down to the selected icon if true (default false)
 * @param {function} [config.action] - Function executed when an icon is selected. Receives the selected icon class as an argument.
 * @param {object[]} [config.columns] - Nnumber of columns to display the icons
 * @param {string} [config.iconSize] - Size of the icons. Ex: "16px"
 * @param {string} [config.selectorSize] - Should be greater than the icon size. Ex: "32px"
 * @param {string} [config.selectorBorderRadius] - Ex: "10px"
 * @param {string} [config.background]
 * @param {string} [config.backgroundColor]
 * @param {string} [config.backgroundColorSelected]
 * @param {string|number} [config.width]
 * @param {string|number} [config.maxWidth]
 * @param {string|number} [config.height]
 * @param {string|number} [config.maxHeight]
 * @param {string} [config.padding]
 * @param {string} [config.margin]
 * @param {string} [config.border]
 * @param {string} [config.borderStyle]
 * @param {string} [config.borderWidth]
 * @param {string} [config.borderColor]
 * @param {string} [config.borderRadius]
 * @param {string} [config.boxShadow]
 * @returns this
 * 
 * ## Generated markup
 * ```
 * <a-iconpicker class="a-iconpicker">
 * 
 *  <!-- For each icon selector -->
 *  <span class="icon-selector"></span>
 * 
 * </a-iconpicker>
 * ```
 */
kiss.ui.IconPicker = class IconPicker extends kiss.ui.Component {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the 3 following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const myIconPicker = document.createElement("a-iconpicker").init(config)
     * ```
     * 
     * Or use the shorthand for it:
     * ```
     * const myIconPicker = createIconPicker({
     *   value: "fas fa-check", 
     *   columns: 10,
     *   action: (iconClass) => console.log(iconClass)
     * })
     * 
     * myIconPicker.render()
     * ```
     * 
     * Or directly declare the config inside a container component:
     * ```
     * const myPanel = createPanel({
     *   title: "My panel",
     *   items: [
     *       {
     *           type: "iconPicker",
     *           value: "fas fa-check", 
     *           columns: 10,
     *           action: (iconClass) => console.log(iconClass)
     *       }
     *   ]
     * })
     * myPanel.render()
     * ```
     */
    constructor() {
        super()
    }

    /**
     * Generates an icon picker from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config = {}) {
        super.init(config)

        // Overwrite default value if the field is binded to a record
        // (default value must not override record's value)
        if (config.record && config.record[this.id]) config.value = config.record[this.id]

        this.value = config.value
        this.iconSize = config.iconSize || "3.2rem"
        this.selectorSize = config.selectorSize || "5rem"
        this.selectorBorderRadius = config.selectorBorderRadius || "0.5rem"
        this.color = config.color || "var(--body)"
        this.colorSelected = config.colorSelected || "#ffffff"
        this.backgroundColor = config.backgroundColor || "var(--body-background)"
        this.backgroundColorSelected = config.backgroundColorSelected || "#00aaee"
        this.columns = config.columns || 10000
        this.autoFocus = config.autoFocus

        // Bind the field to a record, if any
        if (config.record) this._bindRecord(config.record)

        // Id used to track the right picker when there is more than one on the same page
        this.specialId = this.id.replace(new RegExp("-", "g"), "_")

        // Template
        let icons = config.icons || kiss.webfonts.all

        this.innerHTML =
            icons.map((font, index) => /*html*/ `
                <span id="${this.specialId}:icon-${font}"
                    class="icon-selector ${font} ${(this.value == font) ? "icon-selector-selected" : ""}"
                    style=
                    "
                        width: ${this.selectorSize};
                        height: ${this.selectorSize};
                        line-height: ${this.selectorSize};
                        font-size: ${this.iconSize};
                        color: ${this.color};
                        background-color: ${(this.value == font) ? this.backgroundColorSelected : this.backgroundColor};
                        border-radius: ${this.selectorBorderRadius};
                    "
                >
                </span>${((index + 1) % this.columns == 0) ? "<br>" : ""}`.removeExtraSpaces()).join("")

        // Set properties
        this._setProperties(config, [
            [
                ["width", "maxWidth", "height", "maxHeight", "margin", "padding"],
                [this.style]
            ],
        ])

        // Set the default display mode that will be restored by the show() method
        this.displayMode = "inline-block"

        // Bind action to onclick
        this.onclick = (event) => {
            const icon = event.target.closest(".icon-selector")
            if (!icon) return
            const iconClass = icon.classList[1] + " " + icon.classList[2]
            this.setValue(iconClass)
            if (config.action) config.action(iconClass)
        }

        return this
    }

    /**
     * Automatically set the focus on the selected icon 500ms after rendering, if the autoFocus option is enabled
     * 
     * @private
     * @ignore
     */
    _afterRender() {
        if (!this.autoFocus) return
        setTimeout(() => this.focus(), 500)
    }

    /**
     * Bind the field to a record
     * (this subscribes the field to react to database changes)
     * 
     * @private
     * @ignore
     * @param {object} record
     * @returns this
     */
    _bindRecord(record) {
        this.record = record
        this.modelId = record.model.id
        this.recordId = record.id

        if (record[this.id]) {
            this.value = this.initialValue = record[this.id]
        }

        // React to changes on a single record of the binded model
        this.subscriptions.push(
            subscribe("EVT_DB_UPDATE:" + this.modelId.toUpperCase(), (msgData) => {
                if ((msgData.modelId == this.modelId) && (msgData.id == this.recordId)) {
                    const updates = msgData.data
                    this._updateField(updates)
                }
            })
        )

        // React to changes on multiple records of the binded Model
        this.subscriptions.push(
            subscribe("EVT_DB_UPDATE_BULK", (msgData) => {
                const operations = msgData.data
                operations.forEach(operation => {
                    if ((operation.modelId == this.modelId) && (operation.recordId == this.recordId)) {
                        const updates = operation.updates
                        this._updateField(updates)
                    }
                })
            })
        )

        return this
    }

    /**
     * Updates the field value internally
     * 
     * @private
     * @ignore
     * @param {*} updates 
     */
    _updateField(updates) {
        if (this.id in updates) {
            this.value = updates[this.id]
            this._renderValues()
        }
    }    

    /**
     * Set a new icon
     * 
     * @param {string} iconClass - Ex: "fas fa-check"
     * @param {string} [newBackgroundColor] - Optional background color to set under the selected icon
     * @param {boolean} [rawUpdate] - If true, it doesn't update the associated record and doesn't trigger "change" event 
     * @returns this
     */
    setValue(iconClass, newBackgroundColor, rawUpdate) {
        if (iconClass == this.getValue()) return
        if (newBackgroundColor === true) rawUpdate = true // If only 2 arguments are passed, the second one is rawUpdate (exception to the rule to be consistent with the other fields)

        if (rawUpdate) return this._updateValue(iconClass, newBackgroundColor, rawUpdate)

        if (this.record) {
            // If the field is connected to a record, we update the database
            this.record.updateFieldDeep(this.id, iconClass).then(success => {
                if (success) {
                    this._updateValue(iconClass, newBackgroundColor)
                    this.initialValue = iconClass
                }
                else {
                    // Rollback the initial value if the update failed (ACL)
                    this._updateValue(this.initialValue, this.backgroundColorSelected)
                }
            })
        } else {
            this._updateValue(iconClass, newBackgroundColor)
        }

        return this
    }

    /**
     * Clear the field value
     * 
     * @returns this
     */
    clearValue() {
        this.setValue("")
        return this
    }

    /**
     * Update the field's value internally
     * 
     * @private
     * @ignore
     * @param {string} iconClass
     * @param {string} [newBackgroundColor]
     * @param {boolean} [rawUpdate]
     * @returns this
     */
    _updateValue(iconClass, newBackgroundColor, rawUpdate) {
        this.value = iconClass
        if (newBackgroundColor) this.backgroundColorSelected = newBackgroundColor
        this._renderValues()
        if (!rawUpdate) this.dispatchEvent(new Event("change"))
        return this
    }

    /**
     * Render the current value(s) of the widget.
     * 
     * @private
     * @ignore
     */
    _renderValues() {
        const iconClass = this.value || ""
        const newBackgroundColor = this.backgroundColorSelected

        Array.from(this.children).forEach(icon => {
            icon.classList.remove("icon-selector-selected")
            icon.style.color = this.color
            icon.style.backgroundColor = this.backgroundColor
        })

        let icon = $(this.specialId + ":icon-" + iconClass)
        if (!icon) return

        icon.classList.add("icon-selector-selected")
        icon.style.color = this.colorSelected
        icon.style.backgroundColor = (newBackgroundColor) ? newBackgroundColor : this.backgroundColorSelected
    }

    /**
     * Set a new background color for the selected icon
     * 
     * @param {string} newBackgroundColor - Color background to set under the selected icon
     * @returns this
     */
    setColor(newBackgroundColor) {
        const selectedIcon = this.querySelector(".icon-selector-selected")
        this.backgroundColorSelected = selectedIcon.style.backgroundColor = newBackgroundColor
    }

    /**
     * Get the current selected icon class
     * 
     * @returns {string} The icon class. At the moment, we use Font Awesome. Example: "fas fa-check"
     */
    getValue() {
        return this.value
    }

    /**
     * Validate the field (always true because IconPicker fields can't have wrong values)
     * 
     * @ignore
     * @returns {boolean}
     */
    validate() {
        return true
    }

    /**
     * Set the field width
     * 
     * @param {*} width
     * @returns this
     */    
     setWidth(width) {
        this.config.width = width
        this.style.width = this._computeSize("width", width)
        return this
    }

    /**
     * Set the field height
     * 
     * @param {*} height
     * @returns this
     */    
    setHeight(height) {
        this.config.height = height
        this.style.height = this._computeSize("height", height)
        return this
    }

    /**
     * Scroll down to the selected icon
     * 
     * @returns this
     */
    focus() {
        const selectedIcon = this.querySelector(".icon-selector-selected")
        if (!selectedIcon) return

        selectedIcon.scrollIntoView({
            block: "center",
            behavior: "smooth"
        })

        return this
    }
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-iconpicker", kiss.ui.IconPicker)

/**
 * Shorthand to create a new IconPicker. See [kiss.ui.IconPicker](kiss.ui.IconPicker.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createIconPicker = (config) => document.createElement("a-iconpicker").init(config)

;/**
 * 
 * The Rating derives from [Component](kiss.ui.Component.html).
 * 
 * Provides a rating field.
 * 
 * @param {object} config
 * @param {string} config.label
 * @param {number} [config.max] - From 1 to 10
 * @param {number} [config.value] - Default value
 * @param {string} [config.labelWidth]
 * @param {string} [config.labelPosition] - left | right | top | bottom
 * @param {string} [config.labelAlign] - left | right
 * @param {string} [config.fontSize]
 * @param {string} [config.shape] - star | heart | thumb
 * @param {string} [config.iconSize]
 * @param {string} [config.iconColorOn]
 * @param {string} [config.iconColorOff]
 * @param {string} [config.formula]
 * @param {string|number} [config.width]
 * @param {string|number} [config.height]
 * @param {string} [config.margin]
 * @param {string} [config.padding]
 * @param {boolean} [config.readOnly]
 * @param {boolean} [config.disabled]
 * @returns this
 * 
 * ## Generated markup
 * ```
 * <a-rating class="a-rating">
 *  <label class="field-label"></label>
 *  <span class="field-rating">
 *      <span class="rating" index="1">
 *      <span class="rating" index="2">
 *      <span class="rating" index="3">
 *      <span class="rating" index="4">
 *      <span class="rating" index="5">
 *  </span>
 * </a-rating>
 * ```
 */
kiss.ui.Rating = class Rating extends kiss.ui.Component {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the 3 following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const myRating = document.createElement("a-rating").init(config)
     * ```
     * 
     * Or use the shorthand for it:
     * ```
     * const myRating = createRating({
     *  label: "Rate me!",
     *  max: 5,
     *  iconColorOn: "#00aaee",
     *  iconColorOff: "#dddddd"
     * })
     * 
     * myRating.render()
     * ```
     * 
     * Or directly declare the config inside a container component:
     * ```
     * const myPanel = createPanel({
     *  title: "My panel",
     *  items: [
     *      {
     *          type: "rating",
     *          label: "Rate me!",
     *          max: 5
     *      }
     *  ]
     * })
     * myPanel.render()
     * ```
     */
    constructor() {
        super()
    }

    /**
     * Generates a Rating field from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config) {
        super.init(config)

        const id = this.id
        this.value = Number(config.value) || 0
        this.max = config.max || 5

        // Rating icons
        config.shape = config.shape || "star"
        const iconClasses = this.getIconClasses()
        this.icon = iconClasses[config.shape]

        this.iconColorOn = config.iconColorOn || "#ffd139"
        this.iconColorOff = config.iconColorOff || "#dddddd"

        // Disable the field if it's readOnly
        this.readOnly = !!config.readOnly || !!config.computed
        if (this.readOnly) config.disabled = true

        // Template
        this.innerHTML = /*html*/
            `${(config.label) ? `<label id="field-label-${id}" for="${id}" class="field-label">
                ${ (this.isLocked()) ? this.locker : "" }
                ${ config.label || "" }
                ${ (this.isRequired()) ? this.asterisk : "" }
            </label>` : "" }
            
            <span class="field-rating"></span>
            `.removeExtraSpaces()

        // Set properties
        this.label = this.querySelector(".field-label")
        this.field = this.querySelector(".field-rating")

        // Other W3C properties
        this._setProperties(config, [
            [
                ["draggable"],
                [this]
            ],
            [
                ["width", "height", "display", "margin", "padding", "flex"],
                [this.style]
            ],
            [
                ["color", "fontSize", "labelAlign=textAlign", "labelFlex=flex"],
                [this?.label?.style]
            ]
        ])

        // Set the default display mode that will be restored by the show() method
        this.displayMode = "flex"

        // Manage label and field layout according to label position
        this.style.flexFlow = "row"

        // Listen to click events if the field is *not* disabled or *readOnly*
        if (config.disabled != true && !this.readOnly) {
            this.field.onclick = (event) => {
                if (event.target.classList.contains("rating")) {
                    const index = event.target.getAttribute("index")
                    this.setValue(Number(index) + 1)
                }
            }
        }

        // Label setup
        if (config.label) {
            // Label width
            if (config.labelWidth) this.setLabelWidth(config.labelWidth)

            // Label position
            this.config.labelPosition = config.labelPosition || "left"
            this.setLabelPosition(config.labelPosition)

            // Listen to click events if the field is *not* disabled or *readOnly*
            if (config.disabled != true) this.label.onclick = this.field.onclick
        }

        // Bind the field to a record, if any
        if (config.record) this._bindRecord(config.record)

        // Render default value
        this._renderValues()

        return this
    }

    /**
     * Get the icon classes for each checkbox shape
     * 
     * @returns {object}
     */
    getIconClasses() {
        return {
            star: "fas fa-star",
            heart: "fas fa-heart",
            thumb: "fas fa-thumbs-up"
        }
    }

    /**
     * Bind the field to a record
     * (this subscribes the field to react to database changes)
     * 
     * @private
     * @ignore
     * @param {object} record
     * @returns this
     */
    _bindRecord(record) {
        this.record = record
        this.modelId = record.model.id
        this.recordId = record.id

        if (record[this.id]) {
            this.value = this.initialValue = record[this.id]
        }

        // React to changes on a single record of the binded model
        this.subscriptions.push(
            subscribe("EVT_DB_UPDATE:" + this.modelId.toUpperCase(), (msgData) => {
                if ((msgData.modelId == this.modelId) && (msgData.id == this.recordId)) {
                    const updates = msgData.data
                    this._updateField(updates)
                }
            })
        )

        // React to changes on multiple records of the binded Model
        this.subscriptions.push(
            subscribe("EVT_DB_UPDATE_BULK", (msgData) => {
                const operations = msgData.data
                operations.forEach(operation => {
                    if ((operation.modelId == this.modelId) && (operation.recordId == this.recordId)) {
                        const updates = operation.updates
                        this._updateField(updates)
                    }
                })
            })
        )

        return this
    }

    /**
     * Updates the field value internally
     * 
     * @private
     * @ignore
     * @param {*} updates 
     */
    _updateField(updates) {
        if (this.id in updates) {
            const newValue = updates[this.id]
            if (newValue || (newValue === false)) {
                this.value = newValue
                this._renderValues()
            }
        }
    }    

    /**
     * Render the current value(s) of the widget.
     * 
     * @private
     * @ignore
     */
    _renderValues() {
        let html = ""
        for (let i = 0; i < this.max; i++) {
            const color = (i < this.value) ? this.iconColorOn : this.iconColorOff
            html += /*html*/`<span class="rating ${this.icon}" style="color: ${color}" index=${i}></span>`
        }
        this.field.innerHTML = html
    }

    /**
     * Set the field value
     * 
     * @param {boolean} newValue - The new field value
     * @param {boolean} [rawUpdate] - If true, it doesn't update the associated record and doesn't trigger "change" event 
     * @returns this
     */
    setValue(newValue, rawUpdate) {
        newValue = Number(newValue)

        if (newValue == this.value) return this
        if (rawUpdate) return this._updateValue(newValue, rawUpdate)

        if (this.record) {
            // If the field is connected to a record, we update the database
            this.record.updateFieldDeep(this.id, newValue).then(success => {
                if (success) {
                    this._updateValue(newValue)
                    this.initialValue = newValue
                }
                else {
                    // Rollback the initial value if the update failed (ACL)
                    this._updateValue(this.initialValue)
                }
            })
        } else {
            this._updateValue(newValue)
        }
        
        return this
    }

    /**
     * Clear the field value
     * 
     * @returns this
     */
    clearValue() {
        this.setValue(0)
        return this
    }    

    /**
     * Update the field's value internally
     * 
     * @private
     * @ignore
     * @param {boolean} newValue
     * @param {boolean} [rawUpdate]
     * @returns this
     */
    _updateValue(newValue, rawUpdate) {
        this.value = newValue
        this._renderValues()
        this.setValid()
        if (!rawUpdate) this.dispatchEvent(new Event("change"))
        return this
    }


    /**
     * Get the field value
     * 
     * @returns {number} - The field value
     */
    getValue() {
        return Number(this.value)
    }

    /**
     * Validate the field value against validation rules
     * 
     * @returns {boolean}
     */
    validate() {
        if (this.isHidden()) return true
        
        const isValid = kiss.tools.validateValue(this.type, this.config, this.value)
        if (isValid) {
            this.setValid()
        }
        else {
            this.setInvalid()
        }
        return isValid
    }

    /**
     * Remove the invalid style
     * 
     * @returns this
     */
    setValid() {
        this.isValid = true
        this.field.classList.remove("field-input-invalid")
        return this
    }

    /**
     * Change the style when the field is invalid
     * 
     * @returns this
     */
    setInvalid() {
        log("kiss.ui - field.setInvalid - Invalid value for the field: " + this.config.label, 4)

        this.isValid = false
        this.field.classList.add("field-input-invalid")
        return this
    }

    /**
     * Get the field label
     * 
     * @returns {string}
     */
    getLabel() {
        return this?.label?.innerText || ""
    }

    /**
     * Set the field label
     * 
     * @param {string} newLabel
     * @returns this
     */
    setLabel(newLabel) {
        if (!this.label) return

        this.config.label = newLabel
        this.label.innerText = newLabel
        return this
    }

    /**
     * Set the field width
     * 
     * @param {*} width
     * @returns this
     */
    setWidth(width) {
        this.config.width = width
        this.style.width = this._computeSize("width", width)
        return this
    }

    /**
     * Set the input field width
     * 
     * @param {*} width
     * @returns this
     */
    setFieldWidth(width) {
        this.config.fieldWidth = width
        this.field.style.width = this._computeSize("fieldWidth", width)
        return this
    } 

    /**
     * Set the label width
     * 
     * @param {*} width
     * @returns this
     */
    setLabelWidth(width) {
        this.config.labelWidth = width
        this.label.style.minWidth = this.label.style.maxWidth = this._computeSize("labelWidth")
        return this
    }

    /**
     * Get the label position
     * 
     * @returns {string} "left" | "right" | "top"
     */
    getLabelPosition() {
        return this.config.labelPosition
    }

    /**
     * Set label position
     * 
     * @param {string} position - "left" (default) | "right" | "top" | "bottom"
     * @returns this
     */
    setLabelPosition(position) {
        this.config.labelPosition = position

        switch (position) {
            case "top":
                this.style.flexFlow = "column"
                this.style.alignItems = "unset"
                this.field.style.order = 1
                break
            case "bottom":
                this.style.flexFlow = "column"
                this.style.alignItems = "unset"
                this.field.style.order = -1
                break
            case "right":
                this.style.flexFlow = "row"
                this.style.alignItems = "center"
                this.field.style.order = -1
                break
            default:
                this.style.flexFlow = "row"
                this.style.alignItems = "center"
                this.field.style.order = 1
        }
        return this
    }
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-rating", kiss.ui.Rating)

/**
 * Shorthand to create a new Rating. See [kiss.ui.Rating](kiss.ui.Rating.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createRating = (config) => document.createElement("a-rating").init(config)

;/**
 * 
 * The Select derives from [Component](kiss.ui.Component.html).
 * 
 * It's a multi-purpose select field, also known as "dropdown" or "combobox".
 * It can have a single or multiple values.
 * When multiple values, the field value returns an Array.
 * 
 * ## Features:
 * - auto-generation of options with templates like "time" | "weekday" | "month"...
 * - possible to use labels, to display something different than the field values
 * - possible to declare labels/values with a pipe "|". Example: "France|FR"
 * - single or multiple values
 * - auto-complete
 * - possible to disable some options (they are hidden, but it could be easily extended to be visible, using a different class name)
 * - possible to update the list of options afterward
 * - keyboard navigation up and down within options
 * - selection with mouse or Enter
 * - can delete existing entries with Backspace
 * - can sort values asc or desc
 * - option to add values which are not in list
 * - option to prevent duplicates
 * - option to add entries using a separator, comma by default (useful for email-like inputs)
 * - option to have a custom renderer for options
 * - option to have a custom renderer for values
 * - option to delete values by clicking on them
 * - option to switch a value on/off by clicking on it in the dropdown list
 * - option to hide or show the input (search) field
 * - option to position the input (search) field after the values (default) or before
 * - option to display values stacked one on another
 * 
 * ## To do
 * - option to sort the list of options
 * - option to reorder the field values with drag & drop
 * - possibility to navigate the current values / delete them hitting the del key
 * - other templates like range, weekday, month
 * 
 * ## Usage
 * 
 * To define the list of options, you can use a simple array of strings:
 * ```
 * const listOfOptions = ["France", "Great Britain"]
 * ```
 * Or an array of objects:
 * ```
 * const listOfOptions = [
 *  {value: "France"},
 *  {value: "Great Britain"}
 * ]
 * ```
 * Or a function that returns the list of options:
 * ```
 * const listOfOptions = () => {
 *  let options = []
 *  for (let i = 0; i < 10; i++) options.push({label: "Option " + i, value: i})
 *  return options
 * }
 * ```
 * If you used a function to generate the options, you can also combine it with a filtering function:
 * ```
 * const optionsFilter = (optionItem) => optionItem.value > 5
 * 
 * createSelect({
 *  label: "Select field with generated options",
 *  multiple: true,
 *  options: listOfOptions,
 *  optionsFilter // Will keep only the option items which value is > 5
 * })
 * ```
 * You can use labels that are different from the values:
 * ```
 * const listOfOptions = [
 *  {value: "FR", label: "France"},
 *  {value: "GB", label: "Great Britain"}
 * ]
 * ```
 * You can also set a color per option:
 * ```
 * const listOfOptions = [
 *  {value: "FR", color: "#00aaee"},
 *  {value: "GB", color: "#a1ed00"}
 * ]
 * ```
 * You can disable some options:
 * ```
 * const listOfOptions = [
 *  {value: "FR", color: "#00aaee"},
 *  {value: "GB", color: "#a1ed00"},
 *  {value: "USA", color: "#ff0000", disabled: true}
 * ]
 * ```
 * You can select one or multiple values thanks to the "multiple" parameter:
 * ```
 * createSelect({
 *  label: "Countries",
 *  multiple: true,
 *  options: listOfOptions
 * })
 * ```
 * You can define a custom renderer to display the field values. The default renderer is a function like this:
 * ```
 * // Default renderer for field values
 * const valueRenderer = (option) =>
 *  `<div class="field-select-value" value="${option.value}" ${(option.color || this.optionsColor) ? `style="background: ${option.color || this.optionsColor}"` : ""}>
 *      ${option.label || option.value}
 *      ${(this.allowClickToDelete == true) ? `<span class="field-select-value-delete fas fa-times"></span>` : ""}
 *  </div>`
 * ```
 * You can define a custom renderer for each option of the list. The default renderer is a function like this:
 * ```
 * // Default renderer for the list of options
 * const optionRenderer = (option) => option.label || option.value
 * 
 * // It could be like:
 * const optionRenderer = (option) => "Label: " + option.label + " - Value: " + option.value
 * ```
 * 
 * @param {object} config
 * @param {object} config.template - "time" - TODO: other template like "range" | "weekday" | "month" | ...
 * @param {string[]|object[]|function} config.options - List of options or function that returns a list of options, where each option must be an object like:
 *  <br>
 *  {value: "France"} or {label: "France", value: "FR"} or {label: "France", value: "FR", color: "#00aaee"}.
 *  <br>
 *  <br>
 *  A shorthand for the options is to provide an array of strings, like:
 *  <br>
 *  ["France", "Great Britain"] or ["France|FR", "Great Britain|GB"] if you need to separate the label from the value.
 * 
 * @param {function} [config.optionsFilter] - When the options are defined by a function, you can provide a filtering function that will be executed at runtime to filter only a specific set of options, depending on the context
 * @param {boolean} [config.multiple] - True to enable multi-select
 * @param {string|string[]} [config.value] - Default value
 * @param {string} [config.optionsColor] - Default color for all options
 * @param {string} [config.valueSeparator] - Character used to display multiple values
 * @param {string} [config.inputSeparator] - Character used to input multiple values
 * @param {boolean} [config.stackValues] - True to render the values one on another
 * @param {boolean} [config.hideInput] - true (default) to automatically hide the input field after a completed search
 * @param {boolean} [config.allowValuesNotInList] - Allow to input a value which is not in the list of options
 * @param {boolean} [config.allowDuplicates] - Allow to input duplicate values. Default to false.
 * @param {boolean} [config.allowClickToDelete] - Add a "cross" icon over the values to delete them. Default to false.
 * @param {boolean} [config.allowSwitchOnOff] - Allow to click on a value to switch it on/off
 * @param {function} [config.optionRenderer] - Custom function to render each option in the list of options
 * @param {function} [config.valueRenderer] - Custom function to render the actual field values
 * @param {string} [config.label]
 * @param {string} [config.fieldWidth]
 * @param {string} [config.labelWidth]
 * @param {string} [config.labelPosition] - left | right | top | bottom
 * @param {string} [config.labelAlign] - left | right
 * @param {boolean} [config.autocomplete] - Set "off" to disable
 * @param {boolean} [config.readOnly]
 * @param {boolean} [config.disabled]
 * @param {boolean} [config.required]
 * @param {function} [config.validationFunction] - Async function that must return true if the value is valid, false otherwise
 * @param {string} [config.margin]
 * @param {string} [config.padding]
 * @param {string} [config.display] - flex | inline flex
 * @param {string|number} [config.width]
 * @param {string|number} [config.height]
 * @returns this
 * 
 * ## Generated markup
 * The field is a composition of various elements:
 * - a div for the field label
 * - a div that renders the existing values (as chips, by default)
 * - an input field, used to filter options
 * - a div to display and select the options
 * 
 * ```
 * <a-select class="a-select">
 *  <label class="field-label"></label>
 * 
 *  <div class="field-select">
 *      <span class="field-select-values"></span>
 *  </div>
 * 
 *  <div class="field-select-options">
 *      <span class="field-select-input"></span>
 * 
 *      <!-- For each option -->
 *      <div class="field-option"></div>
 *  </div>
 * 
 * </a-select>
 * ```
 */
kiss.ui.Select = class Select extends kiss.ui.Component {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the 3 following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const mySelect = document.createElement("a-select").init(config)
     * ```
     * 
     * Or use the shorthand for it:
     * ```
     * const mySelect = createSelect({
     *   label: "Countries",
     *   options: [
     *       {value: "France"},
     *       {value: "Great Britain"}
     *   ]
     * })
     * 
     * mySelect.render()
     * ```
     * 
     * Or directly declare the config inside a container component:
     * ```
     * const myPanel = createPanel({
     *   title: "My panel",
     *   items: [
     *       {
     *           type: "select",
     *           options: [
     *               {value: "France"},
     *               {value: "Great Britain"}
     *           ]
     *       }
     *   ]
     * })
     * myPanel.render()
     * ```
     */
    constructor() {
        super()
    }

    /**
     * Generates a Select field from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config = {}) {
        super.init(config)

        // Setup all the field options
        const isMobile = kiss.screen.isMobile
        this.optionsColor = config.optionsColor
        this.readOnly = !!config.readOnly || !!config.computed
        this.disabled = !!config.disabled
        this.required = !!config.required
        this.placeholder = config.placeholder || ""
        this.autocomplete = (config.autocomplete != "off")
        this.hideInput = (config.hideInput !== false)
        this.multiple = !!config.multiple
        this.inputSeparator = config.inputSeparator || ","
        this.valueSeparator = config.valueSeparator || ","
        this.stackValues = !!config.stackValues
        this.allowValuesNotInList = !!config.allowValuesNotInList
        this.allowDuplicates = !!config.allowDuplicates
        this.allowClickToDelete = !!config.allowClickToDelete && (this.readOnly !== true)
        this.allowSwitchOnOff = !!config.allowSwitchOnOff
        if (isMobile) this.allowSwitchOnOff = true
        this.displayedOptions = []
        this.selectedOption = null
        this.optionRenderer = config.optionRenderer || null
        this.valueRenderer = config.valueRenderer || null

        // Overwrite default value if the field is binded to a record
        // (default value must not override record's value)
        if (config.record && config.record[this.id]) config.value = config.record[this.id]

        // De-reference the initial value to avoid side effects
        this.value = (Array.isArray(config.value)) ? config.value.map(val => val) : (config.value)

        // Cast value to Array if "multiple" option is enabled
        if (this.multiple && (!Array.isArray(this.value))) this.value = [].concat(this.value)

        // The list of options can vary depending on some pre-defined field templates
        switch (config.template) {
            case "time":
                // Special template for "Time" field
                this.options = this._generateTimes(config.min || 0, config.max || 24, config.interval || 60, true)
                break

            case "gmt":
            case "countries":
            case "... other templates to come":

            default:
                // Other
                // Options can be passed as an array of strings, or an array of objects, or a function.
                if (config.options && typeof config.options == "function") {
                    this.options = config.options(config.optionsFilter)
                } else {
                    this.options = config.options || []
                    this.options = this.options.map(option => {
                        if (typeof option == "object") return option
                        return {
                            value: option
                        }
                    })
                }

                // Options which value contains a pipe "|" auto-generate a label/value option
                this.options.forEach(option => {
                    if (option.value && typeof option.value === "string" && option.value.includes("|")) {
                        const optionConfig = option.value.split("|")
                        option.label = optionConfig[0].trim()
                        option.value = optionConfig[1].trim()
                    }
                })
        }

        // Will keep track of the last value typed into the input field
        this.lastEnteredValue = ""

        // Template
        this.innerHTML =
            `${ (config.label) ? `<label id="field-label-${this.id}" for="${this.id}" class="field-label">
                ${ (this.isLocked()) ? this.locker : "" }
                ${ config.label || "" }
                ${ (this.isRequired()) ? this.asterisk : "" }
            </label>` : "" }

            <div class="field-select ${(!!config.readOnly) ? "field-input-read-only" : ""}">
                <div class="field-select-values"></div>
            </div>
            
            <div class="field-select-options">
                ${(!isMobile) ? "" :
                    `<span class="a-select-mobile-close-container">
                        <span class="a-select-mobile-close fas fa-chevron-left"></span>
                        <span class="field-label">${config.label}</span>
                    </span>`
                }
                <input class="field-select-input" type="text" ${(this.autocomplete && !isMobile) ? "" : `style="display: none"`}>
                <div class="field-select-options-list"></div>
            </div>
            `.removeExtraSpaces()

        this.label = this.querySelector(".field-label")
        this.field = this.querySelector(".field-select")
        this.fieldValues = this.querySelector(".field-select-values")
        this.fieldInput = this.querySelector(".field-select-input")
        this.optionsWrapper = this.querySelector(".field-select-options")
        this.optionsList = this.querySelector(".field-select-options-list")

        // Set properties
        this._setProperties(config, [
            [
                ["draggable"],
                [this]
            ],
            [
                ["width", "height", "display", "margin", "padding", "flex"],
                [this.style]
            ],
            [
                ["value", "maxLength", "min", "max", "placeholder", "readOnly", "disabled", "required"],
                [this.field]
            ],
            [
                ["fieldWidth=width", "minWidth", "fieldHeight=height", "fieldFlex=flex", "boxShadow"],
                [this.field.style]
            ],
            [
                ["fieldLabelWidth=width", "labelAlign=textAlign", "labelFlex=flex"],
                [this.label?.style]
            ],
            [
                ["fieldWidth=width", "minWidth"],
                [this.optionsWrapper.style]
            ],
            [
                ["maxHeight"],
                [this.optionsList.style]
            ],
            [
                ["placeholder"],
                [this.fieldInput]
            ]
        ])

        // Set the default display mode that will be restored by the show() method
        this.displayMode = "flex"

        // Manage label and field layout according to label position
        this.style.flexFlow = "column"

        if (config.label) {
            // Label width
            if (config.labelWidth) this.setLabelWidth(config.labelWidth)

            // Label position
            this.config.labelPosition = config.labelPosition || "left"
            this.setLabelPosition(config.labelPosition)
        }

        // Override mousedown event which can't be customized for a select field (too many edge cases)
        if (!this.readOnly && !this.disabled) {
            this.onmousedown = function (event) {
                event.stop()

                let classes = event.target.classList
                if (classes.contains("field-select-value-delete")) return this._deleteValueByClick(event)
                if (classes.contains("field-select-value")) return this._showOptions()
                if (classes.contains("field-select-values")) return this._showOptions()
                if (classes.contains("field-select-placeholder")) return this._showOptions()
                if (classes.contains("field-select")) return this._showOptions()
                if (classes.contains("field-option")) return this._selectOption(event)
                
                if (!isMobile) return
                const closeHeader = event.target.closest(".a-select-mobile-close-container")
                if (closeHeader) return this._hideOptions()
            }
        }

        // Add field base class
        this.classList.add("a-field")

        // Close option list when exiting the select field
        this.field.onmouseleave = (event) => {
            // We only close it if the mouse is outside the dropdown list
            if (!kiss.tools.isEventInElement(event, this.optionsWrapper, 10)) this._hideOptions()
        }

        // Close option list when leaving the dropdown area
        this.optionsWrapper.onmouseleave = (event) => {
            if (document.activeElement.classList.contains("field-select-input")) {
                if (this.fieldInput.value == "") {
                    this._hideOptions()
                }
            }
            else {
                this._hideOptions()
            }
        }

        // Close option list when leaving the search field
        this.fieldInput.onblur = (event) => {
            this.fieldInput.value = ""
            this._hideOptions()
        }

        // Keyboard management
        if (this.autocomplete != "off") {
            this._manageKeyboard()
        }

        // Bind the field to a record, if any
        if (config.record) this._bindRecord(config.record)

        // Render default values
        this._renderValues()

        return this
    }

    /**
     * Render the current value(s) of the widget.
     * By default, values are rendered as "chips", but we can provide any other renderer using the 'valueRenderer' config.
     * 
     * @private
     * @ignore
     */
    _renderValues() {
        // Check if the field is empty
        let isEmpty = false

        if (this.multiple) {
            if (this.value && Array.isArray(this.value) && this.value.length == 0) isEmpty = true
        } else {
            if (this.value === undefined || this.value === "") isEmpty = true
        }

        if (isEmpty) {
            this.fieldValues.innerHTML = `<span class="field-select-placeholder">${this.placeholder}</span>` || ""
            this._adjustSizeAndPosition()
            return
        }

        // Transform the array of options to a Map, which is faster to retrieve a keyed value
        const mapOptions = new Map(this.options.map(option => [option.value, option]))

        // Separate values by <br> if the option "stackValues" is true
        const htmlSeparator = (this.stackValues) ? "<br>" : ""

        this.fieldValues.innerHTML = []
            .concat(this.value)
            .filter(value => value !== "" && value !== undefined && value !== null)
            .map(value => {
                let option = mapOptions.get(value)

                // If the value is not part of the configurated options, we generate a default config
                if (!option) {
                    option = {
                        value,
                        color: this.defaultColor
                    }
                }

                // Render!
                if (!this.valueRenderer) {
                    // Default renderer
                    return `<div class="field-select-value" value="${option.value}" ${(option.color || this.optionsColor) ? `style="background: ${option.color || this.optionsColor}"` : ""}>
                            ${option.label || option.value}
                            ${(this.allowClickToDelete == true) ? `<span class="field-select-value-delete fas fa-times"></span>` : ""}
                        </div>`.removeExtraSpaces()
                } else {
                    // Custom renderer
                    return this.valueRenderer(option, this.record)
                }
            })
            .join(htmlSeparator)

        // Adjust the size of the options wrapper depending on the field content
        this._adjustSizeAndPosition()
    }

    /**
     * Bind the field to a record
     * (this subscribes the field to react to database changes)
     * 
     * @private
     * @ignore
     * @param {object} record
     * @returns this
     */
    _bindRecord(record) {
        this.record = record
        this.modelId = record.model.id
        this.recordId = record.id

        if (record[this.id]) {
            this.value = (this.multiple) ? [].concat(record[this.id]) : record[this.id]
            this.initialValue = this.value
        }

        // React to changes on a single record of the binded model
        this.subscriptions.push(
            subscribe("EVT_DB_UPDATE:" + this.modelId.toUpperCase(), (msgData) => {
                if ((msgData.modelId == this.modelId) && (msgData.id == this.recordId)) {
                    const updates = msgData.data
                    this._updateField(updates)
                }
            })
        )

        // React to changes on multiple records of the binded Model
        this.subscriptions.push(
            subscribe("EVT_DB_UPDATE_BULK", (msgData) => {
                const operations = msgData.data
                operations.forEach(operation => {
                    if ((operation.modelId == this.modelId) && (operation.recordId == this.recordId)) {
                        const updates = operation.updates
                        this._updateField(updates)
                    }
                })
            })
        )

        return this
    }

    /**
     * Updates the field value internally
     * 
     * @private
     * @ignore
     * @param {*} updates 
     */
    _updateField(updates) {
        if (this.id in updates) {
            const newValue = updates[this.id]
            if (newValue || (newValue === 0) || (newValue === "")) {
                this.value = newValue
                this._renderValues()
            }
        }
    }    

    /**
     * Set the field value
     * 
     * @param {string|string[]} newValue - The new field value
     * @param {boolean} [rawUpdate] - If true, it doesn't update the associated record and doesn't trigger "change" event 
     * @returns this
     */
    setValue(newValue, rawUpdate) {
        if (rawUpdate) return this._updateValue(newValue, rawUpdate)

        this._updateValue(newValue)

        if (this.record) {
            // If the field is connected to a record, we update the database
            this.record.updateFieldDeep(this.id, this.value).then(success => {

                // Rollback the initial value if the update failed (ACL)
                if (!success) {
                    this._updateValue(this.initialValue)
                }
                else {
                    this.initialValue = newValue
                }
            })
        }

        this.validate()
        return this
    }

    /**
     * Clear the field value
     * 
     * @returns this
     */
    clearValue() {
        if (this.multiple) {
            this.setValue([])
        }
        else {
            this.setValue("")
        }
        return this
    }    

    /**
     * Update the field's value internally
     * 
     * @private
     * @ignore
     * @param {string|string[]} newValue
     * @param {boolean} [rawUpdate]
     * @returns this
     */
    _updateValue(newValue, rawUpdate) {
        this.value = newValue

        // Cast value to Array if it's a multiple select
        if (this.multiple) {
            const values = [].concat([...newValue])
            this.value = values.filter(value => value != "" && value != undefined && value != null)
        }

        this._renderValues()

        if (!rawUpdate) this.dispatchEvent(new Event("change"))
        return this
    }

    /**
     * Add a value to the Select field. This method does a few things:
     * - check for duplicate entries (and remove if not allowed)
     * - check for multiple entries (and exit if not allowed)
     * - update the field value
     * - reset the input field then give it focus
     * 
     * @param {string} newValue - Value to add
     */
    async addValue(newValue) {

        // Excludes HTML
        if (("" + newValue).containsHTML()) {
            return
        }

        let nextValue

        if (this.multiple) {
            nextValue = [].concat(this.value)

            // Check for duplicate entries
            // If it's a duplicate, we check the option "allowSwitchOnOff" to know if we switch off the value or just exit
            let switchOff = false
            if ((this.allowDuplicates != true) && (this._isDuplicate(newValue) == true)) {
                if (!this.allowSwitchOnOff) {
                    this._resetInputField()
                    return
                }
                switchOff = true
            }

            if (switchOff) {
                nextValue.remove(newValue)
            } else {
                nextValue.push(newValue)
            }
        } else {
            nextValue = newValue
        }

        this.setValue(nextValue)

        // Reset input field
        this._resetInputField()

        // Reset selected option
        this.selectedOption = null

        // Hide the list of options
        this._hideOptions()
    }    

    /**
     * Validate the field value against validation rules
     * 
     * @returns {boolean}
     */
    validate() {
        if (this.isHidden()) return true
        
        this.setValid()

        // Exit if field is readOnly
        if (this.config.readOnly) return true

        // Required
        if (this.required && this.isEmpty()) this.setInvalid()
        return this.isValid
    }

    /**
     * Remove the invalid style
     * 
     * @returns this
     */
    setValid() {
        this.isValid = true
        this.field.classList.remove("field-input-invalid")
        return this
    }

    /**
     * Change the style when the field is invalid
     * 
     * @returns this
     */
    setInvalid() {
        log("kiss.ui - field.setInvalid - Invalid value for the field: " + this.config.label, 4)

        this.isValid = false
        this.field.classList.add("field-input-invalid")
        return this
    }    

    /**
     * Check if the field is empty
     * 
     * @returns {boolean}
     */
    isEmpty() {
        if (this.multiple && this.getValue().length == 0) return true
        if (this.getValue() == "") return true
        return false
    }

    /**
     * Sort values
     * 
     * @param {string} order - "asc" or "desc"
     * @returns this
     */
    sort(order = "asc") {
        if (order == "desc") this.value.sort().reverse()
        else this.value.sort()

        this._renderValues()
        return this
    }

    /**
     * Sort values according to their corresponding label
     * 
     * @param {string} order - "asc" or "desc"
     * @returns this
     */
    sortByLabel(order = "asc") {
        const coef = (order == "asc") ? 1 : -1
        this.value.sort((a, b) => {
            const optionA = this.options.find(option => option.value == a)
            const optionB = this.options.find(option => option.value == b)
            if (optionA && optionA.label && optionB && optionB.label) return optionA.label.localeCompare(optionB.label) * coef
            return -1
        })

        this._renderValues()
        return this
    }    

    /**
     * Get the field value
     * 
     * @returns {string|string[]} - Returns an array of strings if the "multiple" option is true. Returns a string otherwise.
     */
    getValue() {
        if (this.multiple) {
            const values = [].concat(this.value)
            return values.filter(value => value != "" && value != undefined && value != null)
        } else {
            const value = (Array.isArray(this.value)) ? this.value[0] : this.value
            return (value == undefined) ? "" : value
        }
    }

    /**
     * Get the selected option(s)
     * 
     * @returns {object|object[]} A single option or an array of options if multiple values are selected
     */
    getSelection() {
        const currentValue = this.getValue()
        if (Array.isArray(currentValue)) {
            return this.options.filter(option => currentValue.includes(option.value))
        }
        else {
            return this.options.find(option => option.value == currentValue)
        }
    }

    /**
     * Reset the field value
     * 
     * @returns this
     */
    resetValue() {
        this.value = (this.multiple) ? [] : ""
        this._renderValues()
        return this
    }

    /**
     * Update the list of options
     * 
     * @param {array} newOptions - An array of object defining the field options
     * @example
     * mySelectField.updateOptions([
     *      {
     *          value: "firstName",
     *          disabled: false,
     *          color: "#00aaee"
     *      },
     *      {...}
     * ])
     */
    updateOptions(newOptions) {
        if (!newOptions) return
        this.options = newOptions

        // Options can be passed as an array of strings or an array of objects
        // We cast to an array of objects
        this.options = this.options.map(option => {
            if (typeof option == "object") return option
            return {
                value: option
            }
        })

        // Delete the content of the options wrapper
        this.optionsList.deepDelete(false)

        // Then re-generate the options
        this._createOptions()

        // Update the field values according to the new configuration
        // + filters out the field values that are not anymore in the possible options
        let currentValues = this.getValue()

        if (Array.isArray(currentValues)) {
            let currentOptionValues = this.options.map(option => option.value)
            let newValue = currentValues.filter(value => currentOptionValues.indexOf(value) != -1)

            this.value = newValue
        }
        this._renderValues()
    }

    /**
     * Get the field label
     * 
     * @returns {string}
     */
    getLabel() {
        return this?.label?.innerText || ""
    }

    /**
     * Set the field label
     * 
     * @param {string} newLabel
     * @returns this
     */
    setLabel(newLabel) {
        if (!this.label) return

        this.config.label = newLabel
        this.label.innerText = newLabel
        return this
    }

    /**
     * Set the field container width
     * 
     * @param {*} width
     * @returns this
     */
    setWidth(width) {
        this.config.width = width
        this.style.width = this._computeSize("width", width)
        return this
    }

    /**
     * Set the input field width
     * 
     * @param {*} width
     * @returns this
     */
    setFieldWidth(width) {
        this.config.fieldWidth = width
        this.field.style.width = this._computeSize("fieldWidth", width)
        return this
    }

    /**
     * Set the label width
     * 
     * @param {*} width
     * @returns this
     */
    setLabelWidth(width) {
        this.config.labelWidth = width
        this.label.style.minWidth = this.label.style.maxWidth = this._computeSize("labelWidth", width)
        return this
    }

    /**
     * Get the label position
     * 
     * @returns {string} "left" | "right" | "top"
     */
    getLabelPosition() {
        return this.config.labelPosition
    }

    /**
     * Set label position
     * 
     * @param {string} position - "left" (default) | "right" | "top" | "bottom"
     * @returns this
     */
    setLabelPosition(position) {
        this.config.labelPosition = position

        switch (position) {
            case "top":
                this.style.flexFlow = "column"
                this.field.style.order = 1
                break
            case "bottom":
                this.style.flexFlow = "column"
                this.field.style.order = -1
                break
            case "right":
                this.style.flexFlow = "row"
                this.field.style.order = -1
                break
            default:
                this.style.flexFlow = "row"
                this.field.style.order = 1
        }
        return this
    }

    /**
     * Allow/forbid to select multiple values
     * 
     * @param {boolean} state 
     */
    setMultiple(state = true) {
        this.multiple = state
    }

    /**
     * Allow/forbid to click on field values to delete them
     * 
     * @param {boolean} state 
     */
    setClickToDelete(state = true) {
        this.allowClickToDelete = state
    }

    /**
     * Give focus to the input field
     * 
     * @returns this
     */
    focus() {
        this.fieldInput.focus()
        return this
    }

    /**
     * Manage keyboard interactions:
     * - arrow up/down to navigate within the select options
     * - either ENTER or the "inputSeparator" key, to validate an option
     * - backspace to delete a value
     * 
     * @private
     * @ignore
     */
    _manageKeyboard() {
        this.fieldInput.onkeydown = (event) => {
            if (event.key == "Enter") event.preventDefault()
        }

        this.fieldInput.onkeyup = (event) => {
            event.stop()

            let enteredValue = event.target.value

            // ARROW DOWN (navigate down the list of options)
            if (event.which == 40) {
                this._navigateOptions("down")
                return
            }

            // ARROW UP (navigate down the list of options)
            if (event.which == 38) {
                this._navigateOptions("up")
                return
            }

            // BACKSPACE (delete the last value)
            if (event.key == "Backspace") {
                if ((this.lastEnteredValue == "") && this.value && (this.value.length > 0)) {
                    this.lastEnteredValue = enteredValue
                    let lastValue = this.value[this.value.length - 1]
                    this._deleteValue(lastValue)
                    return
                }
            }

            // ENTER or the SEPARATOR character (comma by default) add the selected value
            if ((event.key == "Enter") || (event.key == this.inputSeparator)) {
                if (this.selectedOption != null) {
                    // An option was selected in the list
                    this._addValueFromOption(this.selectedOption)
                } else {
                    // No options was selected, we use the input field
                    let newValue = (event.key == "Enter") ? enteredValue : enteredValue.slice(0, enteredValue.length - 1)

                    if (newValue != "") {
                        if (!this.allowValuesNotInList) {
                            let checkedValue = this._findValue(newValue)
                            if (!checkedValue) {
                                this._resetInputField()
                                return
                            }
                            this.addValue(checkedValue)
                        } else {
                            this.addValue(newValue)
                        }
                    }
                }
                return
            }

            this._showOptions(enteredValue)
            this.lastEnteredValue = enteredValue
        }

        // Prevent from jumping to the beginning of the input field when hitting "up" key
        /*
        this.field.onkeydown = (event) => {
            if (event.which == 38) {
                event.stop()
                return
            }
        }*/
    }

    /**
     * Checks if a value exists within the options.
     * Search is case insensitive.
     * Returns the found option or null if not found.
     * 
     * @private
     * @ignore
     * @param {string} value - Value to search within the values
     * @returns {boolean}
     */
    _findValue(value) {
        let option = this.options.find(option => option.value.toLowerCase() == value.toLowerCase())
        return (option) ? option.value : null
    }

    /**
     * Create the list of options:
     * - each option generates a div which is inserted into the "optionsWrapper" parent div
     * - the first option is highlighted by default, so that the user can press ENTER to validate it, or navigate within the options
     * 
     * Each option should be composed of:
     * - a value
     * - a label: optional, only when we want to display a different value than the "stored value"
     * - a color: optional, will default to a neutral gray when selected
     * 
     * By default, options are rendered as simple divs, but we can provide any other renderer using the 'optionRenderer' config
     * 
     * @private
     * @ignore
     */
    async _createOptions() {
        for (let index = 0, length = this.options.length; index < length; index++) {
            let option = this.options[index]
            let optionElement = document.createElement("div")
            optionElement.className = "field-option"
            optionElement.setAttribute("value", option.value)
            optionElement.setAttribute("index", index)

            if (option.label) optionElement.setAttribute("label", option.label)
            if (option.color) optionElement.setAttribute("style", "border-color:" + option.color)

            // Hide disabled options
            if (option.disabled == true) optionElement.classList.add("field-option-disabled")

            // Render the option with the default renderer or a custom one
            if (this.optionRenderer) {
                optionElement.innerHTML = this.optionRenderer(option)
            } else {
                optionElement.textContent = option.label || option.value
            }

            this.optionsList.append(optionElement)
        }

        // By default, every options are displayed
        this.displayedOptions = Array.from(this.optionsList.children)
    }

    /**
     * Show the list of options and filter them
     * - the list of options is created the first time this method is called
     * - subsequent calls just change the visibility of the list of options
     * - displaying the list of options also give focus to the input field so the user can start filtering the options (or navigate withing them)
     * - showing the list also trigger a re-filtering according to the last entered value, if any
     * 
     * @private
     * @ignore
     * @param {string} enteredValue 
     */
    _showOptions(enteredValue) {
        // Create the list of options when it's opened for the 1st time
        if (this.optionsList.children.length == 0) this._createOptions()

        // Show the options
        this.optionsWrapper.style.position = "fixed"
        setTimeout(() => {
            this.optionsWrapper.style.display = "block"
            if (this.fieldInput) {
                this.fieldInput.placeholder = ""
                this.fieldInput.focus()
            }
            this._filterOptions(enteredValue || "")
            this._adjustSizeAndPosition()
        }, 100)

        this.optionsList.onmousewheel = (event) => {
            event.preventDefault()
            const direction = event.deltaY < 0 ? -1 : 1;
            this.optionsList.scrollTop += direction * 50;
        }        
    }

    /**
     * Re-compute the size and position of the options wrapper
     * 
     * @private
     * @ignore
     */
    _adjustSizeAndPosition() {
        if (kiss.screen.isMobile) {
            this.optionsWrapper.style.top = "1rem"
            this.optionsWrapper.style.left = "1rem"
            this.optionsWrapper.style.width = "calc(100% - 2rem)"
            this.optionsWrapper.style.height = "calc(100% - 2rem)"
            return
        }

        // Align top to search field if it's visible. Otherwise align to widget
        this.optionsWrapper.style.top = (this.field.getBoundingClientRect().top + this.field.clientHeight) + 4 + "px"
        this.optionsWrapper.style.left = this.field.getBoundingClientRect().left + "px"
        this.optionsWrapper.style.width = this.field.getBoundingClientRect().width + "px"
        
        // Adjust max height
        if (this.config.maxHeight) {
            this.optionsWrapper.style.maxHeight = Math.min(this.config.maxHeight, kiss.screen.current.height - 20) + "px"
            this.optionsList.style.maxHeight = Math.min(this.config.maxHeight - 55, kiss.screen.current.height - 55) + "px"
        }
        else {
            this.optionsWrapper.style.maxHeight = kiss.screen.current.height - 20 + "px"
            this.optionsList.style.maxHeight = kiss.screen.current.height - 55 + "px"
        }

        // Ensure the dropdown is 100% visible inside the viewport
        kiss.tools.moveToViewport(this.optionsWrapper)
    }

    /**
     * Hide the list of options
     * 
     * @private
     * @ignore
     */
    _hideOptions() {
        this.optionsWrapper.style.display = "none"
    }

    /**
     * Reset the input field
     * 
     * @private
     * @ignore
     */
    _resetInputField() {
        this.fieldInput.value = ""
        this.fieldInput.focus()
    }

    /**
     * Filter the list of options according to the value entered in the input field of the widget.
     * Note: if options have labels, we search within the labels, otherwise, we search within the values
     * 
     * @private
     * @ignore
     * @param {string} enteredValue
     */
    _filterOptions(enteredValue) {
        this.displayedOptions = []
        let searchExpression = enteredValue.toLowerCase()

        // Check wether we have to search within the value OR the label
        let propertyToSearch = (this.optionsList.firstChild && this.optionsList.firstChild.getAttribute("label")) ? "label" : "value"

        Array.from(this.optionsList.children).forEach(option => {
            // Remove styling
            option.classList.remove("field-option-selected")
            option.classList.remove("field-option-highlight")

            // Hide options that doesn't match the entered value
            if (!option.getAttribute(propertyToSearch).toLowerCase().includes(searchExpression)) {
                option.classList.add("field-option-hidden")
                return
            }

            // Show other options
            option.classList.remove("field-option-hidden")

            // Show the active values as *selected*
            const optionValue = option.getAttribute("value")
            if (this.value && ((this.multiple && this.value.includes(optionValue)) || (this.value == optionValue))) option.classList.add("field-option-selected")

            // Keep track of all the remaining displayed options
            this.displayedOptions.push(option)
        })

        // Highlight the 1st available option of the new filtered list.
        // This allows to validate this option just by pressing <Enter> key
        this.selectedOption = null

        if (this.displayedOptions.length != 0) {
            this.selectedOption = this.displayedOptions[0]
            this._highlightOption(this.displayedOptions[0], true)
        }
    }

    /**
     * Select the next option (above or below) in the list of options
     * 
     * @private
     * @ignore
     * @param {string} direction - "up" or "down": tells in which direction the user navigated the list
     */
    _navigateOptions(direction) {
        let currentSelectedOption = this.selectedOption
        let index = Array.from(this.displayedOptions).findIndex(node => node == currentSelectedOption)
        let nextIndex = (direction == "down") ? Math.min((index + 1), this.displayedOptions.length) : Math.max((index - 1), 0)
        let newSelectedOption = this.displayedOptions[nextIndex]
        if (newSelectedOption) this._highlightOption(newSelectedOption, true)
    }

    /**
     * Highlight an option in the list of options
     * 
     * @private
     * @ignore
     * @param {HTMLElement} selectedOption - Node representing the selected option
     * @param {boolean} scroll - true to scroll to the option
     */
    _highlightOption(selectedOption, scroll) {
        // Remove styling on previously selected option
        if (this.selectedOption) this.selectedOption.classList.remove("field-option-highlight")

        // Add styling to the newly selected option
        selectedOption.classList.add("field-option-highlight")

        // Store the new selected option and scroll to it
        this.selectedOption = selectedOption

        // TODO: should scroll, but creates strange behavior when encapsulated in iframe: fix that!
        //if (scroll == true) this.selectedOption.scrollIntoView()
    }

    /**
     * Select an option of the list when the user click on it
     * 
     * @private
     * @ignore
     * @param {Event} event - Click event
     * @param {boolean} scroll - true to scroll to the option
     */
    _selectOption(event, scroll) {
        let newSelectedOption = event.target.closest("div")
        //this._highlightOption(newSelectedOption, scroll)
        this.selectedOption = newSelectedOption
        this._addValueFromOption(newSelectedOption)
    }

    /**
     * Add a value to the field when the user clicked an option from the list
     * 
     * @private
     * @ignore
     * @param {HTMLElement} selectedOption - Clicked node
     */
    _addValueFromOption(selectedOption) {
        const optionIndex = selectedOption.getAttribute("index")
        if (!optionIndex) return
        const option = this.options[optionIndex]
        this.addValue(option.value)
    }

    /**
     * Check if a value is a duplicate of an existing value
     * 
     * @private
     * @ignore
     * @param {object} newValue 
     * @returns {boolean}
     */
    _isDuplicate(newValue) {
        return this.value.includes(newValue)
    }

    /**
     * Delete a field value if the user clicked on the "cross" icon.
     * The methods also hides the list of options automatically.
     * 
     * @private
     * @ignore
     * @param {Event} event - The click event that triggered the deletion
     */
    _deleteValueByClick(event) {
        this._hideOptions()

        let fieldValueElement = event.target.closest("div")
        let clickedValue = fieldValueElement.getAttribute("value")
        this._deleteValue(clickedValue)

        event.stop()
    }

    /**
     * Delete value
     * 
     * @private
     * @ignore
     * @param {string} valueToDelete 
     */
    _deleteValue(valueToDelete) {
        let newValue

        if (Array.isArray(this.value)) {
            newValue = this.value.filter(value => value.replace(/\s+/g, ' ') != valueToDelete)
        }
        else newValue = ""

        this.setValue(newValue)
    }

    /**
     * Generate a list of times with daytime colors, for Time fields
     * (ex: blue = afternoon, dark blue = night...)
     * 
     * @private
     * @ignore
     * @param {number} from - Start time, as decimal. 16 means 16:00, 16.5 means 16:30, 16.25 means 16:15, 16.75 means 16:45
     * @param {number} to - End time, as decimal.
     * @param {number} step - Step in minutes (default = 60)
     * @param {boolean} colored 
     * @returns {*} Array of times directly usable as options for a <Select> field
     * 
     * @example
     * this._generateTimes(16, 18, 30) // => ['16:00', '16:30', '17:00', '17:30', '18:00']
     * this_.generateTimes(16.5, 18.5, 30) // => ['16:30', '17:00', '17:30', '18:00', '18:30']
     * this_.generateTimes(16.25, 16.75, 5) // => ['16:15', '16:20', '16:25', '16:30', '16:35', '16:40', '16:45']
     * 
     * // Step is not necessary a multiple of 60:
     * this_.generateTimes(12, 14, 13) // => ['12:00', '12:13', '12:26', '12:39', '12:52', '13:05', '13:18', '13:31', '13:44', '13:57']
     * 
     * // When the colored parameter is true, the time is given with a color to illustrate day light:
     * this_.generateTimes(10, 16, 60, true)
     * 
     * // Returns...
     * [
     *   {
     *       "value": "10:00",
     *       "color": "#0075FF"
     *   },
     *   {
     *       "value": "11:00",
     *       "color": "#0075FF"
     *   },
     *   {
     *       "value": "12:00",
     *       "color": "#FFAA00"
     *   },
     *   {
     *       "value": "13:00",
     *       "color": "#FFAA00"
     *   },
     *   {
     *       "value": "14:00",
     *       "color": "#87BFFF"
     *   },
     *   {
     *       "value": "15:00",
     *       "color": "#87BFFF"
     *   },
     *   {
     *       "value": "16:00",
     *       "color": "#87BFFF"
     *   }
     * ]
     */
    _generateTimes(from = 0, to = 24, step = 60, colored) {

        // Add some basic controls
        from = (from < 0 || from > 23) ? 0 : from
        to = (to <= 0 || to > 24) ? 24 : to
        step = (step <= 0 || step > 60) ? 60 : step
        if (to <= from) {
            from = 0
            to = 24
            step = 60
        }

        const colors = {
            night: "#555555",
            morning: "#0075FF",
            midday: "#FFAA00",
            afternoon: "#87BFFF",
            dawn: "#8833EE"
        }

        const times = []
        for (let h = from * 60; h <= to * 60 && h < 1440; h += step) {
            let value
            const hourValue = Math.floor(h / 60)
            const hour = ("0" + hourValue).slice(-2)
            const minutes = ("0" + Math.round(h % 60)).slice(-2)

            if (colored) {
                let color
                if (hourValue < 5) color = colors.night
                else if (hourValue < 12) color = colors.morning
                else if (hourValue < 14) color = colors.midday
                else if (hourValue < 18) color = colors.afternoon
                else if (hourValue < 20) color = colors.dawn
                else color = colors.night

                value = {
                    value: hour + ":" + minutes,
                    color
                }
            } else {
                value = hour + ":" + minutes
            }

            times.push(value)
        }
        return times
    }    
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-select", kiss.ui.Select)

/**
 * Shorthand to create a new Select field. See [kiss.ui.Select](kiss.ui.Select.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createSelect = (config) => document.createElement("a-select").init(config)

;/**
 * 
 * The Slider derives from [Component](kiss.ui.Component.html).
 * 
 * Provides a progress bar field.
 * 
 * @param {object} config
 * @param {string} config.label
 * @param {number} [config.value] - Default value
 * @param {number} [config.min] - Default 0
 * @param {number} [config.max] - Default 100
 * @param {number} [config.step] - Slider step - Default 5
 * @param {string} [config.labelWidth]
 * @param {string} [config.labelPosition] - left | right | top | bottom
 * @param {string} [config.labelAlign] - left | right
 * @param {string} [config.fontSize]
 * @param {string} [config.formula]
 * @param {string|number} [config.width]
 * @param {string|number} [config.height]
 * @param {string} [config.margin]
 * @param {string} [config.padding]
 * @param {boolean} [config.readOnly]
 * @param {boolean} [config.disabled]
 * @returns this
 * 
 * ## Generated markup
 * ```
 * <a-slider class="a-slider">
 *  <label class="field-label"></label>
 *  <span class="field-slider-container">
 *      <span class="field-slider" type="range">
 *      <span class="field-slider-value">
 *  </span>
 * </a-slider>
 * ```
 */
kiss.ui.Slider = class Slider extends kiss.ui.Component {
    /**
     * Its a Custom Web Component. Do not use the constructor directly with the **new** keyword.
     * Instead, use one of the 3 following methods:
     * 
     * Create the Web Component and call its **init** method:
     * ```
     * const mySlider = document.createElement("a-slider").init(config)
     * ```
     * 
     * Or use the shorthand for it:
     * ```
     * const mySlider = createSlider({
     *  label: "%complete",
     *  min: 0,
     *  max: 200
     * })
     * 
     * mySlider.render()
     * ```
     * 
     * Or directly declare the config inside a container component:
     * ```
     * const myPanel = createPanel({
     *   title: "My panel",
     *   items: [
     *       {
     *           type: "slider",
     *           label: "% complete",
     *           colorOn: "#00aaee",
     *           colorOff: "#dddddd"
     *       }
     *   ]
     * })
     * myPanel.render()
     * ```
     */
    constructor() {
        super()
    }

    /**
     * Generates a Rating field from a JSON config
     * 
     * @ignore
     * @param {object} config - JSON config
     * @returns {HTMLElement}
     */
    init(config) {
        super.init(config)

        const id = this.id
        this.value = Number(config.value) || 0
        this.min = Number(config.min) || 0
        this.max = Number(config.max) || 100
        this.step = Number(config.step) || 5

        // Disable the field if it's readOnly
        this.readOnly = !!config.readOnly || !!config.computed
        if (this.readOnly) {
            this.disabled = true
            config.disabled = true
        }

        // Template
        this.innerHTML = /*html*/
            `${(config.label) ? `<label id="field-label-${id}" for="${id}" class="field-label">
                ${ (this.isLocked()) ? this.locker : "" }
                ${ config.label || ""} ${(config.unit) ? " (" + config.unit + ")" : "" }
                ${ (this.isRequired()) ? this.asterisk : "" }
            </label>` : "" }

            <span class="field-slider-container">
                <input class="field-slider" type="range" value="${this.value}" min="${this.min}" max="${this.max}" step="${this.step}" ${(this.disabled) ? "disabled" : ""}>
                <span class="field-slider-value">${this.value}</span>
            </span>
            `.removeExtraSpaces()

        // Set properties
        this.label = this.querySelector(".field-label")
        this.field = this.querySelector(".field-slider")
        this.sliderValue = this.querySelector(".field-slider-value")

        // Other W3C properties
        this._setProperties(config, [
            [
                ["draggable"],
                [this]
            ],
            [
                ["width", "height", "display", "margin", "padding", "flex"],
                [this.style]
            ],
            [
                ["color", "fontSize", "labelAlign=textAlign", "labelFlex=flex"],
                [this?.label?.style]
            ]
        ])

        // Set the default display mode that will be restored by the show() method
        this.displayMode = "flex"

        // Manage label and field layout according to label position
        this.style.flexFlow = "row"

        // Listen to events if the field is *not* disabled or *readOnly*
        if (config.disabled != true && !this.readOnly) {
            this.field.onchange = (event) => this.setValue(Number(event.target.value))
            this.field.oninput = (event) => this.sliderValue.innerHTML = event.target.value
        }

        // Label setup
        if (config.label) {
            // Label width
            if (config.labelWidth) this.setLabelWidth(config.labelWidth)

            // Label position
            this.config.labelPosition = config.labelPosition || "left"
            this.setLabelPosition(config.labelPosition)

            // Listen to click events if the field is *not* disabled or *readOnly*
            if (config.disabled != true) this.label.onclick = this.field.onclick
        }

        // Bind the field to a record, if any
        if (config.record) this._bindRecord(config.record)
        this._renderValues()

        return this
    }

    /**
     * Get the icon classes for each checkbox shape
     * 
     * @returns {object}
     */
    getIconClasses() {
        return {
            star: "fas fa-star",
            heart: "fas fa-heart",
            thumb: "fas fa-thumbs-up"
        }
    }

    /**
     * Bind the field to a record
     * (this subscribes the field to react to database changes)
     * 
     * @private
     * @ignore
     * @param {object} record
     * @returns this
     */
    _bindRecord(record) {
        this.record = record
        this.modelId = record.model.id
        this.recordId = record.id

        if (record[this.id]) {
            this.value = this.initialValue = record[this.id]
        }

        // React to changes on a single record of the binded model
        this.subscriptions.push(
            subscribe("EVT_DB_UPDATE:" + this.modelId.toUpperCase(), (msgData) => {
                if ((msgData.modelId == this.modelId) && (msgData.id == this.recordId)) {
                    const updates = msgData.data
                    this._updateField(updates)
                }
            })
        )

        // React to changes on multiple records of the binded Model
        this.subscriptions.push(
            subscribe("EVT_DB_UPDATE_BULK", (msgData) => {
                const operations = msgData.data
                operations.forEach(operation => {
                    if ((operation.modelId == this.modelId) && (operation.recordId == this.recordId)) {
                        const updates = operation.updates
                        this._updateField(updates)
                    }
                })
            })
        )

        return this
    }

    /**
     * Updates the field value internally
     * 
     * @private
     * @ignore
     * @param {*} updates 
     */
    _updateField(updates) {
        if (this.id in updates) {
            const newValue = updates[this.id]
            if (newValue || (newValue === false)) {
                this.value = newValue
                this._renderValues()
            }
        }
    }

    /**
     * Render the current value(s) of the widget.
     * 
     * @private
     * @ignore
     */
    _renderValues() {
        this.field.value = this.sliderValue.innerHTML =this.value
        return this
    }

    /**
     * Set the field value
     * 
     * @param {boolean} newValue - The new field value
     * @param {boolean} [rawUpdate] - If true, it doesn't update the associated record and doesn't trigger "change" event 
     * @returns this
     */
    setValue(newValue, rawUpdate) {
        newValue = Number(newValue)

        if (newValue == this.value) return this
        if (rawUpdate) return this._updateValue(newValue, rawUpdate)

        if (this.record) {
            // If the field is connected to a record, we update the database
            this.record.updateFieldDeep(this.id, newValue).then(success => {
                if (success) {
                    this._updateValue(newValue)
                    this.initialValue = newValue
                }
                else {
                    // Rollback the initial value if the update failed (ACL)
                    this._updateValue(this.initialValue)
                }
            })
        } else {
            this._updateValue(newValue)
        }
        
        return this
    }

    /**
     * Clear the field value
     * 
     * @returns this
     */
    clearValue() {
        this.setValue(0)
        return this
    } 

    /**
     * Update the field's value internally
     * 
     * @private
     * @ignore
     * @param {boolean} newValue
     * @param {boolean} [rawUpdate]
     * @returns this
     */
    _updateValue(newValue, rawUpdate) {
        this.value = newValue
        this._renderValues()
        this.setValid()
        if (!rawUpdate) this.dispatchEvent(new Event("change"))
        return this
    }


    /**
     * Get the field value
     * 
     * @returns {number} - The field value
     */
    getValue() {
        return Number(this.value)
    }

    /**
     * Validate the field value against validation rules
     * 
     * @returns {boolean}
     */
    validate() {
        if (this.isHidden()) return true
        
        const isValid = kiss.tools.validateValue(this.type, this.config, this.value)
        if (isValid) {
            this.setValid()
        }
        else {
            this.setInvalid()
        }
        return isValid
    }

    /**
     * Remove the invalid style
     * 
     * @returns this
     */
    setValid() {
        this.isValid = true
        this.field.classList.remove("field-input-invalid")
        return this
    }

    /**
     * Change the style when the field is invalid
     * 
     * @returns this
     */
    setInvalid() {
        log("kiss.ui - field.setInvalid - Invalid value for the field: " + this.config.label, 4)

        this.isValid = false
        this.field.classList.add("field-input-invalid")
        return this
    }

    /**
     * Get the field label
     * 
     * @returns {string}
     */
    getLabel() {
        return this?.label?.innerText || ""
    }

    /**
     * Set the field label
     * 
     * @param {string} newLabel
     * @returns this
     */
    setLabel(newLabel) {
        if (!this.label) return

        this.config.label = newLabel
        this.label.innerText = newLabel
        return this
    }

    /**
     * Set the field width
     * 
     * @param {*} width
     * @returns this
     */
    setWidth(width) {
        this.config.width = width
        this.style.width = this._computeSize("width", width)
        return this
    }

    /**
     * Set the input field width
     * 
     * @param {*} width
     * @returns this
     */
    setFieldWidth(width) {
        this.config.fieldWidth = width
        this.field.style.width = this._computeSize("fieldWidth", width)
        return this
    } 

    /**
     * Set the label width
     * 
     * @param {*} width
     * @returns this
     */
    setLabelWidth(width) {
        this.config.labelWidth = width
        this.label.style.minWidth = this.label.style.maxWidth = this._computeSize("labelWidth")
        return this
    }

    /**
     * Get the label position
     * 
     * @returns {string} "left" | "right" | "top"
     */
    getLabelPosition() {
        return this.config.labelPosition
    }

    /**
     * Set label position
     * 
     * @param {string} position - "left" (default) | "right" | "top" | "bottom"
     * @returns this
     */
    setLabelPosition(position) {
        this.config.labelPosition = position

        switch (position) {
            case "top":
                this.style.flexFlow = "column"
                this.style.alignItems = "unset"
                this.field.style.order = 1
                break
            case "bottom":
                this.style.flexFlow = "column"
                this.style.alignItems = "unset"
                this.field.style.order = -1
                break
            case "right":
                this.style.flexFlow = "row"
                this.style.alignItems = "center"
                this.field.style.order = -1
                break
            default:
                this.style.flexFlow = "row"
                this.style.alignItems = "center"
                this.field.style.order = 1
        }
        return this
    }
}

// Create a Custom Element and add a shortcut to create it
customElements.define("a-slider", kiss.ui.Slider)

/**
 * Shorthand to create a new Progress bar. See [kiss.ui.Slider](kiss.ui.Slider.html)
 * 
 * @param {object} config
 * @returns HTMLElement
 */
const createSlider = (config) => document.createElement("a-slider").init(config)

;/**
 * 
 * Create a form to display a record
 * 
 * @async
 * @param {object} record - record to display in the form
 */
const createForm = function (record) {
    if (!record) return

    const isStandAlone = (kiss.context.ui == "form-view")
    const model = record.model
    const modelId = model.id
    const isMobile = kiss.screen.isMobile
    const isOwner = kiss.session.isOwner
    const isAccountManager = kiss.session.isAccountManager()

    // Update global context
    kiss.context.record = record

    // Can't open the same record twice
    if (record && $(record.id)) {
        return createNotification(txtTitleCase("#record already opened"))
    }

    // Broadcast the event
    // Allow, for example, to close "file preview" window automatically
    kiss.pubsub.publish("EVT_FORM_OPENED")

    // Compute the form position in the page
    function computeFormPosition() {
        if (isMobile) {
            // Mobile is always fullscreen
            return {
                top: 0,
                left: 0,
                width: "100%",
                height: "100%"
            }
        }

        if (model.fullscreen) {
            // Fullscreen
            return {
                top: "1rem",
                left: "1rem",
                width: "calc(100vw - 2rem)",
                height: "calc(100vh - 2rem)"
            }
        }
        else {
            if (model.align == "right") {
                // Right
                return {
                    top: 0,
                    left: () => kiss.screen.current.width - Math.min(kiss.screen.current.width / 3 * 2, 1200),
                    width: () => Math.min(kiss.screen.current.width / 3 * 2, 1200),
                    height: "100%"
                }
            }
            else {
                // Center: the number of records adjust the form panel position / shift
                const numberOfOpenedRecords = Array.from(document.querySelectorAll(".form-record")).length
                return {
                    top: "1rem",
                    left: () => (kiss.screen.current.width - Math.min(kiss.screen.current.width / 3 * 2, 1000)) / 2 + numberOfOpenedRecords * 10,
                    width: () => Math.min(kiss.screen.current.width / 3 * 2, 1200),
                    height: "calc(100vh - 2rem)"
                }
            }
        }
    }
    
    const position = computeFormPosition()

    return createPanel({
        class: "form-record",

        id: record.id,
        title: model.name.toTitleCase(),
        icon: model.icon,
        headerBackgroundColor: model.color,
        layout: "horizontal",
        position: "fixed",
        modal: !isStandAlone,
        closable: true,
        draggable: !isMobile && !model.fullscreen,
        expandable: !isMobile && !model.fullscreen,
        top: position.top,
        left: position.left,
        width: position.width,
        height: position.height,
        padding: 0,
        borderRadius: (isMobile) ? "0px 0px 0px 0px" : "var(--panel-border-radius)",

        items: [
            {
                hidden: true,
                class: "form-side-bar",
                layout: "vertical",
            },
            {
                layout: "vertical",
                flex: 1,
                items: [
                    // Mobile exit button
                    {
                        hidden: true,//!isMobile,
                        id: "mobile-form-exit",
                        type: "button",
                        text: "Back",
                        textAlign: "left",
                        color: "#ffffff",
                        backgroundColor: model.color,
                        icon: "fas fa-chevron-left",
                        iconColor: "#ffffff",
                        height: "5rem",
                        borderRadius: 0,
                        action: () => $(record.id).close()
                    },
                    // Tab bar
                    {
                        class: "form-tabs",
                        display: "inline",
                        defaultConfig: {
                            class: "form-tab",
                        }
                    },
                    // Multiview container for form content + form features
                    {
                        class: "form-panels",
                        multiview: true,
                        layout: "vertical",
                        overflow: "hidden",
                        flex: 1
                    }                    
                ]
            }
        ],

        // Icon to copy record information
        headerIcons: [
            {
                hidden: !kiss.session.isAccountManager(),
                icon: "fas fa-info-circle",
                action: () => {
                    if ($("record-information")) $("record-information").remove()

                    createPanel({
                        id: "record-information",
                        title: "Record information",
                        icon: "fas fa-info-circle",
                        align: "center",
                        verticalAlign: "center",
                        closable: true,
                        draggable: true,
                        modal: true,
                        items: [
                            {
                                layout: "horizontal",
                                alignItems: "center",
                                items: [
                                    {
                                        type: "text",
                                        label: "Model ID",
                                        value: model.id,
                                        disabled: true,
                                        labelWidth: 100,
                                        fieldWidth: 250
                                    },
                                    {
                                        type: "button",
                                        icon: "fas fa-copy",
                                        width: 32,
                                        height: 32,
                                        action: () => {
                                            kiss.tools.copyTextToClipboard(model.id)
                                            createNotification(txtTitleCase("ID copied"))
                                        }
                                    }
                                ]
                            },
                            {
                                layout: "horizontal",
                                alignItems: "center",
                                items: [
                                    {
                                        type: "text",
                                        label: "Record ID",
                                        value: record.id,
                                        disabled: true,
                                        labelWidth: 100,
                                        fieldWidth: 250
                                    },
                                    {
                                        type: "button",
                                        icon: "fas fa-copy",
                                        width: 32,
                                        height: 32,
                                        action: () => {
                                            kiss.tools.copyTextToClipboard(record.id)
                                            createNotification(txtTitleCase("ID copied"))
                                        }
                                    }
                                ]
                            }
                        ]
                    }).render()
                }
            }
        ],

        events: {
            // keydown: function (e) {
            //     if (e.key == "Escape") $(record.id).close()
            // },
            close: function (forceClose) {
                // Closing the form while in stand-alone mode get us back to the home
                if (isStandAlone) {
                    kiss.router.navigateTo({
                        ui: kiss.session.defaultViews.home
                    }, true)
                }

                // Don't try to validate data when we force to close
                if (forceClose) {
                    kiss.pubsub.publish("EVT_FORM_CLOSED")
                    return true
                }

                // Prevent from closing if there are invalid values
                const isValid = $(record.id).validateContent()
                if (!isValid) return false

                kiss.pubsub.publish("EVT_FORM_CLOSED")
                return true
            }
        },

        subscriptions: {
            // Reload the form if its model is updated
            "EVT_DB_UPDATE:MODEL": async function (msgData) {
                if (msgData.id == modelId) await this.load()
            },

            // Update the form's record
            ["EVT_DB_UPDATE:" + model.id.toUpperCase()]: async function (msgData) {
                if (msgData.id == record.id) {
                    Object.assign(this.record, msgData.data)
                    this.applyHideFormulae()
                }
            },

            // Update hide formulae
            EVT_DB_UPDATE_BULK: async function (msgData) {
                const updates = msgData.data
                const update = updates.find(update => update.recordId == record.id)
                if (update) {
                    this.applyHideFormulae()
                }
            }
        },

        methods: {
            /**
             * Load form:
             * - bind the form to the record
             * - insert default form with fields
             * - add form features according to active plugins
             * - add one tab + one panel per feature
             * - add form headers
             * - add form footers
             */
            async load() {
                let formFeatures = []
                let formHeaderFeatures = []
                let formFooterFeatures = []

                // Bind the record to the form
                this.record = record
                this.activeFeatureIndex = -1 // Form

                // Check if the user can update the model
                this.canEditModel = await this.checkIfUserCanEditModel()

                // Insert default form with fields
                let formPanelFeatures = [createFormContent({
                    record: this.record,
                    editMode: !this.record.isLocked // Can edit if the record is locked
                })]

                if (kiss.app.collections.model) {
                    let modelRecord = kiss.app.collections.model.getRecord(modelId)
                    
                    if (modelRecord) {
                        let modelFeatures = modelRecord.features || {}

                        // Add form features according to active plugins
                        this.getActivePlugins(modelFeatures)
                            .forEach(plugin => {

                                // Check if the plugin should be loaded for non-admin users
                                if (plugin.admin == true && !isOwner && !isAccountManager) return

                                // Check if the plugin is disabled
                                if (plugin.disabled == true) return

                                plugin.features
                                    .forEach(feature => {
                                        
                                        // Render the plugin view
                                        let featureId = kiss.tools.shortUid()
                                        let newFeatureView = feature.renderer(this)
                                        newFeatureView.classList.add(featureId)
                                        newFeatureView.setAttribute("featureId", featureId)

                                        // Plugins to load as separate sections / tabs
                                        if (feature.type == "form-section") {
                                            formPanelFeatures = formPanelFeatures.concat(newFeatureView)

                                            formFeatures.push({
                                                id: featureId,
                                                pluginId: plugin.id,
                                                icon: plugin.icon,
                                                name: plugin.name
                                            })
                                        }

                                        // Plugins to load in the form header
                                        if (feature.type == "form-header") {
                                            formHeaderFeatures = formHeaderFeatures.concat(newFeatureView)
                                        }

                                        // Plugins to load in the form footer
                                        if (feature.type == "form-footer") {
                                            formFooterFeatures = formFooterFeatures.concat(newFeatureView)
                                        }
                                    })
                            })

                        // Add one tab per feature
                        let tabs = createFormTabBar(this, formFeatures)
                        let formTabs = this.getFormTabs()
                        formTabs.setItems(tabs)

                        // Adjust the tabs underline effect color
                        const tabElements = formTabs.querySelectorAll(".underline-effect")
                        tabElements.forEach(tab => tab.style.setProperty("--tab-underline-effect", modelRecord.color))

                        // Adjust form panel header
                        this.setTitle(modelRecord.name)
                        this.setIcon(modelRecord.icon)
                        this.setHeaderBackgroundColor(modelRecord.color)
                    }
                }

                // Add one panel per feature
                let formPanels = this.getFormPanels()
                formPanels.setItems(formPanelFeatures)

                // Add form headers
                let formHeader = this.getFormHeader()
                formHeader.setItems(formHeaderFeatures)

                // Add form footers
                let formFooter = this.getFormFooter()
                formFooter.setItems(formFooterFeatures)

                // Build left navigation
                let sideMenus = createFormSideBar(this, formFeatures, formHeaderFeatures, formFooterFeatures)
                let formSideBar = this.getFormSideBar()
                formSideBar.setItems(sideMenus)

                // Apply hide formulae
                this.applyHideFormulae()

                // Restore navigation mode
                this.restoreNavigation()
            },

            /**
             * Switch to fullscreen mode if required
             */
            // _afterRender() {
            //     if (model.fullscreen == true && !isMobile) this.maximize(20)
            // },

            /**
             * Check if the active user can update the Model's fields
             */
            async checkIfUserCanEditModel() {
                if (!kiss.app.collections.model) return false

                const modelRecord = kiss.app.collections.model.records.get(model.id)
                if (!modelRecord) return false

                return await kiss.acl.check({
                    action: "update",
                    record: modelRecord
                })
            },

            /**
             * Get the model's active features
             */
            getActivePlugins(modelFeatures) {
                return kiss.plugins.get()
                    .filter(plugin => {
                        if (!modelFeatures[plugin.id]) return false
                        if (modelFeatures[plugin.id].active == false) return false
                        return true
                    })
            },

            /**
             * Show a feature / displays its panel
             */
            showFeature(featureId) {
                const modelRecord = kiss.app.collections.model.getRecord(modelId)
                const modelFeatures = modelRecord.features || {}
                const activeFeatures = this.getActivePlugins(modelFeatures)
                const featureIndex = activeFeatures.findIndex(feature => feature.id == featureId) + 1

                const animationName = (featureIndex > this.activeFeatureIndex) ? "slideInRight" : "slideInLeft"
                this.activeFeatureIndex = featureIndex

                const animation = {
                    name: animationName,
                    speed: "faster"
                }

                const formFeaturesContainer = this.getFormPanels()
                formFeaturesContainer.showItemByClass(featureId, animation)

                // Adjust the active tab border color
                if (this.getNavigationMode() == "tabs") {
                    const formTabs = $(record.id).querySelector(".form-tabs")
                    const tabs = formTabs.items
    
                    for (let i = 0; i < tabs.length; i++) tabs[i].setBorderColor("var(--button-border)")
                    tabs[featureIndex + 2].setBorderColor(model.color)
                }
            },

            /**
             * Show all sections of the form
             * 
             * @param {string} sectionTitle 
             */
             showAllSections() {
                const content = this.getFormContent()
                const formSections = content.querySelectorAll(".a-panel")
                Array.from(formSections).forEach(panelElement => $(panelElement.id).show())
                this.applyHideFormulae()
            },

            /**
             * Show a single section of the form
             * 
             * @param {string} sectionTitle 
             */
            showSection(sectionTitle) {
                this.showFeature("form-content")

                const content = this.getFormContent()
                const formSections = content.querySelectorAll(".a-panel")
                
                Array.from(formSections).forEach(panelElement => {
                    const panel = $(panelElement.id)
                    if (panel.config.title == sectionTitle) {
                        panel.show()
                        panel.expand()
                    }
                    else panel.hide()
                })
            },

            /**
             * Compute the form position in the page
             */
            computeFormPosition() {
                return computeFormPosition()
            },

            /**
             * Helpers to access form parts
             */
            getFormContent() {
                return this.querySelector(".form-content")
            },

            getFormSections() {
                let sections = []
                const formContent = this.querySelector(".form-fields")
                const formItems = Array.from(formContent.children)
                formItems.forEach(item => {
                    if (item.items) sections.push(item)
                })
                return sections
            },

            getFormTabs() {
                return this.querySelector(".form-tabs")
            },

            getFormSideBar() {
                return this.querySelector(".form-side-bar")
            },

            getFormHeader() {
                return this.querySelector(".form-header")
            },

            getFormFooter() {
                return this.querySelector(".form-footer")
            },

            getFormPanels() {
                return this.querySelector(".form-panels")
            },

            getFormFields() {
                return this.querySelector(".form-fields")
            },

            getNavigationMode() {
                return localStorage.getItem("config-formNavigationMode-" + model.id)
            },

            /**
             * Show / hide tab bar and side bar
             */
            showTabBar() {
                const tabs = this.getFormTabs()
                tabs.setAnimation({
                    name: "slideInLeft",
                    speed: "faster"
                }).show()
            },

            hideTabBar() {
                const tabs = this.getFormTabs()
                tabs.hide()
            },

            showSideBar() {
                const sideBar = this.getFormSideBar()
                sideBar.show()
            },

            hideSideBar() {
                const sideBar = this.getFormSideBar()
                sideBar.hide()
            },            

            switchNavigation(mode) {
                localStorage.setItem("config-formNavigationMode-" + model.id, mode)
                if (mode == "left") {
                    this.hideTabBar()
                    this.showSideBar()
                }
                else {
                    this.hideSideBar()
                    this.showTabBar()
                    this.showAllSections()
                }
            },

            hideNavigation() {
                this.hideTabBar()
                this.hideSideBar()
            },

            restoreNavigation() {
                const navigationMode = localStorage.getItem("config-formNavigationMode-" + model.id)
                if (navigationMode == "left") {
                    this.hideTabBar()
                    this.showSideBar()
                }
                else {
                    this.hideSideBar()
                    this.showTabBar()
                }
            },

            /**
             * Validate the form content
             */            
            validateContent() {
                const formContent = this.getFormContent()
                const isValid = formContent.validate()
                if (!isValid) return false
                return true
            },

            /**
             * Apply hide formulae to form sections and items
             */
            applyHideFormulae() {
                const isDesigner = (kiss.router.getRoute().ui == "form-designer")
                if (isDesigner) return

                this.applyHideFormulaeToSections()
                this.applyHideFormulaeToItems()
            },

            /**
             * Apply hide formulae to form sections
             */            
            applyHideFormulaeToSections() {
                const sections = this.getFormSections()
                sections.forEach(section => {
                    const sectionElement = this.querySelector("#" + section.id.replaceAll(":", "\\:"))
                    if (!sectionElement) return

                    const hideWhen = sectionElement.config.hideWhen
                    if (!hideWhen) return

                    const hideFormula = section.config.hideFormula
                    if (!hideFormula) return

                    try {
                        // kiss.context.record = record
                        const result = kiss.formula.execute(hideFormula, record, model.getActiveFields())

                        const navSectionElement = this.querySelector(("#nav-" + record.id + ":" + section.config.originalId).replaceAll(":", "\\:"))
                        if (result === true) {
                            sectionElement.hide()
                            navSectionElement.hide()
                        }
                        else {
                            sectionElement.show()
                            navSectionElement.show()
                        }
                    }
                    catch(err) {
                        log("kiss.ui - Warning: could not hide the section " + section)
                    }                    
                })
            },

            /**
             * Apply hide formulae to form items
             */
            applyHideFormulaeToItems() {
                const formContent = this.getFormContent()
                const fields = formContent.getFields()
                const elements = formContent.getElements()
                const items = fields.concat(elements)

                items.forEach(item => {
                    const itemElement = this.querySelector("#" + item.id.replaceAll(":", "\\:"))
                    if (!itemElement) return

                    const hideWhen = itemElement.config.hideWhen
                    if (!hideWhen) return

                    const hideFormula = itemElement.config.hideFormula
                    if (!hideFormula) return

                    try {
                        kiss.context.record = record
                        const result = kiss.formula.execute(hideFormula, record, model.getActiveFields())
                        if (result === true) itemElement.hide()
                        else itemElement.show()
                    }
                    catch(err) {
                        log("kiss.ui - Warning: could not hide the item " + item)
                    }
                })
            }           
        }
    }).render()
}

;/**
 * 
 * Form actions
 * 
 * @ignore
 */
const createFormActions = function (form, activeFeatures) {
    const record = form.record
    const isMobile = kiss.screen.isMobile
    const hasFeatures = (activeFeatures.length > 0)
    let featureButtons = []

    // Inject feature shortcuts in the menu for mobile devices
    if (kiss.screen.isMobile && hasFeatures) {
        featureButtons.push({
            id: "button-form-" + record.id,
            text: txtTitleCase("form"),
            icon: "far fa-window-restore",
            action: () => form.showFeature("form-content")
        })

        activeFeatures.forEach(feature => {
            featureButtons.push({
                id: "button-" + feature.id + "-" + record.id,
                text: feature.name,
                icon: feature.icon,
                action: () => form.showFeature(feature.pluginId)
            })
        })
    }

    // Inject custom actions in the menu, if any
    let actions = []
    if (kiss.app.customActions && kiss.app.customActions.length > 0) {
        const userACL = kiss.session.getACL()

        let customActions = kiss.app.customActions.filter(action => {
            const isTargetForm = action.type && action.type.includes("form") && action.formIds && (action.formIds.includes(record.model.id) || action.formIds.includes("*"))
            const isTargetUser = kiss.tools.intersects(userACL, action.accessRead)
            return isTargetForm && isTargetUser
        })

        customActions.forEach(action => {
            const menuAction = {
                id: action.id,
                text: action.name,
                icon: action.icon,
                iconColor: action.color,
                action: () => {
                    // Inject the record in the context so that custom actions can use it
                    // kiss.context.record = record
                    eval(action.code)
                }
            }
            actions.push(menuAction)
        })
    }

    return [
        ...featureButtons,

        (kiss.screen.isMobile && hasFeatures) ? "-" : "",

        // Action to edit form properties
        {
            hidden: !form.canEditModel || isMobile,
            icon: "fas fa-cog",
            text: txtTitleCase("form properties"),
            action: () => {
                kiss.context.modelId = record.model.id
                kiss.views.show("model-properties")
            }
        },

        // Action to edit the form (=> go to form designer)
        {
            hidden: !form.canEditModel || isMobile,
            icon: "fas fa-wrench",
            text: txtTitleCase("edit form"),
            action: () => {
                // Close the active form without saving
                const form = $(record.id)
                form.close("remove", true)

                // Try to close all other forms that are stacked
                let areFormsClosed = true
                const openedForms = document.querySelectorAll(".form-record")
                openedForms.forEach(openedForm => {
                    areFormsClosed = areFormsClosed && openedForm.close()
                })
                if (!areFormsClosed) return

                // Open the form designer
                app.api.openFormDesigner(record.model.id)
            }
        },

        // Action to edit form features
        {
            hidden: !form.canEditModel || isMobile,
            icon: "fas fa-puzzle-piece",
            text: txtTitleCase("#edit features") + " <b></b>",
            action: () => {
                kiss.context.modelId = record.model.id
                kiss.views.show("model-features")
            }
        },

        // Action to edit form access
        {
            hidden: !form.canEditModel || isMobile,
            icon: "fas fa-key",
            text: txtTitleCase("#secure table"),
            action: () => {
                kiss.context.modelId = record.model.id
                kiss.views.show("model-access")
            }
        },

        // Action to manage advanced actions
        {
            hidden: !kiss.session.isAccountManager(),
            text: txtTitleCase("manage advanced actions"),
            icon: kiss.app.models.action.icon,
            action: () => {
                const setup = kiss.views.show("setup-home")
                const sections = setup.sections
                const actionSection = sections.find(section => section.id == "advancedActions")
                setup.selectModel(actionSection)
                setup.close()
            }
        },

        // Menu separator
        (form.canEditModel && !isMobile) ? "-" : "",
        (isMobile) ? "-" : "",

        // Action to expand all sections
        {
            icon: "fas fa-plus-circle",
            text: txtTitleCase("expand all sections"),
            action: () => form.expandAll()
        },

        // Action to collapse all sections
        {
            icon: "fas fa-minus-circle",
            text: txtTitleCase("collapse all sections"),
            action: () => form.collapseAll()
        },

        "-",

        // Action to delete a record
        {
            icon: "fas fa-trash",
            iconColor: "var(--red)",
            text: txtTitleCase("delete this record"),
            action: () => {
                createDialog({
                    type: "danger",
                    title: txtTitleCase("delete this record"),
                    message: txtTitleCase("#delete record warning"),
                    buttonOKPosition: "left",
                    action: async () => {
                        const form = $(record.id)
                        const success = await record.delete(true)
                        if (success) {
                            form.close("remove", true)
                        }
                        else {
                            createNotification(txtTitleCase("#error general"))
                        }
                    }
                })
            }
        },

        // Action to get a link to the document
        {
            hidden: true, // Not used yet
            icon: "fas fa-link",
            text: txtTitleCase("get a link to this document"),
            action: () => {
                kiss.router.updateUrlHash({
                    recordId: record.id
                })

                kiss.tools.copyTextToClipboard(window.location.href)
                createNotification(txtTitleCase("#link copied"))
            }
        },

        // Custom actions
        (actions.length > 0) ? "-" : "",
        ...actions
    ]
}

;/**
 * 
 * Main form content
 * 
 * The form items are given either:
 * - indirectly through the record (config.record.model.items)
 * - directly through the model
 * 
 * @ignore
 * @param {object} config
 * @param {object} [config.record]
 * @param {object} [config.model]
 * @param {boolean} [config.editMode] - If false, the form is in read only mode
 * 
 */
const createFormContent = function (config) {
    let model, modelItems, record

    if (config.record) {
        record = config.record
        model = record.model
        modelItems = JSON.parse(JSON.stringify(model.items)) // Shadow copy
        
    } else if (config.model) {
        model = config.model
        modelItems = config.model.items
    }

    // Cache user ACL
    const userACL = kiss.session.getACL()

    // Screen orientation
    const orientation = kiss.screen.getOrientation()

    // Format model's items in a usable format for a form UI:
    // - filters out deleted fields
    // - regen section ids to be able to open multiple forms of the same type
    // - show a star for required fields
    // - show a locker for readOnly fields
    // - assign model's color to sections
    // - show/hide sections and items according to ACL fields
    function getFormItems(items, editMode) {
        items = items.filter(item => item != null && item.deleted != true)
        items.forEach(item => {
            if (item.items) {
                //
                // Section
                // 
                if (config.record && item.accessRead) item.accessRead = item.accessRead.map(entry => (entry != "$creator") ? entry : config.record.createdBy)
                const canRead = kiss.tools.intersects(item.accessRead, userACL) || !item.accessRead

                if (!canRead) {
                    item.hidden = true
                }
                else {
                    if (config.record && item.accessUpdate) item.accessUpdate = item.accessUpdate.map(entry => (entry != "$creator") ? entry : config.record.createdBy)
                    const canUpdate = (editMode === false) ? false : kiss.tools.intersects(item.accessUpdate, userACL) || !item.accessUpdate

                    item.originalId = item.id
                    item.id = kiss.tools.shortUid()
                    item.headerBackgroundColor = model.color
                    item.items = getFormItems(item.items, canUpdate)
                }

                // Force clean case
                item.title = (item.hasOwnProperty("title")) ? item.title.toTitleCase() : ""

                // Set section "light" style
                if (item.colored === false) {
                    item.headerColor = model.color
                    item.headerBorderColor = model.color
                    item.headerBackgroundColor = "transparent"
                    item.iconColor = model.color
                }
            } else {
                // 
                // Field or Widget
                //

                // Display a lock symbol on read only fields
                if (editMode === false) {
                    item.readOnly = true
                    item.locked = true
                    // item.label = `<span class="field-label-read-only fas fa-lock"></span> ` + item.label
                    item.required = false // Can't be both readOnly and required!
                }
                else if (item.required) {
                    // item.label = item.label + ` <span class="field-label-required"><sup>*</sup></span>`
                }

                // Convert summary & lookup fields to mimic the type of their source field
                if (item.type == "summary") {
                    if (item.summary.type == "directory" && item.summary.operation == "LIST_NAMES") item.type = "directory"
                }
                else if (item.type == "lookup") {
                    item.type = item.lookup.type || "text"
                    if (item.type == "selectViewColumns") item.type = "text"
                }

                // Set layout according to orientation
                if (orientation == "vertical") {
                    item.labelPosition = "top"
                    item.width = "100.00%"
                    item.fieldWidth = "100.00%"
                    item.labelWidth = "100.00%"
                }
            }
        })
        return items
    }

    modelItems = getFormItems(modelItems, config.editMode)

    // Build form content block
    return createBlock({
        class: "form-content",
        layout: "vertical",
        overflowY: "auto",
        flex: 1,
        padding: (orientation == "vertical") ? "0" : "var(--panel-padding)",

        defaultConfig: {
            overflow: "unset"
        },

        items: [
            // Form header
            {
                class: "form-header"
            },

            // Form
            {
                class: "form-fields",

                defaultConfig: {
                    width: "100%",
                    labelWidth: "100%",
                    labelPosition: "top"
                },

                record: record,
                items: modelItems
            },

            // Form footer
            {
                class: "form-footer"
            }
        ],

        methods: {
            async load() {
                // Enable ability to edit fields setup for non mobile UI
                if (kiss.screen.isMobile) return
                const form = this.closest(".form-record")
                if (form.canEditModel) this.enableFieldDesign()
            },

            /**
             * Enable the ability to edit the fields directly inside the form
             */
            enableFieldDesign() {
                const fieldLabels = this.querySelectorAll(".field-label")

                fieldLabels.forEach(labelElement => {
                    labelElement.classList.add("field-label-setup")
                    const fieldId = labelElement.parentNode.id
                    const field = model.getField(fieldId)
                    const isPrimary = field.primary

                    labelElement.onclick = function (event) {

                        createMenu({
                            items: [
                                // EDIT FIELD
                                {
                                    text: txtTitleCase("edit field") + " <b>" + field.label + "</b>",
                                    icon: "fas fa-edit",
                                    action: () => {
                                        kiss.context.dockFieldProperties = false

                                        kiss.router.updateUrlHash({
                                            modelId: model.id,
                                            fieldId
                                        })
                                        kiss.views.show("model-field")
                                    }
                                },
                                
                                // COPY FIELD ID
                                {
                                    hidden: !kiss.session.isAccountManager(),
                                    text: txtTitleCase("copy field ID") + ` (${fieldId})`,
                                    icon: "fas fa-copy",
                                    action: () => {
                                        kiss.tools.copyTextToClipboard(fieldId)
                                        createNotification(txtTitleCase("ID copied"))
                                    }
                                },                                
                                
                                // Menu separator
                                (!isPrimary) ? "-" : "",

                                // DELETE FIELD
                                (!isPrimary) ? {
                                    text: txtTitleCase("delete field"),
                                    icon: "fas fa-trash",
                                    iconColor: "var(--red)",
                                    action: () => {
                                        createDialog({
                                            type: "danger",
                                            title: txtTitleCase("delete a field"),
                                            message: txtTitleCase("#delete field warning"),
                                            action: async () => {
                                                await model.deleteField(fieldId)
                                            }
                                        })
                                    }
                                } : ""
                            ]
                        }).render().showAt(event.clientX - 10, event.clientY - 10)
                    }
                })
            }
        }
    })
}

;/**
 * 
 * Generate the welcome / help message for a form feature
 * 
 * @ignore
 */
const createFormFeatureDescription = function (name, icon, color, description, instructions, showArrow = true) {
    let html = /*html*/ `
        ${(showArrow === false) ? "" :
        `<div style="display: flex; flex-flow: row">
            <div style="flex:1"></div>
            <div class="form-feature-arrow"><span class="fas fa-arrow-up"></span></div>
        </div>`}

        <div class="form-feature-description" style="display: flex; flex-flow: row; background-color: ${color}">
            <div class="form-feature-description-icon" style="flex:1; background-color: ${kiss.tools.adjustColor(color, -0.1)}">
                <span class="${icon}"></span>
            </div>
            <div style="flex: 2">
                <div class="form-feature-description-title">${name}</div>
                <div class="form-feature-description-text">${description}</div>
                <div class="form-feature-description-text">${instructions}</div>
            </div>
        </div>`
    return createHtml({html})
}

;/**
 * 
 * Form side bar
 * 
 * @ignore
 */
const createFormSideBar = function (form, activeFeatures, formHeaderFeatures, formFooterFeatures) {
    const record = form.record
    const model = record.model

    // Creates a navigation entry per section
    const headerSections = Array.from(formHeaderFeatures).map(section => {
        return {
            type: "button",
            text: section.config.title,
            textAlign: "left",
            icon: section.config.icon,
            margin: "0 0.5rem 1rem 5rem",
            classes: {
                "this": "form-side-bar-button"
            },
            action: () => form.showSection(section.config.title)
        }        
    })

    const sections = model.items.map(section => {
        if (section.type != "panel") return ""
        return {
            id: "nav-" + record.id + ":" + section.id,
            type: "button",
            text: section.title,
            textAlign: "left",
            icon: section.icon,
            margin: "0 0.5rem 1rem 5rem",
            classes: {
                "this": "form-side-bar-button"
            },
            action: () => form.showSection(section.title)
        }
    })

    const footerSections = Array.from(formFooterFeatures).map(section => {
        return {
            type: "button",
            text: section.config.title,
            textAlign: "left",
            icon: section.config.icon,
            margin: "0 0.5rem 1rem 5rem",
            classes: {
                "this": "form-side-bar-button"
            },
            action: () => form.showSection(section.config.title)
        }        
    })

    // Creates a navigation entry per feature
    let formFeatures = [
        {
            layout: "horizontal",
            margin: "0 0 2rem 0",
            flexShrink: 0,
            items: [
                // Switch between tab bar and side navigation
                {
                    type: "button",
                    tip: txtTitleCase("#tabs navigation"),
                    icon: "fas fa-columns",
                    classes: {
                        "this": "form-side-bar-menu"
                    },
                    action: () => form.switchNavigation("tabs")
                },

                // Action menu
                {
                    type: "button",
                    text: txtTitleCase("#action menu"),
                    textAlign: "left",
                    icon: "fas fa-bars",
                    classes: {
                        "this": "form-side-bar-menu"
                    },
                    action: function () {
                        createMenu({
                            left: this.getBoundingClientRect().x,
                            top: this.getBoundingClientRect().y,
                            items: createFormActions(form, activeFeatures)
                        }).render()
                    }
                }
            ]
        },

        // Main form
        {
            id: "button-form-" + record.id,
            type: "button",
            text: txtTitleCase("form"),
            textAlign: "left",
            icon: "far fa-window-restore",
            iconColor: model.color,
            classes: {
                "this": "form-side-bar-button"
            },
            action: function () {
                form.showFeature("form-content")
                form.showAllSections()
            }
        },

        // Form sections
        ...headerSections,
        ...sections,
        ...footerSections
    ]

    // Insert one tab per active form feature
    activeFeatures.forEach(feature => {
        let newFeature = {
            id: "button-" + feature.id + "-" + record.id,
            type: "button",
            text: feature.name,
            textAlign: "left",
            icon: feature.icon,
            iconColor: model.color,
            classes: {
                "this": "form-side-bar-button"
            },
            action: () => form.showFeature(feature.pluginId)
        }

        formFeatures = formFeatures.concat(newFeature)
    })

    return formFeatures
}

;/**
 * 
 * Form tab bar
 * 
 * @ignore
 */
const createFormTabBar = function (form, activeFeatures) {
    const record = form.record
    const formTabHeight = "var(--form-tab-height)"
    const formTabFontSize = "var(--form-tab-font-size)"
    const formTabBorderRadius = "var(--form-tab-border-radius)"
    const hasFeatures = (activeFeatures.length > 0)
    const isMobile = kiss.screen.isMobile

    let formFeatures = [
        // Switch between tab bar and side navigation
        {
            hidden: isMobile,
            type: "button",
            tip: txtTitleCase("#side navigation"),
            icon: "fas fa-columns",
            borderWidth: 0,
            borderRadius: "3.2rem",
            fontSize: formTabFontSize,
            height: formTabHeight,
            borderRadius: formTabBorderRadius,
            backgroundColorHover: "transparent",
            action: () => form.switchNavigation("left")
        },

        // Action menu
        {
            type: "button",
            text: (isMobile) ? "" : txtTitleCase("#action menu"),
            icon: "fas fa-bars",
            borderWidth: 0,
            borderRadius: "3.2rem",
            fontSize: formTabFontSize,
            height: formTabHeight,
            borderRadius: formTabBorderRadius,
            backgroundColorHover: "transparent",
            action: function () {
                createMenu({
                    left: this.getBoundingClientRect().x,
                    top: this.getBoundingClientRect().y,
                    items: createFormActions(form, activeFeatures)
                }).render()
            }
        }
    ]

    // Add main form tab if there are some features enabled
    if (hasFeatures) {
        formFeatures.push({
            id: "button-form-" + record.id,
            type: "button",
            text: (isMobile) ? "" : txtTitleCase("form"),
            icon: "far fa-window-restore",
            fontSize: formTabFontSize,
            height: formTabHeight,
            borderRadius: formTabBorderRadius,
            backgroundColorHover: "transparent",
            classes: {
                "this": "underline-effect"
            },
            action: () => form.showFeature("form-content")
        })
    }

    // Insert one tab per active form feature
    activeFeatures.forEach(feature => {
        let newFeature = {
            id: "button-" + feature.id + "-" + record.id,
            type: "button",
            text: (isMobile) ? "" : feature.name,
            icon: feature.icon,
            fontSize: formTabFontSize,
            height: formTabHeight,
            borderRadius: formTabBorderRadius,
            backgroundColorHover: "transparent",
            classes: {
                "this": "underline-effect"
            },
            action: () => form.showFeature(feature.pluginId)
        }
        
        formFeatures = formFeatures.concat(newFeature)
    })

    return formFeatures
}

;/**
 * 
 * Main interface to SHOW or HIDE the FIELDS of a Data Component
 * 
 * @ignore
 */
const createDataFieldsWindow = function (viewId, color = "#00aaee") {
    const selectWindowId = "field-selection-for-" + viewId

    return createPanel({
        id: selectWindowId,
        title: txtTitleCase("select your fields"),
        icon: "fas fa-bars fa-rotate-90",
        headerBackgroundColor: color,
        maxHeight: () => kiss.screen.current.height - 150,
        
        modal: true,
        closable: true,
        draggable: true,
        layout: "vertical",

        items: [
            // Block that contains the list of checkboxes to show/hide fields
            {
                id: "field-selection-for-datable:" + viewId,
                layout: "vertical",
                overflowY: "auto"
            },
            // Buttons
            {
                layout: "horizontal",
                margin: "10px 0px 0px 0px",
                overflow: "unset",

                items: [
                    // Button to hide all fields
                    {
                        type: "button",
                        text: txtTitleCase("hide all"),
                        icon: "fas fa-eye-slash",
                        flex: 1,
                        events: {
                            click: function () {
                                let selectionWindow = $(selectWindowId)
                                selectionWindow.toggleAll("hide")
                            }
                        }
                    },
                    {
                        type: "spacer",
                        width: "10px"
                    },
                    // Button to show all fields
                    {
                        type: "button",
                        text: txtTitleCase("show all"),
                        icon: "fas fa-eye",
                        flex: 1,
                        events: {
                            click: function () {
                                let selectionWindow = $(selectWindowId)
                                selectionWindow.toggleAll("show")
                            }
                        }
                    }
                ]
            }
        ],

        subscriptions: {
            "EVT_DB_UPDATE:VIEW": (msgData) => {
                if ($(selectWindowId) && (msgData.id == viewId) && (msgData.userId != kiss.session.getUserId())) $(selectWindowId).load()
            },
            ["EVT_VIEW_FIELD_MOVED:" + viewId]: () => $(selectWindowId).load()
        },        

        methods: {
            load: () => {
                // Build all the checkboxes to toggle the fields on/off
                let checkboxFields = []

                $(viewId).getFields().forEach(field => {
                    if (field.deleted) return
                    
                    checkboxFields.push({
                        id: "checkbox-" + field.id,
                        type: "checkbox",
                        label: field.title.toTitleCase(),
                        labelWidth: "100%",
                        labelPosition: "right",
                        
                        checked: !field.hidden,

                        shape: "switch",
                        iconSize: "16px",
                        iconColorOn: color,
                        class: "switch-field",
                        draggable: true,

                        events: {
                            /**
                             * Show / hide a single field when clicking on the checkbox
                             */
                            click: function () {
                                let fieldId = this.id.split("checkbox-")[1]
                                kiss.pubsub.publish("EVT_VIEW_FIELD_TOGGLED_ONE:" + viewId, fieldId)
                            },

                            /**
                             * Handle drag&drop
                             */
                            ondragstart: function(event) {
                                event.stopPropagation()
                                kiss.context.draggedElement = event.target.closest("a-checkbox")
                                kiss.context.dragStartY = event.clientY
                            },

                            ondragover: function(event) {
                                event.stop()

                                const dropTarget = event.target.closest("a-checkbox")
                                if (dropTarget.id == kiss.context.draggedElement.id) return
                                dropTarget.style.minHeight = "60px"
                                dropTarget.style.alignItems = "unset"
                                dropTarget.style.transition = "all 0.1s"
                            },

                            ondragleave: function(event) {
                                const dropTarget = event.target.closest("a-checkbox")
                                dropTarget.style.minHeight = "26px"
                                dropTarget.style.alignItems = "center"
                            },

                            ondrop: function(event) {
                                const dropTarget = event.target.closest("a-checkbox")
                                dropTarget.style.minHeight = "26px"
                                dropTarget.style.alignItems = "center"
                                
                                const sourceFieldId = kiss.context.draggedElement.id.split("checkbox-")[1]
                                const targetFieldId = dropTarget.id.split("checkbox-")[1]

                                publish("EVT_VIEW_FIELD_MOVING:" + viewId, {
                                    sourceFieldId,
                                    targetFieldId,
                                    position: "after"
                                })
                            }
                        }
                    })
                })

                $("field-selection-for-datable:" + viewId).setItems(checkboxFields)
            },

            /**
             * Show / hide all fields
             * 
             * @param {string} newState - "show" or "hide"
             */
            toggleAll: (newState) => {
                let isChecked = (newState == "show")

                $(viewId).getFields().forEach(field => {
                    if (field.deleted) return
                    let checkboxId = "checkbox-" + field.id
                    let checkbox = $(checkboxId)
                    checkbox.setValue(isChecked)
                })

                publish("EVT_VIEW_FIELD_TOGGLED_ALL:" + viewId, newState)
            }
        }
    })
}

;/**
 * 
 * ## Create a filter for a view
 * 
 * A filter is a compound object containing:
 * - a delete button, to remove the filter
 * - a dropdown list to select the field to filter
 * - a dropdown list to select the comparison operator (=, >, contains, is empty, is not empty...)
 * - a value to be compared to. The input depends on the field type (for example: a calendar widget for a date field)
 * 
 * @ignore
 * @param {string} viewId - Target view to apply data filtering
 * @param {string} color - window color theme
 * @param {object} config
 * @param {string} [config.target] - Node id where the filter should be inserted
 * @param {string} config.fieldId - The default field id
 * @param {string} config.operator - The default operator
 * @param {string} config.value - The default field value
 * 
 */
const createDataFilter = function (viewId, color, config) {
    // Get initial values
    let id = kiss.tools.shortUid()
    let fieldId = config.fieldId || ""
    let filterOperator = config.operator || "="
    let filterDateOperator = config.dateOperator || "exact date"
    let fieldValue = (kiss.tools.isNumber(config.value)) ? config.value || 0 : config.value || ""

    // Get the possible list of fields to filter
    const model = $(viewId).collection.model
    const isDynamicModel = kiss.tools.isUid(model.id)
    let selectFields = model
        .getFilterableFields()
        .map(field => {
            const needsTranslation = (field.isSystem || field.isFromPlugin || field.label.startsWith("#")) ? true : false
            return {
                type: field.type,
                label: (isDynamicModel && !needsTranslation) ? field.label.toTitleCase() : txtTitleCase(field.label),
                value: field.id
            }
        })

    //
    // Some helpers to get / show / hide filter parameters
    //
    function getFieldId() {
        const filterField = $("filter-field:" + id)
        if (filterField) return filterField.getValue()
    }

    function getFieldType(fieldId) {
        let fieldConfig = $(viewId).collection.model.getField(fieldId)
        let type = (fieldConfig) ? fieldConfig.type : "text"
        if (type == "lookup") type = fieldConfig.lookup.type
        if (type == "summary") type = fieldConfig.summary.type
        if (type == "lookup") type = "text"
        return type || "text"
    }

    function getFilterOperator() {
        const filterOperator = $("filter-operator:" + id)
        if (filterOperator) return filterOperator.getValue()
        return config.operator
    }

    function getFilterDateOperator() {
        const filterDateOperator = $("filter-date-operator:" + id)
        if (filterDateOperator) return filterDateOperator.getValue()
        return config.dateOperator
    }

    function showFilterDateOperator() {
        const filterDateOperator = $("filter-date-operator:" + id)
        if (filterDateOperator) filterDateOperator.show()
    }

    function hideFilterDateOperator() {
        const filterDateOperator = $("filter-date-operator:" + id)
        if (filterDateOperator) filterDateOperator.hide()
    }

    function shouldHideFilterDateOperator() {
        if (getFieldType(fieldId) != "date") return true
        if (getFilterOperator().includes("empty")) return true
        return false
    }    

    function getFilterValue() {
        const filterValue = $("filter-value:" + id)
        return filterValue.getValue()
    }

    function setFilterValue(value) {
        const filterValue = $("filter-value:" + id)
        if (filterValue) filterValue.setValue(value)
    }

    function showFilterInput() {
        const filterValue = $("filter-value:" + id)
        if (filterValue) filterValue.show()
    }

    function hideFilterInput() {
        const filterValue = $("filter-value:" + id)
        if (filterValue) filterValue.hide()
    }
    
    function updateFilterOperator(fieldId) {
        // Reset the operator if its value is not part of the new possible operators
        const filterOperator = $("filter-operator:" + id)
        const newFilterOperators = generateFilterOperators(fieldId)
        filterOperator.updateOptions(newFilterOperators)
        
        const currentOperator = filterOperator.getValue()
        const hasOperator = newFilterOperators.findIndex(operator => operator.value == currentOperator)
        if (hasOperator == -1) filterOperator.setValue("")
    }

    function updateFilterDateOperator(fieldId) {
        const fieldType = getFieldType(fieldId)
        const filterOperator = getFilterOperator()

        if (fieldType == "date" && !filterOperator.includes("empty")) {
            showFilterDateOperator()
        } else {
            hideFilterDateOperator()
        }
    }

    function updateFilterInput(fieldId) {
        // Delete the previous input field
        let field = $("filter-value:" + id)
        let target = field.target
        field.deepDelete()

        // Rebuild a new field at the same position
        let fieldConfig = buildFilterInput(fieldId)
        fieldConfig.target = target
        let input = fieldConfig.renderer(fieldConfig)
        input.render()

        // Show/hide the input
        const fieldType = getFieldType(fieldId)
        const operatorValue = getFilterOperator()
        const dateOperatorValue = getFilterDateOperator()

        if (operatorValue.includes("empty") || (fieldType == "date" && dateOperatorValue.includes("today"))) {
            setFilterValue("")
            hideFilterInput()
        }
        else {
            showFilterInput()
        }
    }    

    /**
     * Define all the possible operators according to the field type.
     * The operator type tells weither it's suitable for text expressions, scalar expressions (numbers & dates), or both (*)
     * 
     * @param {string} fieldId 
     */
    const generateFilterOperators = function (fieldId) {
        const fieldType = getFieldType(fieldId)

        const possibleOperators = {
            text: ["=", "<>", "contains", "does not contain", "is empty", "is not empty"],
            password: ["is empty", "is not empty"],
            textarea: ["=", "<>", "contains", "does not contain", "is empty", "is not empty"],
            aiTextarea: ["=", "<>", "contains", "does not contain", "is empty", "is not empty"],
            number: ["=", "<>", "<", ">", "<=", ">=", "is empty", "is not empty"],
            rating: ["=", "<>", "<", ">", "<=", ">=", "is empty", "is not empty"],
            slider: ["=", "<>", "<", ">", "<=", ">=", "is empty", "is not empty"],
            date: ["=", "<>", "<", ">", "<=", ">=", "is empty", "is not empty"],
            checkbox: ["=", "<>", "is empty", "is not empty"],
            select: ["=", "<>", "contains", "does not contain", "is empty", "is not empty"],
            selectViewColumn: ["=", "<>", "contains", "does not contain", "is empty", "is not empty"],
            selectViewColumns: ["=", "<>", "contains", "does not contain", "is empty", "is not empty"],
            directory: ["contains", "does not contain", "is empty", "is not empty"],
            summary: ["=", "<>", "<", ">", "<=", ">=", "is empty", "is not empty"],
            attachment: ["is empty", "is not empty"],
            color: ["=", "<>", "is empty", "is not empty"],
            icon: ["=", "<>", "is empty", "is not empty"]
        } [fieldType]

        return [{
                label: "=",
                value: "="
            },
            {
                label: "<>",
                value: "<>"
            },
            {
                label: "<",
                value: "<"
            },
            {
                label: ">",
                value: ">"
            },
            {
                label: "<=",

                value: "<="
            },
            {
                label: ">=",
                value: ">="
            },
            {
                label: txtTitleCase("contains"),
                value: "contains"
            },
            {
                label: txtTitleCase("does not contain"),
                value: "does not contain"
            },
            {
                label: txtTitleCase("is empty"),
                value: "is empty"
            },
            {
                label: txtTitleCase("is not empty"),
                value: "is not empty"
            }
        ].filter(operator => possibleOperators.indexOf(operator.value) != -1)
    }

    /**
     * Build the configuration of an input field, according to the desired type (text | number | date | select | ...)
     * 
     * @param {string} fieldId
     * @returns {object} A field configuration, ready to be injected into the field builder function
     */
    function buildFilterInput(fieldId) {
        let fieldConfig = $(viewId).collection.model.getField(fieldId)
        let fieldType = getFieldType(fieldId)
        let isHidden = (filterOperator.includes("empty"))

        let fieldBuilderFunction = createField
        let checked = false
        let options = []
        let optionsFilter
        let shape = ""
        let lookup = {}
        let summary = {}
        let roles = []
        let unit
        let min
        let max
        
        switch (fieldType) {
            case "attachment":
            case "textarea":
            case "aiTextarea":
            case "selectViewColumn":
            case "selectViewColumns":
                fieldType = "text"
                break
            case "select":
                options = fieldConfig.options
                optionsFilter = fieldConfig.optionsFilter
                fieldBuilderFunction = createSelect
                break
            case "checkbox":
                shape = fieldConfig.shape
                fieldBuilderFunction = createCheckbox
                if (fieldValue == true) checked = true
                break
            case "slider":
                min = fieldConfig.min || 0
                max = fieldConfig.max || 100
                fieldBuilderFunction = createSlider
                break
            case "rating":
                shape = fieldConfig.shape || "star"
                min = fieldConfig.min || 0
                max = fieldConfig.max || 10
                color = fieldConfig.iconColorOn
                fieldBuilderFunction = createRating
                break
            case "color":
                fieldBuilderFunction = createColorField
                break
            case "icon":
                fieldBuilderFunction = createIconField
                break
            case "lookup":
                lookup = fieldConfig.lookup
                break
            case "summary":
                summary = fieldConfig.summary
                break
            case "directory":
                roles = ["userId"]
                fieldBuilderFunction = createDirectory
                break
            case "date":
                let dateOperator = getFilterDateOperator() || filterDateOperator
                if (dateOperator == "days from now" || dateOperator == "days ago") {
                    fieldType = "number"
                    unit = txt("days")

                } else if (dateOperator == "today") {
                    isHidden = true
                }
        }

        // Create an input field configuration with the right type
        return {
            hidden: isHidden,

            id: "filter-value:" + id,
            type: fieldType,
            label: txtTitleCase("value"),
            labelPosition: "top",
            minWidth: "25rem",

            value: fieldValue,
            min,
            max,
            unit,
            checked,
            draggable: true,
            allowValuesNotInList: true,

            // Special fields options
            renderer: fieldBuilderFunction, // renderer
            options, // select
            optionsFilter, // select
            optionsColor: color,
            roles, // directory
            shape, // checkbox
            iconColorOn: color, // checkbox
            iconSize: "2rem", // checkbox
            lookup, // lookup field

            events: {
                change: function (event) {
                    // Update filter
                    let rootFilter = event.target.closest(".root-filter")
                    rootFilter.updateFilter()
                },
                dragstart: (event) => event.preventDefault()
            }
        }
    }

    /**
     * Block that contains all the filter's components
     * (delete button + field + operator + field value)
     */
    let dataFilter = createBlock({
        id: "filter-" + id,
        target: config.target,

        layout: "horizontal",
        alignItems: "center",
        draggable: true,
        class: "filter",

        items: [
            // DELETE BUTTON
            {
                id: "filter-delete:" + id,
                type: "button",
                icon: "fas fa-trash",
                width: "3rem",
                height: "3rem",

                events: {
                    click: function (event) {
                        let filter = event.target.closest("a-block")
                        let rootFilter = event.target.closest(".root-filter")
                        let doUpdate = (filter.getFilter() != null)

                        filter.deepDelete()
                        if (doUpdate) rootFilter.updateFilter()
                    }
                }
            },
            // FIELD SELECTOR
            {
                id: "filter-field:" + id,
                type: "select",
                label: txtTitleCase("where field"),
                labelPosition: "top",
                width: "25rem",

                value: fieldId,
                options: selectFields,
                optionsColor: color,

                events: {
                    change: function (event) {
                        const fieldId = getFieldId()
                        updateFilterOperator(fieldId)
                        updateFilterDateOperator(fieldId)
                        updateFilterInput(fieldId)

                        // Update the global filter if the local filter is valid
                        const filter = event.target.closest("a-block")
                        if (filter.getFilter() == null) return
                        const rootFilter = event.target.closest(".root-filter")
                        rootFilter.updateFilter()
                    }
                }
            },
            // COMPARISON OPERATOR SELECTOR
            {
                id: "filter-operator:" + id,
                type: "select",
                label: txtTitleCase("operator"),
                labelPosition: "top",
                width: "15rem",

                autocomplete: "off",
                value: filterOperator,
                options: generateFilterOperators(fieldId),
                optionsColor: color,

                events: {
                    change: function (event) {
                        const fieldId = getFieldId()
                        updateFilterDateOperator(fieldId)
                        updateFilterInput(fieldId)

                        // Update filter
                        const filter = event.target.closest("a-block")
                        if (filter.getFilter() == null) return
                        const rootFilter = event.target.closest(".root-filter")
                        rootFilter.updateFilter()
                    }
                }
            },
            // COMPARISON MODIFIER FOR DATE FIELDS ONLY
            {
                hidden: shouldHideFilterDateOperator(),

                id: "filter-date-operator:" + id,
                type: "select",
                label: txtTitleCase("comparison"),
                labelPosition: "top",
                width: "15rem",

                autocomplete: "off",
                value: filterDateOperator,
                options: [{
                        label: txtTitleCase("exact date"),
                        value: "exact date"
                    },
                    {
                        label: txtTitleCase("today"),
                        value: "today"
                    },
                    {
                        label: txtTitleCase("days from now"),
                        value: "days from now"
                    },
                    {
                        label: txtTitleCase("days ago"),
                        value: "days ago"
                    }
                ],
                optionsColor: color,

                events: {
                    change: function (event, value) {
                        const fieldId = getFieldId()
                        updateFilterInput(fieldId)

                        // Update filter
                        const filter = event.target.closest("a-block")
                        if (filter.getFilter() == null) return
                        const rootFilter = event.target.closest(".root-filter")
                        rootFilter.updateFilter()
                    }
                }
            },
            // FIELD VALUE TO FILTER
            buildFilterInput(fieldId),
        ],

        // Put the currently dragged element available as a global context
        events: {
            dragstart: function (event) {
                kiss.context.draggedElement = event.target
            }
        },

        methods: {
            /**
             * Get the filter configuration.
             * 
             * @returns {object} The filter config
             * @example
             * {
             *   type: "filter",
             *   fieldId: "firstName",
             *   operator: "contains",
             *   value: "wilson"
             * }
             */
            getFilter: function () {
                const filterFieldId = getFieldId()
                const filterFieldType = getFieldType(filterFieldId)
                const filterOperator = getFilterOperator()
                const filterDateOperator = getFilterDateOperator()
                const filterValue = getFilterValue()

                // Exit if the filter is not valid
                if (
                    (filterFieldId === "")
                    || (filterOperator === "")
                    || ((filterValue === "") && !filterOperator.includes("empty") && !filterDateOperator.includes("today"))
                ) return null

                return {
                    type: "filter",
                    id: this.id,
                    fieldId: filterFieldId,
                    fieldType: filterFieldType,
                    operator: filterOperator,
                    dateOperator: filterDateOperator,
                    value: filterValue
                }
            }
        }
    })

    return dataFilter
}

;/**
 * 
 * ## Creates a group of filters for a view
 * 
 * - the group allows to apply a boolean operator (AND / OR) to a list of filters.
 * - the goal is to be able to filter a collection of data with an easy drag&drop interface.
 * 
 * @ignore
 * @param {string} viewId - Target view to apply data filtering
 * @param {string} color - window color theme
 * @param {object} config
 * @param {string} [config.id] - Desired node id
 * @param {string} [config.target] - Node id where the filter group should be inserted
 * @param {boolean} config.canAddGroup - Display the button to add a subgroup
 * @param {boolean} config.canDeleteGroup - Display a trash button to delete the group
 * 
 * The method getFilters() of this component returns a hierarchical object containing all the filters.
 * "Get all people born in France within years 2000 and 2020, which last name is Dupont or Dupond":
 * 
 * @example
 * filters = {
 *  type: "group",
 *  operator: "and",
 *  filters: [
 *      {
 *          type: "group",
 *          operator: "and",
 *          filters: [
 *              {
 *                  type: "filter",
 *                  fieldId: "country",
 *                  operator: "=",
 *                  value: "France"
 *              },
 *              {
 *                  type: "filter",
 *                  fieldId: "birthDate",
 *                  operator: ">=",
 *                  value: "2000-01-01"
 *              },
 *              {
 *                  type: "filter",
 *                  fieldId: "birthDate",
 *                  operator: "<",
 *                  value: "2020-01-01"
 *              }
 *          ]
 *      },
 *      {
 *          type: "group",
 *          operator: "or",
 *          filters: [
 *              {
 *                  type: "filter",
 *                  fieldId: "lastName",
 *                  operator: "=",
 *                  value: "dupond"
 *              },
 *              {
 *                  type: "filter",
 *                  fieldId: "lastName",
 *                  operator: "=",
 *                  value: "dupont"
 *              }
 *          ]
 *      }
 *   ]
 * }
 */
const createDataFilterGroup = function (viewId, color, config) {
    let id = config.id || kiss.tools.shortUid()
    let filterContentId = "group-" + id

    let target = config.target || null
    let isRootFilter = config.isRootFilter || false

    // Setup group options
    let groupOperator = config.operator || "and"
    let canAddGroup = config.canAddGroup || false
    let canDeleteGroup = config.canDeleteGroup || false

    // Create the block that contains the group of filters
    let filterGroup = createBlock({
        id: "filter-group-" + id,
        target,

        layout: "horizontal",
        alignItems: "center",
        classes: {
            "this": "filter-group" + ((isRootFilter) ? " root-filter" : "")
        },

        items: [{
                layout: "horizontal",
                alignItems: "center",
                minWidth: "12.8rem",

                items: [
                    // Button to add a new subgroup within this group
                    {
                        hidden: !canAddGroup,

                        id: "filter-group-add:" + id,
                        type: "button",
                        icon: "fas fa-plus",
                        width: "3rem",
                        height: "3rem",
                        tip: {
                            text: txtTitleCase("add a subgroup"),
                            deltaX: 0,
                            deltaY: 20
                        },

                        events: {
                            click: function () {
                                let filterGroup = this.closest(".filter-group")
                                filterGroup.addFilterGroup({
                                    target: filterContentId,
                                    canDeleteGroup: true
                                })
                            }
                        }
                    },
                    // Button to delete the filter group
                    {
                        hidden: !canDeleteGroup,

                        id: "filter-group-delete:" + id,
                        type: "button",
                        icon: "fas fa-trash",
                        width: "3rem",
                        height: "3rem",

                        events: {
                            click: function (event) {
                                let rootFilter = this.closest(".root-filter")
                                $("filter-group-" + id).deepDelete()
                                rootFilter.updateFilter()
                            }
                        }
                    },
                    // Field to select AND / OR operator
                    {
                        id: "filter-group-operator:" + id,
                        type: "select",
                        autocomplete: "off",
                        width: "8rem",

                        value: groupOperator,
                        options: [{
                                label: txtTitleCase("and"),
                                value: "and"
                            },
                            {
                                label: txtTitleCase("or"),
                                value: "or"
                            }
                        ],
                        optionsColor: "#00aaee",

                        events: {
                            change: function(event) {
                                // Update the filter
                                let rootFilter = this.closest(".root-filter")
                                rootFilter.updateFilter()
                            }
                        }
                    }
                ]
            },
            // Block that contains both:
            // - the filters
            // - the button to add a filter
            {
                class: "filter-group-content",
                layout: "vertical",
                items: [
                    // Block that contains all the filters of this group
                    {
                        id: "group-" + id,
                        flex: 1,
                        class: "filter-group-items",
                        filters: []
                    },
                    // Space between filters and button
                    {
                        type: "spacer",
                        height: "1rem"
                    },
                    // Button to add a new filter within this group
                    {
                        type: "button",
                        text: txtTitleCase("add a filter"),
                        icon: "fas fa-plus",
                        width: "15rem",
                        height: "3rem",

                        events: {
                            click: function () {
                                let filterGroup = this.closest(".filter-group")
                                filterGroup.addFilter({
                                    fieldId: "",
                                    operator: "=",
                                    value: ""
                                })
                            }
                        }
                    },
                    // Space between button and border
                    {
                        type: "spacer",
                        height: "1rem"
                    }
                ],

                events: {
                    dragenter: function(event) {
                        this.classList.add("filter-group-dragover")
                    },
                    dragover: function(event) {
                        event.preventDefault()
                    },
                    dragleave: function(event) {
                        if (kiss.tools.isEventInElement(event, this)) return
                        this.classList.remove("filter-group-dragover")
                    },
                    ondrop: function (event) {
                        event.stop()
                        // The currently dragged element is kept into the kiss.context.draggedElement object
                        kiss.views.removeAndCacheNode(kiss.context.draggedElement.id)
                        kiss.context.draggedElement.render(filterContentId)

                        // Update the filter
                        let rootFilter = event.target.closest(".root-filter")
                        rootFilter.updateFilter()
                    }
                }                
            }
        ],

        methods: {
            /**
             * Show / Hide the button to delete a filter group
             * 
             * @param {*} visible 
             * @returns {object} The button
             */
            toggleDeleteGroupButton: function (visible) {
                let deleteGroupButton = $("filter-group-delete:" + id)
                return (visible) ? deleteGroupButton.show() : deleteGroupButton.hide()
            },

            /**
             * Add a list of filters to the filter group.
             * Each filter can be a single filter, or a filter group, so the function is called recursively.
             * 
             * @param {array} filters - Array of filters
             * @example
             * [{
             *     type: "filter",
             *     fieldId: "firstName",
             *     operator: "contains",
             *     value: "wilson"
             *   },
             *   {
             *     type: "filter",
             *     fieldId: "birthDate",
             *     operator: ">",
             *     value: "2020-01-01"
             *   }
             * ]
             */
            addFilters: function (filters) {
                if (!filters) return

                filters.forEach(filterConfig => {
                    if (filterConfig) {
                        if (filterConfig.type == "filter") {
                            this.addFilter(filterConfig)
                        } else {
                            this.addFilterGroup(filterConfig)
                        }
                    }
                })
            },

            /**
             * Add a filter to the group
             * 
             * @param {string} config.target - DOM Element where the filter should be inserted
             */
            addFilter: function (config) {
                config.target = filterContentId
                createDataFilter(viewId, color, config).render()
            },

            /**
             * Add a filter group to the group (which allows to create nested groups)
             * 
             * @param {string} config.target - DOM Element where the filter group should be inserted
             * @param {string} config.canDeleteGroup - True to add a delete button to the group
             */
            addFilterGroup: function (config) {
                config.target = filterContentId
                config.canDeleteGroup = true
                createDataFilterGroup(viewId, color, config).render()
            },

            /**
             * Get the filter group configuration.
             * 
             * @returns {object} The filter group config
             * @example:
             * {
             *      type: "group",
             *      operator: "and",
             *      filters: [
             *          {
             *              type: "filter",
             *              fieldId: "firstName",
             *              operator: "contains",
             *              value: "wilson"
             *          },
             *          {
             *              type: "filter",
             *              fieldId: "birthDate",
             *              operator: ">",
             *              value: "2020-01-01"
             *          }
             *      ]
             * }
             */
            getFilters: function () {
                // Get the group operator (AND / OR)
                let operator = $("filter-group-operator:" + id).getValue()

                // Parse group items
                let filterGroup = this.querySelector(".filter-group-items")//.firstChild
                let filters = []

                Array.from(filterGroup.children).forEach(filter => {
                    if (filter.id.indexOf("filter-group") != -1) {
                        // If it's a filter group, then we get the filters of the group recursively
                        let newGroupFilter = filter.getFilters()

                        // If the filter group contains no item, we skip it
                        if (newGroupFilter == null) return null

                        // Otherwise add it to the list of filters
                        filters.push(filter.getFilters())
                    } else {
                        // If it's a single filter, we directly get the filter values
                        filters.push(filter.getFilter())
                    }
                })

                // If the group is empty, we skip it
                if (filters.length == 0) return null

                // If the group contains a single item, we don't return a group of filters, but a single filter
                if (filters.length == 1) return filters[0]

                // Returns the filters in the appropriate format
                return {
                    type: "group",
                    id: this.id,
                    operator: operator,
                    filters: filters
                }
            },

            /**
             * Update the filter
             */
            updateFilter() {
                let newFilterConfig = this.getFilters() || {}
                kiss.pubsub.publish("EVT_VIEW_FILTERING:" + viewId, newFilterConfig)
            }
        }
    }).render()

    // If the group have filters passed as parameter, we add them directly after render
    if (config.filters) filterGroup.addFilters(config.filters)

    return filterGroup
}

;/**
 * 
 * Main interface to filter data of a data component
 * 
 * @ignore
 */
const createDataFilterWindow = function (viewId, color = "#00aaee") {
    const filterWindowId = "filter-selection-for-" + viewId

    let filterWindow = createPanel({
        id: filterWindowId,
        title: txtTitleCase("filter your data"),
        icon: "fas fa-filter",
        headerBackgroundColor: color,
        minWidth: "80rem",

        modal: true,
        draggable: true,
        closable: true,

        maxHeight: () => kiss.screen.current.height - 100,
        align: "center",
        verticalAlign: "center",
        overflowY: "auto",

        items: [
            // Placeholder for the query builder
            {
                id: "query-builder-" + viewId
            }
        ],

        methods: {
            // Build or re-build the filter interface from the current filter configuration
            load: function () {
                let fields = $(viewId).collection.model.getFields()

                let filterGroup = {
                    isRootFilter: true,
                    canAddGroup: true,
                    id: viewId,
                    target: "query-builder-" + viewId,
                    fields: fields,
                }

                let filter = $(viewId).filter || {}

                if (Object.keys(filter).length != 0) {
                    if (filter.type == "filter") {
                        filterGroup.filters = [filter]
                    } else {
                        filterGroup.operator = filter.operator
                        filterGroup.filters = filter.filters
                    }
                }

                createDataFilterGroup(viewId, color, filterGroup)
            }
        }
    })

    return filterWindow
}

;/**
 * 
 * Create a new widget used to sort a data collection by field.
 * It's composed of:
 * - a delete button, to remove the sort option
 * - a field selector
 * - a sort direction selector (ascending / descending)
 * 
 * @ignore
 * @param {string} viewId - Id the widget containing this sort widget
 * @param {string} fieldId - Field to sort by
 * @param {string} sortDirection - "asc" or "desc"
 * @param {number} sortIndex - Index of the sorting option (within the array of sort options)
 * @param {array} sortFields
 * 
 */
const createDataSort = function (viewId, fieldId, sortDirection, sortIndex, sortFields, color) {
    return createBlock({
        class: "data-sorter",
        layout: "horizontal",
        alignItems: "center",
        items: [
            // DELETE BUTTON
            {
                id: "sort-delete-for-view-" + viewId + "-index:" + sortIndex,
                type: "html",
                width: "20px",
                html: `<span class="fa fa-times data-sorter-delete"></span>`,
                events: {
                    click: (event) => {
                        let sortIndex = event.target.closest("a-html").id.split(":")[1]
                        
                        // Publish a sort event to update the active view
                        kiss.pubsub.publish("EVT_VIEW_SORTING:" + viewId, {
                            sortAction: "remove",
                            sortIndex: sortIndex
                        })
                    }
                }
            },
            // FIELD SELECTOR
            {
                id: "sort-field-for-view-" + viewId + "-index:" + sortIndex,
                type: "select",
                label: (sortIndex == 0) ? txtTitleCase("sort by") : txt("then by"),

                width: "50rem",
                fieldWidth: "30rem",
                labelWidth: "20rem",
                labelPosition: "left",

                value: [fieldId],
                multiple: false,
                options: sortFields,
                optionsColor: color,
                events: {
                    change: async (event) => {
                        let sortDirectionId = event.target.id.replace("field", "direction")
                        let sortDirection = $(sortDirectionId).getValue()
                        if (sortDirection == "") sortDirection = "asc"

                        // Publish a sort event to update the view
                        kiss.pubsub.publish("EVT_VIEW_SORTING:" + viewId, {
                            sortFieldName: event.target.value,
                            sortDirection: sortDirection,
                            sortIndex: event.target.id.split(":")[1]
                        })
                    }
                }
            },
            // SORT DIRECTION SELECTOR
            {
                id: "sort-direction-for-view-" + viewId + "-index:" + sortIndex,
                type: "checkbox",
                label: txtTitleCase("inverse order"),
                labelWidth: "20rem",
                labelPosition: "right",
                checked: (sortDirection == "desc"),

                shape: "switch",
                iconSize: "2rem",
                iconColorOn: color,

                events: {
                    change: async (event) => {
                        let isChecked = event.target.getValue()
                        let sortDirection = (isChecked) ? "desc" : "asc"
                        let sortFieldId = event.target.id.replace("direction", "field")
                        let fieldName = $(sortFieldId).getValue()
                        if (fieldName == "") return

                        // Publish a sort event to update the view
                        kiss.pubsub.publish("EVT_VIEW_SORTING:" + viewId, {
                            sortFieldName: fieldName,
                            sortDirection: sortDirection,
                            sortIndex: event.target.id.split(":")[1]
                        })
                    }
                }
            }
        ]
    })
}

;/**
 * 
 * Main interface to SORT a collection
 * 
 * @ignore
 */
const createDataSortWindow = function (viewId, color = "#00aaee") {
    const sortWindowId = "sort-selection-for-" + viewId
    const sortListId = "sort-list-for-" + viewId
    const sortFieldId = "sort-create-for-view-" + viewId

    let sortWindow = createPanel({
        id: sortWindowId,
        title: txtTitleCase("sort your data"),
        icon: "fas fa-sort",
        headerBackgroundColor: color,

        modal: true,
        closable: true,
        draggable: true,

        maxHeight: () => kiss.screen.current.height - 100,
        align: "center",
        verticalAlign: "center",
        overflowY: "auto",

        layout: "vertical",
        items: [
            // BLOCK TO DISPLAY EXISTING SORTING OPTIONS
            {
                id: sortListId,
                layout: "vertical"
            },
            {
                layout: "horizontal",
                items: [
                    // FIELD TO ADD A SORT OPTION
                    {
                        id: sortFieldId,
                        type: "select",
                        label: txtTitleCase("select a field to sort by"),
                        width: "50rem",
                        fieldWidth: "30rem",
                        labelWidth: "20rem",
                        labelPosition: "left",
                        margin: "0 0 0 3rem",

                        multiple: false,
                        events: {
                            change: async (event) => {

                                // Publish a sort event to update the view
                                kiss.pubsub.publish("EVT_VIEW_SORTING:" + viewId, {
                                    viewId: viewId,
                                    sortFieldName: event.target.value,
                                    sortDirection: "asc",
                                    sortIndex: $(viewId).sort.length
                                })

                                // Reset the field value
                                $(sortFieldId).resetValue()
                            }
                        }
                    }
                ]
            }
        ],

        subscriptions: {
            "EVT_DB_UPDATE:VIEW": (msgData) => {
                if ($(sortWindowId) && (msgData.id == viewId) && (msgData.userId != kiss.session.getUserId())) $(sortWindowId).load()
            },
            ["EVT_VIEW_SORTED:" + viewId]: () => $(sortWindowId).load()
        },        

        // Render (or re-render) sorting options each time the sort window is displayed
        methods: {
            load: function () {
                this.renderExistingOptions()
            },

            /**
             * Render existing sort options in the pop-up window
             * (it builds a sort widget for each sort option)
             */
            renderExistingOptions: function () {
                // Reset the existing sort options
                this.resetExistingOptions()

                // Build the current list of sort options
                let sortIndex = 0
                const remainingSortFields = this.getRemainingSortFields()
                let currentSortConfig = $(viewId).sort || []

                currentSortConfig.forEach(sortOption => {
                    let sortField = Object.keys(sortOption)[0]
                    let sortDirection = sortOption[sortField]
                    createDataSort(viewId, sortField, sortDirection, sortIndex, remainingSortFields, color).render("sort-list-for-" + viewId)
                    sortIndex++
                })

                // Reset the possible sort options for the field used to add sort options
                const sortField = $(sortFieldId)
                sortField._hideOptions()
                sortField.updateOptions(remainingSortFields)
            },

            /**
             * Reset the content of the block containing the sort options
             */
            resetExistingOptions: () => $("sort-list-for-" + viewId).deepDelete(false),

            /**
             * - Get the fields which the view can still be sorted by.
             * - This is the list of fields, minus the fields already used.
             * - The returned array always have the full list of fields, but fields that can't be used anymore for sorting are disabled.
             * 
             * @returns {array} The list of remaining fields, ready to be injected into a Select field
             * @example
             * [{label: "First name", value: "firstName", disabled: false, color: "#00aaee"}, {...}, ...]
             */
            getRemainingSortFields: function () {
                // Get current sort fields
                const currentSortConfig = $(viewId).sort || []
                const currentSortFields = currentSortConfig.map(sortField => Object.keys(sortField)[0])

                // Build the list of remaining fields (= prevent to sort twice on the same field)
                let remainingSortFields = []
                const model = $(viewId).collection.model
                const isDynamicModel = kiss.tools.isUid(model.id)
                const fields = model.getSortableFields()

                for (let i = 0, length = fields.length; i < length; i++) {
                    const field = fields[i]
                    const disabled = !((field.deleted != true) && (currentSortFields.indexOf(field.id) == -1))
                    const needsTranslation = (field.isSystem || field.isFromPlugin || field.label.startsWith("#")) ? true : false

                    remainingSortFields.push({
                        label: (isDynamicModel && !needsTranslation) ? field.label.toTitleCase() : txtTitleCase(field.label),
                        value: field.id,
                        disabled: disabled // This makes the field unavailable for sorting
                    })
                }
                return remainingSortFields
            }
        }
    })

    return sortWindow
}

;/**
 * 
 * Generates a window to select a record from a list of records.
 * Records are displayed in a datatable.
 * 
 * Important:
 * - This function is only used by the datatable and the "link" field type.
 * - If the user updates the datatable config (columns, sorts, ...), the configuration is automatically stored in the "view" collection.
 * 
 * @ignore
 * @param {object} model - source model
 * @param {string} fieldId - id of the LINK field which generated this window
 * @param {object[]} [records] - Optionnal records to display in the datatable
 * @param {function} [selectRecord] - Optional callback function executed when a record is selected inside the datatable. By default, opens the record.
 * @param {object} [datatableConfig] - Optional parameters to adjust the datatable configuration
 * 
 */
const createRecordSelectionWindow = function(model, fieldId, records, selectRecord, datatableConfig) {
    if (Array.isArray(records) && records.length == 0) return

    const isMobile = kiss.screen.isMobile
    let tempModel = {}
    let tempCollection
    const useMemory = (records) ? true : false
    const tempDatatableId = kiss.tools.shortUid()

    // Defines a default behavior when selecting a record.
    if (!selectRecord) {
        selectRecord = async function(record) {
            // In offline, we need to re-create a temp in-memory record
            if (kiss.session.isOffline()) {
                let tempRecord = await kiss.db.findOne(model.id, record.id)
                record = model.create(tempRecord)
            }
            
            createForm(record)
            this.closest("a-panel").close()
        }
    }

    // Responsive options
    let responsiveOptions

    if (isMobile) {
        responsiveOptions = {
            expandable: false,
            width: "100%",
            height: "100%",
            top: 0,
            left: 0,
            borderRadius: "0 0 0 0",
            padding: 0
        }
    }
    else {
        responsiveOptions = {
            width: () => "calc(100vw - 2rem)",
            height: () => "calc(100vh - 2rem)",
        }
    }

    // Build the panel to show the datatable
    createPanel({
        modal: true,
        closable: true,

        // Header
        title: "<b>" + model.namePlural + "</b>",
        icon: model.icon,
        headerBackgroundColor: model.color,

        // Size and layout
        display: "flex",
        layout: "vertical",
        align: "center",
        verticalAlign: "center",
        autoSize: true,
        background: "var(--body-background)",
        padding: 0,
        
        ...responsiveOptions,

        items: [{
            id: tempDatatableId,
            flex: 1,
            layout: "vertical"
        }],

        // When closing the panel, we must destroy the datatable's temporary source collection
        events: {
            onclose: function () {
                tempCollection.destroy(useMemory)
            }
        },

        methods: {
            async _afterRender() {

                // To insert temp documents in offline mode, we need to build a temporary duplicate in-memory model with a different id,
                // otherwise, working with the temp collection alters the source NeDb collection
                if (records && kiss.session.isOffline()) {
                    Object.assign(tempModel, model)
                    tempModel.id = kiss.tools.uid()
                    tempModel = new kiss.data.Model(tempModel)
                }
                else {
                    tempModel = model
                }

                // Get the record holding the datatable config, or create a new one
                let viewRecord = kiss.app.collections.view.records.find(view => view.fieldId == fieldId)

                let filter = {}
                let sort = [{
                    [model.getPrimaryKeyField().id]: "asc" // Sort on the primary key field by default
                    // "createdAt": "desc" // Sort on the creation date by default
                }]

                if (viewRecord) {
                    if (viewRecord.sort) {
                        sort = viewRecord.sort
                    }
                    if (viewRecord.filter) {
                        filter = viewRecord.filter
                    }
                }

                // Build a temporary collection for the datatable
                tempCollection = new kiss.data.Collection({
                    id: "temp_" + uid(),
                    mode: (useMemory) ? "memory" : kiss.db.mode,
                    model: tempModel,
                    sort,
                    filter
                })
                
                if (records) await tempCollection.insertMany(records)
                
                // If the datatable doesn't have any "view" record to store its config, we create a new one
                if (!viewRecord) {
                    viewRecord = kiss.app.models.view.create({
                        id: kiss.tools.uid(),
                        type: "datatable",
                        fieldId, // <= This key is important to link the datatable to the field
                        modelId: model.id,
                        filter: {},
                        sort: [],
                        projection: {},
                        group: [],
                        config: {
                            columns: model.getFieldsAsColumns()
                        },
                        authenticatedCanRead: true
                    })
                    await viewRecord.save()
                }

                // Finally, build the datatable
                let config = {
                    id: "datatable-" + tempDatatableId,
                    fieldId,
                    type: "datatable",
                    collection: tempCollection,
                    record: viewRecord,
                    autoSize: true,

                    // Options
                    showHeader: true,
                    showToolbar: true,
                    showActions: false,
                    showLinks: false,
                    canEdit: false,
                    canAddField: false,
                    canEditField: false,
                    canCreateRecord: false,
                    color: model.color,

                    // Mobile options
                    canSelectFields: (isMobile) ? false : true,
                    canSort: (isMobile) ? false : true,
                    canFilter: (isMobile) ? false : true,
                    canGroup: (isMobile) ? false : true,
                    showGroupButtons: (isMobile) ? false : true,
                    showLayoutButton: (isMobile) ? false : true,
                    showScroller:  (isMobile) ? false : true,

                    // Override the method to select records
                    methods: {
                        selectRecord
                    }
                }

                if (datatableConfig) Object.assign(config, datatableConfig)
                const datatable = createDatatable(config)

                setTimeout(() => $(tempDatatableId).setItems([datatable]), 50)
            }
        }
    }).render()
}

;/**
 * 
 * Generates the panel to preview files
 * 
 * TODO: bandwith optimization:
 * => cache the preview images that have already been opened to avoid reloading from the network
 * => to cache the blocks, use kiss.views.removeAndCacheNode and kiss.views.restoreCachedNode
 * => free the memory when leaving the preview window, using kiss.views.deleteCachedNode
 * => maybe generalize the concept building a "card" container, using the same approach as Sencha ExtJS
 * => check: https://docs.sencha.com/extjs/6.2.0/classic/Ext.layout.container.Card.html
 * 
 * @ignore
 */
const createPreviewWindow = function (files, fileId, recordId, fieldId) {
    // Check if the preview was opened from a record form
    const isOpenedFromRecord = (recordId) ? true : false
    const previewWindow = $("preview-window")
    let showOnTheSide = localStorage.getItem("config-side-preview") == "true"

    if (isOpenedFromRecord) {
        if (previewWindow) {
            // Check if the preview was opened from the current record form
            if (previewWindow.config.recordId == recordId) {
                // It's the same record form. checks if the preview was opened for the same field
                const isSameField = (fieldId == previewWindow.config.fieldId)
                if (isSameField) {
                    // Update the fileId in the preview
                    previewWindow.openPreview(fileId)
                    return
                }
                else {
                    showOnTheSide = previewWindow.showOnTheSide
                    previewWindow.close()
                }
            }
            else {
                // It's a different record form
                // Close the preview window if it's already opened
                previewWindow.close()
            }
        }
    }
    else {
        if (previewWindow) previewWindow.close()
    }
    
    const useExternalViewer = true
    const disableNavigation = (files.length < 2) || (kiss.screen.isMobile && kiss.screen.isVertical())

    // Create a single thumbnail item
    const createThumbnail = function (file) {
        const fileType = file.filename.split(".").pop().toLowerCase()
        let viewHtml = ""
        let previewHtml = ""

        // Format filename properly
        let filePath = kiss.tools.createFileURL(file)
        filePath = filePath.replaceAll("\\", "/")

        if (["jpg", "jpeg", "png", "gif", "webp"].includes(fileType)) {
            // Image
            viewHtml = `<img class="preview-item" src="${filePath}" loading="lazy">`
            previewHtml = `<img class="preview-thumbnail" src="${kiss.tools.createFileURL(file, 's')}" loading="lazy">`

        } else if (fileType == "pdf") {
            // PDF
            viewHtml = `<iframe width=100% height=100% frameborder=0 border=0 cellspacing=0 src="${filePath}"/>`
            previewHtml = `<span style="color: #ff0000" class="fas fa-file-pdf preview-thumbnail"></span>`

        // } else if (fileType == "docx" && useExternalViewer) {
        //     // DOCX with external viewer (Google viewer or Microsoft Office viewer)
        //     const encodedPath = encodeURIComponent(filePath)
        //     // const url = (useExternalViewer) ? "https://docs.google.com/viewer?embedded=true&url=" + encodedPath : filePath
        //     const url = (useExternalViewer) ? "https://view.officeapps.live.com/op/embed.aspx?src=" + encodedPath : filePath
            
        //     viewHtml = `<iframe width=100% height=100% frameborder=0 border=0 cellspacing=0 src="${url}"/>`
        //     previewHtml = `<span style="color: #00aaee" class="fas fa-file-word preview-thumbnail"></span>`

        } else {
            // Icon
            const {
                icon,
                color
            } = kiss.tools.fileToIcon(fileType)

            viewHtml = `<span style="color: ${color}" class="fas ${icon} preview-item preview-item-icon"></span>
                        <div class="preview-not-available">
                            ${txtTitleCase("#no preview") + " " + fileType}
                        </div>`

            previewHtml = `<span style="color: ${color}" class="fas ${icon} preview-thumbnail"></span>`
        }

        // Create an html element containing either an image or an icon
        return createHtml({
            id: "preview-file-" + file.id,
            html: previewHtml,
            display: "inline-block",

            // Mark the html element with a specific class to recognize it with querySelectorAll
            class: "preview-thumbnail-item",

            events: {
                click: function () {
                    this
                        .select()
                        .openPreview()
                }
            },

            methods: {
                openPreview() {
                    if (kiss.context.fileId == file.id) return
                    kiss.context.fileId = file.id

                    $("preview-content").setInnerHtml(viewHtml)
                    $("preview-window").setTitle(file.filename + " (" + file.size.toFileSize() + ")")
                    $("preview-window").currentPreview = file.id
                    const iframe = $("preview-content").querySelector('iframe')

                    if (iframe) {
                        // Workaround to reload the frame if the token was outdated.
                        iframe.addEventListener('load', async () => {
                            try {
                                const bodyContent = iframe.contentDocument.body.innerText;

                                try {
                                    const json = JSON.parse(bodyContent);
                                    if (json && json.error) {
                                        if (json.code === 498) {
                                            if (!await kiss.session.getNewToken()) {
                                                log("previewWindow - Unable to get a new token to preview the file.")
                                                return
                                            }

                                            let src = iframe.src
                                            iframe.src = ''
                                            iframe.src = src
                                        } // else nothing to do.
                                    }
                                } catch (err) {
                                    // Not JSON data. Nothing to do.
                                    return
                                }
                            } catch (err) {
                                // Unable to detect the error, we're probably in CORS context.
                                // console.error('Unable to check the preview pdf content. Maybe CORS issue.')
                            }
                        })
                    }
                    return this
                },

                select() {
                    const previewItemElements = $("preview-window").querySelectorAll(".preview-thumbnail")
                    const previewItems = [...previewItemElements]
                    previewItems.forEach(item => item.classList.remove("preview-thumbnail-selected"))
                    this.querySelector(".preview-thumbnail").classList.add("preview-thumbnail-selected")
                    return this
                }
            }
        })
    }

    // Build the preview window panel
    return createPanel({
        id: "preview-window",
        recordId,
        fieldId,
        modal: true,
        closable: true,
        icon: "fas fa-search",
        headerHeight: 50,
        headerBackgroundColor: "#555555",
        background: "#000000",
        animation: "fadeIn",
        autoSize: true,

        // Size & position
        position: "absolute",
        top: (showOnTheSide) ? 0 : 10,
        left: (showOnTheSide) ? () => kiss.screen.current.width/2 : 10,
        width: (showOnTheSide) ? () => kiss.screen.current.width/2 : () => (kiss.screen.current.width - 20) + "px",
        height: (showOnTheSide) ? () => kiss.screen.current.height : () => (kiss.screen.current.height - 20) + "px",
        padding: 0,

        // Content
        layout: "vertical",
        items: [
            // Preview content
            {
                id: "preview-content-container",
                layout: "horizontal",
                items: [
                    // Left navigation arrow
                    {
                        hidden: disableNavigation,
                        id: "preview-content-previous",

                        class: "preview-navigation",
                        layout: "vertical",
                        items: [{
                                type: "spacer",
                                flex: 1
                            },
                            {
                                type: "html",
                                flex: 0,
                                html: `<span class="fas fa-chevron-left preview-navigation-button"></span>`,
                                events: {
                                    click: () => $("preview-window").openPreviousPreview()
                                }
                            },
                            {
                                type: "spacer",
                                flex: 1
                            }
                        ]
                    },
                    // Content
                    {
                        id: "preview-content",
                        width: "100%",
                        height: () => {
                            if (disableNavigation) return kiss.screen.getHeightMinus(80) + "px"
                            return kiss.screen.getHeightMinus(160) + "px"
                        },
                        class: "preview-item-container"
                    },
                    // Right navigation arrow
                    {
                        hidden: disableNavigation,
                        id: "preview-content-next",
                        class: "preview-navigation",

                        layout: "vertical",
                        items: [{
                                type: "spacer",
                                flex: 1
                            },
                            {
                                type: "html",
                                flex: 0,
                                html: `<span class="fas fa-chevron-right preview-navigation-button"></span>`,
                                events: {
                                    click: () => $("preview-window").openNextPreview()
                                }
                            },
                            {
                                type: "spacer",
                                flex: 1
                            }
                        ]
                    }
                ]
            },
            // Thumbnails
            {
                hidden: disableNavigation,
                id: "preview-thumbnails",
                class: "preview-thumbnails-container",
                items: files.filter(file => file.path).map(createThumbnail)
            }
        ],

        events: {
            // onclick: function() {
            //     if (disableNavigation) this.close()
            // },

            mousewheel: function (event) {
                if (disableNavigation) return

                // Navigating with the mousewheel
                if (event.wheelDelta < 0) this.openNextPreview()
                else this.openPreviousPreview()
            },

            keydown: function (event) {
                // Close the preview window using Escape key
                if (event.key == "Escape") $("preview-window").close()

                if (disableNavigation) return

                // Navigating with the arrows
                if (event.key == "ArrowRight") return this.openNextPreview()
                if (event.key == "ArrowLeft") return this.openPreviousPreview()
            },

            close: function() {
                $("preview-window").resetFormPosition()
                delete kiss.context.fileId
            }
        },

        subscriptions: {
            EVT_FORM_OPENED: function () {
                this.close()
            },
            EVT_FORM_CLOSED: function () {
                this.close()
            }            
        },

        methods: {
            // Automatically preview the clicked image when loading the window
            load() {
                this.openPreview(fileId)
                if (showOnTheSide) {
                    this.showFormOnTheSide()
                    this.showPreviewOnTheSide()
                }
            },

            openPreview(fileId) {
                const thumbnail = $("preview-file-" + fileId)

                thumbnail
                    .select()
                    .openPreview()

                setTimeout(() => thumbnail.scrollIntoView({
                    block: "center",
                    inline: "center",
                    behavior: "smooth"
                }), 200)
            },

            openNextPreview() {
                const currentPreviewId = $("preview-window").currentPreview
                let previewIndex = files.findIndex(item => item.id == currentPreviewId)
                previewIndex++
                if (previewIndex >= files.length) previewIndex = 0
                const newPreviewId = files[previewIndex].id
                $("preview-window").openPreview(newPreviewId)
            },

            openPreviousPreview() {
                const currentPreviewId = $("preview-window").currentPreview
                let previewIndex = files.findIndex(item => item.id == currentPreviewId)
                previewIndex--
                if (previewIndex < 0) previewIndex = files.length - 1
                const newPreviewId = files[previewIndex].id
                $("preview-window").openPreview(newPreviewId)
            },

            switchDisplayMode() {
                if (this.showOnTheSide != true) {
                    this.showPreviewOnTheSide()
                    this.showFormOnTheSide()
                }
                else {
                    this.resetPreviewPosition()
                    this.resetFormPosition()
                }
            },

            showPreviewOnTheSide() {
                this.showOnTheSide = true
                localStorage.setItem("config-side-preview", true)

                $("preview-window")
                    .hideMask()
                    .setWidth(() => kiss.screen.current.width/2)
                    .setHeight(() => kiss.screen.current.height)
                    .setTop(() => 0)
                    .setLeft(() => kiss.screen.current.width/2)
            },

            showFormOnTheSide() {
                if($(recordId)) {
                    $(recordId)
                        .setWidth(() => kiss.screen.current.width/2)
                        .setHeight(() => kiss.screen.current.height)
                        .setTop(() => 0)
                        .setLeft(() => 0)
                }
            },

            resetPreviewPosition() {
                this.showOnTheSide = false
                localStorage.setItem("config-side-preview", false)

                $("preview-window")
                    .showMask()
                    .setWidth(() => kiss.screen.current.width - 20)
                    .setHeight(() => kiss.screen.current.height - 20)
                    .setTop(10)
                    .setLeft(10)
            },

            resetFormPosition() {
                if($(recordId)) {                        
                    const newFormPosition = $(recordId).computeFormPosition()
                    $(recordId)
                        .setWidth(newFormPosition.width)
                        .setHeight(newFormPosition.height)
                        .setTop(newFormPosition.top)
                        .setLeft(newFormPosition.left)
                }
            }
        }
    }).render()
}

;/**
 * 
 * Widget to upload files from Box.com
 * 
 * @ignore
 */
const createFileUploadBox = function () {
    const BOX_COM_SELECT = "https://app.box.com/js/static/select"
    const BOX_COM_PICKER = "https://cdn01.boxcdn.net/platform/elements/13.0.0/en-US/picker"
    const BOX_COM_PICKER_CSS = "https://cdn01.boxcdn.net/platform/elements/13.0.0/en-US/picker"

    const boxClientID = "s4mkchshoxquwjquomli1dneiwysp2oa"
    const boxAuthenticationUrl = `https://www.box.com/api/oauth2/authorize?client_id=${boxClientID}&response_type=code&state=${kiss.session.getUserId()}&redirect_uri=${encodeURIComponent(window.location.origin + '/boxConnect')}`
    const checkTokenUrl = "https://api.box.com/2.0/folders/0?fields=id&limit=1&offset=0"
    const logoUrl = (kiss.global.absolutePath) ? kiss.global.absolutePath + "/client/pickaform/resources/img/logo 32x32.png" : "./resources/img/logo 32x32.png"

	let filePicker

    return createBlock({
        id: "file-upload-box",
        flex: 1,
        layout: "vertical",
        items: [
            // Hidden upload button to submit the files
            {
                hidden: true,
                type: "html",
                html: /*html*/ `<input id="field-upload-box" type="file" multiple>`
            },
            // BLock to display the list of files
            {
                id: "upload-box-gallery",
                layout: "vertical",
                alignItems: "center",
                overflow: "auto",
                flex: 1,
                class: "upload-gallery",

                items: [
                    // Html to display the help message
                    {
                        id: "upload-box-gallery-help",
                        type: "html",
                        margin: "auto",
                        html: txtTitleCase("#upload drive help", null, {
                                drive: "Box"
                            }) +
                            `<br>` +
                            `<center><button class="a-button box-authentication-button" onclick="$('file-upload-box').connect()">${txtTitleCase('connect to your %drive account', null, {drive: "Box"})}</button></center>`
                    },
                    // Block to display the selected files
                    {
                        id: "upload-box-gallery-items",
                        class: "upload-gallery-items"
                    },
                    // Block to encapsulate the Box file picker
                    {
                        id: "upload-box-picker",
                        hidden: true,
                        class: "upload-box-picker"
                    }
                ]
            },
            // Bottom bar with buttons
            {
                layout: "horizontal",
                class: "upload-button-bar",

                defaultConfig: {
                    height: 36,
                    margin: "0px 0px 0px 10px"
                },

                items: [
                    // Flex element to fill space
                    {
                        type: "spacer",
                        flex: 1
                    },
                    // Button to upload the files
                    {
                        hidden: true,

                        id: "upload-box-button",
                        type: "button",
                        text: txtTitleCase("Upload"),
                        icon: "fas fa-upload",
                        iconColor: "#ffffff",
                        iconColorHover: "#000000",
                        color: "#ffffff",
                        colorHover: "#000000",
                        backgroundColor: "#00aaee",
                        backgroundColorHover: "#ffffff",

                        action: () => $("file-upload").upload("box", function () {
                            $("upload-box-picker").show()
                            $("upload-box-gallery-help").hide()
                        })
                    },
                    // Switch to set public / private upload
                    {
                        hidden: true,
                        
                        id: "upload-box-ACL",
                        type: "checkbox",
                        iconColorOn: "var(--blue)",
                        iconOff: "fas fa-lock",
                        iconOn: "fas fa-lock-open",
                        width: 32
                    }
                ]
            }
        ],

        subscriptions: {
            /**
             * When Box.com redirects to /boxConnect route,
             * our server sends the valid token through WebSocket to the client which requested Box.com.
             * This subscription listens to this message and captures the token.
             */
            EVT_BOX_CODE: (msgData) => {
                localStorage.setItem("api-boxAccessToken", msgData.token)
                $("file-upload-box").showBoxFilePicker()
            }
        },

        methods: {
            /**
             * When loading the component, we check if the boxAccessToken already exists.
             * If yes, we check if the token is still valid.
             * If the token is valid, we use it immediately to display the Box file picker.
             * If not, we do nothing: the user has to log in to Box manually.
             */
            _afterShow: function () {
                let boxAccessToken = localStorage.getItem("api-boxAccessToken")
                if (!boxAccessToken) return

                // Try to fetch a file to test the token
                fetch(checkTokenUrl, {
                        method: "get",
                        headers: {
                            Authorization: "Bearer " + boxAccessToken
                        },
                    })
                    .then(() => {
                        // If it works, the token is still valid
                        this.showBoxFilePicker()
                    })
                    .catch(() => {
                        // Otherwise we do nothing (the user has to reconnect manually using the button)
                    })
            },

            /**
             * Open a new window to connect to Box.com
             */
            connect() {
				const height = 800,
					  width  = 500
	            const y = window.top.outerHeight / 2 + window.top.screenY - ( height / 2);
	            const x = window.top.outerWidth / 2 + window.top.screenX - ( width / 2);

				const win = window.open(
					boxAuthenticationUrl,
	                "BoxLogin",
	                `location,toolbar=no,menubar=no,fullscreen=no,`
	                + `height=${height}px,width=${width}px,top=${y},left=${x}`
				)

	            const timer = setInterval(() => {
					// This is a hack. As long as the window doesn't have the same origin
		            // as the current page, accessing win.document will throw an CORS error
		            // If no CORS errer is thrown, then we know we have been redirected on ui=box-session
					try{
						win.document
		            }catch(err){
			            return
		            }

					// Token not set yet, we must await window loading.
					if(!window.localStorage.getItem('api-boxAccessToken')) return

		            if(win.closed) this.showBoxFilePicker()
		            else{
			            // Ok we can attach the event and trigger
			            win.addEventListener("beforeunload", () => {
				            if(window.localStorage.getItem('api-boxAccessToken')){
					            this.showBoxFilePicker()
				            }
			            })

			            win.close()
		            }

					clearInterval(timer)
	            }, 500)

                return win
            },

            /**
             * Show the file picker
             */
            async showBoxFilePicker() {
                // Dynamically load the Box script
                if (!window.Box) {
                    const loadingId = kiss.loadingSpinner.show()
                    await kiss.loader.loadScript(BOX_COM_SELECT)
                    await kiss.loader.loadScript(BOX_COM_PICKER)
                    await kiss.loader.loadStyle(BOX_COM_PICKER_CSS)
                    kiss.loadingSpinner.hide(loadingId)
                }

                const FilePicker = Box.FilePicker

	            // Reset the gallery
	            $("upload-box-gallery-help").hide()
	            $("upload-box-gallery-items").innerHTML = " "

	            if(filePicker){
		            // Display the picker container
		            $("upload-box-picker").show()
		            return
	            }

                filePicker = new FilePicker({
                    container: ".upload-box-picker",
                })

                let boxAccessToken = localStorage.getItem("api-boxAccessToken")

                // Insert the picker into the DOM
                filePicker.show("0", boxAccessToken, {
                    container: ".upload-box-picker",
                    canUpload: false,
                    canCreateNewFolder: false,
                    canSetShareAccess: false,
                    logoUrl
                })

	            // Display the picker container
	            $("upload-box-picker").show()

                // Attach event listener for when the choose button is pressed
                filePicker.addListener("choose", function (items) {

                    $("upload-box-picker").hide()

                    kiss.ajax.request({
                            url: "/boxFileDetail",
                            method: "post",
                            body: JSON.stringify({
                                items: items,
                                token: boxAccessToken
                            })
                        })
                        .then(async response => {
                            // Build the result in the right format to be processed by the function "previewBase64File":
                            let files = response.result.map(file => {
                                return {
                                    data: {
                                        result: file.fileData,
                                        status: "success"
                                    },
                                    name: file.name
                                }
                            })

                            // Preview each element
                            files.forEach(file => $("file-upload").previewBase64File(file.data, file.name, "box"))
                        })
                })

                // Attach event listener for when the cancel button is pressed
                filePicker.addListener("cancel", function () {
	                $("upload-box-gallery-help").show()

	                // Display the picker container
	                $("upload-box-picker").hide()
                })
            }
        }
    })
}

;/**
 * Window to display the message about successful Box session
 * 
 * @ignore
 */
kiss.app.defineView({
    id: "box-session",
    renderer: function (id, target) {
        return createPanel({
            id,
            target,
            title: txtTitleCase("box.com"),
            icon: "fas fa-box",

            draggable: true,
            align: "center",
            verticalAlign: "center",

            items: [{
                type: "html",
                html: txt("<center>Thank you!<br>Your Box session has been restored.<br></center>"),
                padding: "50px"
            }],

            methods: {
                load: () => {
                    window.close()
                }
            }
        })
    }
})

;/**
 * 
 * Widget to upload files from Dropbox
 * 
 * @ignore
 */
const createFileUploadDropbox = function () {
    const DROPBOX_SRC = "https://www.dropbox.com/static/api/2/dropins"
    const DROPBOX_ID = "dropboxjs"
    // const DROPBOX_APP_KEY = "2tkajpbphy1m7dj"
    const DROPBOX_APP_KEY = "hfxz6unvbi6tfyp"

    const dropBoxOptions = {
        // Required. Called when a user selects an item in the file picker.
        success: function (files) {
            $("file-upload-dropbox").downloadFilesFromDropbox(files)
        },

        // Optional. Called when the user closes the dialog without selecting a file and does not include any parameters.
        cancel: function () {
            log('Attach file request cancelled by the user')
        },

        // Optional. "preview" (default) is a preview link to the document for sharing,
        // "direct" is an expiring link to download the contents of the file.
        // For more information about link types, see Dropbox link types.
        linkType: "direct",

        // Optional. A value of false (default) limits selection to a single file,
        // while true enables multiple file selection.
        multiselect: true,

        // Optional. This is a list of file extensions. If specified, the user will
        // only be able to select files with these extensions. You may also specify
        // file types, such as "video" or "images" in the list. For more information,
        // see File types below. By default, all extensions are allowed.
        // extensions: ['.pdf', '.doc', '.docx','.jpeg','.png','.jpg'],

        // Optional. A limit on the size of each file that may be selected, in bytes.
        // If specified, the user will only be able to select files with size
        // less than or equal to this limit.
        // For the purposes of this option, folders have size zero.
        sizeLimit: 1024 * 1024 * 8, // 8Mb
    }

    return createBlock({
        id: "file-upload-dropbox",
        flex: 1,
        layout: "vertical",
        items: [
            // Hidden upload button to submit the files
            {
                hidden: true,
                type: "html",
                html: /*html*/ `<input id="field-upload-dropbox" type="file" multiple>`
            },
            // BLock to display the list of files
            {
                id: "upload-dropbox-gallery",
                layout: "vertical",
                alignItems: "center",
                overflow: "auto",
                flex: 1,
                class: "upload-gallery",

                items: [
                    // Html to display the help message
                    {
                        id: "upload-dropbox-gallery-help",
                        type: "html",
                        margin: "auto",
                        html: txtTitleCase("#upload drive help", null, {drive: "Dropbox"}) +
                            `<br>` +
                            `<center><div id="dropbox-btn" class="upload-dropbox-button"></div></center>`
                    },
                    // Block to display the selected files
                    {
                        id: "upload-dropbox-gallery-items",
                        class: "upload-gallery-items"
                    }
                ]
            },
            // Bottom bar with buttons
            {
                layout: "horizontal",
                class: "upload-button-bar",

                defaultConfig: {
                    height: 36,
                    margin: "0px 0px 0px 10px"
                },

                items: [
                    // Flex element to fill space
                    {
                        type: "spacer",
                        flex: 1
                    },
                    // Button to upload the files
                    {
                        hidden: true,
                        
                        id: "upload-dropbox-button",
                        type: "button",
                        text: txtTitleCase("Upload"),
                        icon: "fas fa-upload",
                        iconColor: "#ffffff",
                        iconColorHover: "#000000",
                        color: "#ffffff",
                        colorHover: "#000000",
                        backgroundColor: "#00aaee",
                        backgroundColorHover: "#ffffff",
                        action: () => $("file-upload").upload("dropbox")
                    },
                    // Switch to set public / private upload
                    {
                        hidden: true,
                        
                        id: "upload-dropbox-ACL",
                        type: "checkbox",
                        iconColorOn: "var(--blue)",
                        iconOff: "fas fa-lock",
                        iconOn: "fas fa-lock-open",
                        width: 32
                    }
                ]
            }
        ],

        methods: {
            /**
             * Insert the Dropbox button when loading the component
             */
            _afterShow: async function () {
                // Dynamically load the DropBox script
                if (!window.Dropbox) {
                    const loadingId = kiss.loadingSpinner.show()
                    await kiss.loader.loadScript(DROPBOX_SRC, {
                        id: DROPBOX_ID,
                        "data-app-key": DROPBOX_APP_KEY
                    })
                    kiss.loadingSpinner.hide(loadingId)
                }
                const dropBoxButton = Dropbox.createChooseButton(dropBoxOptions)
                $("dropbox-btn").appendChild(dropBoxButton)
            },

            /**
             * Download multiple files from Dropbox
             */
            downloadFilesFromDropbox(filesData) {
                filesData.forEach(fileData => this.downloadFileFromDropbox(fileData))
            },

            /**
             * Download one file from DropBox
             */
            async downloadFileFromDropbox(fileObject) {
                const fileName = fileObject.link.split('/').pop()

                kiss.ajax.request({
                    url: "/urlToBase64",
                    method: "post",
                    showLoading: true,
                    body: JSON.stringify({
                        url: fileObject.link
                    })
                })
                .then(async data => $("file-upload").previewBase64File(data, fileName, "dropbox"))
                .catch((err) => console.log("File upload: ", err))        
            }
        }
    })
}

;/**
 * 
 * Widget to upload files from Google Drive
 * 
 * @ignore
 */
const createUploadGoogleDrive = function () {
    const GOOGLE_AUTH_SRC = "https://accounts.google.com/gsi/client"
    const GOOGLE_DRIVE_SRC = "https://apis.google.com/js/api"
    const scope = 'https://www.googleapis.com/auth/drive.readonly'

	const appId = "pickaform-apps-1668670210366";
	const client_id = "325367213155-k97e6u17n0jq2185f8gnju04qs4afos3.apps.googleusercontent.com"

	let tokenClient
	let accessToken = null
	let pickerInitialized = false
	let driveInitialized = false
	let gisInitialized = false

	function apiLoaded(){
		gapi.load('picker', onPickerApiLoad)
		gapi.load('client', onClientLoaded)
	}

	function onPickerApiLoad() {
		pickerInitialized = true
	}

	function onClientLoaded(){
		gapi.client.load('drive', 'v2', onDriveApiLoad)
	}

	function onDriveApiLoad(){
		driveInitialized = true
	}

	function gisLoaded(){
		tokenClient = google.accounts.oauth2.initTokenClient({
			client_id,
			scope,
			callback: ''
		})

		gisInitialized = true
	}

    return createBlock({
        id: "file-upload-googledrive",
        flex: 1,
        layout: "vertical",
        items: [
            // Hidden upload button to submit the files
            {
                hidden: true,
                type: "html",
                html: /*html*/ `<input id="field-upload-googledrive" type="file" multiple>`
            },
            // BLock to display the list of files
            {
                id: "upload-googledrive-gallery",
                layout: "vertical",
                alignItems: "center",
                overflow: "auto",
                flex: 1,
                class: "upload-gallery",

                items: [
                    // Html to display the help message
                    {
                        id: "upload-googledrive-gallery-help",
                        type: "html",
                        margin: "auto",
                        html: txtTitleCase("#upload drive help", null, {drive: "Google Drive"}) +
                            `<br>` +
                            `<center><button class="a-button box-authentication-button" onclick="$('file-upload-googledrive').connect()">${txtTitleCase('connect to your %drive account', null, {drive: "Google Drive"})}</button></center>`
                    },
                    // Block to display the selected files
                    {
                        id: "upload-googledrive-gallery-items",
                        class: "upload-gallery-items"
                    },
                ]
            },
            // Bottom bar with buttons
            {
                layout: "horizontal",
                class: "upload-button-bar",

                defaultConfig: {
                    height: 36,
                    margin: "0px 0px 0px 10px"
                },

                items: [
                    // Flex element to fill space
                    {
                        type: "spacer",
                        flex: 1
                    },
                    // Button to upload the files
                    {
                        hidden: true,

                        id: "upload-googledrive-button",
                        type: "button",
                        text: txtTitleCase("Upload"),
                        icon: "fas fa-upload",
                        iconColor: "#ffffff",
                        iconColorHover: "#000000",
                        color: "#ffffff",
                        colorHover: "#000000",
                        backgroundColor: "#00aaee",
                        backgroundColorHover: "#ffffff",

                        action: () => $("file-upload").upload("googledrive")
                    },
                    // Switch to set public / private upload
                    {
                        hidden: true,
                        
                        id: "upload-googledrive-ACL",
                        type: "checkbox",
                        iconColorOn: "var(--blue)",
                        iconOff: "fas fa-lock",
                        iconOn: "fas fa-lock-open",
                        width: 32
                    }
                ]
            }
        ],

        methods: {
            /**
             * Load the google picker and drive scope
             */
            _afterShow: async function () {
                // Dynamically load the Google Drive script
                if (!window.google) {
                    const loadingId = kiss.loadingSpinner.show()
                    await kiss.loader.loadScript(GOOGLE_AUTH_SRC, {
                        autoAddExtension: false
                    })
	                await kiss.loader.loadScript(GOOGLE_DRIVE_SRC)
	                kiss.loadingSpinner.hide(loadingId)
                }

                apiLoaded()
	            gisLoaded()
            },

	        showPicker(){
		        const view = new google.picker.DocsView(google.picker.ViewId.DOCS)
		        const mimeTypeArray = [
			        "image/png",
			        "image/jpeg",
			        "image/jpg",
			        "application/msword",
			        "application/pdf",
			        "text/xml",
			        "application/vnd.ms-excel",
			        "text/plain",
			        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
			        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
			        "application/vnd.ms-powerpoint"
		        ]

		        view
			        .setIncludeFolders(true)
			        .setSelectFolderEnabled(false)
			        .setMimeTypes(mimeTypeArray)

		        const picker = new google.picker.PickerBuilder()
			        .enableFeature(google.picker.Feature.NAV_HIDDEN)
			        .enableFeature(google.picker.Feature.MULTISELECT_ENABLED)
			        .setOAuthToken(accessToken)
			        .setAppId(appId)
			        .addView(view)
			        .setCallback(this.pickerCallback)
			        .build()
		        picker.setVisible(true)
			},

	        connect(){
				this.createPicker()
	        },

	        createPicker(){
		        tokenClient.callback = async response => {
			        if(response.error !== undefined) throw response

			        accessToken = response.access_token
			        this.showPicker()
		        }

				if(accessToken === null){
					// No session, user should choose an account
					tokenClient.requestAccessToken({ prompt: 'consent' })
				}else{
					// There is already a session, so no need to ask to choose an account
					tokenClient.requestAccessToken({ prompt: '' })
				}
	        },

            // A simple callback implementation.
            async pickerCallback(data) {
                if (data.action == google.picker.Action.PICKED) {
                    // Getting the file object from file Id 
                    let allDocumentData = await Promise.all((data.docs).map(async doc => {
                        return await $("file-upload-googledrive").getFilesObject(doc)
                    }))

                    // Function to set selected files into input field of type file
                    $("file-upload").fileSetter(allDocumentData, "googledrive")

                    // Preview Google Drive Data 
                    $("file-upload").previewFiles(allDocumentData, "googledrive")
                }
            },

            // Get File object using file Ids
            async getFilesObject(files) {
                let res = await window.gapi.client.drive.files.get({
                    fileId: files.id,
                    alt: "media",
                })
                const dataUrl = "data:" + res.headers["Content-Type"] + ";base64," + window.btoa(res.body)
                return $("file-upload").dataURLtoFile(dataUrl, files.name)
            }
        }
    })
}

;/**
 * 
 * Widget to upload files from instagram
 * 
 * @ignore
 */
const createFileUploadInstagram = function () {
    // Instagram optional details
    const instagramOption = {
        baseUrl: "https://api.instagram.com/oauth/authorize",
        clientId: "3985518578229875",
        redirectUrl: "https://449abdd7f2cf.ngrok.io/instagramOauth", // replace it with your redirect url here
        nextPage: "",
        images: []
    }

    return createBlock({
        id: "file-upload-instagram",
        flex: 1,
        layout: "vertical",
        items: [
            // Hidden upload button to submit the files
            {
                hidden: true,
                type: "html",
                html: /*html*/ `<input id="field-upload-instagram" type="file" multiple>`
            },

            // BLock to display the list of files
            {
                id: "upload-instagram-gallery",
                layout: "vertical",
                alignItems: "center",
                overflow: "auto",
                flex: 1,
                class: "upload-gallery",

                items: [
                    // Html to display the help message
                    {
                        id: "upload-instagram-gallery-help",
                        type: "html",
                        margin: "auto",
                        html: txtTitleCase("#upload drive help", null, {drive: "Instagram"}) +
                            `<br>` +
                            `<center><button class="a-button box-authentication-button" onclick="$('file-upload-instagram').connect()">${txtTitleCase('connect to your %drive account', null, {drive: "Instagram"})}</button></center>`
                    },
                    // Block to preview the search result and select some images
                    {
                        hidden: true,
                        id: "upload-instagram-preview-items",
                        class: "upload-preview-items"
                    },
                    // Block to display the selected files
                    {
                        id: "upload-instagram-gallery-items",
                        class: "upload-gallery-items"
                    },
                ]
            },
            // Bottom bar with buttons
            {
                layout: "horizontal",
                class: "upload-button-bar",

                defaultConfig: {
                    height: 36,
                    margin: "0px 0px 0px 10px"
                },

                items: [
                    // Flex element to fill space
                    {
                        type: "spacer",
                        flex: 1
                    },
                    // Button to select the files
                    {
                        hidden: true,
                        id: "load-instagram-button",
                        type: "button",
                        text: txtTitleCase("Load more files"),
                        icon: "fas fa-plus",
                        iconColorHover: "#00aaee",
                        action: (event) => $("file-upload-instagram").loadMoreFiles(event)
                    },
                    {
                        hidden: true,
                        id: "add-instagram-button",
                        type: "button",
                        text: txtTitleCase("Add files from Instagram"),
                        icon: "fas fa-plus",
                        iconColorHover: "#00aaee",
                        action: (event) => $("file-upload-instagram").addImagesFromInstagram(event)
                    },
                    // Button to upload the files
                    {
                        hidden: true,

                        id: "upload-instagram-button",
                        type: "button",
                        text: txtTitleCase("Upload"),
                        icon: "fas fa-upload",
                        iconColor: "#ffffff",
                        iconColorHover: "#000000",
                        color: "#ffffff",
                        colorHover: "#000000",
                        backgroundColor: "#00aaee",
                        backgroundColorHover: "#ffffff",

                        action: () => $("file-upload").upload("instagram")
                    },
                    // Switch to set public / private upload
                    {
                        hidden: true,
                        
                        id: "upload-instagram-ACL",
                        type: "checkbox",
                        iconColorOn: "var(--blue)",
                        iconOff: "fas fa-lock",
                        iconOn: "fas fa-lock-open",
                        width: 32
                    }
                ]
            }
        ],

        subscriptions: {
            /**
             * When Instagram Auth redirects to /instagramOauth route,
             * our server sends the valid token through WebSocket to the client which requested Instagram.
             * This subscription listens to this message and captures the token.
             */
            EVT_INSTAGRAM_CODE: (msgData) => {
                localStorage.setItem("api-instagramAccessToken", msgData.token)
                $("file-upload-instagram").getInstagramFeeds()
            }
        },

        methods: {
            /**
             * Open a new window to connect to Instagram
             */
            connect() {
                let boxAccessToken = localStorage.getItem("api-instagramAccessToken")
                if (!boxAccessToken) return window.open("https://api.instagram.com/oauth/authorize?client_id=" + instagramOption.clientId + "&scope=user_profile,user_media&response_type=code&state=" + kiss.session.getUserId() + "&redirect_uri=" + instagramOption.redirectUrl, "_blank")

                $("file-upload-instagram").getInstagramFeeds()
            },

            getInstagramFeeds() {
                let instagramAccessToken = localStorage.getItem("api-instagramAccessToken")

                fetch("/instagramMedia", {
                        method: "post",
                        body: JSON.stringify({
                            access_token: instagramAccessToken
                        })
                    })
                    .then(response => response.json())
                    .then((response) => {
                        if (response.result) {
                            const dataset = response.result.data
                            if (response.result.paging && response.result.paging.next) {
                                instagramOption.nextPage = response.result.paging.next
                                $("load-instagram-button").show()
                            }
                            dataset.map((i) => (instagramOption.images).push(i))

                            $("upload-instagram-preview-items").show()
                            $("add-instagram-button").show()
                            $("upload-instagram-gallery-items").hide()

                            const preview = (instagramOption.images).map(this.buildImagePreview).join("")

                            $("upload-instagram-preview-items").setInnerHtml(preview)
                            $("upload-instagram-gallery-help").hide()
                        }
                    })
                    .catch((err) => ("Something went wrong please check and try again.", err))
            },

            /**
             * Build a single image preview
             */
            buildImagePreview(file) {
                if (file.media_type == "VIDEO") {
                    return `<video controls src="${file.media_url}" class="upload-preview-item" onclick="$('file-upload-instagram').selectImagePreview(event)"><source src="${file.media_url}"></video>`
                } else {
                    return `<img src="${file.media_url}" class="upload-preview-item" onclick="$('file-upload-instagram').selectImagePreview(event)" loading="lazy">`
                }
            },

            /**
             * Select an image preview
             */
            selectImagePreview(event) {
                const image = event.target
                image.classList.toggle("upload-instagram-item-selected")
            },

            /**
             * Add the selected images to the list of files to upload
             */
            addImagesFromInstagram(event) {
                event.preventDefault()

                const token = kiss.session.getToken()
                const selectedImages = document.querySelectorAll(".upload-instagram-item-selected")
                const images = [...selectedImages].map(image => {
                    var fileName = (image.getAttribute("src")).split("/").pop()
                    fileName = fileName.split("?")[0]
                    return {
                        image: image.getAttribute("src"),
                        name: fileName
                    }
                })

                kiss.ajax.request({
                    url: "/multiUrlToBase64",
                    method: "post",
                    showLoading: true,
                    body: JSON.stringify({
                        url: images
                    })
                })
                .then(async response => {
                    $("upload-instagram-preview-items").hide()
                    $("add-instagram-button").hide()
                    $("upload-instagram-gallery-items").show()
                    
                    allDocumentData = response.result
                    allDocumentData.forEach(data => $("file-upload").previewBase64File({
                        result: data.fileData,
                        status: "success"
                    }, data.name, "instagram"))
                })
                .catch((err) => ("Error occured ", err))
            },

            /**
             * Load More Instagram Files
             */
            loadMoreFiles(event) {
                event.preventDefault()

                fetch(instagramOption.nextPage, {
                        method: "get",
                    })
                    .then(response => response.json())
                    .then((response) => {
                        const dataset = response.data
                        paging = response.paging

                        if (response.paging && response.paging.next) {
                            instagramOption.nextPage = response.paging.next
                            $("load-instagram-button").show()
                        } else {
                            instagramOption.nextPage = ""
                            $("load-instagram-button").hide()
                        }

                        dataset.map((i) => (instagramOption.images).push(i))

                        const preview = (instagramOption.images).map(this.buildImagePreview).join("")
                        $("upload-instagram-preview-items").setInnerHtml(preview)
                    })
                    .catch((err) => ("Something went wrong please check and try again.", err))
            }
        }
    })
}

;/**
 * Window to display the message about successful Instagram session
 * 
 * @ignore
 */
kiss.app.defineView({
    id: "instagram-session",
    renderer: function (id, target) {
        return createPanel({
            id,
            target,
            title: txtTitleCase("instagram.com"),
            icon: "fas fa-instagram",

            draggable: true,
            align: "center",
            verticalAlign: "center",

            items: [{
                type: "html",
                html: txt("<center>Thank you!<br>Your instagram session has been restored.<br>You can close this page.</center>"),
                padding: "50px"
            }]
        })
    }
})

;/**
 * 
 * Widget to upload files from an URL link
 * 
 * @ignore
 */
const createFileUploadLink = function () {
    return createBlock({
        id: "file-upload-link",
        flex: 1,
        layout: "vertical",
        items: [
            // Hidden upload button to submit the files
            {
                hidden: true,
                type: "html",
                html: /*html*/ `<input id="field-upload-link" type="file" multiple>`
            },
            // BLock to display the list of files
            {
                id: "upload-link-gallery",
                layout: "vertical",
                alignItems: "center",
                overflow: "auto",
                flex: 1,
                class: "upload-gallery",
                
                items: [
                    // Html to display the help message
                    {
                        id: "upload-link-gallery-help",
                        type: "html",
                        margin: "auto",
                        html: txtTitleCase("#upload link help")
                    },
                    // Block to display the selected files
                    {
                        id: "upload-link-gallery-items",
                        class: "upload-gallery-items"
                    }
                ]
            },
            // Bottom bar with buttons
            {
                layout: "horizontal",
                class: "upload-button-bar",

                defaultConfig: {
                    height: 36,
                    margin: "0px 0px 0px 10px"
                },

                items: [
                    // Text to copy/paste the link
                    {
                        id: "upload-link-url",
                        type: "text",
                        placeholder: txtTitleCase("enter an URL here"),
                        padding: "0px",
                        fieldWidth: 300
                    },
                    // Button to select the files
                    {
                        type: "button",
                        text: txtTitleCase("add file from URL"),
                        icon: "fas fa-link",
                        iconColorHover: "#00aaee",
                        action: function (event) {
                            $("file-upload-link").downloadFileFromUrl(event)
                            $("upload-link-url").setValue("")
                        }
                    },
                    {
                        type: "spacer",
                        flex: 1
                    },
                    // Button to upload the files
                    {
                        hidden: true,

                        id: "upload-link-button",
                        type: "button",
                        text: txtTitleCase("upload"),
                        icon: "fas fa-upload",
                        iconColor: "#ffffff",
                        iconColorHover: "#000000",
                        color: "#ffffff",
                        colorHover: "#000000",
                        backgroundColor: "#00aaee",
                        backgroundColorHover: "#ffffff",
                        action: () => $("file-upload").upload("link")
                    },
                    // Switch to set public / private upload
                    {
                        hidden: true,
                        
                        id: "upload-link-ACL",
                        type: "checkbox",
                        iconColorOn: "var(--blue)",
                        iconOff: "fas fa-lock",
                        iconOn: "fas fa-lock-open",
                        width: 32
                    }
                ]
            }
        ],

        methods: {

            /**
             * Download the list of selected files
             */
            downloadFileFromUrl(event) {
                event.preventDefault()

                const ImageUrl = $("upload-link-url").getValue()
                if (!ImageUrl) return

                const fileName = ImageUrl.split('/').pop()

                kiss.ajax.request({
                    url: "/urlToBase64",
                    method: "post",
                    showLoading: true,
                    body: JSON.stringify({
                        url: ImageUrl
                    })
                })
                .then(async data => $("file-upload").previewBase64File(data, fileName, "link"))
                .catch((err) => console.log("File upload: ", err))
            }
        }
    })
}

;/**
 * 
 * Widget to upload files from the local device
 * 
 * @ignore
 */
const createFileUploadLocal = function () {
    return createBlock({
        id: "file-upload-local",
        flex: 1,
        layout: "vertical",
        items: [
            // Hidden upload button to submit the files
            {
                hidden: true,
                type: "html",
                html: /*html*/ `<input id="field-upload-local" type="file" multiple onchange="$('file-upload').previewFiles(this.files, 'local')">`
            },
            // Gallery block
            {
                id: "upload-local-gallery",
                layout: "vertical",
                overflow: "auto",
                alignItems: "center",
                flex: 1,
                class: "upload-gallery",

                items: [
                    // Html to display the help message
                    {
                        id: "upload-local-gallery-help",
                        type: "html",
                        display: "flex",
                        flexFlow: "column",
                        alignItems: "center",
                        justifyContent: "flex-end",
                        flex: 1,
                        html: (kiss.screen.isMobile) ? txtTitleCase("#upload local help mobile") : txtTitleCase("#upload local help")
                    },
                    // Block to display the selected files
                    {
                        id: "upload-local-gallery-items",
                        class: "upload-gallery-items"
                    }
                ],

                // Drag'n drop events
                events: {
                    dragover: function (e) {
                        e.preventDefault()
                        this.classList.add("upload-gallery-dragover")
                    },
                    dragleave: function () {
                        this.classList.remove("upload-gallery-dragover")
                    },
                    drop: function (e) {
                        e.preventDefault()
                        this.classList.remove("upload-gallery-dragover")
                        $("file-upload-local").handleDrop(e)
                    }
                },
            },

            // Bottom bar with buttons
            {
                layout: (kiss.screen.isMobile) ? "vertical" : "horizontal",
                class: "upload-button-bar",
                
                defaultConfig: {
                    margin: "10px 10px 0px 0px",
                    iconColorHover: "#00aaee"
                },
                
                items: [
                    // Flex element to fill space
                    {
                        type: "spacer",
                        flex: 1
                    },
                    // Button to select the files
                    {
                        type: "button",
                        text: txtTitleCase("select files to upload"),
                        icon: "fas fa-file-alt",
                        action: () => $("field-upload-local").click()
                    },
                    {
                        layout: "horizontal",
                        width: "100%",
                        items: [
                            // Button to upload the files
                            {
                                hidden: true,
                                id: "upload-local-button",
                                type: "button",
                                text: txtTitleCase("Upload"),
                                icon: "fas fa-upload",
                                iconColor: "#ffffff",
                                iconColorHover: "#000000",
                                color: "#ffffff",
                                colorHover: "#000000",
                                backgroundColor: "#00aaee",
                                backgroundColorHover: "#ffffff",
                                flex: 1,
                                action: () => $("file-upload").upload("local")
                            },
                            // Switch to set public / private upload
                            {
                                hidden: true,
                                id: "upload-local-ACL",
                                type: "checkbox",
                                tip: txtTitleCase("#upload security mode"),
                                iconColorOn: "var(--blue)",
                                iconOff: "fas fa-lock",
                                iconOn: "fas fa-lock-open",
                                width: 50
                            }
                        ]
                    }

                ]
            }
        ],

        methods: {

            /**
             * Handle files after drag'n drop event
             * 
             * @param {object} event - The drop event
             */
            handleDrop: function (event) {
                const files = event.dataTransfer.files
                $("field-upload-local").files = files
                $("file-upload").previewFiles(files, "local")
            }
        }
    })
}

;/**
 * 
 * Widget to upload files from Microsoft One Drive
 * 
 * @ignore
 */
const createFileUploadOneDrive = function () {
    const oneDriveOption = {
        clientId: "9f2e6664-61f3-412b-b1ea-5aa4c7411876",
        action: "download",
        multiSelect: true,
        redirectUri: window.location.host + "/fake",
        openInNewWindow: true,
        advanced: {
            queryParameters: "select=id,name,size,file,folder,photo,@microsoft.graph.downloadUrl"
        },

        // Required. Called when a user selects an item in the file picker.
        success: function (files) {
            $("file-upload-onedrive").downloadFilesFromOneDrive(files.value)
        }
    }

    return createBlock({
        id: "file-upload-onedrive",
        flex: 1,
        layout: "vertical",
        items: [
            // Hidden upload button to submit the files
            {
                hidden: true,
                type: "html",
                html: /*html*/ `<input id="field-upload-onedrive" type="file" multiple>`
            },

            // BLock to display the list of files
            {
                id: "upload-onedrive-gallery",
                layout: "vertical",
                alignItems: "center",
                overflow: "auto",
                flex: 1,
                class: "upload-gallery",

                items: [
                    // Html to display the help message
                    {
                        id: "upload-onedrive-gallery-help",
                        type: "html",
                        margin: "auto",
                        html: txtTitleCase("#upload drive help", null, {drive: "One Drive"}) +
                            `<br>` +
                            `<center><button class="a-button box-authentication-button" onclick="$('file-upload-onedrive').connect()">${txtTitleCase('connect to your %drive account', null, {drive: "One Drive"})}</button></center>`
                    },
                    // Block to display the selected files
                    {
                        id: "upload-onedrive-gallery-items",
                        class: "upload-gallery-items"
                    },
                ]
            },
            // Bottom bar with buttons
            {
                layout: "horizontal",
                class: "upload-button-bar",

                defaultConfig: {
                    height: 36,
                    margin: "0px 0px 0px 10px"
                },

                items: [
                    // Flex element to fill space
                    {
                        type: "spacer",
                        flex: 1
                    },
                    // Button to upload the files
                    {
                        hidden: true,

                        id: "upload-onedrive-button",
                        type: "button",
                        text: txtTitleCase("Upload"),
                        icon: "fas fa-upload",
                        iconColor: "#ffffff",
                        iconColorHover: "#000000",
                        color: "#ffffff",
                        colorHover: "#000000",
                        backgroundColor: "#00aaee",
                        backgroundColorHover: "#ffffff",

                        action: () => $("file-upload").upload("onedrive")
                    },
                    // Switch to set public / private upload
                    {
                        hidden: true,
                        
                        id: "upload-onedrive-ACL",
                        type: "checkbox",
                        iconColorOn: "var(--blue)",
                        iconOff: "fas fa-lock",
                        iconOn: "fas fa-lock-open",
                        width: 32
                    }
                ]
            }
        ],

        methods: {
            /**
             * Open a new window to connect to OneDrive.com
             */
            async connect() {
                const ONE_DRIVE_SRC = "https://js.live.net/v7.0/OneDrive"

                // Dynamically load the OneDrive script
                if (!window.OneDrive) {
                    const loadingId = kiss.loadingSpinner.show()
                    await kiss.loader.loadScript(ONE_DRIVE_SRC)
                    kiss.loadingSpinner.hide(loadingId)
                }

                setTimeout(() => OneDrive.open(oneDriveOption), 500)
            },

            /**
             * Download multiple files from one drive
             */
            downloadFilesFromOneDrive(filesData) {
                let selectedImage = []
                for (let files of filesData) {
                    selectedImage.push({
                        image: files["@microsoft.graph.downloadUrl"],
                        thumb: files.thumbnails[0].medium["url"],
                        name: files.name
                    })
                }

                // Fetch the base64 data by image url
                kiss.ajax.request({
                    url: "/multiUrlToBase64",
                    method: "post",
                    showLoading: true,
                    body: JSON.stringify({
                        url: selectedImage
                    })
                })
                .then(async response => {
                    allDocumentData = response.result
                    allDocumentData.forEach(data => $("file-upload").previewBase64File({
                        result: data.fileData,
                        status: "success"
                    }, data.name, "onedrive"))
                })
                .catch((err) => ("Error occured ", err))            
            }
        }
    })
}

;/**
 * 
 * Widget to upload files from Webcam
 * 
 * @ignore
 */
const createFileUploadTakePhoto = function () {
    return createBlock({
        id: "file-upload-takephoto",
        flex: 1,
        layout: "vertical",
        items: [
            // Hidden upload button to submit the files
            {
                hidden: true,
                type: "html",
                html: /*html*/ `<input id="field-upload-takephoto" type="file" multiple>`
            },

            // BLock to display the list of files
            {
                id: "upload-takephoto-gallery",
                layout: "vertical",
                alignItems: "center",
                overflow: "auto",
                flex: 1,
                class: "upload-gallery",

                items: [
                    // Html to display the help message
                    {
                        id: "upload-takephoto-gallery-help",
                        type: "html",
                        margin: "auto",
                        html: txtTitleCase("#upload webcam help")
                    },
                    {
                        id: "upload-takephoto"
                    },
                    // Block to preview the search result and select some images
                    {
                        id: "upload-takephoto-preview-items",
                        class: "upload-preview-items"
                    },
                    // Block to display the selected files
                    {
                        id: "upload-takephoto-gallery-items",
                        class: "upload-gallery-items"
                    },
                ]
            },
            // Bottom bar with buttons
            {
                layout: "horizontal",
                class: "upload-button-bar",

                defaultConfig: {
                    height: 36,
                    margin: "0px 0px 0px 10px"
                },

                items: [
                    // Flex element to fill space
                    {
                        type: "spacer",
                        flex: 1
                    },
                    // Open Webcam Button
                    {
                        type: "button",
                        text: txtTitleCase("open webcam"),
                        icon: "fas fa-camera",
                        iconColorHover: "#00aaee",
                        action: async function () {
                            $("upload-takephoto-gallery-help").hide()
                            await $("file-upload-takephoto").connect()
                            $("upload-takephoto").show()
                            $("upload-takephoto-gallery-items").hide()
                        }
                    },
                    // Add Webcam Image Button
                    {
                        type: "button",
                        text: txtTitleCase("#take photo"),
                        icon: "fas fa-plus",
                        iconColorHover: "#00aaee",
                        action: async function () {
                            await $("file-upload-takephoto").addImagesFromWebConnect()
                            $("upload-takephoto").hide()
                            $("upload-takephoto-gallery-items").show("")
                        }
                    },
                    // Button to upload the files
                    {
                        hidden: true,

                        id: "upload-takephoto-button",
                        type: "button",
                        text: txtTitleCase("Upload"),
                        icon: "fas fa-upload",
                        iconColor: "#ffffff",
                        iconColorHover: "#000000",
                        color: "#ffffff",
                        colorHover: "#000000",
                        backgroundColor: "#00aaee",
                        backgroundColorHover: "#ffffff",
                        action: () => $("file-upload").upload("takephoto")
                    },
                    // Switch to set public / private upload
                    {
                        hidden: true,
                        
                        id: "upload-takephoto-ACL",
                        type: "checkbox",
                        iconColorOn: "var(--blue)",
                        iconOff: "fas fa-lock",
                        iconOn: "fas fa-lock-open",
                        width: 32
                    }
                ]
            }
        ],
        methods: {
            // Function to connect webcam
            async connect() {
                
                // Dynamically load the webcam script
                if (!window.Webcam) {
                    const loadingId = kiss.loadingSpinner.show()
                    await kiss.loader.loadScript("./resources/webcam/webcam.min")
                    kiss.loadingSpinner.hide(loadingId)
                }

                Webcam.set({
                    width: 450,
                    height: 400,
                    image_format: "jpeg",
                    jpeg_quality: 90
                });
                Webcam.attach($("upload-takephoto"));
            },

            // Function to add image from webcam
            async addImagesFromWebConnect() {
                if (!window.Webcam) {
                    const loadingId = kiss.loadingSpinner.show()
                    await kiss.loader.loadScript("./resources/webcam/webcam.min")
                    kiss.loadingSpinner.hide(loadingId)
                }

                // take snapshot and get image data
                Webcam.snap(function (data_uri) {
                    Webcam.reset($("upload-takephoto"))
                    $("file-upload").previewBase64File({ result: data_uri, status: "success" }, Date.now() + "capture.jpeg", "takephoto");
                });
            },
        }
    })
}

;/**
 * 
 * Widget to upload images from a web search
 * 
 * @ignore
 */
const createFileUploadWebSearch = function () {
    return createBlock({
        id: "file-upload-websearch",
        flex: 1,
        layout: "vertical",
        items: [
            // Hidden upload button to submit the files
            {
                hidden: true,
                type: "html",
                html: /*html*/ `<input id="field-upload-websearch" type="file" multiple>`
            },
            // BLock to display the list of files
            {
                id: "upload-websearch-gallery",
                layout: "vertical",
                alignItems: "center",
                overflow: "auto",
                flex: 1,
                class: "upload-gallery",
                
                items: [
                    // Html to display the help message
                    {
                        id: "upload-websearch-gallery-help",
                        type: "html",
                        margin: "auto",
                        html: txtTitleCase("#upload web search help")
                    },
                    // Block to preview the search result and select some images
                    {
                        id: "upload-websearch-preview-items",
                        class: "upload-preview-items"
                    },
                    // Block to display the selected files
                    {
                        id: "upload-websearch-gallery-items",
                        class: "upload-gallery-items"
                    }
                ]
            },
            // Bottom bar with buttons
            {
                layout: "horizontal",
                class: "upload-button-bar",

                defaultConfig: {
                    height: 36,
                    margin: "0px 0px 0px 10px"
                },

                items: [
                    // Text to enter the web search
                    {
                        id: "upload-websearch-url",
                        type: "text",
                        placeholder: txtTitleCase("enter your search term and press Enter"),
                        padding: "0px",
                        fieldWidth: 300,
                        events: {
                            onkeypress: function (event) {
                                if (event.key == "Enter") {
                                    $("file-upload-websearch").downloadFileFromWebSearch(event)
                                    $("upload-websearch-preview-items").show()
                                    $("upload-websearch-gallery-items").hide()
                                    $("upload-websearch-url").setValue("")
                                }
                            }
                        }
                    },
                    // Button to select the files
                    {
                        type: "button",
                        text: txtTitleCase("add images from Web search"),
                        icon: "fas fa-plus",
                        iconColorHover: "#00aaee",
                        action: (event) => $("file-upload-websearch").addImagesFromWebSearch(event)
                    },
                    {
                        type: "spacer",
                        flex: 1
                    },
                    // Button to upload the files
                    {
                        hidden: true,

                        id: "upload-websearch-button",
                        type: "button",
                        text: txtTitleCase("upload"),
                        icon: "fas fa-upload",
                        iconColor: "#ffffff",
                        iconColorHover: "#000000",
                        color: "#ffffff",
                        colorHover: "#000000",
                        backgroundColor: "#00aaee",
                        backgroundColorHover: "#ffffff",
                        action: () =>$("file-upload").upload("websearch")
                    },
                    // Switch to set public / private upload
                    {
                        hidden: true,
                        
                        id: "upload-websearch-ACL",
                        type: "checkbox",
                        iconColorOn: "var(--blue)",
                        iconOff: "fas fa-lock",
                        iconOn: "fas fa-lock-open",
                        width: 32
                    }
                ]
            }
        ],

        methods: {

            /**
             * Download the list of selected files
             */
            async downloadFileFromWebSearch(event) {
                event.preventDefault()

                const search = $("upload-websearch-url").getValue()
                if (!search) return

                $("upload-websearch-gallery").showLoading()

	            try{
		            const response = await kiss.ajax.request({
			            url: "/googleImageSearch",
			            method: 'post',
			            body: JSON.stringify({ search })
		            });

		            if(!response) return;

					console.log(response)
		            const webImages = (response.result || []).map((item) => {
			            return {
				            "url": item.link,
				            "thumbnail": item.image.thumbnailLink,
				            "snippet": item.title,
				            "context": item.image.contextLink
			            }
		            })

		            const preview = webImages.map(this.buildImagePreview).join("")
		            $("upload-websearch-preview-items").setInnerHtml(preview)
	            }catch(err){
					log('kiss.fileUpload.googleWebSearch - Error while trying to upload file: ', 4, err)
	            } finally {
		            $("upload-websearch-gallery").hideLoading()
		            $("upload-websearch-gallery-help").hide()
				}
            },

            /**
             * Build a single image preview
             */
            buildImagePreview(file) {
                return `<img src="${file.thumbnail}" fullSizeImage="${file.url}" class="upload-preview-item" onclick="$('file-upload-websearch').selectImagePreview(event)" loading="lazy">`
            },

            /**
             * Select an image preview
             */
            selectImagePreview(event) {
                const image = event.target
                image.classList.toggle("upload-preview-item-selected")
            },

            /**
             * Add the selected images to the list of files to upload
             */
            addImagesFromWebSearch(event) {
                event.preventDefault()

                const selectedImages = document.querySelectorAll(".upload-preview-item-selected")
                const images = [...selectedImages].map(image => {
                    return {
                        image: image.getAttribute("fullSizeImage"),
                        thumb: image.src
                    }
                })

                kiss.ajax.request({
                    url: "/multiUrlToBase64",
                    method: "post",
                    body: JSON.stringify({
                        url: images
                    })
                })
                .then(async response => {
                    $("upload-websearch-preview-items").hide()
                    $("upload-websearch-gallery-items").show()
                    $("upload-websearch-button").show()

                    // Build the result in the right format to be processed by the function "previewBase64File":
                    let files = response.result.map((file, i) => {
                        let fileExtension = file.fileData.split(';')[0].split('/')[1]
                        return {
                            data: {
                                result: file.fileData,
                                status: "success"
                            },
                            name: "WebImage_" + i + "." + fileExtension
                        }
                    })

                    // Preview each element
                    files.forEach(file => $("file-upload").previewBase64File(file.data, file.name, "websearch"))
                })
            }
        }
    })
}

;/**
 * 
 * Generates a file upload window.
 * 
 * The uploaded files will be link to an attachment field, so you need to provide the destination model ID, record ID and field ID.
 * To restrict the total size of the uploaded files, you can set the maxSize in the config object.
 * 
 * @param {object} config - Configuration object
 * @param {string} config.modelId - The model ID
 * @param {string} config.recordId - The record ID
 * @param {string} config.fieldId - The field ID
 * @param {number} [config.maxSize] - The maximum size of the uploaded files in bytes.
 * 
 * @ignore
 */
const createFileUploadWindow = function (config = {}) {

    const uploadServices = {
        local: txtTitleCase("my device"),
        link: txtTitleCase("link (URL)"),
        websearch: txtTitleCase("web search"),
        dropbox: txtTitleCase("dropbox"),
        box: txtTitleCase("box"),
        googledrive: txtTitleCase("google drive"),
        onedrive: txtTitleCase("one Drive"),
        instagram: txtTitleCase("instagram"),
        takephoto: txtTitleCase("take photo"),
    }

    return createPanel({
        id: "file-upload",
        title: txtTitleCase("upload files"),
        headerBackgroundColor: (kiss.context.application) ? kiss.context.application.color : "#00aaee",

        modal: true,
        draggable: true,
        closable: true,

        // Center vertically and horizontally
        align: "center",
        verticalAlign: "center",

        class: (kiss.screen.isMobile) ? "upload-window-mobile" : "upload-window",
        layout: "vertical",
        items: [
            // Container for the buttons to select a file upload service
            {
                hidden: kiss.screen.isMobile, // Mobile has only access to local files & camera
                layout: "horizontal",
                alignItems: "center",
                minHeight: "5rem",

                defaultConfig: {
                    margin: "0 1rem 0 0",
                    iconColorHover: "#00aaee"
                },

                items: [{
                        id: "upload-method-button",
                        type: "button",
                        text: txtTitleCase("choose your upload method"),
                        icon: "fas fa-chevron-down",
                        iconPosition: "right",
                        action: () => {

                            // Exit if the menu already exists
                            if ($("upload-method-menu")) return

                            // Otherwise build the menu
                            const buttonBox = $("upload-method-button").getBoundingClientRect()

                            createMenu({
                                    id: "upload-method-menu",
                                    top: buttonBox.top + kiss.tools.remToPx(4),
                                    left: buttonBox.left,
                                    width: () => $("upload-method-button").getBoundingClientRect().width,
                                    items: [{
                                            text: uploadServices.local,
                                            icon: "fas fa-paperclip",
                                            action: () => $("file-upload").displayService("file-upload-local")
                                        },
                                        {
                                            text: uploadServices.link,
                                            icon: "fas fa-link",
                                            action: () => $("file-upload").displayService("file-upload-link")
                                        }, {
                                            type: "button",
                                            text: uploadServices.websearch,
                                            icon: "fas fa-search",
                                            action: () => $("file-upload").displayService("file-upload-websearch")
                                        }, {
                                            type: "button",
                                            text: uploadServices.box,
                                            icon: "fas fa-box",
                                            action: () => $("file-upload").displayService("file-upload-box")
                                        }, {
                                            type: "button",
                                            text: uploadServices.dropbox,
                                            icon: "fab fa-dropbox",
                                            action: () => $("file-upload").displayService("file-upload-dropbox")
                                        }, {
                                            type: "button",
                                            text: uploadServices.onedrive,
                                            icon: "fas fa-cloud",
                                            action: () => $("file-upload").displayService("file-upload-onedrive")
                                        }, {
                                            type: "button",
                                            text: uploadServices.googledrive,
                                            icon: "fab fa-google-drive",
                                            action: () => $("file-upload").displayService("file-upload-googledrive")
                                        }, {
                                            type: "button",
                                            text: uploadServices.instagram,
                                            icon: "fab fa-instagram",
                                            action: () => $("file-upload").displayService("file-upload-instagram")
                                        }, {
                                            type: "button",
                                            text: uploadServices.takephoto,
                                            icon: "fas fa-camera",
                                            action: () => $("file-upload").displayService("file-upload-takephoto")
                                        }
                                    ]
                                })
                                .render()
                        }
                    },
                    {
                        id: "upload-method-title",
                        type: "html",
                        class: "upload-method-title",
                        html: uploadServices.local
                    }
                ]
            },
            // Container for the file upload services
            {
                id: "file-upload-services",
                layout: "vertical",
                width: "100%",
                class: "upload-gallery-container",
                multiview: true,

                items: [
                    createFileUploadLocal(),
                    createUploadGoogleDrive(),
                    createFileUploadLink(),
                    createFileUploadDropbox(),
                    createFileUploadBox(),
                    createFileUploadWebSearch(),
                    createFileUploadOneDrive(),
                    createFileUploadInstagram(),
                    createFileUploadTakePhoto(),
                ]
            }
        ],

        // Observe onclose event
        events: {
            onclose: () => {
                // Close the upload method menu if it's opened while exiting the upload widget
                if ($("upload-method-menu")) kiss.views.remove("upload-method-menu")

                // Propagate close event in case some other elements depend on it
                kiss.pubsub.publish("EVT_FILE_UPLOAD_CLOSED")
            }
        },

        methods: {
            /**
             * Display the right upload service
             * 
             * @param {string} uploadServiceType - "local" | "link" | "dropbox" | "box" | "websearch" | "googledrive" | "onedrive"
             */
            displayService(uploadServiceType) {
                $("file-upload-services").showItemById(uploadServiceType)
                $("upload-method-title").setInnerHtml(uploadServices[uploadServiceType.split("-")[2]])
            },

            // Function to set the selected files into the input field of type "file"
            fileSetter(data, uploadServiceType) {
                let objHidden = document.getElementById("field-upload-" + uploadServiceType);
                const dt = new DataTransfer()

                for (let i = 0; i < data.length; i++) {
                    const file = data[i]
                    dt.items.add(file)
                    objHidden.files = dt.files
                }
            },

            /**
             * Upload the list of selected files
             * 
             * @param {string} uploadServiceType - "local" | "link" | "dropbox" | "box" | "websearch" | "googledrive" | "onedrive"
             * @param {function} callback - Used by "box" service to show/hide elements after upload
             */
            upload(uploadServiceType, callback) {
                // Exit if offline
                if (kiss.session.isOffline()) return kiss.tools.featureNotAvailable()

                // Check file upload field
                const formData = new FormData()
                const input = $("field-upload-" + uploadServiceType)

                if (input.files.length == 0) {
                    return createNotification(txtTitleCase("please add a file before uploading..."))
                }

                // Check total size of files
                let totalSize = 0
                for (const file of input.files) totalSize += file.size
                if (config.maxSize && totalSize > config.maxSize) {
                    return createNotification(txtTitleCase("#warning file size") + " " + config.maxSize.toFileSize())
                }

                // Add files to form data
                for (let i = 0; i < input.files.length; i++) {
                    formData.append("files", input.files[i])
                }

                // Set ACL for uploaded files ("public" or "private")
                const ACLSwitch = $("upload-" + uploadServiceType + "-ACL")
                let ACLValue = (ACLSwitch) ? ACLSwitch.getValue() : "private"
                ACLValue = (ACLValue === true) ? "public" : "private"
                formData.append("ACL", ACLValue)

                kiss.ajax.request({
                        method: "post",
                        url: `/upload/${config.modelId}/${config.recordId}/${config.fieldId}`,
                        contentType: "multipart/form-data",
                        showLoading: true,
                        body: formData
                    })
                    .then(data => {
                        // Reset the gallery
                        $("upload-" + uploadServiceType + "-gallery-help").show()
                        $("upload-" + uploadServiceType + "-gallery-items").innerHTML = " "

                        // Reset the <input type="file"> field
                        const dt = new DataTransfer()
                        input.files = dt.files

                        // Hide the upload button
                        $("upload-" + uploadServiceType + "-button").hide()
                        $("upload-" + uploadServiceType + "-ACL").hide()

                        // Execute custom callback
                        if (callback) callback()

                        $("file-upload").close()
                    })
                    .catch((err) => {
                        log("kiss.ui - File upload with service <" + uploadServiceType + "> failed:", 4, err)
                    })
            },

            /**
             * Preview base 64 data
             * 
             * @param {object} data
             * @param {string} fileName
             * @param {string} uploadServiceType - "local" | "link" | "dropbox" | "box" | "websearch" | "googledrive" | "onedrive"
             */
            previewBase64File(data, fileName, uploadServiceType) {
                if (data.status == "success") {
                    const dt = new DataTransfer()
                    const input = $("field-upload-" + uploadServiceType)
                    const files = input.files

                    // Add the files which are already attached to the <input type=file> field
                    for (let i = 0; i < files.length; i++) {
                        let file = files[i]
                        dt.items.add(file)
                        input.files = dt.files
                    }

                    // Add the new file created from URL
                    let dataUrl = data.result
                    let fileData = $("file-upload").dataURLtoFile(dataUrl, fileName)
                    dt.items.add(fileData)

                    // Update the <input type="file"> field
                    input.files = dt.files

                    // Update the upload button text
                    const btnUploadText = txtTitleCase("upload %n file(s)", null, {
                        n: input.files.length
                    })
                    $("upload-" + uploadServiceType + "-button").setText(btnUploadText).show()
                    $("upload-" + uploadServiceType + "-ACL").show()

                    // Add the preview of the new file
                    $("file-upload").previewFile(fileData, (input.files.length - 1), uploadServiceType)
                }
            },

            /**
             * Preview the files that have been selected for upload
             * 
             * @param {array} files - List of selected files to upload
             * @param {string} uploadServiceType - "local" | "link" | "dropbox" | "box" | "websearch" | "googledrive" | "onedrive"
             */
            previewFiles: function (files, uploadServiceType) {
                $("upload-" + uploadServiceType + "-gallery-items").innerHTML = " "

                files = [...files]
                files.forEach((file, i) => {
                    $("file-upload").previewFile(file, i, uploadServiceType)
                })

                // Update the upload button
                const btnUploadText = txtTitleCase("upload %n file(s)", null, {
                    n: files.length
                })
                $("upload-" + uploadServiceType + "-button").setText(btnUploadText)
                if (files.length > 0) {
                    $("upload-" + uploadServiceType + "-button").show()
                    $("upload-" + uploadServiceType + "-ACL").show()
                }
                
                // Show ACL switcher
                const ACLSwitch = $("upload-" + uploadServiceType + "-ACL")
                if (ACLSwitch) ACLSwitch.show()
            },

            /**
             * Show file preview after upload
             * 
             * @param {object} file 
             * @param {number} i - File index
             * @param {string} uploadServiceType - "local" | "link" | "dropbox" | "box" | "websearch" | "googledrive" | "onedrive"
             */
            previewFile: function (file, i, uploadServiceType) {
                // Hide the help message of the gallery
                $("upload-" + uploadServiceType + "-gallery-help").hide()

                const extension = (file.name).split(".").pop()
                const reader = new FileReader()
                reader.readAsDataURL(file)

                reader.onloadend = function () {
                    let thumbnail = $("file-upload").getFileUploadThumbnail(extension, reader.result)

                    $("upload-" + uploadServiceType + "-gallery-items").innerHTML += /*html*/ `
                        <div class="upload-item">
                            <span class="upload-thumbnail-container">${thumbnail}</span>
                            <span class="upload-filename">${file.name}</span>
                            <span class="upload-filesize">${file.size.toFileSize()}</span>
                            <span class="upload-delete fas fa-times" index="${i}" onclick="$('file-upload').deleteFile(this, '${uploadServiceType}')"></span>
                        </div>
                    `.removeExtraSpaces()
                }
            },

            /**
             * Convert base64 data to file
             * 
             * @param {string} dataUrl 
             * @param {string} filename 
             * @returns {object}
             */
            dataURLtoFile(dataUrl, filename) {
                let arr = dataUrl.split(','),
                    mime = arr[0].match(/:(.*?);/)[1],
                    bstr = atob(arr[1]),
                    n = bstr.length,
                    u8arr = new Uint8Array(n);
                while (n--) {
                    u8arr[n] = bstr.charCodeAt(n);
                }
                return new File([u8arr], filename, {
                    type: mime
                })
            },

            /**
             * Delete a file from the upload list
             * 
             * @param {Element} element - DOM element of the Delete button
             * @param {string} uploadServiceType - "local" | "link" | "dropbox" | "box" | "websearch" | "googledrive" | "onedrive"
             */
            deleteFile: function (element, uploadServiceType) {
                const index = element.getAttribute("index")
                const dt = new DataTransfer()
                const input = $("field-upload-" + uploadServiceType)
                const files = input.files
                for (let i = 0; i < files.length; i++) {
                    let file = files[i]
                    if (index != i) dt.items.add(file)
                    input.files = dt.files
                }
                $("file-upload").previewFiles(input.files, uploadServiceType)

                // If it was the last element, show the gallery help message and hide the upload button 
                if (input.files.length == 0) {
                    $("upload-" + uploadServiceType + "-gallery-help").show()
                    $("upload-" + uploadServiceType + "-button").hide()
                    $("upload-" + uploadServiceType + "-ACL").hide()
                }
                else {
                    $("upload-" + uploadServiceType + "-button").show()
                    $("upload-" + uploadServiceType + "-ACL").show()
                }
            },

            /**
             * Return an image thumbnail, which can be:
             * - a real image, for image files
             * - a font awesome icon class, for all other types
             * 
             * @param {string} fileType
             * @param {string} encodedImage - Base64 image used for gallery thumbnail
             * @returns {string} The Font Awesome class
             */
            getFileUploadThumbnail(fileType, encodedImage) {
                switch (fileType.toLowerCase()) {
                    // Images
                    case "jpg":
                    case "jpeg":
                    case "png":
                    case "gif":
                    case "webp":
                        return `<img class="upload-thumbnail" src="${encodedImage}">`

                        // Other
                    default:
                        const {
                            icon, color
                        } = kiss.tools.fileToIcon(fileType.toLowerCase())
                        return `<span style="color: ${color}" class="fas ${icon} upload-thumbnail"></span>`
                }
            }
        }
    }).render()
}

;/**
 * Authentication error
 */
kiss.app.defineView({
    id: "authentication-error",
    renderer: function (id, target) {

        let msgCode = kiss.router.getRoute().msgCode
        if (!msgCode) msgCode = "authentication-error"
        const errorMessage = txtTitleCase(msgCode)

        /**
         * Generates the panel containing the error infos
         */
        return createBlock({
            id,
            target,
            fullscreen: true,
            layout: "horizontal",

            items: [{
                    type: "view",
                    id: "common-matrix"
                },
                {
                    type: "panel",
                    icon: "fas fa-exclamation-triangle",
                    headerBackgroundColor: "var(--background-red)",

                    modal: true,
                    draggable: true,

                    align: "center",
                    verticalAlign: "center",
                    layout: "vertical",

                    items: [{
                            type: "html",
                            html: errorMessage,
                            padding: "32px"
                        },
                        {
                            type: "button",
                            icon: "fas fa-times",
                            flex: 1,
                            text: "OK",
                            action: () => kiss.router.navigateTo("authentication-login", true)
                        }
                    ]
                }
            ]
        })
    }
})

;/**
 * Authentication => invitation process
 */
kiss.app.defineView({
    id: "authentication-invite",
    renderer: function (id, target) {
        return createPanel({
            id,
            target,
            title: txtTitleCase("invite a new user"),
            icon: "fas fa-user-plus",
            headerBackgroundColor: "var(--background-blue)",

            modal: true,
            draggable: true,
            position: "absolute",

            width: "50rem",
            align: "center",
            verticalAlign: "center",

            items: [
                // EMAIL
                {
                    type: "text",
                    id: "email",
                    label: txtUpperCase("email"),
                    width: "100%",
                    labelPosition: "top",
                    required: true,
                    validationType: "email",
                    methods: {
                        load: function () {
                            setTimeout(() => this.focus(), 50)
                        }
                    }
                },
                // BUTTONS
                {
                    layout: "horizontal",
                    margin: "2rem 0 0 0",
                    items: [
                        // SEND INVITATION BUTTON
                        {
                            type: "button",
                            icon: "fa fa-paper-plane",
                            text: txtTitleCase("send the invitation"),
                            iconColor: "#00aaee",
                            flex: 1,
                            action: async () => {
                                let fieldEmail = $("email")
                                if (!fieldEmail.isValid) return

                                let email = fieldEmail.getValue()

                                const response = await kiss.ajax.request({
                                    url: "/invite",
                                    method: "post",
                                    showLoading: true,
                                    body: JSON.stringify({
                                        email: email,
                                        language: kiss.language.current
                                    })
                                })

                                if (response.code === 403) {
                                    return createDialog({
                                        message: txtTitleCase(response.error),
                                        noCancel: true
                                    })
                                }

                                if (response.error) {
                                    createNotification({
                                        message: txtTitleCase(response.error)
                                    })
                                } else {
                                    createNotification({
                                        message: txtTitleCase("invitation sent for") + " " + email
                                    })

                                    if ($("directory-users")) $("directory-users").close()
                                    $(id).close()
                                }
                            }
                        }
                    ]
                }
            ]
        })
    }
})

;/**
 * Authentication => login
 * 
 * - This view allows the user to login using different methods (internal, Google, Microsoft, ...)
 * - The view is responsive and adapts to the screen size
 * - The view can be called with the following parameters:
 *  . username: default username
 *  . password: default password
 *  . redirectTo: view to redirect to after login
 */
kiss.app.defineView({
    id: "authentication-login",
    renderer: function (id, target) {

        // Define the possible login methods and build login buttons accordingly
        let loginMethods = kiss.router.getRoute().lm
        if (!loginMethods) loginMethods = kiss.session.getLoginMethods()

        const allLoginButtons = kiss.session.getLoginMethodTypes().slice(1).map(loginMethod => {
            return {
                type: "button",
                alias: loginMethod.alias,
                text: loginMethod.text,
                icon: loginMethod.icon,
                action: async () => {

                    // Some environment (ex: docker) don't allow external auth
                    const serverEnvironment = await kiss.session.getServerEnvironment()
                    if (serverEnvironment == "docker") {
                        return createNotification(txtTitleCase("#feature not available"))
                    }

                    $("login").showLoading({
                        fullscreen: true,
                        spinnerSize: "12.8rem"
                    })

                    let acceptInvitationOf = kiss.context.acceptInvitationOf || ''
                    if (acceptInvitationOf) acceptInvitationOf = '?acceptInvitationOf=' + acceptInvitationOf

                    document.location = loginMethod.callback + acceptInvitationOf
                }
            }
        })

        const loginButtons = Array.from(loginMethods).map(loginMethodAlias => allLoginButtons.find(button => button.alias == loginMethodAlias))
        const hasInternalLogin = loginMethods.includes("i")
        const hasExternalLogin = loginMethods.includes("g")

        // Capture default login infos within URL parameters (useful for test mode)
        const username = kiss.router.getRoute().username
        const password = kiss.router.getRoute().password

        // Get the required redirection after login, if any, or points to the default home page
        let redirectTo = kiss.context.redirectTo || {
            ui: kiss.session.defaultViews.home
        }
        delete kiss.context.redirectTo

        // Check if the user tries to open a deep link to a record
        if (kiss.context.modelId && kiss.context.recordId) {
            redirectTo = {
                ui: "form-view",
                modelId: kiss.context.modelId,
                recordId: kiss.context.recordId
            }
            delete kiss.context.recordId
        }
        
        // Parameters for mobile
        let layoutParams = {}
        if (kiss.screen.isMobile) {
            layoutParams = {
                position: "fixed",
                top: 0,
                left: 0,
                width: "100%",
                height: () => kiss.screen.current.height,
                minHeight: () => kiss.screen.current.height,
                borderRadius: "0px 0px 0px 0px",
                draggable: false
            }
        }
        else {
            layoutParams = {
                width: "80rem",
                align: "center",
                verticalAlign: "center",
                draggable: true
            }
        }

        /**
         * Generates the panel containing the login infos
         */
        return createBlock({
            id,
            target,

            items: [
                // Fullscreen background with cover image
                {
                    id: "login-page",
                    fullscreen: true,
                    layout: "horizontal",
                    overflow: "auto",

                    items: [
                        // Gradient
                        {
                            flex: 1,
                            background: "var(--background-blue)"
                        },
                        // Matrix effect
                        {
                            type: "view",
                            id: "common-matrix"
                        }
                    ]
                },

                // Logo and login window
                {
                    height: "100%",
                    items: [
                        // Logo
                        {
                            hidden: !kiss.app.logo,
                            position: "absolute",
                            top: 0,
                            left: 0,

                            type: "image",
                            src: kiss.app.logo,
                            alt: "Logo",
                        },
                        // Login panel
                        {
                            id: "login",
                            type: "panel",
                            headerBackgroundColor: "var(--background-blue)",
                            layout: "horizontal",
                            overflowY: "auto",
                            
                            ...layoutParams,

                            // Language buttons
                            headerButtons: kiss.templates.authLanguageButtons(),

                            items: [
                                // LOCAL LOGIN METHOD
                                {
                                    hidden: !hasInternalLogin,

                                    flex: 1,
                                    class: "auth-block",
                                    overflow: "hidden",

                                    defaultConfig: {
                                        width: "100%",
                                        fieldWidth: "100%",
                                        labelPosition: "top",
                                        padding: 0
                                    },

                                    items: [
                                        // EMAIL
                                        {
                                            type: "text",
                                            id: "username",
                                            label: txtTitleCase("email"),
                                            required: true,
                                            validationType: "email",
                                            value: username
                                        },
                                        // PASSWORD
                                        {
                                            type: "password",
                                            id: "password",
                                            label: txtTitleCase("password"),
                                            value: password,
                                            events: {
                                                keydown: (event) => {
                                                    if (event.key == "Enter") {
                                                        $("login").login()
                                                    }
                                                }
                                            }
                                        },
                                        // LOGIN button
                                        {
                                            type: "button",
                                            icon: "fa fa-check",
                                            text: txtTitleCase("login"),
                                            iconColor: "#00aaee",
                                            height: "4rem",
                                            margin: "2rem 0",
                                            action: () => $("login").login()
                                        },
                                        // LINK TO PASSWORD RESET
                                        {
                                            type: "html",
                                            html: `
                                            <div class="auth-reset-password">${txtTitleCase("forgot password?")}</div>
                                        `,
                                            events: {
                                                click: () => $("login").requestPasswordReset()
                                            }
                                        },                                        
                                        // LINK TO REGISTER PAGE
                                        {
                                            hidden: kiss.screen.isMobile,
                                            type: "html",
                                            html: `
                                            <div class="auth-create-account">${txtTitleCase("#no account")}</div>
                                        `,
                                            events: {
                                                click: () => kiss.router.navigateTo({
                                                    ui: "authentication-register",
                                                    lm: loginMethods
                                                }, true)
                                            }
                                        }
                                    ]
                                },

                                // Separation between login methods
                                {
                                    hidden: !hasInternalLogin || !hasExternalLogin,

                                    id: "auth-login-separator",
                                    class: "auth-separator",

                                    layout: "vertical",
                                    items: [{
                                            type: "spacer",
                                            flex: 1
                                        },
                                        {
                                            type: "html",
                                            class: "auth-separator-text",
                                            html: txtUpperCase("or")
                                        },
                                        {
                                            type: "spacer",
                                            flex: 1
                                        }
                                    ]
                                },

                                // OTHER LOGIN METHODS
                                {
                                    hidden: !hasExternalLogin,
                                    id: "auth-login-external",
                                    flex: 1,
                                    class: "auth-block",
                                    layout: "vertical",
                                    justifyContent: "center",

                                    defaultConfig: {
                                        margin: "0.5rem",
                                        colorHover: "#00aaee",
                                        backgroundColorHover: "#ffffff",
                                        iconSize: "2rem",
                                        iconColorHover: "#00aaee",
                                        height: "4rem"
                                    },

                                    items: loginButtons.concat({
                                        hidden: hasInternalLogin,
                                        type: "html",
                                        html: `<div class="auth-create-account">${txtTitleCase("#no account")}</div>`,
                                        events: {
                                            click: () => kiss.router.navigateTo({
                                                ui: "authentication-register",
                                                lm: loginMethods
                                            }, true)
                                        }
                                    })
                                }
                            ],

                            methods: {
                                async load() {
                                    // Check if a token was returned from a 3rd party service (Microsoft, Google, ...)
                                    // If yes, update the session with the token before routing
                                    const token = kiss.router.getRoute().token
                                    if (token) {
                                        this.hide()
                                        const success = await kiss.session.login({
                                            token: token
                                        })

                                        if (success) {
                                            await kiss.router.navigateTo(redirectTo, true)
                                        } else {
                                            $("login").setAnimation("shakeX")
                                        }
                                    } else {

                                        // Responsiveness
                                        this.adjustToScreen()
                                    }
                                },

                                /**
                                 * Login the user with the provided username and password
                                 */
                                async login() {
                                    const fieldUsername = $("username")
                                    const fieldPassword = $("password")

                                    if (fieldUsername.isValid && fieldPassword.isValid) {
                                        const success = await kiss.session.login({
                                            username: fieldUsername.getValue(),
                                            password: fieldPassword.getValue()
                                        })

                                        // Check if the login process needs to redirect to a host account
                                        if (kiss.context.accountId && (kiss.context.accountId != kiss.session.getAccountId())) {
                                            kiss.router.updateUrlHash(redirectTo, true)
                                            log.info("kiss.session - Switching to account " + kiss.context.accountId)
                                            return kiss.session.switchAccount(kiss.context.accountId)
                                        }
                                        
                                        if (success) {
                                            await kiss.router.navigateTo(redirectTo, true)
                                        } else {
                                            $("login").setAnimation("shakeX")
                                        }
                                    } else {
                                        $("login").setAnimation("shakeX")
                                    }
                                },

                                /**
                                 * Send a request to reset the password
                                 */
                                async requestPasswordReset() {
                                    const fieldUsername = $("username")
                                    if (!fieldUsername.isValid) {
                                        createNotification(txtTitleCase("#email missing"))
                                        return
                                    }

                                    await kiss.ajax.request({
                                        url: "/requestPasswordReset",
                                        method: "post",
                                        showLoading: true,
                                        body: JSON.stringify({
                                            username: fieldUsername.getValue(),
                                            language: kiss.language.current
                                        })
                                    })

                                    createDialog({
                                        type: "message",
                                        message: txtTitleCase("#password reset request")
                                    })
                                },

                                /**
                                 * Adjust layout to screen size
                                 */
                                adjustToScreen() {
                                    if (!$("authentication-login")) return

                                    if (kiss.screen.isVertical()) {
                                        $("common-matrix").hide()
                                        $("login").config.width = "38rem"
                                        $("panel-body-login").style.flexFlow = "column"
                                        $("auth-login-separator").style.flexFlow = "row"
                                    } else {
                                        $("common-matrix").show()
                                        $("login").config.width = "76rem"    
                                        $("panel-body-login").style.flexFlow = "row"
                                        $("auth-login-separator").style.flexFlow = "column"
                                    }
                                    
                                    if (kiss.screen.isMobile) {
                                        $("login").config.width = "100%"
                                        $("login").config.height = "100%"
                                    }
                                }
                            },

                            // Responsiveness
                            subscriptions: {
                                EVT_WINDOW_RESIZED: function() {
                                    this.adjustToScreen()
                                }
                            }
                        }
                    ]
                }
            ]
        })
    }
})

;/**
 * Authentication => registration process
 */
kiss.app.defineView({
    id: "authentication-register",
    renderer: function (id, target) {
        // Grab parameters sent through URL
        const userEmail = kiss.router.getRoute().email
        const pendingUserId = kiss.router.getRoute().userId

        // Define the possible login methods and build registration buttons accordingly
        let loginMethods = kiss.router.getRoute().lm
        if (!loginMethods) loginMethods = kiss.session.getLoginMethods()

        const allLoginButtons = kiss.session.getLoginMethodTypes().slice(1).map(loginMethod => {
            return {
                type: "button",
                alias: loginMethod.alias,
                text: loginMethod.text,
                icon: loginMethod.icon,
                action: async () => {

                    // Some environment (ex: docker) don't allow external registration
                    const serverEnvironment = await kiss.session.getServerEnvironment()
                    if (serverEnvironment == "docker") {
                        return createNotification(txtTitleCase("#feature not available"))
                    }

                    document.location = loginMethod.callback
                }
            }
        })

        const loginButtons = Array.from(loginMethods).map(loginMethodAlias => allLoginButtons.find(button => button.alias == loginMethodAlias))
        const hasInternalLogin = loginMethods.includes("i")
        const hasExternalLogin = loginMethods.includes("g")

        // Parameters for mobile
        let layoutParams = {}
        if (kiss.screen.isMobile) {
            layoutParams = {
                position: "fixed",
                top: 0,
                left: 0,
                width: "100%",
                height: () => kiss.screen.current.height,
                minHeight: () => kiss.screen.current.height,
                borderRadius: "0px 0px 0px 0px",
                draggable: false
            }
        }
        else {
            layoutParams = {
                width: "80rem",
                align: "center",
                verticalAlign: "center",
                draggable: true
            }
        }

        /**
         * Generates the panel containing the login infos
         */
        return createBlock({
            id,
            target,

            items: [
                // Fullscreen background with cover image
                {
                    id: "register-page",
                    fullscreen: true,
                    layout: "horizontal",
                    overflow: "auto",

                    items: [
                        // Gradient
                        {
                            flex: 1,
                            background: "var(--background-blue)"
                        },
                        // Image
                        {
                            id: "welcome-image",
                            flex: 1,
                            
                            type: "image",
                            position: "absolute",
                            top: 0,
                            left: "50%",
                            minWidth: "100%",
                            height: "100%",
                            objectFit: "cover",
                            src: "./resources/img/registration.jpg",
                            alt: "Registration",
                        }
                    ]
                },

                // Logo and register window
                {
                    height: "100%",
                    items: [
                        // Logo
                        {
                            hidden: !kiss.app.logo,
                            position: "absolute",
                            top: 0,
                            left: 0,

                            type: "image",
                            src: kiss.app.logo,
                            alt: "Logo"
                        },
                        // Register panel
                        {
                            id: "register",
                            type: "panel",
                            headerBackgroundColor: "var(--background-blue)",
                            layout: "horizontal",
                            overflowY: "auto",

                            ...layoutParams,
                            
                            // Language buttons
                            headerButtons: kiss.templates.authLanguageButtons(),

                            items: [
                                // LOCAL REGISTRATION METHOD
                                {
                                    hidden: !hasInternalLogin,

                                    flex: 1,
                                    class: "auth-block",

                                    defaultConfig: {
                                        width: "100%",
                                        fieldWidth: "100%",
                                        labelPosition: "top",
                                        padding: "0.2rem 0"
                                    },

                                    items: [
                                        // FIRST NAME
                                        {
                                            type: "text",
                                            id: "firstName",
                                            placeholder: txtTitleCase("first name"),
                                            required: true
                                        },
                                        // LAST NAME
                                        {
                                            type: "text",
                                            id: "lastName",
                                            placeholder: txtTitleCase("last name"),
                                            required: true
                                        },
                                        // COMPANY
                                        {
                                            hidden: (pendingUserId) ? true : false,
                                            type: "text",
                                            id: "company",
                                            placeholder: txtTitleCase("company")
                                        },
                                        // TELEPHONE
                                        {
                                            hidden: (pendingUserId) ? true : false,
                                            type: "text",
                                            id: "telephone",
                                            placeholder: txtTitleCase("telephone")
                                        },
                                        // EMAIL
                                        {
                                            type: "text",
                                            id: "email",
                                            placeholder: txtTitleCase("email"),
                                            required: true,
                                            validationType: "email",
                                            value: userEmail
                                        },
                                        // PASSWORD
                                        {
                                            type: "password",
                                            id: "password",
                                            placeholder: txtTitleCase("password"),
                                            required: true
                                        },
                                        // PASSWORD CONFIRMATION
                                        {
                                            type: "password",
                                            id: "passwordConfirmation",
                                            placeholder: txtTitleCase("password confirmation"),
                                            required: true
                                        },
                                        // BUTTONS
                                        {
                                            layout: "horizontal",
                                            margin: "1rem 0 0 0",
                                            items: [
                                                // REGISTER button
                                                {
                                                    type: "button",
                                                    icon: "fa fa-check",
                                                    text: txtTitleCase("register"),
                                                    iconColor: "#00aaee",
                                                    flex: 1,
                                                    height: "4rem",
                                                    action: async function () {
                                                        let fieldFirstName = $("firstName")
                                                        let fieldLastName = $("lastName")
                                                        let fieldEmail = $("email")
                                                        let fieldPassword = $("password")
                                                        let fieldPasswordConfirmation = $("passwordConfirmation")

                                                        fieldFirstName.validate()
                                                        fieldLastName.validate()
                                                        fieldEmail.validate()
                                                        fieldPassword.validate()
                                                        fieldPasswordConfirmation.validate()

                                                        if (fieldFirstName.isValid && fieldLastName.isValid && fieldEmail.isValid && fieldPassword.isValid && fieldPasswordConfirmation.isValid) {
                                                            let firstName = fieldFirstName.getValue()
                                                            let lastName = fieldLastName.getValue()
                                                            let email = fieldEmail.getValue()
                                                            let password = fieldPassword.getValue()
                                                            let passwordConfirmation = fieldPasswordConfirmation.getValue()

                                                            if (password != passwordConfirmation) {
                                                                createNotification(txtTitleCase("#password don't match"))
                                                                return $("register").setAnimation("shakeX")
                                                            }

                                                            kiss.ajax.request({
                                                                    url: "/register",
                                                                    method: "post",
                                                                    body: JSON.stringify({
                                                                        userId: pendingUserId,
                                                                        firstName: firstName,
                                                                        lastName: lastName,
                                                                        language: kiss.language.current,
                                                                        email: email,
                                                                        password: password,
                                                                        passwordConfirmation: passwordConfirmation
                                                                    })
                                                                })
                                                                .then(response => {
                                                                    if (response.error) {
                                                                        $("register").setAnimation("shakeX")
                                                                    } else {
                                                                        // Jump to welcome page
                                                                        $("register").showWelcome()
                                                                    }
                                                                }).catch(err => {
                                                                    $("register").setAnimation("shakeX")
                                                                })
                                                        } else {
                                                            $("register").setAnimation("shakeX")
                                                        }
                                                    }
                                                }
                                            ]
                                        },
                                        // LINK TO LOGIN PAGE
                                        {
                                            hidden: kiss.screen.isMobile,
                                            type: "html",
                                            html: `<div class="auth-create-account">${txtTitleCase("#already an account")}</div>`,
                                            events: {
                                                click: () => kiss.router.navigateTo({
                                                    ui: "authentication-login",
                                                    lm: loginMethods
                                                }, true)
                                            }
                                        }
                                    ]
                                },

                                // Separation between registration methods
                                {
                                    hidden: !hasInternalLogin || !hasExternalLogin,

                                    id: "auth-separator",
                                    class: "auth-separator",

                                    layout: "vertical",
                                    items: [{
                                            type: "spacer",
                                            flex: 1
                                        },
                                        {
                                            type: "html",
                                            class: "auth-separator-text",
                                            html: txtUpperCase("or")
                                        },
                                        {
                                            type: "spacer",
                                            flex: 1
                                        }
                                    ]
                                },

                                // OTHER REGISTRATION METHODS
                                {
                                    hidden: !hasExternalLogin,
                                    flex: 1,
                                    class: "auth-block",
                                    layout: "vertical",
                                    justifyContent: "center",

                                    defaultConfig: {
                                        margin: "0.5rem",
                                        colorHover: "#00aaee",
                                        backgroundColorHover: "#ffffff",
                                        iconSize: "2rem",
                                        iconColorHover: "#00aaee",
                                        height: "4rem"
                                    },

                                    items: loginButtons.concat({
                                        hidden: hasInternalLogin,
                                        type: "html",
                                        html: `<div class="auth-create-account">${txtTitleCase("#already an account")}</div>`,
                                        events: {
                                            click: () => kiss.router.navigateTo({
                                                ui: "authentication-login",
                                                lm: loginMethods
                                            }, true)
                                        }
                                    })
                                }
                            ],

                            methods: {
                                load: function () {
                                    this.adjustToScreen()

                                    // Display additional message if there is an error
                                    const error = kiss.router.getRoute().error
                                    if (error) {
                                        createDialog({
                                            type: "danger",
                                            message: txtTitleCase(error),
                                            noCancel: true
                                        })
                                    }
                                },

                                /**
                                 * Show a welcome popup once the registration is complete
                                 */
                                showWelcome() {
                                    $("register").hide()

                                    createPanel({
                                        type: "panel",
                                        title: txtUpperCase("welcome onboard"),
                                        icon: "fas fa-handshake",
                                        headerBackgroundColor: "var(--background-blue)",
                                        position: "absolute",
                                        width: () => "min(calc(100vw - 10rem), 60rem)",
                                        align: "center",
                                        verticalAlign: "center",

                                        items: [{
                                            type: "html",
                                            html: "<center>" + txtTitleCase("#thanks for registration") + "</center>",
                                            padding: "3.2rem"
                                        }]
                                    }).render()
                                },

                                /**
                                 * Adjust layout to screen size
                                 */
                                adjustToScreen: () => {
                                    if (kiss.context.ui != "authentication-register") return

                                    if (kiss.screen.isVertical()) {
                                        $("welcome-image").hide()
                                        $("register").config.width = (kiss.screen.isMobile) ? "32remx" : "38rem"
                                        $("panel-body-register").style.flexFlow = "column"
                                        $("auth-separator").style.flexFlow = "row"
                                    } else {
                                        $("welcome-image").show()
                                        $("register").config.width = "76rem"
                                        $("panel-body-register").style.flexFlow = "row"
                                        $("auth-separator").style.flexFlow = "column"
                                    }
                                }
                            },

                            // Responsiveness
                            subscriptions: {
                                EVT_WINDOW_RESIZED: function () {
                                    this.adjustToScreen()
                                }
                            }
                        }
                    ]
                }

            ]
        })
    }
})

;/**
 * Authentication => reset password process
 */
kiss.app.defineView({
    id: "authentication-reset-password",
    renderer: function (id, target) {

        // Parameters for mobile
        let layoutParams = {}
        if (kiss.screen.isMobile) {
            layoutParams = {
                position: "fixed",
                top: 0,
                left: 0,
                width: "100%",
                height: () => kiss.screen.current.height,
                minHeight: () => kiss.screen.current.height,
                borderRadius: "0px 0px 0px 0px",
                draggable: false
            }
        }
        else {
            layoutParams = {
                width: "50rem",
                align: "center",
                verticalAlign: "center",
                draggable: true
            }
        }

        return createBlock({
            id,
            target,

            items: [
                // Fullscreen background with cover image
                {
                    fullscreen: true,
                    layout: "horizontal",
                    overflow: "auto",

                    items: [
                        // Gradient
                        {
                            flex: 1,
                            background: "var(--background-blue)"
                        },
                        // Image
                        {
                            id: "welcome-image",
                            flex: 1,
                            class: "auth-welcome"
                        }
                    ]
                },

                // Logo and password reset window
                {
                    height: "100%",
                    items: [
                        // Logo
                        {
                            hidden: !kiss.app.logo,
                            position: "absolute",
                            top: 0,
                            left: 0,
                            type: "image",
                            src: kiss.app.logo,
                            alt: "Logo"
                        },
                        // Reset password panel
                        {
                            id: "password-reset",
                            type: "panel",
                            title: txtTitleCase("password reset"),
                            icon: "fas fa-recycle",
                            headerBackgroundColor: "var(--background-blue)",
                            layout: "horizontal",

                            ...layoutParams,

                            // Language buttons
                            headerButtons: (kiss.screen.isMobile) ? [] : kiss.templates.authLanguageButtons(),

                            items: [{
                                flex: 1,
                                class: "auth-block",

                                defaultConfig: {
                                    width: "100%",
                                    labelPosition: "top"
                                },

                                items: [
                                    // PASSWORD
                                    {
                                        type: "password",
                                        id: "password",
                                        label: txtUpperCase("new password"),
                                        required: true
                                    },
                                    // PASSWORD CONFIRMATION
                                    {
                                        type: "password",
                                        id: "passwordConfirmation",
                                        label: txtUpperCase("new password confirmation"),
                                        required: true
                                    },
                                    // BUTTONS
                                    {
                                        layout: "horizontal",
                                        margin: "1rem 0 0 0",
                                        items: [
                                            // VALIDATE button
                                            {
                                                type: "button",
                                                icon: "fa fa-check",
                                                text: txtTitleCase("change password"),
                                                iconColor: "#00aaee",
                                                flex: 1,
                                                events: {
                                                    click: async function () {
                                                        let fieldPassword = $("password")
                                                        let fieldPasswordConfirmation = $("passwordConfirmation")

                                                        fieldPassword.validate()
                                                        fieldPasswordConfirmation.validate()

                                                        if (fieldPassword.isValid && fieldPasswordConfirmation.isValid) {
                                                            let password = fieldPassword.getValue()
                                                            let passwordConfirmation = fieldPasswordConfirmation.getValue()

                                                            if (password != passwordConfirmation) {
                                                                createNotification(txtTitleCase("#password don't match"))
                                                                return $("password-reset").setAnimation("shakeX")
                                                            }

                                                            await kiss.ajax.request({
                                                                url: "/resetPassword",
                                                                method: "post",
                                                                body: JSON.stringify({
                                                                    token: kiss.router.getRoute().token,
                                                                    password: password,
                                                                    language: kiss.language.current
                                                                })
                                                            })

                                                            kiss.router.navigateTo({
                                                                ui: "authentication-login"
                                                            }, true)
                                                        } else {
                                                            $("password-reset").setAnimation("shakeX")
                                                        }
                                                    }
                                                }
                                            }
                                        ]
                                    }
                                ]
                            }],

                            methods: {
                                load: function () {
                                    this.adjustToScreen()
                                },

                                /**
                                 * Adjust layout to screen size
                                 */
                                adjustToScreen: () => {
                                    if (kiss.context.ui != "authentication-reset-password") return

                                    // Hide picture under a width/height ratio
                                    if (kiss.screen.current.ratio < 1) {
                                        $("welcome-image").hide()
                                    } else {
                                        $("welcome-image").show()
                                    }
                                }
                            },

                            // Responsiveness
                            subscriptions: {
                                EVT_WINDOW_RESIZED: function () {
                                    this.adjustToScreen()
                                }
                            }
                        }
                    ]
                }

            ]
        })
    }
})

;/**
 * Authentication language buttons
 */
kiss.templates.authLanguageButtons = () => kiss.language.available.map(language => {
    return {
        text: language.code.toUpperCase(),
        icon: "fas fa-globe",
        height: "3.2rem",
        fontSize: "1.1rem",
        margin: "0 0.5rem 0 0",
        color: "#ffffff",
        iconColor: "#ffffff",
        backgroundColor: "transparent",
        borderWidth: 0,
        action: () => kiss.language.set(language.code)
    }
})

;/**
 * Matrix effect
 */
kiss.app.defineView({
    id: "common-matrix",
    renderer: function (id, target) {
        return createBlock({
            id,
            target,

            layout: "vertical",
            height: "100%",
            flex: 1, //width: "50%",

            items: [{
                type: "html",
                flex: 1,
                html: /*html*/ `<canvas id="matrix-effect"></canvas>`
            }],

            subscriptions: {
                EVT_WINDOW_RESIZED: function () {
                    if (this.isConnected) this.load()
                }
            },

            methods: {
                load() {
                    const rootStyles = getComputedStyle(document.documentElement)
                    const matrixBackground = rootStyles.getPropertyValue('--body-background').trim() || "#ffffff"
                    const matrixColor = rootStyles.getPropertyValue('--body-alt').trim() || "#cccccc"

                    kiss.tools.wait(1000).then(() => {
                        clearInterval(kiss.global.matrix)

                        const canvas = $("matrix-effect")
                        if (!canvas) return

                        const ctx = canvas.getContext("2d")
                        const w = canvas.width = $(id).offsetWidth
                        const h = canvas.height = $(id).offsetHeight

                        const cols = Math.floor(w / 20) + 1
                        const ypos = Array(cols).fill(0)

                        // Fill the background
                        ctx.fillStyle = matrixBackground
                        ctx.fillRect(0, 0, w, h)

                        function matrix() {
                            // Draw a semitransparent rectangle on top of previous drawing
                            ctx.fillStyle = matrixBackground + "11"
                            ctx.fillRect(0, 0, w, h)

                            // Set color and font to 15pt monospace in the drawing context
                            ctx.fillStyle = matrixColor
                            ctx.font = "15pt monospace"

                            // For each column put a random character at the end
                            ypos.forEach((y, ind) => {
                                // Generate a random character
                                const text = String.fromCharCode(Math.random() * 1000)

                                // x coordinate of the column, y coordinate is already given
                                const x = ind * 20

                                // Render the character at (x, y)
                                ctx.fillText(text, x, y)

                                // Randomly reset the end of the column if it's at least 100px high
                                if (y > 100 + Math.random() * 10000) ypos[ind] = 0

                                // ...otherwise just move the y coordinate for the column 20px down
                                else ypos[ind] = y + 20
                            })
                        }

                        // Render the animation at 20 FPS
                        kiss.global.matrix = setInterval(matrix, 25)
                    })
                },

                _afterDisconnected() {
                    // Stop the animation when hidden
                    clearInterval(kiss.global.matrix)
                }
            }
        })
    }
})


;/**
 * 
 * Represents a **Collection** of records.
 * 
 * A **Collection** is an interface to manipulate and cache a collection of records.
 * To see how a **Collection** relates to models, fields and records, please refer to the [Model documentation](kiss.data.Model.html).
 * 
 * Each **Model** has an associated default Collection to hold its records:
 * - this default Collection is instantiated (but not loaded) at the same time as the Model.
 * - it means that you can always access the records of a Model, even if you didn't explicity created a Collection for it.
 * - this default collection is accessible with: **kiss.app.collections[modelId]**, or simply **app.collections.modelId**
 * 
 * ```
 * let myCarCollection = kiss.app.collections["car"]
 * ```
 * 
 * Below is a table that shows the global flow between KissJS client and KissJS server, and the chain of methods used.
 * 
 * Here is the flow:
 * - **kiss.data.Collection** or [**kiss.data.Record**](kiss.data.RecordFactory-Record.html) calls [**kiss.db**](kiss.db.html)
 * - kiss.db points to the right db api: [**kiss.db.memory**](kiss.db.memory.html) or [**kiss.db.offline**](kiss.db.offline.html) or [**kiss.db.online**](kiss.db.online.html)
 * - if online, kiss.db perform an HTTP request using [**kiss.ajax.request**](kiss.ajax.html)
 * - the KissJS server receives the request
 * - the request is processed by the server Controller
 * - the Controller calls MongoDb api with the native MongoDb driver
 * - the Controller pass the response back to kiss.ajax.request
 * - if a database mutation has occured (CUD operations), the server Controller sends a WebSocket message to the connected clients
 * - each Collection intercepts the WebSocket message and update its records accordingly
 * - each data Component (field, datatable...) intercepts the message and updates its UI accordingly
 * 
 * Currently, database mutations must be performed at the Record level.
 * 
 * kiss.data.Collection | kiss.db | HTTP | KissJS server - Node.controller | MongoDb database
 * --- | --- | --- | --- | ---
 * find() | find | GET /modelId | find | find({})
 * find(query) | find(modelId, query) | POST /modelId :body=query | findAndSort(query) | find(query.filter).sort(query.sort)
 * findOne(recordId) | findOne(modelId, recordId) | GET /modelId/recordId | findOne | collection.findOne
 * insertOne(record) | insertOne(modelId, record) | POST /modelId :body=record | insertOne | insertOne
 * insertMany(records) | insertMany(modelId, records) | POST /modelId :body=records | insertMany | insertMany
 * updateOne(recordId, update) | updateOne(modelId, recordId, update) | PATCH /modelId/recordId :body=update | updateOne | updateOne
 * updateMany(query, update) | updateMany(modelId, query, updates) | PATCH /modelId/ :body=query+updates | updateMany | updateMany
 * deleteOne(recordId) | deleteOne(modelId, recordId) | DELETE /modelId/recordId | delete | delete (performs a soft delete)
 * <none> | updateBulk(modelId, updates) | PATCH /modelId/ :body=updates | updateBulk | updateBulk
 * 
 * Technical notes about performances:
 * - KissJS collections don't contain raw data, but actual record's instances
 * - this allows to use virtual (computed) fields as normal fields, and even perform aggregations on those fields
 * - the process of instanciating a record takes a linear time which is about 0.0004ms per field for an Intel core i7-4790K
 * - for example: it take 24ms to load 5000 records with 12 fields, or 480ms to load 50000 records with 24 fields
 * 
 * @param {object} config - Collection configuration
 * @param {string} [config.mode] - "memory" | "offline" | "online"
 * @param {string} [config.id]
 * @param {object} config.model - The Model used to build the collection
 * @param {object[]} [config.records] - Records to init the collection: [{...}, {...}, ...]
 * @param {object} [config.sort] - default sort
 * @param {object} [config.filter] - default filter
 * @param {object} [config.projection] - default projection
 * @param {object} [config.group] - default grouping
 * @param {boolean} [config.groupUnwind] - Unwind allow records belonging to multiple groups to appear as multiple entries
 * @param {boolean} [config.showLoadingSpinner] - if false, doesn't show the loading spinner while retrieving data (default = true)
 * 
 * @example
 * // Register a new collection
 * let userCollection = new kiss.data.Collection({model: modelUser})
 * 
 * // Get collection records
 * let users = await userCollection.find()
 * 
 * // Create a new model and use its auto-generated collection
 * let taskModel = new kiss.data.Model({
 *  id: "YOUR_MODEL_ID",
 *  name: "task",
 *  namePlural: "tasks",
 *  items: [
 *      {id: "name", label: "Name", type: "text"},
 *      {id: "duedate", label: "Due date", type: "date"},
 *      {id: "done", label: "Done?", type: "checkbox"} // = Checkbox implicit type is "boolean"
 *  ]
 * })
 * 
 * // Create a new Record
 * let newTask = taskModel.create({name: "Task 1", duedate: "2021-03-30", done: false})
 * await newTask.save()
 * 
 * // Get the default collection for this model, then get the records
 * let tasksCollection = kiss.app.collections["YOUR_MODEL_ID"]
 * let tasks = await tasksCollection.find()
 * console.log(tasks)
 */
kiss.data.Collection = class {

    constructor(config) {
        this.id = config.id || uid()

        // Define collection's database (memory, offline, online)
        this.mode = config.mode || kiss.db.mode
        this.db = kiss.db[this.mode]

        // Define collection's model
        this.model = config.model
        this.modelId = this.model.id
        this.modelName = this.model.name

        log(`kiss.data.Collection - Defining collection ${this.id} for <${this.modelName}> in mode <${this.mode}>`)

        // The model's master collection is the default model's collection and is a proxy to access *all* its records (no filter)
        // TODO: for the "in-memory" strategy, we can cache the master collection in db.memory then use it as a local proxy source for all data components
        this.isMaster = config.isMaster || false

        // Keep a pointer to the master collection in any case
        this.masterCollection = (this.isMaster) ? this : kiss.app.collections[this.modelId]

        // Init records
        this.records = config.records || []

        // By default, records are not loaded automatically into the collection
        this.isLoaded = false
        this.showLoadingSpinner = (config.showLoadingSpinner === false) ? false : true

        // Filter sort, project, group, group unwind
        this.filter = config.filter || {}
        this.filterSyntax = config.filterSyntax || "normalized"
        this.sort = config.sort || []
        this.sortSyntax = config.sortSyntax || "normalized"
        this.projection = {}
        this.group = config.group || []
        this.groupUnwind = config.groupUnwind || false

        // Init
        this._initSubscriptions()

        // Hooks
        this.hooks = {
            beforeInsert: [],
            afterInsert: [],
            beforeUpdate: [],
            afterUpdate: [],
            beforeDelete: [],
            afterDelete: []
        }

        // Self-register in the kiss.app object
        kiss.app.collections[this.id] = this

        return this
    }

    /**
     * Initialize the collection subscriptions to the PubSub events :
     * 1 - Listen to database mutations (broadcasted via PubSub)
     * 2 - Update collection's records accordingly
     * 
     * @private
     * @ignore
     */
    _initSubscriptions() {
        this.subscriptions = [
            subscribe("EVT_DB_INSERT:" + this.modelId.toUpperCase(), (msgData) => {
                if (msgData.dbMode != this.mode) return
                this._insertOne(msgData.data)
            }),

            subscribe("EVT_DB_UPDATE:" + this.modelId.toUpperCase(), (msgData) => {
                if (msgData.dbMode != this.mode) return
                this._updateOne(msgData.id, msgData.data)
            }),

            subscribe("EVT_DB_DELETE:" + this.modelId.toUpperCase(), (msgData) => {
                if (msgData.dbMode != this.mode) return
                this._deleteOne(msgData.id)
            }),

            subscribe("EVT_DB_UPDATE_BULK", (msgData) => {
                if (msgData.dbMode != this.mode) return
                msgData.data.forEach(operation => {
                    if (operation.modelId == this.modelId) {
                        this._updateOne(operation.recordId, operation.updates)
                    }
                })
            }),

            subscribe("EVT_DB_INSERT_MANY:" + this.modelId.toUpperCase(), (msgData) => {
                if (msgData.dbMode != this.mode) return
                this.find({}, true)
            }, `Collection.insertMany / Model: ${this.model.name}`),

            subscribe("EVT_DB_DELETE_MANY:" + this.modelId.toUpperCase(), (msgData) => {
                if (msgData.dbMode != this.mode) return
                this.find({}, true)
            }, `Collection.deleteMany / Model: ${this.model.name}`)
        ]
    }

    /**
     * Destroy the collection.
     * 
     * It deletes the collection and also unsubscribes all its events from kiss.pubsub
     * 
     * @param {boolean} deleteInMemoryDb - If true, force to destroy the in-memory database
     * 
     */
    destroy(deleteInMemoryDb) {
        // Unsubscribe all the collection events from the PubSub
        this.subscriptions.forEach(subscriptionId => kiss.pubsub.unsubscribe(subscriptionId))

        // Delete NeDb collection if we're working with a temporary in-memory collection,
        // except if the general application mode is in-memory (it would destroy the master collection)
        if (this.mode == "memory" && kiss.db.mode != "memory" || deleteInMemoryDb) {
            this.db.deleteCollection(this.modelId)
        }

        // Unregister the collection from kiss.app
        delete kiss.app.collections[this.id]

        // Delete the Collection object
        delete this
    }

    /**
     * Clone the collection to memory.
     * This allows to create a temporary in-memory collection that is a copy of the current collection.
     * 
     * @returns {object} The cloned collection
     */
    clone(mode) {
        const clonedCollection = new kiss.data.Collection({
            id: uid(),
            mode: this.mode,
            model: this.model,
            records: this.records,
            filter: this.filter,
            filterSyntax: this.filterSyntax,
            sort: this.sort,
            sortSyntax: this.sortSyntax,
            projection: this.projection,
            group: this.group,
            groupUnwind: this.groupUnwind
        })

        clonedCollection.isLoaded = this.isLoaded
        clonedCollection._initSubscriptions()

        log(`kiss.data.Collection - Cloning collection ${this.model.name} (${clonedCollection.id}) in mode ${mode || this.mode}...`)

        return clonedCollection
    }

    /**
     * Set the database mode
     * 
     * @param {string} mode - memory | offline | online
     */
    setMode(mode) {
        this.mode = mode
        this.db = kiss.db[mode]
    }

    /**
     * Add a hook to perform an action before or after a mutation occurs (insert, update, delete)
     * 
     * @param {string} hookType - "beforeInsert" | "beforeUpdate" | "beforeDelete" | "afterInsert" | "afterUpdate" | "afterDelete"
     * @param {function} callback - Function to execute. It receives the following parameters: *insert(record), *update(recordId, update), *delete(recordId)
     * @returns this
     * 
     * @example
     * 
     * // It's possible to add a hook to observe a mutation
     * tasksCollection.addHook("beforeInsert", function(record) {
     *  console.log("The following record will be inserted:")
     *  console.log(record)
     * })
     * 
     * // It's possible to add multiple hooks to the same mutation
     * tasksCollection.addHook("beforeInsert", function(record) {
     *  console.log("Another function executed for the same mutation!")
     * })
     * 
     * // Input parameters of the callback depend on the mutation type
     * tasksCollection.addHook("afterUpdate", function(recordId, update) {
     *  console.log("The record has been udpated: " + recordId)
     *  console.log(update)
     * })
     * 
     * tasksCollection.addHook("afterDelete", function(recordId) {
     *  console.log("The following record has been udpated: " + recordId)
     * })
     */
    addHook(hookType, callback) {
        if (["beforeInsert", "beforeUpdate", "beforeDelete", "afterInsert", "afterUpdate", "afterDelete"].includes(hookType)) this.hooks[hookType].push(callback)
        return this
    }

    /**
     * Hooks
     * 
     * @private
     * @ignore
     */
    _hookInsert(type, record) {
        let event = type + "Insert"
        if (this.hooks[event].length != 0) {
            this.hooks[event].forEach(hook => {
                hook(record)
            })
        }
    }

    _hookUpdate(type, recordId, update) {
        let event = type + "Update"
        if (this.hooks[event].length != 0) {
            this.hooks[event].forEach(hook => {
                hook(recordId, update)
            })
        }
    }

    _hookDelete(type, recordId) {
        let event = type + "Delete"
        if (this.hooks[event].length != 0) {
            this.hooks[event].forEach(hook => {
                hook(recordId)
            })
        }
    }

    /**
     * Insert one record into the collection.
     * 
     * @private
     * @ignore
     * @param {object} record 
     */
    _insertOne(record) {
        log("kiss.data.Collection - _insertOne in collection " + this.id, 0, record)

        const existingRecord = this.records.get(record.id)
        if (existingRecord) {
            log("kiss.data.Collection - _insertOne rejected because it violates the unique constraint", 4)
            return
        }

        // Hook before
        this._hookInsert("before", record)

        const newRecord = this.model.create(record)
        this.records.push(newRecord)
        this.hasChanged = true

        // Hook after
        this._hookInsert("after", record)
    }

    /**
     * Update all the records that have a given id.
     * 
     * @private
     * @ignore
     * @param {string} recordId
     * @param {object} update - The update to apply to a record. Example: {firstName: "Bob"}
     */
    _updateOne(recordId, update) {
        // log(`kiss.data.Collection - _updateOne in collection ${this.id} / Record: ${recordId}`, 0, update)


        // Hook before
        this._hookUpdate("before", recordId, update)

        // There are 2 scenarios:
        // 1. the collection is not grouped and unwound: there is only one occurence of each record
        // 2. the collection is grouped and unwound: the same records can appear multiple times in different groups

        // Case 1: ungrouped, or grouped but not unwound
        let groupId
        if (this.groupUnwind !== true) {

            // Update the visible records
            let record = this.records.get(recordId)
            if (record) {
                Object.assign(record, update)
                groupId = record.$groupId
            }
            
            // Update the collapsed records (they are not visible and stored in cache)
            if (this.group.length > 0) {
                Object.values(this.cachedRecords).forEach(collapsedGroupRecords => {
                    let record = collapsedGroupRecords.get(recordId)
                    if (record) {
                        Object.assign(record, update)
                        groupId = record.$groupId
                    }
                })
            }
        }
        // Case 2: grouped and unwound
        else {

            // Update the visible records
            this.records.forEach(record => {
                if (record.id == recordId) Object.assign(record, update)
            })

            // Update the collapsed records (they are not visible and stored in cache)
            if (this.group.length > 0) {
                Object.values(this.cachedRecords).forEach(collapsedGroupRecords => {
                    collapsedGroupRecords.forEach(record => {
                        if (record.id == recordId) Object.assign(record, update)
                    })
                })
            }
        }

        // Update aggregation, if needed
        if (groupId) {
            this._groupUpdateAggregations(groupId)
        }

        this.hasChanged = true

        // Hook after
        this._hookUpdate("after", recordId, update)
    }

    /**
     * Delete all the records that have a specific id.
     * There can be multiple records with the same id if the view is grouped and unwound.
     * TODO: optimize process for ungrouped collections, like for _updateOne
     * 
     * @private
     * @ignore
     * @param {string} recordId
     */
    _deleteOne(recordId) {
        log("kiss.data.Collection - _deleteOne in collection " + this.id, 2)

        // Hook before
        this._hookDelete("before", recordId)

        // Delete the visible records
        this.records = this.records.filter(record => record.id != recordId)

        // Delete the collapsed records (they are not visible and stored in cache)
        if (this.group.length > 0) {
            Object.values(this.cachedRecords).forEach(collapsedGroupRecords => {
                collapsedGroupRecords = collapsedGroupRecords.filter(record => record.id != recordId)
            })
        }

        this.hasChanged = true

        // Hook after
        this._hookDelete("after", recordId)
    }

    /**
     * Insert many records in the collection
     * 
     * @async
     * @param {object[]} records - An array of records [{...}, {...}] for bulk insert
     * @returns {object[]} The array of inserted records data
     */
    async insertMany(records) {
        return await this.db.insertMany(this.modelId, records)
    }

    /**
     * Insert one record in the collection
     * 
     * @async
     * @param {object} record - A single record
     * @returns {object} The inserted record data
     */
    async insertOne(record) {
        return await this.db.insertOne(this.modelId, record)
    }

    /**
     * Update a single record in the collection
     * 
     * @async
     * @param {string} recordId
     * @param {object} update
     * @returns {object} The request's result
     */
    async updateOne(recordId, update) {
        return await this.db.updateOne(this.modelId, recordId, update)
    }

    /**
     * Delete a record from the collection
     * 
     * @async
     * @param {string} recordId
     * @param {boolean} [sendToTrash] - If true, keeps the original record in a "trash" collection
     * @returns The request's result
     */
    async deleteOne(recordId, sendToTrash) {
        return await this.db.deleteOne(this.modelId, recordId, sendToTrash)
    }

    /**
     * Update many records in a single collection
     * 
     * @async
     * @param {object} query
     * @param {object} update
     * @returns The request's result
     */
    async updateMany(query, update) {
        return await this.db.updateMany(this.modelId, query, update)
    }

    /**
     * Delete many records from a collection
     * 
     * @async
     * @param {object} query
     * @param {boolean} [sendToTrash] - If true, keeps the original record in a "trash" collection
     * @returns The request's result
     */
    async deleteMany(query, sendToTrash) {
        await this.db.deleteMany(this.modelId, query, sendToTrash)
    }

    /**
     * Insert some fake records in the collection, for testing purpose.
     * 
     * It automatically uses the model's fields to generate fake data.
     * 
     * @async
     * @param {integer} numberOfRecords - Number of fake records to insert
     * @returns {object[]} The array of inserted records data
     * 
     * @example
     * await myCollection.insertFakeRecords(100)
     */
    async insertFakeRecords(numberOfRecords) {
        return await kiss.db.insertFakeRecords(this.modelId, this.model.getFields(), numberOfRecords)
    }

    /**
     * Delete the all fake records created with the method *createFakeRecords*
     * 
     * @async
     * 
     * @example
     * await myCollection.deleteFakeRecords()
     */
    async deleteFakeRecords() {
        await kiss.db.deleteFakeRecords(this.modelId)
    }

    /**
     * Get the records matching a query.
     * 
     * Remember:
     * - without a query parameter, it returns all the records of the collection.
     * - the filter can be given as a normalized object which is easy to serialize / deserialize, or as a MongoDb query
     * - the sort can be given as a normalized object, or as a MongoDb sort
     * - in future releases of kissjs, the query syntax could be extended to "sql"
     * 
     * For more details about the query object, check the example in the [db.find()](kiss.db.html#.find) api.
     * 
     * Tech note:
     * This method is the one generating the most http traffic, because it returns a collection of records.
     * Due to the extremely loose coupling system of KissJS components, it can happen that many components
     * are requesting the same collection at the same time, without knowing it.
     * 
     * To solve this, the method is optimized to request the database only once using a combination of pubsub and Promise:
     * - the 1st call is changing the collection state "isLoading" to true
     * - because isLoading is now true, subsequent calls wait for the response of the 1st call inside a promise, which is waiting for the pubsub event "EVT_COLLECTION_LOADED"
     * - when the 1st call has a result, it broadcasts the result in the "EVT_COLLECTION_LOADED" channel, then turns the collection state "isLoading" to false
     * - when the subsequent calls receive the result in the pubsub, the promise resolves
     * 
     * @async
     * @param {object} [query] - Query object
     * @param {*} [query.filter] - The query
     * @param {string} [query.filterSyntax] - The query syntax. By default, passed as a normalized object
     * @param {*} [query.sort] - Sort fields
     * @param {string} [query.sortSyntax] - The sort syntax. By default, passed as a normalized array
     * @param {string[]} [query.group] - Array of fields to group by: ["country", "city"]
     * @param {boolean} [query.groupUnwind] - true to unwind the fields for records that belongs to multiple groups
     * @param {object} [query.projection] - {firstName: 1, lastName: 1, password: 0}
     * @param {object} [query.skip] - Number of records to skip
     * @param {object} [query.limit] - Number of records to return
     * @param {boolean} [nocache] - Force the collection to request the database instead of returning the cache
     * @param {boolean} [nospinner] - Hide the loading spinner if true
     * @returns {array} Array of records
     * 
     * @example
     * // Retrieves the records using the default or last used query parameters
     * let myRecords = await myCollection.find()
     * 
     * // Retrieves the records matching a MongoDb query
     * let myRecords = await myCollection.find({
     *  filterSyntax: "mongo", // Means we use a standard MongoDb query syntax
     *  filter: {
     *      $and: [
     *          {yearOfBirth: 1980},
     *          {country: "USA"}
     *      ]
     *  },
     *  sortSyntax: "mongo",
     *  sort: {
     *      birthDate: 1,
     *      lastName: -1
     *  },
     *  group: ["state", "city"]
     *  skip: 200,
     *  limit: 100,
     * )
     * 
     * // Retrieves the records using a normalized query
     * let myRecords = await myCollection.find({
     *  filterSyntax: "normalized",
     *  filter: {
     *      type: "group",
     *      operator: "and",
     *      filters: [
     *          {
     *              type: "filter",
     *              fieldId: "firstName",
     *              operator: "contains",
     *              value: "wilson"
     *          },
     *          {
     *              type: "filter",
     *              fieldId: "birthDate",
     *              operator: ">",
     *              value: "2020-01-01"
     *           }
     *      ]
     *  },
     *  sortSyntax: "normalized",
     *  sort: [
     *      {birthDate: "desc"},
     *      {lastName: "asc"}
     *  ],
     *  group: ["state", "city"],
     *  skip: 200,
     *  limit: 100,
     * })
     */
    async find(query = {}, nocache, nospinner) {
        let loadingId

        try {
            // If the collection records haven't changed and cache is allowed, we return its current records
            // TODO: test if the query is the same
            if (this.isLoaded && this.hasChanged == false && nocache != true) {
                log(`kiss.data.Collection - find - ${this.id} (${this.mode}) - Got ${this.records.length} record(s) from CACHE`, 2)
                return this.records
            }

            // If the collection is already loading, we wait for the loading process to finish so that we can capture its result
            // TODO: test if the query is the same
            if (this.isLoading && !this.hasChanged) {
                this.records = await new Promise((resolve, reject) => {
                    const subscriptionId = subscribe("EVT_COLLECTION_LOADED:" + this.id, (msgData) => {
                        kiss.pubsub.unsubscribe(subscriptionId)
                        resolve(msgData)
                    })
                })

                log(`kiss.data.Collection - find - ${this.id} (${this.mode}) - Got ${this.records.length} record(s) from PUBSUB`, 2)
                return this.records
            }

            log(`kiss.data.Collection - find - ${this.id} (${this.mode})`)
            if (this.showLoadingSpinner && nospinner != true) loadingId = kiss.loadingSpinner.show()

            this.isLoading = true
            this.isLoaded = false
            this.hasChanged = false
            this.cachedRecords = []

            // Update filter, projection, sort, group, skip, limit, normalization
            if (query.filter) this.filter = query.filter
            if (query.filterSyntax) this.filterSyntax = query.filterSyntax
            if (query.sort) this.sort = query.sort
            if (query.sortSyntax) this.sortSyntax = query.sortSyntax
            if (query.group) this.group = query.group
            if (query.groupUnwind) this.groupUnwind = query.groupUnwind
            if (query.projection) this.projection = query.projection
            if (query.skip) this.skip = query.skip
            if (query.limit) this.limit = query.limit

            let search = {
                operation: "search",
                filter: this.filter,
                filterSyntax: this.filterSyntax || "normalized",
                sort: this.sort,
                sortSyntax: this.sortSyntax || "normalized",
                group: this.group,
                groupUnwind: this.groupUnwind,
                projection: this.projection,
                skip: this.skip,
                limit: this.limit
            }

            if (this.group.length != 0) {

                // Case 1. Records are grouped by a field
                this.collapsedGroups = []
                this.groupedRecords = await this.db.find(this.modelId, search, this.mode)
                this.groupedRecords = this.groupedRecords.map(record => this.model.create(record))
                this.groupedRecords = this._groupBy(this.groupedRecords, this.group, this.groupUnwind)

                // Convert the hierarchical structure of this.groupedRecords (a Map of Maps of Maps...)
                // into a flat array where each group / sub-group is represented by a "group" row in the datatable
                this._groupBuildHierarchy()

            } else {

                // Case 2. Records are not grouped
                this.records = await this.db.find(this.modelId, search, this.mode)
                this.records = this.records.map(record => this.model.create(record))
                this.count = this.records.length
            }

            this.hasChanged = false
            this.isLoading = false
            this.isLoaded = true

            // Broadcast result to parallel queries
            publish("EVT_COLLECTION_LOADED:" + this.id, this.records)
            log(`kiss.data.Collection - find - ${this.id} (${this.mode}) - Got ${this.records.length} record(s) from DATABASE`, 2)

            if (this.showLoadingSpinner && nospinner != true) kiss.loadingSpinner.hide(loadingId)
            return this.records

        } catch (err) {
            //if (!this.records) this.records = []
            this.isLoaded = false
            this.isLoading = false
            this.hasChanged = false

            if (this.showLoadingSpinner && nospinner != true) kiss.loadingSpinner.hide(loadingId)
            return this.records
        }
    }

    /**
     * Get a single record of the collection ASYNCHRONOUSLY
     * 
     * @async
     * @param {string} recordId
     * @param {boolean} nocache - If true, doesn't use cache
     * @returns {object} The record, or false is not found
     * 
     * @example
     * const myRecord = await myCollection.findOne("Xzyww90sqxnllM38")
     */
    async findOne(recordId, nocache) {
        log(`kiss.data.Collection - findOne ${this.model.name} - ${this.id} - Record: ${recordId}`)

        let record

        if (this.isLoaded && !this.hasChanged && !nocache) {
            log(`kiss.data.Collection - returning cached record`)
            record = this.records.get(recordId)
        }

        if (!record) {
            log(`kiss.data.Collection - retrieving record from db`)

            let recordData = await this.db.findOne(this.modelId, recordId)
            if (!recordData) return false
            record = this.model.create(recordData)
        }

        return record
    }

    /**
     * Get multiple records of the collection, found by id
     * 
     * @async
     * @param {string} recordIds - ids of the records to retrieve
     * @param {object[]|object} [sort] - Sort options, as a normalized array or a Mongo object. Normalized example: [{fieldA: "asc"}, {fieldB: "desc"}]. Mongo example: {fieldA: 1, fieldB: -1}
     * @param {string} [sortSyntax] - Sort syntax: "nomalized" | "mongo". Default is normalized
     * @param {boolean} [nocache] - If true, doesn't use cache. Default is false
     * @returns {object[]} The list of records, or false is not found
     * 
     * @example
     * const myRecord = await myCollection.findOne("Xzyww90sqxnllM38")
     */
    async findById(recordIds, sort = [], sortSyntax = "normalized", nocache) {
        log(`kiss.data.Collection - findById ${this.model.name} - ${this.id} - Records: ${recordIds}`)

        let records = []
        let missingRecordIds = [...recordIds]

        if (this.isLoaded && !this.hasChanged && !nocache) {
            log(`kiss.data.Collection - returning cached records`)

            while (recordIds.length > 0) {
                let recordId = recordIds.pop()
                let record = this.records.get(recordId)

                if (record) {
                    records.push(record)
                    missingRecordIds.pop()
                }
            }

            if (missingRecordIds.length == 0) return records
        }

        if (missingRecordIds.length > 0) {
            log(`kiss.data.Collection - retrieving missing records from db`)

            let missingRecords = await this.db.findById(this.modelId, missingRecordIds, sort, sortSyntax)
            if (!missingRecords) return false

            records = records.concat(missingRecords)
            records = records.map(record => this.model.create(record))
            return records
        }
    }

    /**
     * Get a single record of the collection SYNCHRONOUSLY
     * 
     * Important: the collection must be loaded before using this method, or it will return undefined
     * 
     * @param {string} recordId 
     * @returns {object} The record
     * 
     * @example
     * const myRecord = myCollection.getRecord("Xzyww90sqxnllM38")
     */
    getRecord(recordId) {
        return this.records.get(recordId)
    }

    /**
     * Filter the collection
     * 
     * @async
     * @param {object} filterConfig - Use MongoDb syntax
     * @returns {object[]} Array of records
     * 
     * @example
     * await myCollection.filterBy({
     *  $and: [
     *      {yearOfBirth: 1980},
     *      {country: "USA"}
     *  ]
     * })
     */
    async filterBy(filterConfig) {
        this.filter = filterConfig
        this.hasChanged = true
        await this.find()
        return this.records
    }

    /**
     * Sort the collection
     * 
     * @async
     * @param {object[]} sortConfig - Array of fields to sort by.
     * 
     * @example
     * await myCollection.sortBy(
     *  [
     *      {firstName: "asc"},
     *      {birthDate: "desc"}
     *  ]
     * )
     */
    async sortBy(sortConfig) {
        this.sort = sortConfig
        this.hasChanged = true
        await this.find()
    }

    /**
     * Set a groupBy field and reload the records
     * 
     * @async
     * @param {string[]} groupFields - Array of fields to group by.
     * 
     * @example
     * await myCollection.groupBy(["country", "city", "age"])
     */
    async groupBy(groupFields) {
        this.group = (groupFields.length != 0) ? groupFields : []
        this.hasChanged = true
        await this.find()
    }

    /**
     * Expand all groups
     */
    groupExpandAll() {
        this.collapsedGroups = []
        this.cachedRecords = {}
        this._groupBuildHierarchy()
    }

    /**
     * Collapse all groups
     */
    groupCollapseAll() {
        this.collapsedGroups = []
        this.cachedRecords = {}
        this._groupBuildHierarchy(true)
    }

    /**
     * Group the records by 1 or multiple fields
     * 
     * @private
     * @ignore
     * @param {object[]} records - Records to group
     * @param {string[]} fieldIds - Array of field ids by which records should be grouped
     * @param {boolean} groupUnwind - true to unwind fields with multiple values over multiple groups
     * @returns {Map} - Where the Map key is the field value (= group) and the Map values are the records belonging to this group
     * 
     * @note
     * We've built different functions for performance reasons.
     * Having a single function would have required to perform a test within huge loops, which costs extra processing
     */
    _groupBy(records, fieldIds, groupUnwind) {
        switch (fieldIds.length) {
            case 1:
                return this._groupBy1Field(records, fieldIds, groupUnwind)
                break
            case 2:
                return this._groupBy2Fields(records, fieldIds, groupUnwind)
                break
            case 3:
                return this._groupBy3Fields(records, fieldIds, groupUnwind)
                break
            case 4:
                return this._groupBy4Fields(records, fieldIds, groupUnwind)
                break
            case 5:
                return this._groupBy5Fields(records, fieldIds, groupUnwind)
                break
            case 6:
                return this._groupBy6Fields(records, fieldIds, groupUnwind)
                break
        }
    }

    /**
     * Group the records by 1 field.
     * TODO: USE DIFFERENT GROUPERS DEPENDING ON FIELD TYPE TO AVOID TESTING INSIDE LOOPS!!!
     * 
     * @private
     * @ignore
     * @param {object[]} records - Records to group
     * @param {string[]} fieldIds - Array of field ids by which records should be grouped
     * @param {boolean} groupUnwind - true to unwind fields with multiple values over multiple groups
     * @returns {Map} Where the Map key is the field value (= group) and the Map values are the records belonging to this group
     */
    _groupBy1Field(records, fieldIds, groupUnwind) {
        const fieldId = fieldIds[0]

        // Unwind group if the field is a multi-valued field:
        // - select field with multiple = true
        // - collaborator field with multiple = true
        // if (groupUnwind) return this._groupBy1UnwoundField(records, fieldIds)
        const groupField = this.model.getField(fieldId)
        if (groupField.multiple) {
            return this._groupBy1UnwoundField(records, fieldIds)
        }

        return records.reduce((map, record) => {
            let value = record[fieldId]

            if (Array.isArray(value)) value = value[0]
            return map.set(value, [...map.get(value) || [], record])
        }, new Map())
    }

    /**
     * Virtualize a record to be able to assign it multiple $groupId values.
     * This is used only for the purpose of aggregations on multi-values fields
     * 
     * @private
     * @ignore
     * @param {object} record 
     * @returns The proxified record
     */
    _proxifier(record) {
        let groupId = null
        return new Proxy(record, {
            set(target, prop, value) {
                if (prop == "$groupId") {
                    groupId = value
                    return true
                }
                target[prop] = value
                return true
            },
            get(target, prop) {
                if (prop == "$groupId") return groupId
                else return target[prop]
            }
        })
    }

    /**
     * Group the records by 1 field
     * + unwind fields with multiple values
     * 
     * @private
     * @ignore
     * @param {object[]} records - Records to group
     * @param {string[]} fieldIds - Array of field ids by which records should be grouped
     */
    _groupBy1UnwoundField(records, fieldIds) {
        const fieldId = fieldIds[0]

        return records.reduce((map, record) => {
            [].concat(record[fieldId])
                .forEach(value => {
                    map.set(value, [...map.get(value) || [], this._proxifier(record)]) // Build & feed a new category per unwound value
                })
            return map
        }, new Map())
    }

    /**
     * Group the records by 2 fields.
     * 
     * @private
     * @ignore
     * @param {*} records - Records to group
     * @param {string[]} fieldIds - Array of field ids by which records should be grouped
     * @returns {Map} Where the Map key is the field value (= group) and the Map values are the records belonging to this group
     */
    _groupBy2Fields(records, fieldIds) {
        let map = new Map()

        records.forEach(record => {
            let groupLevel1 = record[fieldIds[0]]
            if (Array.isArray(groupLevel1)) groupLevel1 = groupLevel1[0]

            let groupLevel2 = record[fieldIds[1]]
            if (Array.isArray(groupLevel2)) groupLevel2 = groupLevel2[0]

            if (!map.get(groupLevel1)) map.set(groupLevel1, new Map())
            map.get(groupLevel1).set(groupLevel2, [...map.get(groupLevel1).get(groupLevel2) || [], record])
        })
        return map
    }

    /**
     * Group the records by 3 fields.
     * 
     * @private
     * @ignore
     * @param {*} records - Records to group
     * @param {string[]} fieldIds - Array of field ids by which records should be grouped
     * @returns {Map} Where the Map key is the field value (= group) and the Map values are the records belonging to this group
     */
    _groupBy3Fields(records, fieldIds) {
        let map = new Map()

        records.forEach(record => {
            let groupLevel1 = record[fieldIds[0]]
            if (Array.isArray(groupLevel1)) groupLevel1 = groupLevel1[0]

            let groupLevel2 = record[fieldIds[1]]
            if (Array.isArray(groupLevel2)) groupLevel2 = groupLevel2[0]

            let groupLevel3 = record[fieldIds[2]]
            if (Array.isArray(groupLevel3)) groupLevel3 = groupLevel3[0]

            if (!map.get(groupLevel1)) map.set(groupLevel1, new Map())
            if (!map.get(groupLevel1).get(groupLevel2)) map.get(groupLevel1).set(groupLevel2, new Map())
            map.get(groupLevel1).get(groupLevel2).set(groupLevel3, [...map.get(groupLevel1).get(groupLevel2).get(groupLevel3) || [], record])
        })
        return map
    }

    /**
     * Group the records by 4 fields.
     * 
     * @private
     * @ignore
     * @param {*} records - Records to group
     * @param {string[]} fieldIds - Array of field ids by which records should be grouped
     * @returns {Map} Where the Map key is the field value (= group) and the Map values are the records belonging to this group
     */
    _groupBy4Fields(records, fieldIds) {
        let map = new Map()

        records.forEach(record => {
            let groupLevel1 = record[fieldIds[0]]
            if (Array.isArray(groupLevel1)) groupLevel1 = groupLevel1[0]

            let groupLevel2 = record[fieldIds[1]]
            if (Array.isArray(groupLevel2)) groupLevel2 = groupLevel2[0]

            let groupLevel3 = record[fieldIds[2]]
            if (Array.isArray(groupLevel3)) groupLevel3 = groupLevel3[0]

            let groupLevel4 = record[fieldIds[3]]
            if (Array.isArray(groupLevel4)) groupLevel4 = groupLevel4[0]

            if (!map.get(groupLevel1)) map.set(groupLevel1, new Map())
            if (!map.get(groupLevel1).get(groupLevel2)) map.get(groupLevel1).set(groupLevel2, new Map())
            if (!map.get(groupLevel1).get(groupLevel2).get(groupLevel3)) map.get(groupLevel1).get(groupLevel2).set(groupLevel3, new Map())
            map.get(groupLevel1).get(groupLevel2).get(groupLevel3).set(groupLevel4, [...map.get(groupLevel1).get(groupLevel2).get(groupLevel3).get(groupLevel4) || [], record])
        })
        return map
    }

    /**
     * Group the records by 5 fields.
     * 
     * @private
     * @ignore
     * @param {*} records - Records to group
     * @param {string[]} fieldIds - Array of field ids by which records should be grouped
     * @returns {Map} Where the Map key is the field value (= group) and the Map values are the records belonging to this group
     */
    _groupBy5Fields(records, fieldIds) {
        let map = new Map()

        records.forEach(record => {
            let groupLevel1 = record[fieldIds[0]]
            if (Array.isArray(groupLevel1)) groupLevel1 = groupLevel1[0]

            let groupLevel2 = record[fieldIds[1]]
            if (Array.isArray(groupLevel2)) groupLevel2 = groupLevel2[0]

            let groupLevel3 = record[fieldIds[2]]
            if (Array.isArray(groupLevel3)) groupLevel3 = groupLevel3[0]

            let groupLevel4 = record[fieldIds[3]]
            if (Array.isArray(groupLevel4)) groupLevel4 = groupLevel4[0]

            let groupLevel5 = record[fieldIds[4]]
            if (Array.isArray(groupLevel5)) groupLevel5 = groupLevel5[0]

            if (!map.get(groupLevel1)) map.set(groupLevel1, new Map())
            if (!map.get(groupLevel1).get(groupLevel2)) map.get(groupLevel1).set(groupLevel2, new Map())
            if (!map.get(groupLevel1).get(groupLevel2).get(groupLevel3)) map.get(groupLevel1).get(groupLevel2).set(groupLevel3, new Map())
            if (!map.get(groupLevel1).get(groupLevel2).get(groupLevel3).get(groupLevel4)) map.get(groupLevel1).get(groupLevel2).get(groupLevel3).set(groupLevel4, new Map())
            map.get(groupLevel1).get(groupLevel2).get(groupLevel3).get(groupLevel4).set(groupLevel5, [...map.get(groupLevel1).get(groupLevel2).get(groupLevel3).get(groupLevel4).get(groupLevel5) || [], record])
        })
        return map
    }

    /**
     * Group the records by 6 fields.
     * 
     * @private
     * @ignore
     * @param {*} records - Records to group
     * @param {string[]} fieldIds - Array of field ids by which records should be grouped
     * @returns {Map} Where the Map key is the field value (= group) and the Map values are the records belonging to this group
     */
    _groupBy6Fields(records, fieldIds) {
        let map = new Map()

        records.forEach(record => {
            let groupLevel1 = record[fieldIds[0]]
            if (Array.isArray(groupLevel1)) groupLevel1 = groupLevel1[0]

            let groupLevel2 = record[fieldIds[1]]
            if (Array.isArray(groupLevel2)) groupLevel2 = groupLevel2[0]

            let groupLevel3 = record[fieldIds[2]]
            if (Array.isArray(groupLevel3)) groupLevel3 = groupLevel3[0]

            let groupLevel4 = record[fieldIds[3]]
            if (Array.isArray(groupLevel4)) groupLevel4 = groupLevel4[0]

            let groupLevel5 = record[fieldIds[4]]
            if (Array.isArray(groupLevel5)) groupLevel5 = groupLevel5[0]

            let groupLevel6 = record[fieldIds[5]]
            if (Array.isArray(groupLevel6)) groupLevel6 = groupLevel6[0]

            if (!map.get(groupLevel1)) map.set(groupLevel1, new Map())
            if (!map.get(groupLevel1).get(groupLevel2)) map.get(groupLevel1).set(groupLevel2, new Map())
            if (!map.get(groupLevel1).get(groupLevel2).get(groupLevel3)) map.get(groupLevel1).get(groupLevel2).set(groupLevel3, new Map())
            if (!map.get(groupLevel1).get(groupLevel2).get(groupLevel3).get(groupLevel4)) map.get(groupLevel1).get(groupLevel2).get(groupLevel3).set(groupLevel4, new Map())
            if (!map.get(groupLevel1).get(groupLevel2).get(groupLevel3).get(groupLevel4).get(groupLevel5)) map.get(groupLevel1).get(groupLevel2).get(groupLevel3).get(groupLevel4).set(groupLevel5, new Map())
            map.get(groupLevel1).get(groupLevel2).get(groupLevel3).get(groupLevel4).get(groupLevel5).set(groupLevel6, [...map.get(groupLevel1).get(groupLevel2).get(groupLevel3).get(groupLevel4).get(groupLevel5).get(groupLevel6) || [], record])
        })
        return map
    }

    /**
     * Organize records grouped by a list of fields.
     * Each group is reduced to a single Map object which <key> is the value of the grouped field, and <values> are the records of the group.
     * For multi-level nested group, the values of intermediate levels are arrays of Maps, and only the last level holds the records.
     * 
     * @private
     * @ignore
     * @param {boolean} collapsed - Indicates wether the hierarchy of groups should be collapsed or expanded
     */
    _groupBuildHierarchy(collapsed) {
        this.records = []
        this.recordIndex = 0

        // Get the list of <number> fields
        // Those fields will be aggregated automatically
        this.numberFields = this.model.getFields().filter(field => kiss.tools.isNumericField(field))

        // Initiate the group level index
        // It's a n dimension array where each position corresponds to a depth into the hierarchy of groups
        // Example: [2,4] represents the fourth group within the second group.
        this.levelIndex = []

        // Start the analysis
        this._groupParse(this.groupedRecords, {}, 0, collapsed)
        this.count = this.records.length
    }

    /**
     * TODO: Work in progress for real-time update of aggregations
     * Recompute aggregations (sum, average...) for a group and its parent
     * @private
     * @ignore
     * @param {string} groupId 
     */
    _groupUpdateAggregations(groupId) {
        const numberFieldIds = this.numberFields.map(field => field.id)
        const groups = this.records.filter(record => record.$type == "group")
        const visibleRecords = this.records.filter(record => record.$groupId == groupId)
        // log(this.cachedRecords)
        // const hiddenRecords = this.cachedRecords[groupId].filter(record => record.$groupId == groupId)

        // log(visibleRecords)
        // log(hiddenRecords)

        // log(this.groupedRecords)
        // log(groupId)

        groups.forEach(group => {

            // log(group)
            // const groupRecords = this.groupedRecords.get(groupId)


            numberFieldIds.forEach(fieldId => {
                // log(">>>>>>>" + fieldId)
                // log(group[fieldId])
            })
        })
    }

    /**
     * Analyzes a data group and does a few things:
     * - injects a "group" record into the dataset (this will allow the view to render it differently compared to normal records)
     * - generates a groupId (example: 2.1.3) to keep track of the group into the source dataset (this.groupedRecords)
     * - computes the number of records within the group
     * - performs aggregations for number fields
     * - calls itself recursively to manage nested groups
     * 
     * @private
     * @ignore
     * @param {Map} group - Map where each key represents a group of records
     * @param {object} parentGroupData - Data representing the group, and injected as a "fake" record into the dataset
     * @param {number} groupLevel - 0-based group depth
     * @param {boolean} collapsed - If true, the records of the group are not injected into the dataset, but rather hold in a cache used when expanding the group
     */
    _groupParse(group, parentGroupData, groupLevel, collapsed) {
        this.levelIndex[groupLevel] = 0

        group.forEach((subgroup, key, map) => {

            // Compute the groupId, which is simply its level in the hierarchy. Examples: 7, or 6.5, or 4.3.2.1
            this.levelIndex[groupLevel] += 1
            const groupId = this.levelIndex.slice(0, groupLevel + 1).join(".")

            // Populate the groupId into the source dataset
            group.get(key).groupId = groupId

            // Add a "group" record into the dataset
            const subGroupData = {
                $type: "group",
                $groupLevel: groupLevel,
                $groupId: groupId,
                $size: subgroup.length,
                $name: key
            }

            if (!collapsed || groupLevel == 0) {
                this.records.push(subGroupData)
            } else {
                // If the group is collapsed (and not level 0), we put its data in cache instead of inserting it into the datatable
                this.cachedRecords[parentGroupData.$groupId] = (this.cachedRecords[parentGroupData.$groupId] || []).concat(subGroupData)
            }

            if (collapsed) this.collapsedGroups.push(groupId)

            if (subgroup instanceof Map) {
                // If the group is a Map,
                // it means it's a sub-group in the aggregation.

                // We parse this subgroup recursively
                const deeperSubGroup = this._groupParse(subgroup, subGroupData, groupLevel + 1, collapsed)

                // Compute the number of records for this group
                parentGroupData.$size = (parentGroupData.$size || 0) + deeperSubGroup.$size

                // Perform aggregations for number fields
                this.numberFields.forEach(field => {
                    const parentSum = (parentGroupData[field.id]) ? (parentGroupData[field.id].sum || 0) + deeperSubGroup[field.id].sum : deeperSubGroup[field.id].sum
                    parentGroupData[field.id] = {
                        sum: parentSum,
                        avg: parentSum / parentGroupData.$size
                    }
                })

            } else {
                // ...else, the group is an Array,
                // which means we've reach the last level in the hierarchy, and group items are records.

                // Compute the number of records for this group
                parentGroupData.$size = (parentGroupData.$size || 0) + subgroup.length

                // Perform aggregations for number fields
                this.numberFields.forEach(field => {
                    const sum = subgroup.reduce((sum, record) => {
                        return sum + (Number(record[field.id]) || 0)
                    }, 0)

                    subGroupData[field.id] = {
                        sum,
                        avg: sum / subgroup.length
                    }

                    const parentSum = (parentGroupData[field.id]) ? (parentGroupData[field.id].sum || 0) + sum : sum
                    parentGroupData[field.id] = {
                        sum: parentSum,
                        avg: parentSum / parentGroupData.$size
                    }
                })

                // Assign the groupId to all records belonging to this group
                subgroup.forEach(record => {
                    record.$groupId = groupId + "."
                    record.$index = this.recordIndex++

                    // subGroupData.$index = (subGroupData.$index || []).concat(record)
                })

                if (!collapsed) {
                    this.records.push(...subgroup)
                } else {
                    // If the group is collapsed, we put its data in cache instead of inserting it into the datatable
                    this.cachedRecords[groupId] = subgroup
                }
            }
        })
        return parentGroupData
    }

    /**
     * Expand a group.
     * 
     * Internally, it retrieves all the hidden records which are hold in cache, and reinjects them in the list of records.
     * 
     * @param {string} groupId - Id of the group to expand/collapse. Example: 3.10.7
     * @param {number} rowIndex - Index of the group row into the datatable
     */
    groupExpand(groupId, rowIndex) {
        this.collapsedGroups.remove(groupId)

        // Re-insert the records of the group, at the right row index
        let recordsToInsert = this.cachedRecords[groupId]
        this.records.splice(Number(rowIndex) + 1, 0, ...recordsToInsert)

        // Re-compute record indexes
        let index = 0
        this.records.forEach(record => {
            if (record.$type != "group") record.$index = index++
        })

        this.count = this.records.length
    }

    /**
     * Collapse a group.
     * 
     * Internally, it does 2 things:
     * - builds a new dataset without the collapsed records
     * - stores in cache the records that are excluded from the dataset, to use them when expanding the group again
     * 
     * @param {string} groupId - Id of the group to expand/collapse. Example: 3.10.7
     */
    groupCollapse(groupId) {
        let recordsKept = []
        let recordsCached = []
        let groupIdToSearch = groupId + "."

        this.records.forEach(record => {
            if (!(record.$groupId.startsWith(groupIdToSearch))) {
                // Records to keep
                recordsKept.push(record)
            } else {
                // Records to exclude and cache
                recordsCached.push(record)
            }
        })
        this.records = recordsKept
        this.cachedRecords[groupId] = recordsCached

        // Re-compute the visible records indexes
        let index = 0
        this.records.forEach(record => {
            if (record.$type != "group") record.$index = index++
        })
        this.count = this.records.length

        // Keep track of the collapsed group
        this.collapsedGroups.push(groupId)
    }
}

;/**
 * 
 * Represents a **Model**.
 * 
 * The models are the central elements to structure the data of your applications.
 * The jargon can be slightly different depending on the frameworks, therefore, let's ensure we're talking the same language when it comes to **Model**, **Field**, **Record**, and **Collection**.
 * 
 * **Model**:
 * - a model is a representation of a real-world entity: a user, a car, an invoice, a task, a project, a dream, a quark
 * - a model defines the properties of the entity, but **is not** that entity: a model defines what is a car, but is not a car
 * - a model **must** define the properties of the entity. Ex: firstName, lastName, email
 * - a model **can** have custom methods. Ex: invite(), sendEmail(), ...
 * 
 * **Field**:
 * - a field is a single property of a model. Ex: firstName
 * - a field has an id. Ex: firstName, lastName, bwxJF4yz
 * - a field has a label. Ex: First name, Last name
 * - a field has a type. Ex: text, number, date, select
 * 
 * **Record**:
 * - a record is an entity created thanks to the model definition
 * - a record has data. Ex: firstName: **Bob**, lastName: **Wilson**, email: **bob@wilson.com**
 * - a record inherits the model's methods. Ex: myUser.invite(), myUser.sendMail()
 * 
 * **Collection**:
 * - a collection is an array of multiple records
 * - a collection acts as a proxy for model's data, with specific projection, filtering, sorting, grouping, paging...
 * - it means multiple collections can be bound to the same model
 * - a collection is useful to cache a specific set of records and represent them into the UI
 * - in KissJS, each record of a collection is not just a JSON object, but it's a Record's instance, so you can directly use its methods
 * 
 * <img src="../../resources/doc/KissJS - Data model.png">
 * 
 * In KissJS:
 * - a model needs basic properties like **id**, **name**, **items**
 * - a model needs to know its **singular** and its **plural** name: man / men, child / children, box / boxes, spy / spies 
 * - a model **can** have custom **methods**: sendEmail(), archive(), processTask()
 * - to be able to represent the model visually in KissJS applications, it has an **icon** and a **color** property
 * - to classify the models semantically, KissJS **can** have meta-data like **tags** and **domains**
 * 
 * You define a model passing its names (singular and plural) and its items:
 * ```
 * let spyModel = new kiss.data.Model({
 *  name: "spy",
 *  namePlural: "spies",
 *  items: [
 *      {label: "Spy code number"},
 *      {label: "Spy real name"}
 *  ]
 * })
 * ```
 * 
 * Important note about KissJS conventions:
 *  - we define model **items** instead of **fields**
 *  - fields have a **label** instead of a **name**
 * 
 * This is because KissJS shares a single convention for both the **model** and its direct UI representation: the **form**:
 * - forms have **items** (which can be fields, panels, buttons, images...)
 * - panels contain **fields** or other items (like **buttons**)
 * - fields have a **label**
 * - panels have a **title**
 * 
 * It means you can also define a model like this:
 * ```
 * let spyModel = new kiss.data.Model({
 *  name: "spy",
 *  namePlural: "spies",
 *  items: [
 *      {
 *          type: "panel",
 *          title: "General informations",
 *          items: [
 *              {label: "Spy code number"},
 *              {label: "Spy fake name"}
 *           ]
 *      },
 *      {
 *          type: "panel",
 *          title: "Secret informations",
 *          items: [
 *              {label: "Spy real name"},
 *              {label: "Last mission date"}
 *          ]
 *      }
 *  ]
 * })
 * ```
 * This model will be automatically represented by a form with 2 sections.
 * 
 * If you just give a label to a field, its **id** will be randomly generated.
 * To keep control over your field ids, just add them to the field definition:
 * ```
 * let newModel = new kiss.data.Model({
 *  name: "spy",
 *  namePlural: "spies",
 *  items: [
 *      {id: "code", label: "Spy code number"},
 *      {id: "name", label: "Spy real name"}
 *  ]
 * })
 * ```
 * The default type is "text", but you can of course define the field's type and **validation** rules:
 * - using **validation** property and a regex
 * - using **validationType** property for pre-defined rules (alpha, alphanumeric, email, url, ip)
 * ```
 * let newModel = new kiss.data.Model({
 *  name: "spy",
 *  namePlural: "spies",
 *  items: [
 *      {id: "code", label: "Spy code number", type: "text", validation: /^\d{3}$/}, // Force 3 digits, like "007"
 *      {id: "name", label: "Spy real name", type: "text"},
 *      {id: "missions", label: "Number of missions", type: "number"},
 *      {id: "lastMission", label: "Last mission date", type: "date"},
 *      {id: "secretEmail", label: "Spy secret mailbox", type: "text", validationType: "email"}, // Predefined validation type
 *      {id: "isActive", label: "Is this spy still active?", type: "checkbox"}
 *  ]
 * })
 * ```
 * The field **type** is used to define how the field is rendered into the UI, and its **data type** is implicit.
 * In the previous example, the **checkbox** type has implicitly a **boolean** data type.
 * 
 * Once a model has been defined, you can **create** model instances.
 * In KissJS, a model instance is called a **Record**:
 * 
 * ```
 * let userModel = kiss.app.models.user
 * let userRecord = userModel.create({firstName: "Bob", lastName: "Wilson"})
 * ```
 * 
 * **Fields**
 * 
 * To define a field, the minimum is to have a field **label**:
 * ```
 * {label: "First name"}
 * ```
 * 
 * If you just set a label, KissJS will automatically:
 * - generate an id, using [kiss.tools.shortUid()](kiss.tools.html#.shortUid)
 * - set the type to **text**
 * 
 * If you prefer having control over your field ids, do:
 * ```
 * {id: "firstName", label: "First name"}
 * ```
 * 
 * **Field types**
 * 
 * Because KissJS is primarily a **UI library**, it is designed to make it easier to display the model in the user interface.
 * It's a very opiniated architecture choice.
 * The point here is to keep the focus on the UI and not the underlying structure.
 * Doing that way allows us to just throw a model definition to KissJS and it will automagically generate the UI as a form.
 * 
 * **Basic field types:**
 * 
 * Field type | Data type | Displayed as
 * --- | --- | ---
 * text | text | input field
 * textarea | text | textarea field
 * number | number | number field
 * date | ISO 8601 extended. Example: 2021-04-01T23:20:15Z | date picker
 * checkbox | boolean | checkbox
 * select | string[] | single or multi-value dropdown list
 * rating | number | a rating field with stars (or other icons)
 * slider | number | a slider field
 * icon | string | a single icon field
 * iconPicker | string | an icon picker (using Font Awesome icons at the moment)
 * color | string | a single color field
 * colorPicker | string | a color picker
 * attachment | object | file upload control
 * 
 * **Special field types (non mandatory extensions):**
 * 
 * Field type | Data type | Displayed as
 * --- | --- | ---
 * aiTextarea | text | textarea field with AI suggestions
 * aiImage | object | file upload control with AI image generation
 * directory | string[] | dropdown list to select users and/or groups
 * link | * | list to show one or multiple records and create relationships between tables
 * lookup | * | computed field that lookup a value from a single foreign linked record
 * summary | * | computed field that makes a summary of multiple foreign linked records (a sum, a percentage, a concatenation...)
 * 
 * **Roadmap for news field types:**
 * - automatic number
 * - address (with search / completion and map)
 * - checkbox group (= just another UI for Select field with "multiple: true" option)
 * - radio group (= just another UI for Select field with "multiple: false" option)
 * - image (= just another UI for the attachment field)
 * 
 * **Methods:**
 * 
 * By default, every instanciated record will have default methods:
 * - save
 * - read
 * - update
 * - delete
 * 
 * But you can also define custom methods as well (just ensure their name doesn't conflict with default CRUD methods):
 * ```
 * let contactModel = new kiss.data.Model({
 *  name: "contact",
 *  namePlural: "contacts",
 *  items: [
 *      {id: "name", label: "Contact name", type: "text"},
 *      {id: "email", label: "Email", type: "text", validationType: "email"}
 *  ],
 *  methods: {
 *      sendEmail: function (subject, message) {
 *          yourSmtpService.sendMessage(this.email, subject, message)
 *      }
 *  }
 * })
 * 
 * // Instanciate a new record
 * let newContact = contactModel.create({name: "Bob", email: "bob@wilson.com"})
 * 
 * // Using its custom method
 * newContact.sendEmail("Urgent", "Do that")
 * ```
 * 
 * @param {object} config - model configuration
 * @param {string} [config.mode] - "memory" | "offline" | "online"
 * @param {string} [config.id]
 * @param {string} [config.templateId] - id of the original template model (used to keep track of the source model)
 * @param {string} [config.name] - Name of the model: Lead
 * @param {string} [config.namePlural] - Plural name: Leads
 * @param {object[]} config.items - Array for field definitions
 * @param {object} config.acl - model's acl (Access Control List)
 * @param {object} config.methods - model's methods
 * @param {object} [config.features] - model's features (workflow, comments, ...)
 * @param {string} [config.icon] - The Font Awesome icon class. Example: "fas fa-check"
 * @param {string} [config.color] - Hexa color. Ex: "#00aaee"
 * @param {string[]} [config.tags] - Ex: ["Leads", "Sales", "CRM", "HRM"]
 * @param {string[]} [config.domains] - Ex: ["banking", "insurance"]
 * 
 * @example
 * // Register a new model
 * let leadModel = new kiss.data.Model({
 *  name: "lead",
 *  namePlural: "leads",
 * 
 *  icon: "fas fa-user",
 *  color: "#00aaee",
 * 
 *  // Define model fiels
 *  items: [
 *      {
 *          label: "Name",
 *          id: "name",
 *          type: "text"
 *      },
 *      {
 *          primary: true, // Primary key field
 *          label: "Email",
 *          id: "email",
 *          type: "text",
 *          validationType: "email"
 *      },
 *      {
 *          label: "Category",
 *          id: "category",
 *          type: "select",
 *          options: [
 *              {
 *                  label: "National"
 *                  value: "NAT",
 *                  color: "#00aaee"
 *              },
 *              {
 *                  label: "International",
 *                  value: "INT",
 *                  color: "#aa00ee"
 *              }
 *          ]
 *      }
 *  ],
 * 
 *  // Define model methods
 *  methods: {
 *      // Get all the pending deals for this lead
 *      getPendingDeals: async function() {
 *          return await kiss.app.collections["deal"].find({
 *              filter: {
 *                  $and: [
 *                      {leadId: this.id},
 *                      {status: "pending"}
 *                  ]
 *              }
 *          })
 *      }
 *  }
 * })
 * 
 * // Your can create a new instance like this
 * let myLead = leadModel.create({name: "Bob Wilson", email: "bob@wilson.com", category: "INT"})
 * 
 * // Creating a new instance happens in memory. You have to save it manually with
 * await myLead.save()
 * 
 * // Updating an instance using default CRUD methods
 * await myLead.update({name: "Bob Wilson Junior"})
 * 
 * // Calling a custom method
 * let pendingDeals = await myLead.getPendingDeals()
 * 
 * // Deleting an instance
 * await myLead.delete()
 * 
 */
kiss.data.Model = class {

    constructor(config) {
        // log(`kiss.data.Model - Defining model <${config.name}>`, 0, config)

        // Define collection's database (memory, offline, online)
        this.mode = config.mode || kiss.db.mode
        this.db = kiss.db[this.mode]

        // Basic model properties
        this.id = config.id || this.namePlural || this.name || uid()
        this.accountId = config.accountId
        this.name = (config.name || this.id).toTitleCase()
        this.namePlural = (config.namePlural || this.id).toTitleCase()
        this.icon = config.icon || "fas fa-th"
        this.color = config.color || "#00aaee"
        this.backgroundColor = config.backgroundColor || "#ffffff"
        this.fullscreen = !!config.fullscreen
        this.align = config.align || "center"
        this.tags = config.tags || []
        this.domains = config.domains || []
        this.methods = config.methods || {}
        this.features = config.features
        this.splitBy = config.splitBy

        // Dynamic models get their acl rules from the generic "dynamicModel" definition
        this.acl = (kiss.tools.isUid(this.id) && kiss.app.models.dynamicModel) ? kiss.app.models.dynamicModel.acl : config.acl
        this.acl = this.acl || {}

        // Model access fields
        this.authenticatedCanCreate = config.authenticatedCanCreate
        this.authenticatedCanRead = config.authenticatedCanRead
        this.authenticatedCanUpdate = config.authenticatedCanUpdate
        this.authenticatedCanDelete = config.authenticatedCanDelete
        this.ownerCanManage = config.ownerCanManage
        this.accessCreate = config.accessCreate
        this.accessRead = config.accessRead
        this.accessUpdate = config.accessUpdate
        this.accessDelete = config.accessDelete
        this.accessManage = config.accessManage

        // Public forms
        this.public = !!config.public
        this.publicFormWidth = config.publicFormWidth
        this.publicFormMargin = config.publicFormMargin
        this.publicFormHeader = config.publicFormHeader
        this.publicEmailTo = config.publicEmailTo
        this.publicFormActionId = config.publicFormActionId

        // Keep the id of the original application it was created in
        if (config.applicationId) this.applicationId = config.applicationId

        // Keep the id of the original template used to generate this model
        if (config.templateId) this.templateId = config.templateId

        // Self-register the Model into the kiss.app object
        kiss.app.models[this.id] = this

        // Init items, fields, computed fields
        this._initItems(config.items)
            ._initFields()
            ._initElements()
            ._initACLFields()
            ._initComputedFields()

        // Init the Record factory
        this._initRecordFactory()

        // Init client methods: master collection, subscriptions
        if (kiss.isClient) {
            this._initMasterCollection()
                ._initSubscriptions()
        }

        // Init server methods: set accepted fields
        if (kiss.isServer) {
            this._initAcceptedFields()
        }

        return this
    }

    // #region CRUD methods

    /**
     * Create a new Record from this model
     * 
     * **This does not save the record automatically**: to save the record into the database, use the **save()** method of the created record.
     * 
     * @param {object} [recordData] - The new record's data
     * @param {boolean} [inherit] - If true, create a blank record then assign recordData to it
     * @returns {object} The new Record object
     * 
     * @example
     * userModel = kiss.app.models["user"]
     * let Bob = userModel.create({firstName: "Bob", lastName: "Wilson"})
     * await Bob.save()
     */
    create(recordData, inherit) {
        return new this.recordFactory(recordData, inherit)
    }

    /**
     * Create a record using field labels as keys
     * 
     * @param {object} record
     * @returns The record
     * 
     * @example
     * userModel = kiss.app.models["user"]
     * let Bob = userModel.createFromLabels({"First name": "Bob", "Last name": "Wilson"})
     * await Bob.save()
     */
    createFromLabels(record) {
        let newRecord = {}

        Object.keys(record).forEach(fieldLabel => {
            const field = this.getFieldByLabel(fieldLabel)
            const value = record[fieldLabel]
            newRecord[field.id] = value
        })
        return this.create(newRecord)
    }

    /**
     * Check the permission (client-side) to perform an action on the model.
     * 
     * @param {string} action - "update" | "delete"
     * @returns {boolean} true if the permission is granted
     */
    async checkPermission(action) {
        const record = kiss.app.collections.model.records.get(this.id)
        const hasPermission = await kiss.acl.check({
            action,
            record
        })

        if (!hasPermission) {
            createNotification(txtTitleCase("#not authorized"))
            return false
        }

        return true
    }    

    // #endregion

    // #region Initialization

    /**
     * Initialize the model's items
     * 
     * - set an id
     * - cast <select> field options to objects if they're given as string
     * 
     * Important:
     * Items contains all the UI components required to render a record as a form.
     * This includes "non-field" informations like panels, buttons, images, html...
     * 
     * @private
     * @ignore
     * @param {object[]} items
     * @returns this
     */
    _initItems(items) {
        if (kiss.isClient) {
            this._initClientItems(items)
        } else {
            this._initServerItems(items)
        }
        return this
    }

    /**
     * Initialize the model's fields
     * 
     * Fields is a subset of items, containing only the fields.
     * 
     * The model fields are deduced from:
     * - the model's items
     * - the model's plugins, which can add custom fields to the model
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initFields() {
        const modelFields = this.getFields()
        const featureFields = this.getFeatureFields()
        const systemFields = this.getSystemFields()
        this.fields = modelFields.concat(featureFields).concat(systemFields)
        
        if (kiss.isClient) {
            this.fields.forEach(field => {
                // Translate system field labels for the client UI
                if (field.label && field.label.startsWith("#")) {
                    field.label = txtTitleCase(field.label)
                }

                // Set the field's renderer for data views (like datatable, calendar, kanban...)
                kiss.fields.setRenderer(this, field)
            })
        }

        return this
    }

    /**
     * Initialize the model's elements
     * 
     * Elements are the non-field items of the model, like:
     * - html
     * - image
     * - button
     * 
     * @private
     * @ignore
     * @param {object[]} items 
     * @returns this
     */
    _initElements(items) {
        this.elements = this.getElements(items)
        return this
    }    

    /**
     * Init the model's ACL fields
     * 
     * This is only used server-side to define the fields that holds ACL entries (users and/or groups).
     * When a user or group is deleted, the ACL entries in the model's fields are updated accordingly.
     * This is done by kiss.directory.cleanupAllUserReferences
     * 
     * @returns this
     */
    _initACLFields() {
        if (kiss.isClient) return this

        this.aclFields = this.fields.filter(field => field.isACL)
        if (this.aclFields.length > 0) kiss.acl.addFields(this, this.aclFields)
        return this
    }
    
    /**
     * - Transform the fields "semantic" formulae into some formulae ready to be evaluated.
     * - Init dependencies between fields
     * - Check if the model has cyclic dependencies
     * 
     * @private
     * @ignore
     * @returns {boolean|string} false if no cyclic dependencies, or the field id that is causing the cyclic dependency
     */
    _initComputedFields() {
        this.computedFields = []
        const fields = this.getActiveFields()

        // Reset all props
        fields.forEach(field => {
            field.dependencies = []
            field.deepDependencies = []

            if (field.computed) {
                field.formulaSourceFields = []
                field.formulaSourceFieldIds = []
            }
        })

        // Init dependencies and formula source fields
        for (let i = 0; i < fields.length; i++) {
            let field = fields[i]

            if (field.computed) {
                // Add this field to the list of computed fields
                this.computedFields.push(field.id)

                // Keep in cache the field dependencies of the formula:
                // - field names
                field.formulaSourceFields = kiss.tools.findTags(field.formula)

                // - field ids
                field.formulaSourceFieldIds = field.formulaSourceFields.map(sourceFieldName => {
                    let sourceField
                    const fieldIndex = Number(sourceFieldName)
                    const isFieldIndex = Number.isInteger(fieldIndex)

                    if (isFieldIndex) {
                        sourceField = fields[fieldIndex]
                    } else {
                        sourceField = this.getFieldByLabel(sourceFieldName)
                    }

                    if (sourceField) {
                        sourceField.dependencies.push(field.id)
                        sourceField.dependencies = sourceField.dependencies.unique()
                        return sourceField.id
                    }
                    else {
                        // log.err("Field used in formula but not found:", sourceFieldName)
                        return sourceFieldName
                    }
                })
                .unique()
            }
        }

        // Define the fields execution order of the formulas, to be able to compute everything in a single pass
        this._initFieldsFormulaExecutionOrder()

        // Init the chain of deep dependencies between fields
        this._initFieldsDeepDependencies()

        // Check if the model has cyclic dependencies
        return this._checkFieldsCyclicDependencies()
    }

    /**
     * Define the fields execution order of the formulas using Khan algorithm
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initFieldsFormulaExecutionOrder() {
        let dependencies = {}
        let inDegree = {}

        for (let field of this.fields) {
            if (field.computed) {
                dependencies[field.id] = new Set(field.dependencies || [])
                inDegree[field.id] = 0
            }
        }

        // Compute in-degree dependencies
        for (let fieldId in dependencies) { 
            for (let dep of dependencies[fieldId]) {
                if (!(dep in inDegree)) {
                    inDegree[dep] = 0
                }
                inDegree[dep]++
            }
        }

        // Topological sort with Kahn algorithm
        let queue = Object.keys(inDegree).filter(fieldId => inDegree[fieldId] === 0)
        let orderedFields = []

        while (queue.length > 0) {
            let fieldId = queue.shift()
            orderedFields.push(fieldId)
            if (dependencies[fieldId]) {
                dependencies[fieldId].forEach(dep => {
                    inDegree[dep]--
                    if (inDegree[dep] === 0) queue.push(dep)
                })
            }
        }
        
        this.orderedComputedFields = orderedFields.filter(fieldId => {
            let field = this.getField(fieldId)
            return field.computed
        })

        return this
    }

    /**
     * Initialize the deep dependencies between the fields,
     * and detect cyclic dependencies, which are forbidden
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initFieldsDeepDependencies() {
        const getDeepDependencies = (fieldId, visited = new Set()) => {
            if (visited.has(fieldId)) return []
            visited.add(fieldId)
            
            let field = this.getField(fieldId)
            if (!field || !field.dependencies) return []
            
            let deepDeps = new Set(field.dependencies)
            
            for (let dep of field.dependencies) {
                let subDeps = getDeepDependencies(dep, visited)
                subDeps.forEach(d => deepDeps.add(d))
            }
            
            return Array.from(deepDeps)
        }
        
        this.fields.forEach(field => field.deepDependencies = getDeepDependencies(field.id))

        return this
    }

    /**
     * Check if the model has computed fields with cyclic dependencies
     * 
     * @returns {boolean|string} false if no cyclic dependencies, or the field id that is causing the cyclic dependency
     */
    _checkFieldsCyclicDependencies() {
        let computedFields = this.fields.filter(field =>
            !field.deleted
            && field.computed
            && field.deepDependencies
            && Array.isArray(field.deepDependencies)
            && field.deepDependencies.length > 0
        )
        
        for (let field of computedFields) {
            if (field.deepDependencies.includes(field.id)) {
                this.hasCyclicDependencies = true

                log.warn(`kiss.data.Model - Cyclic dependency detected in model <${this.name}> (${this.id}) on field <${field.label}> (${field.id})`)
                // log.warn(`kiss.data.Model - Dependencies:`, field.dependencies)
                // log.warn(`kiss.data.Model - Deep dependencies:`, field.deepDependencies)
                // log.warn(`kiss.data.Model - Field formula:`, field.formula)
                // log.warn(`kiss.data.Model - Field formula source fields:`, field.formulaSourceFieldIds)
                // log.err('Label', field.formulaSourceFieldIds.map(id => this.getField(id)?.label))
                return field.id
            }
        }
        
        this.hasCyclicDependencies = false
        return false
    }

    /**
     * Get the accepted fields of the model.
     * This includes model's fields, plus default system fields:
     * - id
     * - createdAt
     * - createdBy
     * - updatedAt
     * - updatedBy
     * - deletedAt
     * - deletedBy
     * - accessRead
     * - accessUpdate
     * - accessDelete
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initAcceptedFields() {
        const defaultAcceptedFields = ["id", "createdAt", "createdBy", "updatedAt", "updatedBy", "deletedAt", "deletedBy", "accessRead", "accessUpdate", "accessDelete", "accessManage"]
        const acceptedFields = this.fields.map(field => field.id)
        this.acceptedFields = defaultAcceptedFields.concat(acceptedFields)
        return this
    }    

    /**
     * Initialize the model's items for the CLIENT
     * - set an id
     * - cast <select> field options to objects if they're given as string
     * 
     * Important:
     * Items contains all the UI components required to render a record as a form.
     * This includes "non-field" informations like panels, buttons, images, html...
     * 
     * @private
     * @ignore
     * @param {object[]} items
     * @returns this
     */
    _initClientItems(items, read, update) {
        if (!items) return []

        const userACL = kiss.session.getACL()
        items = items.filter(item => item != null)

        items.forEach(item => {
            if (!item.id) item.id = kiss.tools.shortUid()

            if (item.items) {
                // Section
                const canRead = kiss.tools.intersects(item.accessRead, userACL) || !item.accessRead
                const canUpdate = kiss.tools.intersects(item.accessUpdate, userACL) || !item.accessUpdate

                item.acl = item.acl || {}

                // item.acl.read = item.acl.hasOwnProperty("read") ? item.acl.read : !!canRead
                // item.acl.update = item.acl.hasOwnProperty("update") ? item.acl.update : !!canUpdate

                item.acl.read = !!canRead
                item.acl.update = !!canUpdate

                this._initClientItems(item.items, canRead, canUpdate)
            } else {
                // Fields or elements
                item.acl = item.acl || {}

                // item.acl.read = item.acl.hasOwnProperty("read") ? item.acl.read : read
                // item.acl.update = item.acl.hasOwnProperty("update") ? item.acl.update : update

                item.acl.read = read
                item.acl.update = update

                if (item.type == "select") {
                    if (!item.options) return
                    item.options = item.options.map(option => {
                        if (typeof option == "object") return option
                        return {
                            value: option
                        }
                    })
                }
            }
        })

        this.items = items
        return this
    }

    /**
     * Initialize the model's items for the SERVER
     * 
     * @private
     * @ignore
     * @param {object[]} items
     * @returns this
     */
    _initServerItems(items) {
        if (!items) return []

        items = items.filter(item => item != null)
        items.forEach(item => {
            if (!item.id) item.id = kiss.tools.shortUid()

            if (item.items) {
                // Section
                this._initServerItems(item.items)
            } else {
                // Fields or widgets
                if (item.type == "select") {
                    if (!item.options) return
                    item.options = item.options.map(option => {
                        if (typeof option == "object") return option
                        return {
                            value: option
                        }
                    })
                }
            }
        })

        this.items = items
        return this
    }

    /**
     * Create a Record class specific to this Model
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initRecordFactory() {
        this.recordFactory = kiss.data.RecordFactory(this.id)
        return this
    }

    /**
     * Create and register a default collection for the model
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initMasterCollection() {
        this.collection = new kiss.data.Collection({
            id: this.id,
            mode: this.mode,
            model: this,
            isMaster: true, // The default model's collection is flagged as the "master" collection
            sort: [{
                [this.getPrimaryKeyField().id]: "asc" // Sort on the primary key field by default
            }]
        })
        return this
    }

    /**
     * Subscribe the model to react to changes
     * 
     * @private
     * @ignore
     * @returns this
     */
    _initSubscriptions() {
        const modelId = this.id.toUpperCase()

        this.subscriptions = [
            // React to model updates
            subscribe("EVT_DB_UPDATE:MODEL", (msgData) => {
                if (this.id == msgData.id) {
                    Object.assign(this, msgData.data)

                    if (msgData.data.hasOwnProperty("items")) {
                        this._initItems(this.items)
                        this._initFields()
                    }
                }
            }),

            subscribe("EVT_DB_UPDATE_BULK", (msgData) => {
                if (msgData.data && msgData.data[0] && msgData.data[0].modelId == "model" && msgData.data[0].recordId == this.id) {
                    Object.assign(this, msgData.data[0].updates)
                }
            }),

            // React to database mutations on records built from this model
            subscribe("EVT_DB_INSERT:" + modelId, this._notifyUser),
            subscribe("EVT_DB_UPDATE:" + modelId, this._notifyUser),
            subscribe("EVT_DB_DELETE:" + modelId, this._notifyUser),
            subscribe("EVT_DB_UPDATE_BULK", (msgData) => {
                let isUpdated = false
                for (let operation of msgData.data) {
                    if (operation.modelId == this.id) {
                        isUpdated = true
                        break
                    }
                }
                if (isUpdated) this._notifyUser(msgData)
            }),

            // Hardly ever happens, so we put this in standby at the moment to limit the number of subscriptions:
            // subscribe("EVT_DB_INSERT_MANY:" + modelId, this._notifyUser),
            // subscribe("EVT_DB_UPDATE_MANY:" + modelId, this._notifyUser),
            // subscribe("EVT_DB_DELETE_MANY:" + modelId, this._notifyUser)
        ]
        return this
    }

    // #endregion

    // #region Fields managements

    /**
     * Create a new field configuration.
     * This method also updates the views that are connected to the model.
     * 
     * @async
     * @param {object} config - New field config
     * @param {string} [sectionId] - Optional section id. If provided, adds the field at the end this section
     * @returns {boolean} true in case of success
     */
    async addField(config, sectionId) {

        // const hasPermission = await this.checkPermission("update")
        // if (!hasPermission) return false

        // Enforce field id
        if (!config.id) config.id = kiss.tools.shortUid()

        // If the model doesn't have any section, adds the field at the end
        if (!this.hasSections()) {
            this.items.push(config)
        } else {
            if (!sectionId) {
                // No specific section is given to add the field: it is added at the end of the last section
                const lastSection = this.items[this.items.length - 1]
                lastSection.items.push(config)
            } else {
                // A specific section is given: we append the field to it
                this.items
                    .find(section => section.id == sectionId)
                    .items
                    .push(config)
            }
        }

        // Recompute formulas
        this._initComputedFields()

        // Update the model's record which is stored in db
        await this.saveItems()

        // Update the fields and elements
        this._initFields()
        this._initElements()

        // Computed fields need to be computed on every record
        if (config.computed) await this.updateFieldFormula(config.id)

        // Get all the views that display this model and update them
        await this.syncViewsWithModelFields()

        // For offline apps, re-compute relationships locally
        if (kiss.session.isOffline()) {
            this._defineRelationships()
        }

        // Reset the context
        kiss.context.addFieldToSectionId = null

        return true
    }  

    /**
     * Get a field by id
     * 
     * Note: if the field is not found, the method tries to find the field by its label
     * 
     * @param {string} fieldId
     * @returns {object} The field definition
     * 
     * @example
     * let myField = myModel.getField("xD12z4ml00z")
     * 
     * // Returns...
     * {
     *      id: "yearlyIncome",
     *      label: "Yearly income",
     *      type: "number",
     *      precision: 2,
     *      formula: "{{Monthly income}} * 12",
     * }
    */
    getField(fieldId) {
        const field = this.fields.find(field => field.id == fieldId)
        if (field) return field
        return this.getFieldByLabel(fieldId)
    }

    /**
     * Get a field id by its label
     * 
     * @param {string} fieldLabel
     * @returns {*} The field id or false if not found
     * 
     * @example
     * let fieldId = myModel.getFieldId("Project name") // "xD12z4ml00z"
     */
    getFieldId(fieldLabel) {
        const field = this.getFieldByLabel(fieldLabel)
        return field ? field.id : null
    }

    /**
     * Get the first field matching a label.
     * 
     * Note:
     * - if the field label is not found, it defaults to searching the field id
     * - deleted field are not taken into consideration
     * 
     * @param {string} fieldLabel
     * @returns {object} The field definition
     * 
     * @example
     * let myField = myModel.getFieldByLabel("Project name")
     */
    getFieldByLabel(fieldLabel) {
        const fields = this.fields.filter(field => !field.deleted)

        let field = fields.find(field => field.label && field.label.toLowerCase() == fieldLabel.toLowerCase())
        if (field) return field

        field = fields.find(field => field.id.toLowerCase() == fieldLabel.toLowerCase())
        return field
    }
    
    /**
     * Get a field type
     * 
     * Specific field types like "lookup" and "summary" have to be converted to the type of the fields they point to.
     * For example, if a "lookup" field is getting the value of a "number" field, the "real" field type is "number"
     * 
     * Warning:
     * - this method doesn't return the field data type.
     * - field type and field data type are 2 different things: a field which type is "checkbox" has a "boolean" data type.
     * 
     * @private
     * @ignore
     * @param {object} field
     * @returns {string} The field type: "text", "number", "date", "checkbox", "select"...
     */
    getFieldType(field) {
        if (field.type == "lookup") {
            return field.lookup.type
        } else if (field.type == "summary") {
            return field.summary.type
        } else {
            return field.type || "text"
        }
    }

    /**
     * Get the primary field of this model
     * 
     * @returns {object} The primary field, or the model's 1st field if it wasn't found
     */
    getPrimaryKeyField() {
        const fields = this.fields
        const primaryKeyField = fields.find(field => field.primary == true)
        if (primaryKeyField) return primaryKeyField
        return fields[0]
    }

    /**
     * Search inside a model which field links to a foreign model
     * 
     * @param {string} foreignModelId - Foreign model id
     * @returns {object} The <link> field that links to the foreign model
     */
    getLinkField(foreignModelId) {
        const fields = this.fields
        for (let field of fields) {
            if (field.type == "link") {
                if (field.link.modelId == foreignModelId) return field
            }
        }
        return null
    }

    /**
     * Update a field configuration.
     * This method also updates the views that are connected to the model.
     * 
     * @async
     * @param {string} fieldId 
     * @param {object} config - New field config
     * @param {boolean} shouldUpdateFormula - If true, re-compute the field value on every record of the collection
     * @returns {boolean} true in case of success
     */
    async updateField(fieldId, config, shouldUpdateFormula) {

        // const hasPermission = await this.checkPermission("update")
        // if (!hasPermission) return false

        // Update the model's field
        this._updateItemInTree(this, fieldId, config)

        // Recompute formulas
        this._initComputedFields()

        // Update the model's record which is stored in db
        await this.saveItems()

        // Update the fields and elements
        this._initFields()
        this._initElements()

        // Computed field need to update their values (100% server-side process)
        if (shouldUpdateFormula) await this.updateFieldFormula(fieldId)

        // Get all the views that display this model and update them
        await this.syncViewsWithModelFields()

        // For offline apps, re-compute relationships locally
        if (kiss.session.isOffline()) {
            this._defineRelationships()
        }

        return true
    }

    /**
     * Recompute the computed field value on every record of the collection.
     * 
     * @async
     */
    async updateFieldFormula() {
        if (kiss.session.isOffline()) {
            await kiss.data.relations.updateAllDeep(this.id)
        } else {
            await kiss.ajax.request({
                showLoading: true,
                url: "/updateAllDeep",
                method: "post",
                body: JSON.stringify({
                    modelId: this.id
                })
            })
        }
    }

    /**
     * Check if the field labels used in a formula are still valid.
     * If not, returns the list of invalid field labels.
     * 
     * @private
     * @ignore
     * @param {string} fieldId 
     * @returns {string[]} Array with the wrong field labels (empty if OK)
     */
    _checkFormula(formula) {
        const tags = kiss.tools.findTags(formula)
        let errorFields = []

        tags.forEach(fieldLabel => {
            const field = this.getFieldByLabel(fieldLabel)
            if (kiss.tools.isNumber(fieldLabel)) return
            if (!field) errorFields.push(fieldLabel)
        })

        return errorFields
    }

    /**
     * Check if a field formula creates cyclic dependencies
     * 
     * @private
     * @ignore
     * @param {string} label - Field label
     * @param {string} formula - Field formula
     * @returns {string[]} Array with the field labels causing cyclic dependencies (empty if OK)
     */
    _checkFormulaCyclicDependencies(label, formula) {
        let errorFields = []
        const tags = kiss.tools.findTags(formula)

        tags.forEach(tag => {
            const tagField = this.getFieldByLabel(tag)
            if (!tagField) return
            if (!tagField.formula) return

            let fieldFormula = tagField.formula
            if (tag == label) fieldFormula = formula

            const tagFieldTags = kiss.tools.findTags(fieldFormula)
            console.log("- ", tagFieldTags)
            if (tagFieldTags.includes(label)) errorFields.push(tagField.label)
        })
        
        return errorFields
    }    

    /**
     * Delete a field configuration and update all the views that are connected to this model.
     * A primary field can't (and must not) be deleted.
     * 
     * @async
     * @param {string} fieldId
     * @returns {boolean} false if the field couldn't be deleted (primary field)
     */
    async deleteField(fieldId) {
        let field = this.getField(fieldId)
        if (!field) field = this.getElement(fieldId)
        
        if (!field) {
            log("kiss.data.Model - deleteField: could not find the item to delete", 3)
            return false
        }

        if (field.primary == true) {
            log("kiss.data.Model - deleteField: could not delete primary field", 3)
            return false
        }

        if (field.type == "html") {
            return this.deleteElement(fieldId)
        }

        log(`kiss.data.Model - deleteField: ${fieldId} / ${field.label}`)

        field.deleted = true
        await this.updateField(fieldId, field)
        this._initFields()
        return true
    }

    /**
     * Get the model's fields
     * 
     * In KissJS, the model can be directly defined by a complex form with multiple sections and sub items.
     * This method explores the tree and returns only the items which are fields.
     * 
     * Important: deleted fields are also returned, with a flag deleted = true
     * 
     * @returns {object[]} Array of field definitions
     */
    getFields(containerItems) {
        const fieldTypes = kiss.global.fieldTypes.map(type => type.value)
        let fields = []
        let items = containerItems || this.items || []

        items = items.filter(item => item != null)
        items.forEach(item => {
            if ((fieldTypes.indexOf(item.type) != -1) || (item.dataType != null)) {
                fields.push(item)
            } else {
                if (item.items) {
                    fields.push(this.getFields(item.items))
                }
            }
        })

        return fields.flat()
    }

    /**
     * Initialize the system fields
     * 
     * @returns {object[]} Array of system fields
     */
    getSystemFields() {
        return [{
                id: "createdAt",
                label: "#createdAt",
                type: "date",
                dataType: Date,
                isSystem: true,
                readOnly: true,
                hidden: true,
                acl: {
                    update: false
                }
            },
            {
                id: "createdBy",
                label: "#createdBy",
                type: "directory",
                dataType: Date,
                isSystem: true,
                readOnly: true,
                hidden: true,
                acl: {
                    update: false
                }
            },
            {
                id: "updatedAt",
                label: "#updatedAt",
                type: "date",
                dataType: Date,
                isSystem: true,
                readOnly: true,
                hidden: true,
                acl: {
                    update: false
                }
            },
            {
                id: "updatedBy",
                label: "#updatedBy",
                type: "directory",
                dataType: Date,
                isSystem: true,
                readOnly: true,
                hidden: true,
                acl: {
                    update: false
                }
            },
            {
                id: "deletedAt",
                label: "#deletedAt",
                type: "date",
                dataType: Date,
                isSystem: true,
                readOnly: true,
                hidden: true,
                acl: {
                    update: false
                }
            },
            {
                id: "deletedBy",
                label: "#deletedBy",
                type: "directory",
                dataType: Date,
                isSystem: true,
                readOnly: true,
                hidden: true,
                acl: {
                    update: false
                }
            }
        ]
    }

    /**
     * Get the fields brought by the model's active plugins
     * 
     * @returns {object[]} Array of field definitions
     */
    getFeatureFields() {
        if (kiss.isServer) return []

        let featureFields = []
        if (this.features) {
            Object.keys(this.features)
                .filter(featureId => this.features[featureId].active)
                .forEach(featureId => {
                    const plugin = kiss.plugins.get(featureId)
                    if (!plugin) return

                    const texts = plugin.texts || {}

                    if (plugin && plugin.fields) {
                        plugin.fields.forEach(field => {
                            field.isFromPlugin = true
                            field.pluginId = featureId
                            field.label = txtTitleCase(field.label, texts)
                            featureFields.push(field)
                        })
                    }
                })
        }
        return featureFields
    }

    /**
     * Returns the model's fields using the datatable format
     * 
     * @ignore
     * @returns {object[]} Array of columns
     */
    getFieldsAsColumns() {
        let columns = this.fields
            .filter(field => field.label)
            .map(field => {
                if (field.deleted) return null

                let columnConfig = {
                    id: field.id,
                    type: this.getFieldType(field),
                    title: (!field.label) ? txtTitleCase(field.id) : ((field.label.startsWith("#")) ? txtTitleCase(field.label) : field.label.toTitleCase())
                }

                // Flag columns coming from plugins
                if (field.isFromPlugin) {
                    columnConfig.isFromPlugin = true
                    columnConfig.pluginId = field.pluginId
                    columnConfig.title = txtTitleCase(field.label)
                }

                // Flag system columns
                if (field.isSystem) {
                    columnConfig.isSystem = true
                    columnConfig.title = txtTitleCase(field.label)
                    columnConfig.hidden = (field.hidden !== false)
                }

                return columnConfig
            })
            .filter(column => column != null)

        return columns
    }

    /**
     * Get fields as a list of options for a Select field
     * 
     * @param {string[]} types - Types of fields to return
     * @returns {object[]} Array of options
     * 
     * @example
     * let options = myModel.getFieldsAsOptions(["text", "number"])
     */
    getFieldsAsOptions(types) {
        const isDynamicModel = kiss.tools.isUid(this.id)
        if (!Array.isArray(types)) types = [types]
        if (types.length == 0) return []

        const fields = this.getFieldsByType(types)
        if (fields.length == 0) return []

        return fields.filter(field => !field.deleted).map(field => {
            return {
                value: field.id,
                label: (isDynamicModel && !field.isSystem) ? field.label.toTitleCase() : txtTitleCase(field.label),
                isFromPlugin: !!field.isFromPlugin
            }
        })
    }

    /**
     * Get visible fields (= non deleted)
     * 
     * @returns {object[]} Array of field definitions
     */
    getActiveFields() {
        return this.fields.filter(field => !field.deleted)
    }

    /**
     * Get only the fields of specific types
     * 
     * @param {string|string[]} types -Types of fields to return. When a field is a lookup, its type is the lookup type.
     * @returns {object[]} The fields of the required type, or []
     */
    getFieldsByType(types) {
        const fields = this.fields
        if (!Array.isArray(types)) types = [types]
        
        if (types.length > 0) {
            return fields.filter(field => {
                if (field.type == "lookup") {
                    return types.includes(field.lookup.type)
                }
                else if (field.type == "summary") {
                    return types.includes(field.summary.type)
                }
                else {
                    return types.includes(field.type)
                }
            })
        }
    }

    /**
     * Get the fields which can be used for sorting
     * 
     * @returns {object[]} The list of sortable fields
     */
    getSortableFields() {
        return this.fields.filter(field => field.type != "password" && field.type != "link" && field.type != "attachment" && field.label && field.deleted != true)
    }

    /**
     * Get the fields which can be used for grouping
     * 
     * @returns {object[]} The list of groupable fields
     */
    getGroupableFields() {
        // return this.fields.filter(field => field.multiple != true && field.type != "link" && field.type != "attachment" && field.label && field.deleted != true)
        return this.fields.filter(field => field.type != "password" && field.type != "link" && field.type != "attachment" && field.label && field.deleted != true)
    }

    /**
     * Get the fields which can be used for filtering
     * 
     * @returns {object[]} The list of filterable fields
     */
    getFilterableFields() {
        return this.fields.filter(field => field.type != "link" && field.label && field.deleted != true)
    }

    /**
     * Get the fields which can be used inside a formula
     * @returns {object[]} The list of formula fields
     */
    getFormulaFields() {
        return this.fields.filter(field => {
            return field.type != "link" &&
                field.type != "attachment" &&
                field.label &&
                field.deleted != true &&
                field.isSystem != true &&
                field.isFromPlugin != true
        })
    }

    /**
     * Get the fields which can be used for batch operations.
     * 
     * @returns {object[]} The list of fields
     */
    getBatchableFields() {
        return this.fields.filter(field => {
            return field.deleted != true &&
                field.isSystem != true &&
                // field.isFromPlugin != true &&
                field.computed != true &&
                !field.sourceFor &&
                field.type != "lookup" &&
                field.type != "summary" &&
                field.type != "attachment" &&
                field.type != "password" &&
                field.type != "selectViewColumn" &&
                field.type != "selectViewColumns" &&
                field.type != "link" &&
                field.type != "aiImage"
        })
    }

    // #endregion

    // #region Elements management

    /**
     * Get an element by id
     * 
     * Elements are the non-field items of the model, like:
     * - html
     * - image
     * - button
     * 
     * @param {string} elementId
     * @returns {object} The element definition
     * 
     * @example
     * let myHtmlElement = myModel.getElement("xD12z4ml00z")
     * 
     * // Returns...
     * {
     *      id: "yearlyIncome",
     *      type: "html",
     *      html: "<p>Yearly income is calculated by multiplying the monthly income by 12</p>",
     * }
     */
    getElement(elementId) {
        return this.elements.find(element => element.id == elementId)
    }

    /**
     * Get the model's elements
     * 
     * In KissJS, the model can be directly defined by a complex form with multiple sections and sub items.
     * This method explores the tree and returns only the items which are "elements", like:
     * - html
     * - image
     * - button
     * 
     * @returns {object[]} Array of element definitions
     */
    getElements(containerItems) {
        const elementTypes = ["html"]
        let elements = []
        let items = containerItems || this.items || []

        items = items.filter(item => item != null)
        items.forEach(item => {
            if ((elementTypes.indexOf(item.type) != -1) || (item.dataType != null)) {
                elements.push(item)
            } else {
                if (item.items) {
                    elements.push(this.getElements(item.items))
                }
            }
        })

        return elements.flat()
    }

    /**
     * Delete an element configuration
     * 
     * @param {string} elementId 
     */
    async deleteElement(elementId) {
        let element = this.getElement(elementId)
        if (!element) return false

        // log(`kiss.data.Model - deleteElement: ${elementId} / ${element.type}`)

        this._deleteItemFromTree(this, elementId, element)
        await this.saveItems()
        this._initElements()
        return true
    }

    // #endregion

    // #region Form and Sections management

    /**
     * Get a section by id
     * 
     * Note: if the section is not found, the method tries to find the section by its title
     * 
     * @param {string} fieldId
     * @returns {object} The section definition
     * 
     * @example
     * let mySection = myModel.getSection("General informations")
     * 
     * // Returns...
     * {
     *      id: "aE7x450",
     *      title: "General informations",
     *      items: [
     *          // ... Section items
     *      ]
     * }
     */
    getSection(sectionId) {
        let section = this.items.find(section => section.id == sectionId)
        if (section) return section
        return this.getSectionByTitle(sectionId)
    }

    /**
     * Get the first section matching a title.
     * 
     * Note: if the section title is not found, it defaults to searching the section id
     * 
     * @param {string} sectionTitle
     * @returns {object} The section definition
     * 
     * @example
     * let mySection = myModel.getSectionByTitle("General informations")
     */
    getSectionByTitle(sectionTitle) {
        let section = this.items.find(section => section.title && section.title.toLowerCase() == sectionTitle.toLowerCase())
        if (section) return section

        section = this.items.find(section => section.id.toLowerCase() == sectionTitle.toLowerCase())
        return section
    }

    /**
     * Check if the model has sections.
     * 
     * @returns {boolean}
     */
    hasSections() {
        const modelSections = this.items.filter(item => item.type == "panel")
        return (modelSections.length > 0)
    }

    /**
     * Get the model's sections
     * 
     * In KissJS, the model can be directly defined by a complex form with multiple sections and sub items.
     * This method explores the tree and returns only the items which are sections.
     * 
     * @returns {object[]} Array of sections definitions
     */
    getSections() {
        let sections = []
        let items = this.items || []

        items = items.filter(item => item != null)
        items.forEach(item => {
            if (item.items) sections.push(item)
        })

        return sections
    }    

    /**
     * Creates the first form section, at the top of the form
     * 
     * @ignore
     * @param {object} config - Section configuration
     * @returns {string} The new section id
     */
    async createFirstSection(config) {
        const newSectionId = kiss.tools.shortUid()
        const newSection = {
            id: newSectionId,
            type: "panel",
            icon: config.icon || "far fa-file-alt",
            title: config.title || "Section",
            collapsible: true,
            collapsed: config.collapsed,
            colored: config.colored,
            acl: config.acl,
            items: this.items
        }
        this.items = [newSection]
        await this.saveItems()

        // Update items & fields & elements
        this._initItems(this.items)
        this._initFields()
        this._initElements()

        return newSectionId
    }

    /**
     * Creates a new section just before the item passed as a parameter 
     * 
     * @ignore
     * @param {object} config - Section configuration
     * @param {string} breakItemId - Item id where to break the form
     * @returns {string|boolean} The new section id, or false if it did not succeed
     */
    async createSection(config, breakItemId) {
        const sections = this.items

        // Explore the model to find the section and break index
        let breakIndex
        let sectionIndex

        sections.forEach((section, index) => {
            const itemIndex = section.items.findIndex(item => item.id == breakItemId)
            if (itemIndex != -1) {
                breakIndex = itemIndex
                sectionIndex = index
            }
        })

        // Can't insert a section immediately after an existing section!
        if (breakIndex == 0) return false

        // Rebuild a new section after the break index
        const fieldsInPreviousSection = sections[sectionIndex].items.slice(0, breakIndex)
        const fieldsInNewSection = sections[sectionIndex].items.slice(breakIndex)
        sections[sectionIndex].items = fieldsInPreviousSection

        const newSectionId = kiss.tools.shortUid()
        const newSection = {
            id: newSectionId,
            type: "panel",
            icon: config.icon || "far fa-file-alt",
            title: config.title || "Section",
            collapsible: true,
            collapsed: config.collapsed,
            colored: config.colored,
            accessRead: config.accessRead,
            accessUpdate: config.accessUpdate,
            acl: config.acl,
            items: fieldsInNewSection
        }

        sections.splice(sectionIndex + 1, 0, newSection)

        this.items = sections
        await this.saveItems()

        // Update items & fields & elements
        this._initItems(this.items)
        this._initFields()
        this._initElements()

        return newSectionId
    }

    /**
     * Check if an item is the first in its section.
     * (used to perform checks in the form builder)
     * 
     * @param {string} itemId
     * @returns {boolean}
     */
    isFirstItemInSection(itemId) {
        if (!this.hasSections()) return false

        let breakIndex
        const sections = this.items

        sections.forEach((section, index) => {
            const itemIndex = section.items.findIndex(item => item.id == itemId)
            if (itemIndex != -1) {
                breakIndex = itemIndex
            }
        })

        // Can't insert a section immediately after an existing section!
        if (breakIndex === 0) return true
        return false
    }

    /**
     * Update a section configuration
     * 
     * @async
     * @param {string} sectionId
     * @param {object} newSectionConfig 
     */
    async updateSection(sectionId, newSectionConfig) {
        // Update the section in the model
        this._updateItemInTree(this, sectionId, newSectionConfig)

        // Update the model's record which is stored in db
        await this.saveItems()

        // Update items & fields & elements
        this._initItems(this.items)
        this._initFields()
        this._initElements()
    }

    /**
     * Delete a section, and move its items into the previous section.
     * The method doesn't allow to delete the 1st section.
     * 
     * @ignore
     * @param {string} sectionId 
     * @returns {boolean} false if the section id could not be found
     */
    async deleteSection(sectionId) {
        for (let i = 0; i < this.items.length; i++) {
            const section = this.items[i]

            if (section.id == sectionId) {
                const fieldsToMove = section.items
                let previousSection = this.items[i - 1]
                let nextSection = this.items[i + 1]

                if (i == 0) {
                    if (nextSection) {
                        // Move items to next section, if there is one
                        nextSection.items.splice(0, 0, ...fieldsToMove)
                        this.items.splice(i, 1)
                    } else {
                        // Otherwise, there are no sections anymore
                        this.items = fieldsToMove
                    }
                } else {
                    // Move items to previous section
                    previousSection.items.splice(previousSection.items.length, 0, ...fieldsToMove)
                    this.items.splice(i, 1)
                }

                await this.saveItems()

                // Update items & fields & elements
                this._initItems(this.items)
                this._initFields()
                this._initElements()

                return true
            }
        }
    }

    /**
     * Move a section from a position to another (move "up" or "down")
     * 
     * @ignore
     * @param {string} sectionId 
     * @param {string} direction - "up" | "down"
     * @returns {boolean} false if the section id could not be found
     */
    async moveSection(sectionId, direction) {
        const fromIndex = this.items.findIndex(section => section.id == sectionId)
        if (fromIndex == -1) return false

        const toIndex = (direction == "down") ? fromIndex + 1 : fromIndex - 1

        // Switch section positions
        const tempSection = this.items[fromIndex]
        this.items[fromIndex] = this.items[toIndex]
        this.items[toIndex] = tempSection

        await this.saveItems()
        return true
    }

    /**
     * Save the model's items
     */
    async saveItems() {
        // Prevent from saving an empty form
        if (!Array.isArray(this.items)) return
        if (this.items.length == 0) return

        const modelRecord = kiss.app.collections.model.getRecord(this.id)
        await modelRecord.update({
            items: this.items
        })
    }

    /**
     * Export the model definition as JSON.
     * 
     * This is used to import/export application templates.
     */
    exportAsJSON() {
        let items
        const hasSections = (this.items[0].items) ? true : false

        if (hasSections) {
            items = this.items.map(section => {
                section.items = section.items.filter(item => !item.deleted).map(this._sanitizeFieldProperties)

                // Neutralize section ACL
                section.accessRead = ["*"]
                section.accessUpdate = ["*"]
                return section
            })
        }
        else {
            items = this.items.filter(item => !item.deleted).map(this._sanitizeFieldProperties)
        }

        return {
            id: this.id,
            name: this.name,
            namePlural: this.namePlural,
            language: kiss.language.current,
            icon: this.icon,
            color: this.color,
            fullscreen: !!this.fullscreen,
            items,
            // items: this.items.map(section => {
            //     section.items = section.items.filter(item => !item.deleted).map(this._sanitizeFieldProperties)

            //     // Neutralize ACL
            //     section.accessRead = ["*"]
            //     section.accessUpdate = ["*"]
            //     return section
            // }),
            features: this.features,

            // Neutralize ACL
            authenticatedCanCreate: true,
            authenticatedCanRead: true,
            authenticatedCanUpdate: true,
            authenticatedCanDelete: true,
            ownerCanManage: true,
            accessCreate: [],
            accessRead: [],
            accessUpdate: [],
            accessDelete: [],
            accessManage: []
        }
    }

    /**
     * Sanitize field properties before exporting Model (as JSON)
     * 
     * @private
     * @ignore
     * @param {object} field - Field JSON definition
     * @returns {object} The sanitized field definition
     */
    _sanitizeFieldProperties(field) {
        delete field.acl

        // Reset field formulas
        delete field.formulaSourceFields
        delete field.formulaSourceFieldIds

        if ((field.type == "lookup") || (field.type == "summary")) delete field.formula

        // Reset relations
        delete field.sourceFor
        if (field.type == "link") delete field.link.model

        // Reset DOM specific properties
        delete field.target

        // Sort props alphabetically
        let exportedField = {}
        Object.keys(field)
            .sortAlpha()
            .forEach(property => exportedField[property] = field[property])

        return exportedField
    }

    /**
     * Update an item in the nested model's config
     * 
     * @private
     * @ignore
     * @param {object} node - Root node to explore
     * @param {string} itemId - Id of the field to update
     * @param {object} config - New field config
     */
    _updateItemInTree(node, itemId, config) {
        if (node.id == itemId) {
            Object.assign(node, config)
        } else if (node.items) {
            for (let i = 0; i < node.items.length; i++) {
                this._updateItemInTree(node.items[i], itemId, config)
            }
        }
    }

    /**
     * Delete an item in the nested model's config
     * 
     * @private
     * @ignore
     * @param {object} node - Root node to explore
     * @param {string} itemId - Id of the field to delete
     * @returns {boolean} - Returns true if the item was deleted, otherwise false
     */
    _deleteItemFromTree(node, itemId) {
        if (node.items) {
            for (let i = 0; i < node.items.length; i++) {
                if (node.items[i].id === itemId) {
                    // Item found, delete it
                    node.items.splice(i, 1);
                    return true;
                } else if (this._deleteItemFromTree(node.items[i], itemId)) {
                    // Continue searching in nested children
                    return true;
                }
            }
        }
        return false; // Item not found
    }    

    // #endregion

    // #region Manage the model's views

    /**
     * Get all the views that are connected to this model
     * 
     * @returns {Record[]} Array of records containing the view configurations
     */
    getViews() {
        const viewCollection = kiss.app.collections.view
        if (!viewCollection) return

        const viewRecords = viewCollection.records
        const modelViews = viewRecords.filter(view => view.modelId == this.id)
        return modelViews
    }

    /**
     * Get the views a user is allowed to access.
     * 
     * A user can see a view if:
     * - he is the account owner
     * - he is one of the account managers
     * - he is the view creator
     * - the view read access is allowed to all authenticated users
     * - he is mentionned in the field "accessRead"
     * 
     * @param {string} userId 
     * @returns {object[]} The list of authorized views
     */
    getViewsByUser(userId) {
        const views = this.getViews()
        const userACL = kiss.directory.getUserACL(userId)

        // Account owner and account managers always sees all the views
        if (kiss.session.isOwner) return views
        if (kiss.session.isManager) return views

        return views.filter(view => {
            return !!view.authenticatedCanRead == true || kiss.tools.intersects(view.accessRead, userACL) || view.createdBy == userId
        })
    }

    /**
     * Get all the views that display this model and sync their fields
     * 
     * @ignore
     */
    async syncViewsWithModelFields() {
        const viewsToUpdate = this.getViews()
        for (let viewRecord of viewsToUpdate) {
            await viewRecord.syncWithModelFields()
        }
    }

    // #endregion

    // #region Relationships management

    /**
     * Generate link records between 2 models when their 2 given fields are equal.
     * 
     * Note: it does **not** save the links into the database.
     * It's up to the caller function to decide what to do with the links (create them or cancel)
     * 
     * @param {object} config
     * @param {object} config.foreignModelId
     * @param {object} config.sourceLinkFieldId
     * @param {object} config.sourceFieldId
     * @param {object} config.foreignLinkFieldId
     * @param {object} config.foreignFieldId
     * @returns {object[]} link records
     */
    async generateLinksToModel({
        foreignModelId,
        sourceLinkFieldId,
        sourceFieldId,
        foreignLinkFieldId,
        foreignFieldId
    }) {
        const localCollection = this.collection
        const foreignCollection = kiss.app.collections[foreignModelId]
        const localRecords = await localCollection.find({}, true)
        const foreignRecords = await foreignCollection.find({}, true)
        let links = []

        localRecords.forEach(localRecord => {
            foreignRecords.forEach(foreignRecord => {
                let localValue = localRecord[sourceFieldId]
                if (localValue == foreignRecord[foreignFieldId] && localValue !== "" && localValue !== undefined) {
                    links.push({
                        id: kiss.tools.uid(),
                        mX: this.id,
                        rX: localRecord.id,
                        fX: sourceLinkFieldId,
                        mY: foreignModelId,
                        rY: foreignRecord.id,
                        fY: foreignLinkFieldId,
                        auto: true // Tell it was created automatically. Can be used to rollback the process.
                    })
                }
            })
        })

        return links
    }

    /**
     * Delete all the links that were auto-generated for a given model.
     * 
     * @param {string} foreignModelId
     * @returns {integer} The number of deleted links
     */
    async deleteLinksToModel(foreignModelId) {
        const query = {
            $or: [{
                    mX: this.id,
                    mY: foreignModelId,
                    auto: true
                },
                {
                    mY: this.id,
                    mX: foreignModelId,
                    auto: true
                },
            ]
        }
        await kiss.app.collections.link.deleteMany(query)
    }

    /**
     * Connect the model to a foreign model using a <link> field.
     * 
     * To connect the 2 models, a symmetric <link> field is created in the foreign model.
     * 
     * @param {string} foreignModelId  - id of the foreign model to connect
     * @param {object} fieldSetup - Setup of the <link> field in the local model
     * @returns {object} The generated foreign <link> field
     */
    async connectToModel(foreignModelId, fieldSetup) {
        const foreignModel = kiss.app.models[foreignModelId]
        const foreignLinkFields = foreignModel.getFieldsByType("link")

        log("kiss.data.Model - Connecting model " + this.name + " to model " + foreignModel.name)

        let foreignLinkFieldId = null
        let existingLinkField = null
        let foreignLinkFieldConfig = {}

        // First, check if a deleted link field already points to the same model.
        // If yes, just restore the field instead of creating a new one.
        foreignLinkFields.forEach(linkField => {
            if (linkField.link.modelId == this.id) existingLinkField = linkField
        })

        if (existingLinkField != null) {
            // A link field already exists: we update it
            log("kiss.data.Model - connectToModel: updating existing link in the foreign model " + foreignModel.name, 2)

            delete existingLinkField.deleted
            existingLinkField.link.field = fieldSetup.label
            existingLinkField.link.fieldId = fieldSetup.id

            // Restore the field in case it was deleted
            existingLinkField.deleted = false
            existingLinkField.hidden = false

            await foreignModel.updateField(existingLinkField.id, existingLinkField)
            foreignLinkFieldId = existingLinkField.id

        } else {
            // There is no link field: we create it
            log("kiss.data.Model - connectToModel: adding a new link field in the foreign model " + foreignModel.name, 2)

            foreignLinkFieldConfig = {
                id: kiss.tools.shortUid(),
                label: this.namePlural,
                type: "link",

                // Layout parameters
                display: "inline-flex",
                width: "100%",
                fieldWidth: "100%",
                labelWidth: "100%",
                labelPosition: "top",
                labelAlign: "left",

                link: {
                    model: this.name,
                    modelId: this.id,
                    field: fieldSetup.label,
                    fieldId: fieldSetup.id
                }
            }

            await foreignModel.addField(foreignLinkFieldConfig)
            foreignLinkFieldId = foreignLinkFieldConfig.id

            log("kiss.data.Model - Foreign link field config:", 2, foreignLinkFieldConfig)
        }

        // Update the local link field
        fieldSetup.deleted = fieldSetup.hidden = false
        fieldSetup.link.fieldId = foreignLinkFieldId
        await this.updateField(fieldSetup.id, fieldSetup)

        // Update model relationships
        this._defineRelationships()
        foreignModel._defineRelationships()

        return foreignLinkFieldConfig
    }

    /**
     * Discover dynamically the relationships with foreign models.
     * 
     * Call this method once your models are loaded and available into kiss.app.models.
     * 
     * @private
     * @ignore
     * @returns {this}
     */
    _defineRelationships() {
        const modelProblems = []
        this.sourceFor = this.sourceFor || []
        const fields = this.fields.filter(field => !field.deleted)

        // Parse connections established by "link" fields
        fields.filter(field => field.type == "link").forEach(field => {
            try {
                let targetLinkModel = kiss.app.getModel(field.link.modelId || field.link.model)
                if (!targetLinkModel) throw new Error("Model not found")
                
                // Link model => foreign model, in case the connection was made with the foreign model name instead of its id
                if (!field.link.modelId) {
                    field.link.modelId = targetLinkModel.id
                    delete field.link.model
                }

                // Get the field to link in the foreign model
                let targetLinkField = targetLinkModel.getField(field.link.fieldId || field.link.field)
                if (!targetLinkField) throw new Error("Symmetric link field not found in the foreign model")

                // Enforce the field id in case the connection was made with the field name instead of its id
                field.link.fieldId = targetLinkField.id

                // Show the relationships in the console
                let hasMany = field.multiple
                let toModel = (hasMany) ? targetLinkModel.namePlural : targetLinkModel.name
                // log(`kiss.data.Model - ${this.name.padEnd(40, " ")} -> ${(hasMany) ? "N" : "1"} ${toModel.padEnd(40, " ")}` + " (link field: " + field.label + ")")

            } catch (err) {
                // Problem, the foreign model does not exist
                // log(err)
                // log(field)
                field.type = "text"
                modelProblems.push(`kiss.data.Model - The link field <${this.name + " / " + field.label}> points to a foreign model or a foreign link field that can't be found`)
            }
        })

        // Parse connections established by "lookup" fields
        fields.filter(field => field.type == "lookup").forEach(field => {
            try {
                // Get the field to lookup in the foreign model
                let lookupLinkField = this.getField(field.lookup.linkId || field.lookup.link)
                let lookupLinkedModel = kiss.app.models[lookupLinkField.link.modelId]
                if (!lookupLinkedModel) throw new Error("Model not found")
                let lookupSourceField = lookupLinkedModel.getField(field.lookup.fieldId || field.lookup.field)
                
                // The foreign model is a source for this one
                lookupLinkedModel.sourceFor = (lookupLinkedModel.sourceFor || []).concat(this.id).unique()

                // Link model => foreign model
                field.computed = true
                if (!field.lookup.linkId) {
                    field.lookup.linkId = lookupLinkField.id
                    delete field.lookup.link
                }
                
                if (!field.lookup.fieldId) {
                    field.lookup.fieldId = lookupSourceField.id
                    delete field.lookup.field
                }

                field.lookup.type = lookupSourceField.type
                if (field.lookup.type == "number") field.precision = lookupSourceField.precision

                // Link foreign model => model
                lookupSourceField.sourceFor = lookupSourceField.sourceFor || []
                let newSource = {
                    modelId: this.id,
                    modelName: this.name,
                    fieldId: field.id,
                    fieldName: field.label,
                    type: "lookup"
                }

                if (!lookupSourceField.sourceFor.includesObject(newSource)) lookupSourceField.sourceFor.push(newSource)
                lookupSourceField.sourceFor = lookupSourceField.sourceFor.uniqueObject("fieldId")

            } catch (err) {
                // Problem, the foreign model does not exist
                field.type = "text"
                modelProblems.push(`kiss.data.Model - The lookup field <${this.name + " / " + field.label}> points to a model that can't be found`)
            }
        })

        // Parse connections established by "summary" fields
        fields.filter(field => field.type == "summary").forEach(field => {
            try {
                // Get the field to summarize in the foreign model
                let summaryLinkField = this.getField(field.summary.linkId || field.summary.link)
                let summaryLinkModel = kiss.app.models[summaryLinkField.link.modelId]
                if (!summaryLinkModel) throw new Error("Model not found")
                let summaryField = summaryLinkModel.getField(field.summary.field || field.summary.fieldId)

                // The foreign model is a source for this one
                summaryLinkModel.sourceFor = (summaryLinkModel.sourceFor || []).concat(this.id).unique()

                // Link model => foreign model
                field.computed = true
                
                if (!field.summary.linkId) {
                    field.summary.linkId = summaryLinkField.id
                    delete field.summary.link
                }
                
                if (!field.summary.fieldId) {
                    field.summary.fieldId = summaryField.id
                    delete field.summary.field
                }
                
                field.summary.type = summaryField.type
                if (field.summary.type == "number") field.precision = summaryField.precision

                // Link foreign model => model
                summaryField.sourceFor = summaryField.sourceFor || []
                let newSource = {
                    modelId: this.id,
                    modelName: this.name,
                    fieldId: field.id,
                    fieldName: field.label,
                    type: "summary"
                }

                if (!summaryField.sourceFor.includesObject(newSource)) summaryField.sourceFor.push(newSource)
                summaryField.sourceFor = summaryField.sourceFor.uniqueObject("fieldId")

            } catch (err) {
                // Problem, the foreign model does not exist
                // log(err)
                field.type = "text"
                modelProblems.push(`kiss.data.Model - The summary field <${this.name + " / " + field.label}> points to a model that can't be found`)
            }
        })

        // Clean the list of foreign models that depends on this one for computed fields
        this.sourceFor = this.sourceFor.unique()

        // modelProblems.forEach(warning => log(warning))
        return this
    }

    // #endregion

    /**
     * Notify the user about a change that has been made by someone else
     * 
     * @private
     * @ignore
     * @param {object} msgData - The original pubsub message
     */
    _notifyUser(msgData) {
        if (msgData.userId == kiss.session.getUserId()) return

        let msgEvent
        let object

        if (msgData.channel == "EVT_DB_UPDATE_BULK") {
            msgEvent = txtTitleCase("#msg update")
            object = "#some data"
        } else {
            const event = msgData.channel.split(":")[0]
            const modelId = msgData.channel.split(":")[1]

            if (event.includes("INSERT")) msgEvent = txtTitleCase("#msg insert")
            else if (event.includes("UPDATE")) msgEvent = txtTitleCase("#msg update")
            else if (event.includes("DELETE")) msgEvent = txtTitleCase("#msg delete")

            if (kiss.tools.isUid(modelId.toLowerCase())) object = "#a record"
            else if (modelId == "VIEW") object = "#a view"
            else if (modelId == "MODEL") object = "#a model"
            else object = "#some data"
        }

        createNotification({
            message: txtTitleCase(
                msgEvent, null, {
                    user: kiss.directory.getEntryName(msgData.userId),
                    object: txt(object)
                }
            ),
            top: () => kiss.screen.current.height - 50,
            left: 10,
            height: "40px",
            padding: "0px",
            animation: "slideInUp",
            duration: 4000
        })
    }
 }

;kiss.data.RecordFactory = function (modelId) {
    /**
     * To see how a **Record** relates to models, fields and collections, please refer to the [Model documentation](kiss.data.Model.html).
     * 
     * A Record can't be instanciated directly.
     * You have to use the Model's **create** method:
     * ```
     * let myUser = userModel.create({
     *      firstName: "Bob",
     *      lastName: "Wilson"
     * })
     * ```
     * A record automatically has default methods for CRUD operations:
     * - save
     * - read
     * - update
     * - delete
     * 
     * @class
     * @param {object} [recordData] - Optional data used to create the record
     * @param {boolean} [inherit] - If true, create a blank record then assign recordData to it
     * @returns {object} Record
     * 
     * @example
     * // Get the "user" model
     * const userModel = kiss.app.models.user
     * 
     * // Create a new user instance
     * const myUser = userModel.create({
     *  firstName: "Bob",
     *  lastName: "Wilson",
     *  email: "bob.wilson@gmail.com"
     * })
     * 
     * // Save the new record
     * await myUser.save()
     * 
     * // Call custom model's method
     * myUser.sendEmail({
     *  subject: "Hello ${myContact.firstName}",
     *  message: "How are you?"
     * })
     * 
     * // Update the record
     * await myUser.update({
     *  firstName: "Bobby"
     * })
     * 
     * // Delete the record
     * await myUser.delete()
     * 
     */
    const Record = class {

        constructor(recordData, inherit) {
            this.model = kiss.app.models[modelId]
            this.db = this.model.db

            if (!recordData || inherit) {
                this.id = uid()
                this.createdAt = new Date().toISOString()
                this.createdBy = kiss.session.getUserId()

                this._initDefaultValues()
                this._computeFields()
            } else {
                this.id = recordData.id || uid()
                Object.assign(this, recordData)
            }

            if (inherit) Object.assign(this, recordData)

            return this
        }

        /**
         * Set or restore the model's default values
         * 
         * Default values can be predefined values like:
         * - username
         * - today
         * - now
         * - unid
         * 
         * Or:
         * - today+10
         * - today-5
         * 
         * Or: 
         * - {YYYY} // Year
         * - {MM} // Month
         * - {DD} // Day
         * - {hh} // Hour
         * - {mm} // Minutes
         * - {ss} // Seconds
         * - {XX} // Random letters
         * - {NN} // Random numbers
         * 
         * @private
         * @ignore
         * @returns this
         */
        _initDefaultValues() {
            const primaryKeyField = this.model.getPrimaryKeyField()

            this.model.getFields().forEach(field => {
                let defaultValue = field.value

                if (defaultValue === 0) {
                    this[field.id] = defaultValue
                    return
                }

                if (defaultValue && typeof defaultValue == "string") {
                    if ((defaultValue.includes("today+") || defaultValue.includes("today-"))) {
                        // Process special date formatting like:
                        // today+10, today-5
                        const daysFromNow = Number(field.value.split("today")[1])
                        if (!isNaN(daysFromNow)) {
                            let newDate = (new Date()).addDays(daysFromNow)
                            defaultValue = newDate.toISO()
                        }
                    }
                    else {
                        // Process special values like:
                        defaultValue = defaultValue
                            .replace("username", kiss.session.getUserId())
                            .replace("today", new Date().toISO())
                            .replace("now", kiss.tools.getTime())
                            .replace("unid", kiss.tools.shortUid().toUpperCase())
                            .replace("{YYYY}", new Date().getFullYear())
                            .replace("{MM}", (new Date().getMonth() + 1).toString().padStart(2, "0"))
                            .replace("{DD}", (new Date().getDate()).toString().padStart(2, "0"))
                            .replace("{hh}", (new Date().getHours()).toString().padStart(2, "0"))
                            .replace("{mm}", (new Date().getMinutes()).toString().padStart(2, "0"))
                            .replace("{ss}", (new Date().getSeconds()).toString().padStart(2, "0"))
                            .replace("{XX}", String.fromCharCode(65 + Math.random() * 26 | 0) + String.fromCharCode(65 + Math.random() * 26 | 0))
                            .replace("{NN}", (Math.floor(Math.random() * 100) + "").padStart(2, "0"))
                    }

                    this[field.id] = defaultValue

                } else if (defaultValue) {

                    this[field.id] = defaultValue

                }
            })
            return this
        }

        /**
         * Check the permission (client-side) to perform an action on the record.
         * 
         * @param {string} action - "update" | "delete"
         * @returns {boolean} true if the permission is granted
         */
        async checkPermission(action) {
            const hasPermission = await kiss.acl.check({
                action,
                record: this
            })

            if (!hasPermission) {
                createNotification(txtTitleCase("#not authorized"))
                return false
            }

            return true
        }

        /**
         * Check if the record has changed since its last state
         * 
         * @param {object} [data] - Optional data to compare
         * @returns {boolean}
         */
        hasChanged(data) {
            if (!data) data = this.getSanitizedData()

            const currentState = JSON.stringify(data)
            if (currentState == this.lastState) return false

            this.lastState = currentState
            return true
        }

        /**
         * Get the record's sanitized data to keep only the model's fields
         * 
         * @returns {object} The sanitized data
         */
        getSanitizedData() {
            const data = {
                id: this.id
            }

            // this.model.getFields().forEach(field => {
            //     data[field.id] = this[field.id]
            // })

            // Include revision fields
            // const revisionFields = ["createdAt", "createdBy", "updatedAt", "updatedBy", "deletedAt", "deletedBy"]
            // revisionFields.forEach(fieldId => {
            //     data[fieldId] = this[fieldId]
            // })

            this.model.fields.forEach(field => {
                data[field.id] = this[field.id]
            })

            return data
        }

        /**
         * Save a record in the database
         * 
         * @async
         * @returns {boolean} true if successfuly created, false otherwise
         * 
         * @example
         * let newUser = userModel.create({firstName: "Bob", lastName: "Wilson"})
         * await newUser.save() // Insert the record into the database
         * newUser.lastName = "SMITH" // Update a property
         * await newUser.update() // Update the existing record according to the new data
         * await newUser.update({lastName: "JONES"}) // Explicit update of the lastName (same as above)
         */
        async save() {
            let loadingId

            try {
                log("kiss.data.Record - Saving " + this.id)
                const data = this.getSanitizedData()

                // Check permission to create
                const permission = await this.checkPermission("create")
                if (!permission) return false

                // Update db, wherever it is: in memory, offline or online
                loadingId = kiss.loadingSpinner.show()
                const response = await this.db.insertOne(this.model.id, data)
                kiss.loadingSpinner.hide(loadingId)

                if (response.error) {
                    log("kiss.data.Record - save - Error: " + response.error, 4)
                    return false
                }
                return true

            } catch (err) {
                log("kiss.data.Record - save - Error:", 4, err)
                kiss.loadingSpinner.hide(loadingId)
            }
        }

        /**
         * Duplicate a record in the database.
         * 
         * The copy of the record can handle its connected records in 3 ways:
         * - Duplicate the linked records and link them to the new record
         * - Link the linked records to the new record without duplication
         * - Do nothing with the linked records
         * 
         * This is a per field configuration, using the `linksToDuplicate` and `linksToMaintain` options.
         * Link fields that belong to no category will be ignored.
         * 
         * This duplicate method is very useful in some practical uses cases, like:
         * - Duplicating an order and its order details
         * - Maintaining the customer linked to the duplicated order
         * 
         * @async
         * @param {object} [config]
         * @param {boolean} [config.resetPluginFields] - If true (default), reset all the fields belonging to a plugin
         * @param {string[]} [config.linksToDuplicate] - List of link field ids which foreign records should be duplicated. Default is []
         * @param {string[]} [config.linksToMaintain] - List of link field ids which foreign records should be linked to the duplicated record. Default is []
         * @returns {*} The new record id, or false in case of error
         * 
         * @example
         * await myRecord.duplicate() // Duplicate the record
         * 
         * await myRecord.duplicate({
         *  linksToDuplicate: ["order_details"], // Duplicate linked records, and link them to the new record
         *  linksToMaintain: ["customer"], // Only link the linked records to the new record
         * })
         */        
        async duplicate(config = {}) {
            const linksToDuplicate = config.linksToDuplicate || []
            const linksToMaintain = config.linksToMaintain || []
            const resetPluginFields = (config.resetPluginFields != undefined) ? config.resetPluginFields : true

            let loadingId

            try {
                log("kiss.data.Record - duplicate " + this.id)

                // Check permission to create
                const permission = await this.checkPermission("create")
                if (!permission) return false

                loadingId = kiss.loadingSpinner.show()

                // Duplicate the record's data, except the id, attached files and revision fields
                const data = this.getSanitizedData()
                data.id = kiss.tools.uid()
                data.createdAt = new Date().toISOString()
                data.createdBy = kiss.session.getUserId()

                // Reset attached fields
                const attachmentFields = this.model.getFieldsByType("attachment")
                attachmentFields.forEach(field => {
                    data[field.id] = []
                })

                // Reset plugin fields
                if (resetPluginFields) {
                    const pluginFields = this.model.fields.filter(field => field.isFromPlugin)
                    pluginFields.forEach(field => {
                        delete data[field.id]
                    })
                }

                const response = await this.db.insertOne(this.model.id, data)

                if (response.error) {
                    log("kiss.data.Record - duplicate - Error: " + response.error, 4)
                    kiss.loadingSpinner.hide(loadingId)
                    return false
                }

                let newChildren = []
                let newLinks = []

                // Manage the linked records
                let linkFields = this.model.getFieldsByType("link").filter(field => !field.deleted)

                for (let linkField of linkFields) {
                    const foreignLinkFieldId = linkField.link.fieldId
                    const foreignModelId = linkField.link.modelId

                    if (linksToDuplicate.includes(linkField.id)) {

                        // Case 1: The linked records should be duplicated and linked to the new record
                        const foreignRecords = await this.getLinkedRecordsFrom(linkField.id)
    
                        for (let foreignRecord of foreignRecords) {
    
                            // Build new children
                            foreignRecord.id = kiss.tools.uid()
                            foreignRecord.createdAt = new Date().toISOString()
                            foreignRecord.createdBy = kiss.session.getUserId()
    
                            // Reset attached fields
                            const attachmentFields = kiss.app.models[foreignModelId].getFieldsByType("attachment")
                            attachmentFields.forEach(field => {
                                foreignRecord[field.id] = []
                            })
    
                            // Reset plugin fields
                            if (resetPluginFields) {
                                const pluginFields = kiss.app.models[foreignModelId].fields.filter(field => field.isFromPlugin)
                                pluginFields.forEach(field => {
                                    delete foreignRecord[field.id]
                                })
                            }
    
                            newChildren.push(foreignRecord)
    
                            // Build new link
                            const linkInfos = {
                                id: kiss.tools.uid(),
                                mX: this.model.id,
                                rX: data.id,
                                fX: linkField.id,
                                mY: foreignModelId,
                                rY: foreignRecord.id,
                                fY: foreignLinkFieldId,
                                createdAt: new Date().toISOString(),
                                createdBy: kiss.session.getUserId()
                            }
                            newLinks.push(linkInfos)
                        }
                    }
                    else if (linksToMaintain.includes(linkField.id)) {

                        // Case 2: The linked records should be linked to the new record without duplication
                        const foreignRecords = await this.getLinkedRecordsFrom(linkField.id)

                        for (let foreignRecord of foreignRecords) {
                            const linkInfos = {
                                id: kiss.tools.uid(),
                                mX: this.model.id,
                                rX: data.id,
                                fX: linkField.id,
                                mY: foreignModelId,
                                rY: foreignRecord.id,
                                fY: foreignLinkFieldId,
                                createdAt: new Date().toISOString(),
                                createdBy: kiss.session.getUserId()
                            }
                            newLinks.push(linkInfos)
                        }
                    }

                    // Insert the new children and links
                    const foreignCollection = kiss.app.collections[foreignModelId]
                    if (newChildren.length > 0) {
                        log.info("kiss.data.Record - duplicate - Inserting new children")
                        log(newChildren)
                        await foreignCollection.insertMany(newChildren)
                    }
                }

                const linkCollection = kiss.app.collections.link
                if (newLinks.length > 0) {
                    log.info("kiss.data.Record - duplicate - Inserting new links")
                    log(newLinks)
                    await linkCollection.insertMany(newLinks)
                }

                kiss.loadingSpinner.hide(loadingId)
                return data.id

            } catch (err) {
                log("kiss.data.Record - duplicate - Error:", 4, err)
                kiss.loadingSpinner.hide(loadingId)
            }
        }

        /**
         * Get all the records linked to the current record from a specific field
         * 
         * @param {string} fieldId 
         * @returns {object[]} The linked records
         */
        async getLinkedRecordsFrom(fieldId) {
            return await kiss.data.relations.getLinkedRecordsFrom(this.model.id, this.id, fieldId)
        }    

        /**
         * Get the record's data from the database and update the record's instance.
         * It guaranties to get the last version of the record locally in case it was updated remotely.
         * 
         * @async
         * @returns this
         * 
         * @example
         * console.log(user) // Bob Wilson
         * await user.read()
         * console.log(user) // Bob WILSON JR
         */
        async read() {
            let record = await this.db.findOne(this.model.id, this.id)
            Object.assign(this, record)
            return this
        }

        /**
         * Update the record in the database
         * TODO: apply data validation
         * 
         * @async
         * @param {object} [update] - Optional update. If not specified, updates all the fields.
         * @param {boolean} [silent] - Set to true to hide the loading spinner (update in the background)
         * @returns {boolean} true if updated successfuly
         * 
         * @example
         * await myTask.update({status: "done"})
         * 
         * // Will work too but not optimal because it will save the whole record
         * myTask.status = "done"
         * await myTask.update() 
         */
        async update(update, silent) {
            let loadingId

            try {
                log("kiss.data.Record - update " + this.id, 0, update)
                if (!silent) loadingId = kiss.loadingSpinner.show()

                // Exit if no changes
                if (!this.hasChanged(update)) {
                    log("kiss.data.Record - update - Record didn't change, exit!")
                    if (!silent) kiss.loadingSpinner.hide(loadingId)
                    return true
                }

                const permission = await this.checkPermission("update")
                if (!permission) {
                    kiss.loadingSpinner.hide(loadingId)
                    return false
                }

                if (!update) update = this.getSanitizedData()

                Object.assign(this, update)

                const response = await this.db.updateOne(this.model.id, this.id, update)
                if (!silent) kiss.loadingSpinner.hide(loadingId)
                return response

            } catch (err) {
                log("kiss.data.Record - update - Error:", 4, err)
                if (!silent) kiss.loadingSpinner.hide(loadingId)
                return false
            }
        }

        /**
         * Update multiple fields
         * 
         * This update propagates other mutations inside the same record and also in foreign records
         * 
         * @async
         * @param {string} fieldId
         * @param {*} value
         * @param {object} transaction - The global Transaction object that contains all the database mutations to perform at once
         * @returns {boolean} true if the field was updated successfuly
         * 
         * @example
         * await user.updateDeep({
         *  fistName: "Bob",
         *  lastName: "Wilson"
         * })
         */
        async updateDeep(update) {
            let loadingId

            try {
                log(`kiss.data.Record - updateDeep ${this.id} / ${update}`)
                loadingId = kiss.loadingSpinner.show()

                const permission = await this.checkPermission("update")
                if (!permission) {
                    kiss.loadingSpinner.hide(loadingId)
                    return false
                }

                // Update the field and propagate the change
                const response = await this.db.updateOneDeep(this.model.id, this.id, update)

                kiss.loadingSpinner.hide(loadingId)

                if (response) return true

            } catch (err) {
                log("kiss.data.Record - updateDeep - Error:", 4, err)
                kiss.loadingSpinner.hide(loadingId)
                return false
            }
        }

        /**
         * Update a single field of the record
         * 
         * This update propagates other mutations inside the same record and also in foreign records.
         * It also check the new field value against custom validation function, if it exists.
         * 
         * @async
         * @param {string} fieldId
         * @param {*} value
         * @returns {boolean} true if the field was updated successfuly
         * 
         * @example
         * await user.updateFieldDeep("lastName", "Wilson")
         */
        async updateFieldDeep(fieldId, value) {
            let loadingId

            try {
                log(`kiss.data.Record - updateFieldDeep ${this.id} / ${fieldId} / ${value}`)
                loadingId = kiss.loadingSpinner.show()

                const permission = await this.checkPermission("update")
                if (!permission) {
                    kiss.loadingSpinner.hide(loadingId)
                    return false
                }

                const validation = await this.checkValidationRules(fieldId, value)
                if (!validation) {
                    kiss.loadingSpinner.hide(loadingId)
                    return false
                }

                // Update the undo log
                const field = this.model.getField(fieldId)
                if (field && field.type != "attachment" && field.type != "aiImage") {
                    kiss.undoRedo.addOperation({
                        id: uid(),
                        action: "updateField",
                        createdAt: new Date(),
                        createdBy: kiss.session.getUserId(),
                        modelId: this.model.id,
                        recordId: this.id,
                        fieldId,
                        oldValue: this[fieldId],
                        newValue: value
                    })
                }

                // Update the field and propagate the change
                const response = await this.db.updateOneDeep(this.model.id, this.id, {
                    [fieldId]: value
                })
                kiss.loadingSpinner.hide(loadingId)

                if (response) return true

            } catch (err) {
                log("kiss.data.Record - updateFieldDeep - Error:", 4, err)
                kiss.loadingSpinner.hide(loadingId)
                return false
            }
        }

        /**
         * Check the validation rules of a field if they exist
         * 
         * @param {string} fieldId 
         * @param {*} value 
         * @returns {boolean} true if the value is valid or if there is no validation rule
         */
        async checkValidationRules(fieldId, value) {
            const field = this.model.getField(fieldId)

            if (!field) {
                // Should not happen, but just in case...
                log(`kiss.data.Record - checkValidationRules - Field ${fieldId} not found`)
                return true
            }

            if (!field.validationFunction) return true

            const result = await field.validationFunction(value)
            return !!result
        }

        /**
         * Delete the record from the database
         * 
         * @async
         * @param {boolean} [sendToTrash] - If true, keeps the original record in a "trash" collection. Default = false
         * @returns {boolean} true if deleted successfuly
         * 
         * @example
         * await myTask.delete()
         */
        async delete(sendToTrash) {
            let loadingId

            try {
                log("kiss.data.Record - delete " + this.id)
                loadingId = kiss.loadingSpinner.show()

                const permission = await this.checkPermission("delete")
                if (!permission) {
                    kiss.loadingSpinner.hide(loadingId)
                    return false
                }

                // Update the undo log
                if (this.model.id != "trash") {
                    kiss.undoRedo.addOperation({
                        id: uid(),
                        action: "deleteRecord",
                        createdAt: new Date(),
                        createdBy: kiss.session.getUserId(),
                        modelId: this.model.id,
                        recordId: this.id
                    })
                }

                const response = await this.db.deleteOne(this.model.id, this.id, sendToTrash)
                kiss.loadingSpinner.hide(loadingId)

                return response

            } catch (err) {
                log("kiss.data.Record - update - Error:", 4, err)
                kiss.loadingSpinner.hide(loadingId)
                return false
            }
        }

        /**
         * Get a field value from the record
         * 
         * @param {string} fieldId - The field id or label
         * @returns {*} The field value
         */
        get(fieldId) {
            const field = this.model.getField(fieldId)
            if (!field) return undefined
            return this[field.id]
        }

        /**
         * Create a new record in the join table to link the 2 records
         * 
         * @ignore
         * @param {object} foreignRecord 
         * @param {string} localLinkFieldId 
         * @param {string} foreignLinkFieldId
         */
        async linkTo(foreignRecord, localLinkFieldId, foreignLinkFieldId) {
            let loadingId

            try {
                log(`kiss.data.Record - linkTo ${this.id} / ${foreignRecord.id}`)
                loadingId = kiss.loadingSpinner.show()

                const linkModel = kiss.app.models.link
                const linkInfos = {
                    id: kiss.tools.uid(),
                    mX: this.model.id,
                    rX: this.id,
                    fX: localLinkFieldId,
                    mY: foreignRecord.model.id,
                    rY: foreignRecord.id,
                    fY: foreignLinkFieldId // Never used
                }
                const newLink = linkModel.create(linkInfos)
                await newLink.save()

                // Re-compute all fields of both records with the new link
                await this.db.updateLink(linkInfos)

                kiss.loadingSpinner.hide(loadingId)
            } catch (err) {
                log("kiss.data.Record - linkTo - Error:", 4, err)
                kiss.loadingSpinner.hide(loadingId)
            }
        }

        /**
         * Delete a link between 2 records.
         * 
         * @ignore
         * @param {string} linkId - id of the record in the join table
         */
        async deleteLink(linkId) {
            let loadingId

            try {
                log(`kiss.data.Record - deleteLink ${this.id} / ${linkId}`)
                loadingId = kiss.loadingSpinner.show()

                const linkModel = kiss.app.models.link
                const linkRecord = await linkModel.collection.findOne(linkId)
                const linkInfos = await linkRecord.getData()

                const result = await linkRecord.delete()
                if (!result) {
                    kiss.loadingSpinner.hide(loadingId)
                    return false
                }

                // Re-compute all fields of both records without the link
                await this.db.updateLink(linkInfos)

                kiss.loadingSpinner.hide(loadingId)
                return result

            } catch (err) {
                log("kiss.data.Record - linkTo - Error:", 4, err)
                kiss.loadingSpinner.hide(loadingId)
            }
        }

        /**
         * Get the data and populate the fields linked to foreign records.
         * 
         * The function is recursive and explore all the records connections.
         * To avoid endless loops, each model that has already been explored is "skipped" from inner exploration.
         * In a future evolution, we may also allow exploration of the same model in inner exploration, but limiting it to a predefined depth.
         * 
         * @param {pbject} config
         * @param {boolean} [config.useLabels] - If true, use labels as exported keys. Default to false
         * @param {boolean} [config.convertNames] - If true, convert emails and groups ids to directory names
         * @param {boolean} [config.numberAsText] - If true, convert numbers to text with fixed number of digits according to the defined precision. Default to false
         * @param {boolean} [config.includeLinks] - If true, explore links and includes them as nested data. Default to false
         * @param {number} [config.linksDepth] - Maximum depth when exploring the links. Default to 1, meaning it only gets the direct relationships.
         * @param {boolean} [config.sortLinks] - If true, check if the links have been sorted by the user. Default to false
         * @param {string[]} [config.projection] - Keep only the fields specified in this array. All fields by default.
         * @param {string[]} [skipIds] - Model ids to skip in the exploration of nested data
         * @param {string} [accountId] - For server only: accountId allows to retrieve the right directory to merge directory fields
         * @returns {object} Record's data, like: {a: 1, b: 2}
         * 
         * @example
         * myRecord.getData() // {"aEf32x": "Bob", "e07d58": "Wilson"}
         * myRecord.getData({useLabels: true}) // {"First name": "Bob", "Last name": "Wilson"}
         * 
         */
        async getData(config = {}, skipIds, accountId) {
            const recordData = {
                id: this.id
            }

            // Update the list of models that must be skipped when "link" fields are populated
            const modelId = this.model.id
            const skipModelIds = (Array.isArray(skipIds)) ? skipIds : []
            skipModelIds.push(modelId)

            // Update the current depth
            config.linksDepth = (config.linksDepth != undefined) ? config.linksDepth : 1
            const depth = config.linksDepth - 1
            const newConfig = Object.assign({}, config, {
                linksDepth: depth
            })
            
            let fields = this.model.fields.filter(field => !field.deleted)
            if (config.projection) {
                fields = fields.filter(field => config.projection.includes(field.id) || config.projection.includes(field.label))
            }

            for (let field of fields) {
                const fieldLabel = (config.useLabels == true) ? field.label : (field.id || field.label)

                // Link fields are populated with the linked records values
                if (field.type == "link") {

                    // Exploration of the relationships is limited to the defined depth
                    if (config.includeLinks == true && depth >= 0) {
                        const linkedModelId = field.link.modelId

                        // To avoid endless loop, We can't explore the same model twice
                        if (!skipModelIds.includes(linkedModelId)) {
                            let sort
                            if (config.sortLinks) sort = await this._getLinkFieldSortConfig(linkedModelId, field.id)
                            const links = await kiss.data.relations.getLinksAndRecords(modelId, this.id, field.id, sort)
                            const linkedRecords = links.map(link => link.record)
                            const connectedRecords = []

                            // For each linked record, try to get data recursively
                            for (let linkData of linkedRecords) {
                                const linkedRecord = kiss.app.models[linkedModelId].create(linkData)
                                const linkedRecordData = await linkedRecord.getData(newConfig, skipModelIds, accountId)
                                connectedRecords.push(linkedRecordData)
                            }
                            recordData[fieldLabel] = connectedRecords
                        }
                    } else {
                        recordData[fieldLabel] = []
                    }
                } else {
                    let value = this[field.id]

                    if (value !== "" && config.numberAsText && (field.type == "number" || (field.type == "lookup" && field.lookup.type == "number") || (field.type == "summary" && field.summary.type == "number"))) {
                        // Cast number to text with fixed precision
                        const precision = (field.precision != undefined) ? field.precision : 2
                        value = Number(value).round(precision).toFixed(precision)

                    } else if (config.convertNames && field.type == "directory") {
                        // Cast user id fields to directory names
                        if (kiss.isClient) {
                            value = (!value) ? [] : kiss.directory.getEntryNames([].concat(value))
                        } else {
                            value = (!value) ? [] : kiss.directory.getEntryNames(accountId, [].concat(value))
                        }

                    } else if (field.exporter && typeof field.exporter === "function") {
                        // If a plugin field has a special exporter, we use it
                        value = field.exporter(value)
                    }

                    if (value == undefined) value = ""
                    recordData[fieldLabel] = value
                }
            }

            return recordData
        }

        /**
         * Get the view configuration associated to a link field, if any
         * 
         * @private
         * @ignore
         * @param {string} modelId 
         * @param {string} fieldId 
         * @returns {object[]} The sort configuration (normalized), or null
         */
        async _getLinkFieldSortConfig(modelId, fieldId) {
            const viewRecord = await kiss.db.findOne("view", {
                modelId,
                fieldId
            })
            if (viewRecord && viewRecord.sort) return viewRecord.sort
            return null
        }        

        /**
         * Get the files attached to the record
         * 
         * @returns {object[]} The list of file objects
         * 
         * @example
         * [
         *     {
         *         "id": "dbba41cc-6ec6-4bb9-981a-4e27eafb20b9",
         *         "filename": "logo 8.png",
         *         "path": "https://pickaform-europe.s3.eu-west-3.amazonaws.com/files/a50616e1-8cce-4788-ae4e-7ee10d35b5f2/2022/06/17/logo%208.png",
         *         "size": 7092,
         *         "type": "amazon_s3",
         *         "mimeType": "image/png",
         *         "thumbnails": {
         *              // Thumbnails infos
         *         },
         *         "createdAt": "2022-06-16T20:49:29.349Z",
         *         "createdBy": "john.doe@pickaform.com"
         *     },
         *     {
         *          "id": "0185c4f3-e3ff-7933-a1f2-e06459111665",
         *          "filename": "France invest.PNG",
         *          "path": "uploads\\01847546-a751-7a6e-9e6a-42b8b8e37570\\2023\\01\\18\\France invest.PNG",
         *          "size": 75999,
         *          "type": "local",
         *          "mimeType": "image/png",
         *          "thumbnails": {
         *              // Thumbnails infos
         *          },
         *          "createdAt": "2023-01-18T12:56:36.095Z",
         *          "createdBy": "georges.lucas@pickaform.com"
         *      }
         * ]
         */
        getFiles() {
            const attachmentFields = this.model.getFieldsByType("attachment").filter(field => !field.deleted)
            return attachmentFields.filter(field => this[field.id] !== undefined).map(field => this[field.id]).flat()
        }

        /**
         * Get record's raw data.
         * 
         * @returns {object}
         */
        getRawData() {
            return kiss.tools.snapshot(this)
        }

        /**
         * Compute the local computed fields when initializing a record.
         * lookup and summary fields are excluded because they are necessarily empty for a blank record.
         * 
         * @private
         * @ignore
         * @param {string} updatedFieldId 
         * @param {number} depth 
         */
        _computeFields_v1_deprecated(updatedFieldId, depth = 0) {
            if (depth > 10) return
            depth++

            for (let computedFieldId of this.model.computedFields) {
                const computedField = this.model.getField(computedFieldId)
                const computedFieldCurrentValue = this[computedField.id]

                if (computedFieldId != updatedFieldId // Don't recompute the same field 
                    &&
                    computedField.type != "lookup" // New records have no links => no lookups
                    &&
                    computedField.type != "summary" // New records have no links => no summary
                    &&
                    (!updatedFieldId || computedField.formulaSourceFieldIds.includes(updatedFieldId))
                ) {
                    let newComputedFieldValue = this._computeField(computedField)
                    if (newComputedFieldValue !== undefined && newComputedFieldValue !== computedFieldCurrentValue) {
                        // If the field's value changed, we propagate it to all form fields (except the field itself)
                        this[computedField.id] = newComputedFieldValue
                        this._computeFields(computedField.id, depth)
                    }
                }
            }
        }

        /**
         * Compute the local computed fields when initializing a record.
         * 
         * - exit immediately if the model has cyclic dependencies
         * - lookup and summary fields are excluded because they are necessarily empty for a blank record.
         * - fields are computed in their topological order
         */
        _computeFields() {
            if (this.model.hasCyclicDependencies) {
                log.warn("kiss.data.Record - _computeFields - The model fields have cyclic dependencies, the computed fields will not be computed.")
                return
            }

            for (let fieldId of this.model.orderedComputedFields) {
                const field = this.model.getField(fieldId)
                if (field.type == "lookup" || field.type == "summary") continue
                const newValue = this._computeField(field)
                if (newValue === undefined) continue
                if (kiss.tools.isNumericField(field) && isNaN(newValue)) continue
                this[fieldId] = newValue
            }
        }

        /**
         * Compute a single computed field
         * 
         * @private
         * @ignore
         * @param {object} field 
         * @returns The computed value, or "" in case of error
         */
        _computeField(field) {
            try {
                let newValue = kiss.formula.execute(field.formula, this, this.model.getActiveFields(), field)
                return newValue
            } catch (err) {
                log.err("kiss.data - Record.computeField - Error:", err)
                return ""
            }
        }
    }

    // Attach the Model's method to the Record's prototype.
    // This allows to use model's methods on every record instanciated from this Record class.
    const model = kiss.app.models[modelId]
    Object.keys(model.methods).forEach(methodName => {
        Record.prototype[methodName] = model.methods[methodName]
    })

    return Record
}

;/**
 * 
 * kiss.relations
 * 
 * This module handles the relationships between models inside a NoSQL environment.
 * 
 * Context:
 * 
 * In modern applications, we are used to update the database as soon as a single field is modified.
 * It brings a better user experience than filling a bunch of fields then click on a "Save" button.
 * It also prevents too much data from being lost in case of a crash when a user is filling tons of data.
 * 
 * Problem:
 * 
 * In NoSQL, databases are denormalized: data is redundant accross records.
 * When the field's value of a record depends on foreign records, we need some logic to keep data in sync between records.
 * 
 * To keep things simple, we will say that some fields can be a "source" for other fields.
 * We simply call them: "source fields".
 * When a source field is updated, we need to update all the fields that depends on this source.
 * 
 * In business applications, we have identified 2 common scenarios:
 * - **lookup** fields:
 *   A lookup field takes its value inside another field of a foreign record.
 *   When the value of the foreign source field is updated, the lookup field must be updated too.
 * 
 * - **summary** fields:
 *   A summary field summarizes (aggregates) data of multiple foreign records.
 *   When the value of a single foreign source field is updated, the summary field must re-compute the whole aggregation
 * 
 * Solution:
 * 
 * When a field is updated, we track all the mutations that are triggered:
 * 1. inside the same record (because of computed fields)
 * 2. inside foreign records (because of the relationships between records, defined by special "link" records)
 * 
 * To fit all possible scenarios (1-1, 1-N, N-N), KissJS manage all relations as N-N.
 * The links are maintained in a single external table: the "link" table.
 * 
 * When a **lookup** field or a **summary** field needs to be computed, the process is:
 * - search for the foreign records (thanks to the **link** fields of the record)
 * - get data from foreign records
 * - compute the new field value, but **do not** update the field immediately
 * - instead, add the upcoming change to a transaction
 * 
 * Because a field change can trigger a chain reaction over other computed fields,
 * the process is called recursively until there is no more field to update.
 * 
 * At each cycle, the change is added to the transaction.
 * At the end, the transaction is processed, performing all required database mutations at once (batch update).
 * 
 * To boost performances, an architectural choice was to load every links into cache,
 * amd maintain this cache each time a link is added or removed.
 * For bigger applications with tens of thousands of records and links,
 * this choice might need some optimization process.
 * 
 */
kiss.data.relations = {
    /**
     * Connect 2 models together by adding a LINK field on each side.
     * 
     * @param {string} modelIdA 
     * @param {string} modelIdB 
     * @param {string} cardinality - "11" | "1N" | "N1" | "NN"
     */
    async connectModels(modelIdA, modelIdB, cardinality) {
        const modelA = kiss.app.models[modelIdA]
        const modelB = kiss.app.models[modelIdB]

        // Prepare link fields
        const linkIdA = kiss.tools.shortUid()
        const linkIdB = kiss.tools.shortUid()
        const cardinalityA = cardinality[0]
        const cardinalityB = cardinality[1]

        let linkFieldA = {
            id: linkIdA,
            type: "link",
            label: (cardinalityB == "N") ? modelB.namePlural : modelB.name,
            multiple: (cardinalityB == "N") ? true : false,
            link: {
                modelId: modelIdB,
                fieldId: linkIdB
            }
        }

        let linkFieldB = {
            id: linkIdB,
            type: "link",
            label: (cardinalityA == "N") ? modelA.namePlural : modelA.name,
            multiple: (cardinalityA == "N") ? true : false,
            link: {
                modelId: modelIdA,
                fieldId: linkIdA
            }
        }

        // Check if models already have connections together
        const modelAlinks = modelA.getFieldsByType("link")
        const modelBlinks = modelB.getFieldsByType("link")

        linkAtoB = []
        modelAlinks.forEach(field => {
            if (field.link.modelId == modelB.id) linkAtoB.push(field)
        })

        linkBtoA = []
        modelBlinks.forEach(field => {
            if (field.link.modelId == modelA.id) linkBtoA.push(field)
        })

        // Set operations to link the 2 models
        let AhasLinkToB = (linkAtoB.length > 0)
        let BhasLinkToA = (linkBtoA.length > 0)

        if (AhasLinkToB) {
            linkFieldA = linkAtoB[0]
            linkFieldA.label = (cardinalityB == "N") ? modelB.namePlural : modelB.name
            linkFieldA.multiple = (cardinalityB == "N") ? true : false
        }

        if (BhasLinkToA) {
            linkFieldB = linkBtoA[0]
            linkFieldB.label = (cardinalityA == "N") ? modelA.namePlural : modelA.name
            linkFieldB.multiple = (cardinalityA == "N") ? true : false
        }

        await Promise.all([
            (AhasLinkToB) ? modelA.updateField(linkFieldA.id, linkFieldA) : modelA.addField(linkFieldA),
            (BhasLinkToA) ? modelB.updateField(linkFieldB.id, linkFieldB) : modelB.addField(linkFieldB)
        ])
    },

    /**
     * Update relationships of a model
     * 
     * @param {string} modelId 
     */
    update(modelId) {
        const model = kiss.app.models[modelId]
        if (model) {
            model._defineRelationships()
            // log("kiss.data.relations - Building relationships for model " + model.name)
        }
    },

    /**
     * Update a single field or all fields of a record, and propagate the changes:
     * - to the computed fields of the same records
     * - to the **lookup** and **summary** fields of foreign records
     * 
     * All the database mutations are processed inside a single transaction
     * 
     * @param {object} model 
     * @param {object} record 
     * @param {string} [update] - If not specified, update all fields
     * @param {string} userId - user who updated the record
     * @returns The transaction result
     */
    async updateOneDeep(model, record, update, userId) {
        // Prepare temp cache
        const cacheId = kiss.tools.uid()
        kiss.cache[cacheId] = {}
        kiss.cache[cacheId].deletedRecords = []

        try {
            const transaction = new kiss.data.Transaction({
                userId
            })

            await kiss.data.relations.computeTransactionToUpdate(model, record, update, transaction, cacheId)
            const operations = await transaction.process()

            // Clear cache
            delete kiss.cache[cacheId]

            return operations

        } catch (err) {
            log.err("kiss.dataRelations - updateOneDeep - Error:", err)
            return []
        }
    },

    /**
     * Re-compute computed fields on a selection of records of a collection.
     * 
     * Note: this is used when updating data from an XLS or a CSV file.
     * 
     * @param {string} modelId
     * @param {string[]} ids - ids of the records to update
     * @returns The transaction result
     */
    async updateManyDeep(modelId, ids) {
        try {
            const model = kiss.app.models[modelId]
            const transaction = new kiss.data.Transaction()
            const records = await kiss.db.findById(modelId, ids)

            const cacheId = "cache-" + kiss.tools.uid()
            await kiss.data.relations.buildCache(cacheId, modelId, records)

            for (const record of records) {
                await kiss.data.relations.computeTransactionToUpdate(model, record, null, transaction, cacheId)
            }

            const operations = await transaction.process()

            // Clear cache
            delete kiss.cache[cacheId]

            return operations

        } catch (err) {
            log.err("kiss.dataRelations - updateManyDeep - Error:", err)
            return []
        }
    },

    /**
     * Re-compute computed fields on all records of a collection.
     * 
     * Note: this is used when changing a computed field formula.
     * 
     * @param {string} modelId
     * @returns The transaction result
     */
    async updateAllDeep(modelId) {
        try {
            const model = kiss.app.models[modelId]
            const transaction = new kiss.data.Transaction()
            const records = await kiss.db.find(modelId, {})

            const cacheId = "cache-" + kiss.tools.uid()
            await kiss.data.relations.buildCache(cacheId, modelId, records)

            for (const record of records) {
                await kiss.data.relations.computeTransactionToUpdate(model, record, null, transaction, cacheId)
            }

            const operations = await transaction.process()

            // Clear cache
            delete kiss.cache[cacheId]

            return operations

        } catch (err) {
            log.err("kiss.dataRelations - updateAllDeep - Error:", err)
            return []
        }
    },

    /**
     * Build a cache of a set of records used for updateAllDeep and updateManyDeep operations.
     * Without pre-caching, these operations would trigger a HUGE number of database requests.
     * 
     * @param {string} cacheId 
     * @param {string} modelId 
     */
    async buildCache(cacheId, modelId) {
        kiss.cache[cacheId] = {}
        kiss.cache[cacheId].deletedRecords = []

        // Whatever happen, we need to clear this cache at some time
        setTimeout(() => {
            log.ack("kiss.data.relations - Cleaning cache " + cacheId)
            delete kiss.cache[cacheId]
        }, 60 * 1000)

        if (!cacheId.startsWith("cache")) return

        const model = kiss.app.models[modelId]
        // console.log("kiss.data.relations - Building cache for relationships of model: " + model.name)

        const accountId = model.accountId
        const modelsToExplore = Object.values(kiss.app.models).filter(model => model.accountId == accountId)
        const connectedModelsToCache = kiss.data.relations.getConnectedModels(modelId, modelsToExplore, [model.id])
        const modelsToCache = [model].concat(connectedModelsToCache)

        let count = 0

        for (let modelToCache of modelsToCache) {
            kiss.cache[cacheId][modelToCache.id] = {}
            const records = await kiss.db.find(modelToCache.id, {})
            records.forEach(record => {
                count++
                kiss.cache[cacheId][modelToCache.id][record.id] = record
            })
        }

        // console.log(`kiss.data.cache - ${count} records cached from ${modelsToCache.length} collections:`)
        // modelsToCache.forEach(model => {
        //     console.log(`kiss.data.cache - ${model.name} - ${Object.keys(kiss.cache[cacheId][model.id]).length} records`)
        // })
    },

    /**
     * Get all the models connected to a model
     */
    getConnectedModels(modelId, modelsToExplore, exploredModels) {
        let connectedModels = modelsToExplore.filter(model => !exploredModels.includes(model.id) && model.sourceFor && model.sourceFor.includes(modelId))
        if (connectedModels.length == 0) return []

        exploredModels = exploredModels.concat(connectedModels.map(model => model.id))

        for (let connectedModel of connectedModels) {
            let deeperModels = kiss.data.relations.getConnectedModels(connectedModel.id, modelsToExplore, exploredModels)
            connectedModels = connectedModels.concat(deeperModels)
        }

        return connectedModels
    },

    /**
     * !NOT USED AT THE MOMENT, TOO CPU INTENSIVE
     * Build a cache exploring the links between records
     */
    async buildSmartCache(cacheId, modelId, records) {
        kiss.cache[cacheId] = {}
        kiss.cache[cacheId].deletedRecords = []

        // Whatever happen, we need to clear this cache at some time
        setTimeout(() => {
            if (kiss.cache[cacheId]) {
                log("kiss.data.relations - Cleaning cache " + cacheId)
                delete kiss.cache[cacheId]
            }
        }, 60 * 1000)

        if (!cacheId.startsWith("cache")) return

        // Expore all links of all records
        let links = []
        let exploredNodes = []

        for (const record of records) {
            const recordLinks = kiss.data.relations.getRelationTree(modelId, record.id, exploredNodes)
            links = links.concat(recordLinks)
            exploredNodes = links.map(link => link.recordId).unique()
        }

        // Group links by model
        const linksByModel = links.reduce((map, link) => {
            map[link.modelId] = map[link.modelId] || {}
            map[link.modelId][link.recordId] = 0
            return map
        }, {})

        // Retrieve all the records we must cache from db
        for (modelId of Object.keys(linksByModel)) {
            if (kiss.app.models[modelId]) {
                const cachedRecords = await kiss.db.findById(modelId, Object.keys(linksByModel[modelId]))
                kiss.cache[cacheId][modelId] = {}
                cachedRecords.forEach(record => {
                    kiss.cache[cacheId][modelId][record.id] = record
                })
            }
        }

        // console.log("kiss.data.relations - Explored links: " + links.length)
        // console.log("kiss.data.relations - Unique links: " + links.map(link => link.recordId).unique().length)
    },

    /**
     * !NOT USED AT THE MOMENT, TOO CPU INTENSIVE
     * Get the tree of all relations of a record
     * 
     * @param {string} modelId 
     * @param {string} recordId 
     * @param {string[]} exploredNodes 
     * @param {number} depth 
     * @returns {object[]} Array of links
     */
    getRelationTree(modelId, recordId, exploredNodes = [], depth = 0) {
        const model = kiss.app.models[modelId]
        if (!model) return []

        exploredNodes.push(recordId)
        let nodeLinks = kiss.data.relations.getLinks(modelId, recordId)

        nodeLinks = nodeLinks.filter(link => {
            const foreignModel = kiss.app.models[link.modelId]
            if (!foreignModel) return false
            return !exploredNodes.includes(link.recordId) && foreignModel.sourceFor.includes(modelId)
        })

        let allLinks = []

        for (link of nodeLinks) {
            exploredNodes.push(link.recordId)
            const foreignLinks = kiss.data.relations.getRelationTree(link.modelId, link.recordId, exploredNodes, exploredLinks, depth)
            exploredNodes = exploredNodes.concat(foreignLinks.map(foreignLink => foreignLink.recordId))
            allLinks = allLinks.concat(foreignLinks)
        }

        allLinks = allLinks
            .concat(nodeLinks)
            .concat({
                modelId,
                recordId
            })
        return allLinks
    },

    /**
     * Re-compute computed fields on 2 records connected by a link.
     * 
     * Note: this is used when linking / unlinking records together.
     * 
     * @param {object} linkRecord
     * @param {string} userId - user who linked / unlinked the records
     * @returns The transaction result
     */
    async updateLink(linkRecord, userId) {
        let recordX
        let recordY

        const {
            mX,
            rX,
            mY,
            rY,
        } = linkRecord

        const modelX = kiss.app.models[mX]
        const modelY = kiss.app.models[mY]

        if (kiss.isServer) {
            recordX = await kiss.db.findOne(mX, {
                _id: rX
            })
            recordY = await kiss.db.findOne(mY, {
                _id: rY
            })
        } else {
            recordX = await kiss.db.findOne(mX, rX)
            recordY = await kiss.db.findOne(mY, rY)
        }

        // Temp cache
        const cacheId = kiss.tools.uid()
        kiss.cache[cacheId] = {}
        kiss.cache[cacheId].deletedRecords = []

        const transaction = new kiss.data.Transaction({
            userId
        })
        await kiss.data.relations.computeTransactionToUpdate(modelX, recordX, null, transaction, cacheId)
        await kiss.data.relations.computeTransactionToUpdate(modelY, recordY, null, transaction, cacheId)
        const operations = await transaction.process()

        // Clear cache
        delete kiss.cache[cacheId]

        return operations
    },

    /**
     * Update all the foreign records of a given record
     * 
     * @param {string} modelId 
     * @param {string} recordId 
     * @returns The transaction result
     */
    async updateForeignRecords(modelId, recordId) {
        // Prepare temp cache
        const cacheId = kiss.tools.uid()
        kiss.cache[cacheId] = {}
        kiss.cache[cacheId].deletedRecords = []

        const transaction = new kiss.data.Transaction()
        await kiss.data.relations.computeTransactionToUpdateForeignRecords(modelId, recordId, transaction, cacheId)
        const operations = await transaction.process()

        // Clear cache
        delete kiss.cache[cacheId]

        return operations
    },

    /**
     * Update all the foreign records of multiple records.
     * Currently used by deleteMany operation, which can trigger multiple mutations on foreign records
     * 
     * @param {string} modelId 
     * @param {string[]} ids
     * @returns The transaction result
     */
    async updateForeignRecordsForMultipleRecords(modelId, ids) {
        // Prepare temp cache
        const cacheId = kiss.tools.uid()
        kiss.cache[cacheId] = {}
        kiss.cache[cacheId].deletedRecords = []

        const transaction = new kiss.data.Transaction()
        for (recordId of ids) {
            await kiss.data.relations.computeTransactionToUpdateForeignRecords(modelId, recordId, transaction, cacheId)
        }
        const operations = await transaction.process()

        // Clear cache
        delete kiss.cache[cacheId]

        return operations
    },

    /**
     * Compute the transaction to update all the foreign records linked to a specific record
     * 
     * @param {object} modelId
     * @param {object} recordId
     */
    async computeTransactionToUpdateForeignRecords(modelId, recordId, transaction, cacheId) {
        const model = kiss.app.models[modelId]
        const linkFields = model.fields.filter(field => field.type == "link")

        // For each "link" fields...
        for (const linkField of linkFields) {
            const foreignModel = kiss.app.models[linkField.link.modelId]

            // ... get the foreign records given by this "link" field
            const foreignRecords = await kiss.data.relations.getLinkedRecordsFrom(modelId, recordId, linkField.id, transaction, cacheId)

            for (const foreignRecord of foreignRecords) {
                await kiss.data.relations.computeTransactionToUpdate(foreignModel, foreignRecord, null, transaction, cacheId)
            }
        }
    },

    /**
     * Compute the transaction to update a record with its relationships
     * 
     * The method is recursive: for each update, it re-checks which computed fields is impacted by the new change.
     * This method does **not** update the fields, but only returns the changes to apply to the record.
     * All the field updates are performed later in a single transaction.
     * 
     * @param {object} model
     * @param {object} record 
     * @param {string} [update]
     * @param {object} transaction 
     */
    async computeTransactionToUpdate(model, record, update, transaction, cacheId, depth = 0) {
        // Limit the update depth to avoid infinite loops
        if (depth > 10) return

        let recordUpdates = {}

        // Update the record if it's specified
        if (update) {
            Object.assign(record, update)
            recordUpdates = update
        }

        // Recompute other fields of the same record, then cache all the updates to be done for this record
        recordUpdates = await kiss.data.relations._computeFields(model, record, update, recordUpdates, 0, transaction, cacheId)

        // Remove empty properties from the updates to perform
        Object.keys(recordUpdates).forEach(property => {
            if (recordUpdates[property] == undefined) delete recordUpdates[property]
        })

        // No updates to perform: exit
        if (Object.keys(recordUpdates).length == 0) return

        // Add operations to the global transaction
        transaction.addOperation({
            modelId: model.id,
            recordId: record.id,
            updates: recordUpdates
        })

        if (!kiss.global.ops) kiss.global.ops = 0
        kiss.global.ops++

        // Define all the foreign models impacted by this update.
        // For each of them, store the impacted fields too
        let foreignModelTargetFields = {}

        Object.keys(recordUpdates).forEach(updatedFieldId => {
            const field = model.getField(updatedFieldId)
            if (field && field.sourceFor) {
                field.sourceFor.forEach(source => {
                    foreignModelTargetFields[source.modelId] = foreignModelTargetFields[source.modelId] || []
                    foreignModelTargetFields[source.modelId].push(source.fieldId)
                })
            }
        })

        // Loop over foreign models
        for (const foreignModelId of Object.keys(foreignModelTargetFields)) {
            const foreignModel = kiss.app.models[foreignModelId]
            const fieldsToUpdateInForeignRecord = foreignModelTargetFields[foreignModelId]
            const linkField = model.getLinkField(foreignModelId)

            if (linkField) {
                const foreignRecordsToUpdate = await kiss.data.relations.getLinkedRecordsFrom(model.id, record.id, linkField.id, transaction, cacheId)

                // Loop over foreign records
                for (const foreignRecord of foreignRecordsToUpdate) {

                    // Loop over foreign fields
                    for (const foreignFieldId of fieldsToUpdateInForeignRecord) {
                        const foreignField = foreignModel.getField(foreignFieldId)
                        const newForeignRecordValue = await kiss.data.relations._computeField(foreignModel, foreignRecord, foreignField, transaction, cacheId)

                        // The new value might impact other fields, so, we recursively update the impacted fields
                        let foreignFieldUpdate = {}
                        foreignFieldUpdate[foreignFieldId] = newForeignRecordValue

                        depth++
                        await kiss.data.relations.computeTransactionToUpdate(foreignModel, foreignRecord, foreignFieldUpdate, transaction, cacheId, depth)
                        depth--
                    }
                }
            }
        }
    },

    /**
     * Calculate the computed fields values based on their source fields
     * (source fields = other fields involved in their formula).
     * 
     * BEWARE:
     * Highly sensitive recursive algorithm.
     * Any mistake while updating this code can impact the NoSQL relational model deeply.
     * 
     * @private
     * @ignore
     * @async
     * @param {object} model
     * @param {object} record
     * @param {string} [update] - original update which triggered the re-compute. If not passed or set to null, recomputes all fields.
     * @param {object} changes
     * @param {number} depth - Max number of iterations in the recursive loop
     * @returns {object} Object containing all updates to perform on the record after all the computed fields have been recalculated
     */
    async _computeFields_V1_deprecated(model, record, update, changes = {}, depth = 0, transaction, cacheId) {
        // Limit the field dependency depth to avoid infinite loops
        if (depth > 30) {
            return changes
        }
        depth++

        // console.log("UPDATE:", update)

        const updatedFieldIds = (update) ? Object.keys(update) : []
        const recomputeAllFields = (updatedFieldIds.length == 0)

        for (let computedFieldId of model.computedFields) {
            let skip = false
            const computedField = model.getField(computedFieldId)

            // Check if the computed field's formula relies on the field that has changed.
            // If yes => re-compute the computed field value
            if (
                !updatedFieldIds.includes(computedFieldId) &&
                (
                    recomputeAllFields ||
                    kiss.tools.intersects(computedField.formulaSourceFieldIds, updatedFieldIds)
                )
            ) {
                let newComputedFieldValue = await kiss.data.relations._computeField(model, record, computedField, transaction, cacheId)

                if (
                    newComputedFieldValue === undefined ||
                    newComputedFieldValue === record[computedField.id] ||
                    (kiss.tools.isNumericField(computedField) && isNaN(newComputedFieldValue))
                ) skip = true

                if (!skip) {
                    record[computedField.id] = changes[computedField.id] = newComputedFieldValue
                    await kiss.data.relations._computeFields(model, record, changes, changes, depth, transaction, cacheId)
                }
            }
        }
        // console.log("Changes:", changes, record.id)
        return changes
    },

    /**
     * Compute fields of a record for a given update.
     * 
     * @private
     * @ignore
     * @async
     * @param {object} model - The model of the record
     * @param {object} record - The record to update
     * @param {object} update - The fields to update, or null to update all fields
     * @param {object} changes - The changes to apply to the record after all the computed fields have been recalculated
     * @param {number} depth - Not used anymore. Kept for compatibility with the previous recursive algorithm
     * @param {object} transaction - The transaction to which the changes will be added
     * @param {string} cacheId - The cache id to use for the operation
     * 
     * @returns {object} The changes to apply to the record
     */
    async _computeFields(model, record, update = null, changes = {}, depth = 0, transaction, cacheId) {
        // Apply the update to the record
        Object.assign(record, update)
        
        let updateAllFields = false
        let impactedFieldIds = []

        if (update != null) {
            Object.keys(update).forEach(fieldId => {
                let field = model.getField(fieldId)
                impactedFieldIds = impactedFieldIds.concat(field.deepDependencies)
            })
        }
        else {
            updateAllFields = true
        }

        // Compute fields in their topological order
        for (let fieldId of model.orderedComputedFields) {
            if (updateAllFields || impactedFieldIds.includes(fieldId)) {
                const field = model.getField(fieldId)
                
                // console.log(field.label, "(", field.id, ")")
                const newValue = await this._computeField(model, record, field, transaction, cacheId)
                // console.log(newValue)

                if (newValue === undefined) continue
                if (kiss.tools.isNumericField(field) && isNaN(newValue)) continue
                
                if (newValue !== record[fieldId]) {
                    record[fieldId] = changes[fieldId] = newValue
                }
            }
        }

        return changes
    },

    /**
     * Compute a single field
     * 
     * @private
     * @ignore
     * @async
     * @param {object} model 
     * @param {object} record 
     * @param {object} field 
     * @param {object} [transaction]
     * @returns The new value or undefined in case of error
     */
    async _computeField(model, record, field, transaction, cacheId) {
        try {
            let newValue

            switch (field.type) {
                case "lookup":
                    newValue = await kiss.data.relations._computeLookupField(model.id, record.id, field.id, transaction, cacheId)
                    break
                case "summary":
                    newValue = await kiss.data.relations._computeSummaryField(model.id, record.id, field.id, transaction, cacheId)
                    break
                default:
                    newValue = kiss.formula.execute(field.formula, record, model.getActiveFields(), field)
            }

            // console.log("Updating field:", field.label, " - New value:", newValue)
            return newValue

        } catch (err) {
            // console.log("kiss.data.relations - _computeField - Field: ", field.label, " - Error:", err)
        }
    },

    /**
     * Compute a **lookup** field
     * 
     * A lookup field is taking its value from another field inside a foreign record
     * 
     * @private
     * @ignore
     * @param {string} modelId
     * @param {string} recordId
     * @param {string} fieldId
     * @param {object} transaction
     * @returns {*} The value(s) found in the foreign record
     */
    async _computeLookupField(modelId, recordId, fieldId, transaction, cacheId) {
        const model = kiss.app.models[modelId]
        const field = model.getField(fieldId)

        // Get the foreign records associated to the <link> field
        const foreignRecords = await kiss.data.relations.getLinkedRecordsFrom(modelId, recordId, field.lookup.linkId, transaction, cacheId)

        // Retrieve the foreign value from the source field
        if (foreignRecords.length == 0) return ""
        if (foreignRecords.length == 1) return foreignRecords[0][field.lookup.fieldId]

        // If there are multiple values to lookup, we perform a summary "LIST" operation
        return kiss.data.relations._summarizeField(foreignRecords, field.lookup.fieldId, "LIST")
    },

    /**
     * Compute a **summary** field
     * 
     * A summary field get all the foreign records connected through a link field, then summarize the information of a foreign field.
     * For example, imagine a "Project" record connected to multiple "Tasks" records, where each task has a **workload**.
     * You could have a "Total workload" field in the Project, and this field is a **summary** field that gather the informations of all "Workload" fields.
     * 
     * Summary operations can be:
     * - SUM
     * - AVERAGE
     * - COUNT
     * - MIN
     * - MAX
     * - CONCATENATE
     * - LIST
     * - ... more to come?
     * 
     * @private
     * @ignore
     * @async
     * @param {string} modelId
     * @param {string} recordId
     * @param {string} fieldId
     * @param {object} transaction
     * @returns {*} The summary of all values found in the foreign records
     */
    async _computeSummaryField(modelId, recordId, fieldId, transaction, cacheId) {
        const model = kiss.app.models[modelId]
        let field = model.getField(fieldId)

        // Get the foreign records associated to the <link> field
        const foreignRecords = await kiss.data.relations.getLinkedRecordsFrom(modelId, recordId, field.summary.linkId, transaction, cacheId)

        // If there are no foreign records to "summup", return 0 or "" depending on the field type
        if (foreignRecords.length == 0) {
            if (field.summary.type == "number") return 0
            return ""
        }

        // Gather all foreign records and summarize their data
        return kiss.data.relations._summarizeField(foreignRecords, field.summary.fieldId, field.summary.operation, field.precision)
    },

    /**
     * Summarize the information of a given field for a given set of records
     * 
     * @private
     * @ignore
     * @param {object} collection - The collection which holds the records
     * @param {string[]} recordIds - List of records from which we want to collect information
     * @param {string} fieldId - The field from which we want to collect information
     * @param {string} operation - SUM, MIN, MAX, AVERAGE, CONCATENATE
     * @param {number} [precision] - Uses a fixed number of digits in case the operation returns a number
     * @returns {*} The summarized value
     */
    _summarizeField(records, fieldId, operation, precision) {
        let values = []

        records.forEach(record => {
            if (record) values.push(record[fieldId])
        })

        if (operation == "CONCATENATE" || operation == "LIST" || operation == "LIST_NAMES") {
            return kiss.formula[operation](...values)
        } else {
            if (precision) return Number((kiss.formula[operation](...values)).toFixed(precision))
            return Number(kiss.formula[operation](...values))
        }
    },

    /**
     * Get the foreign records associated to a specific link field
     * and use cache to optimize database access
     * 
     * @private
     * @ignore
     * @async
     * @param {string} modelId
     * @param {string} recordId
     * @param {string} linkFieldId
     * @param {object} [transaction]
     * @param {string} cacheId
     * @returns {object[]} Array of records
     */
    async getLinkedRecordsFrom(modelId, recordId, linkFieldId, transaction, cacheId) {

        if (!cacheId) {
            // Build temp cache
            cacheId = kiss.tools.uid()
            await kiss.data.relations.buildCache(cacheId)
        } else if (cacheId.startsWith("cache")) {
            // Check if records where already cached to limit the number of database access
            return await kiss.data.relations.getLinkedRecordsFromCache(modelId, recordId, linkFieldId, transaction, cacheId)
        }

        const links = kiss.data.relations.getLinksFromField(modelId, recordId, linkFieldId)
        if (links.length == 0) {
            return []
        }

        // Get links to foreign records and filters out links to deleted records
        const foreignModelId = links[0].modelId
        const ids = links
            .map(link => link.recordId)
            .filter(recordId => !kiss.cache[cacheId].deletedRecords.includes(recordId))

        let records = []
        let remainingIds = []

        // Get linked records from cache and stack missing ids for future retrieval
        ids.forEach(id => {
            if (kiss.cache[cacheId][id]) {
                records.push(kiss.cache[cacheId][id])
            } else {
                remainingIds.push(id)
            }
        })

        // Retrieve the records missing from cache
        let dbRecords = []

        if (remainingIds.length > 0) {
            dbRecords = await kiss.db.findById(foreignModelId, remainingIds)

            dbRecords.forEach(record => {
                kiss.cache[cacheId][record.id] = record
            })

            // If some records were not found, add them to the cache of deleted records, to not try anymore retrieving them
            if (links.length != dbRecords.length) {
                const foundRecordIds = dbRecords.map(record => record.id)
                links.forEach(link => {
                    if (!foundRecordIds.includes(link.recordId)) {
                        kiss.cache[cacheId].deletedRecords = (kiss.cache[cacheId].deletedRecords || []).concat(link.recordId)
                    }
                })
            }
        }

        records = records.concat(dbRecords)

        if (transaction) {
            records = kiss.data.relations._patchRecordsFromTransactionCache(foreignModelId, records, transaction)
        }

        // Prevent duplicates to be returned (should never happen, though)
        // records = records.uniqueObjectId()
        return records
    },

    /**
     * Get FROM CACHE the foreign records associated to a specific link field
     * 
     * @private
     * @ignore
     * @async
     * @param {string} modelId
     * @param {string} recordId
     * @param {string} linkFieldId
     * @param {object} transaction
     * @param {string} cacheId
     * @returns {object[]} Array of records
     */
    async getLinkedRecordsFromCache(modelId, recordId, linkFieldId, transaction, cacheId) {
        const links = kiss.data.relations.getLinksFromField(modelId, recordId, linkFieldId)

        if (links.length == 0) {
            return []
        }

        // Get links to foreign records and filters out links that points to deleted records
        const foreignModelId = links[0].modelId
        const ids = links.map(link => link.recordId)
        let records = []

        if (kiss.cache[cacheId][foreignModelId]) {
            let missingCount = 0
            ids.forEach(id => {
                const cachedRecord = kiss.cache[cacheId][foreignModelId][id]
                if (cachedRecord) {
                    records.push(cachedRecord)
                } else {
                    missingCount++
                }
            })
            // if (missingCount) console.log("kiss.data.relations - getLinkedRecordsFromCache - Record missing from cache or deleted: " + kiss.app.models[foreignModelId].name + " / " + missingCount + " records")
        } else {
            // const foreignModel = kiss.app.models[foreignModelId]
            // const foreignModelName = (foreignModel) ? foreignModel.name : "Unknown model name (maybe deleted?)"
            // console.log("kiss.data.relations - getLinkedRecordsFromCache - Model records missing from cache: " + foreignModelId + " / " + foreignModelName)
        }

        if (transaction) {
            records = kiss.data.relations._patchRecordsFromTransactionCache(foreignModelId, records, transaction)
        }

        return records
    },

    /**
     * Get the foreign links associated to a specific link field.
     * Look for all the linked records where the current record id match rX (left) or rY (right).
     * 
     * @param {string} modelId
     * @param {string} recordId
     * @param {string} linkFieldId - Field that makes the link between models
     * @returns {object[]} Array of objects holding the links, or empty array
     */
    getLinksFromField(modelId, recordId, linkFieldId) {
        const model = kiss.app.models[modelId]
        const accountId = model.accountId
        const foreignLinkField = model.getField(linkFieldId)

        if (!foreignLinkField) return []

        const foreignModelId = foreignLinkField.link.modelId
        const foreignLinkFieldId = foreignLinkField.link.fieldId
        const linkModel = kiss.app.models.link

        // Get the dynamic links between records
        // They are kept in cache to improve lookup performances
        let links
        if (kiss.isClient) {
            links = linkModel.collection.records
        } else {
            links = kiss.global.links[accountId] || []
        }

        // Get the links where the id of the record is in the **left** column of the join table
        const left = links
            .filter(link => link.mX == modelId && link.rX == recordId && link.fX == linkFieldId)
            .map(link => {
                return {
                    linkId: link.id,
                    modelId: link.mY,
                    recordId: link.rY
                }
            })

        // Get the links where the id of the record is in the **right** column of the join table
        const right = (modelId == foreignModelId) ? [] : links
            .filter(link => link.mY == modelId && link.rY == recordId && link.fX == foreignLinkFieldId)
            .map(link => {
                return {
                    linkId: link.id,
                    modelId: link.mX,
                    recordId: link.rX
                }
            })

        // Lookup records from their ids
        const join = [].concat(left.concat(right))
        return join
    },

    /**
     * Delete all the links from multiple records
     * 
     * @param {object} params
     * @param {object} params.req - The original request
     * @param {object} params.records - The records from which we have to delete the links
     */
    async deleteLinksFromRecords({
        req,
        records
    }) {
        const linkIds = kiss.data.relations.getLinksFromRecords(records)
        if (linkIds.length == 0) return

        // Remove links from db
        await kiss.db.deleteMany("links" + req.targetCollectionSuffix, {
            _id: {
                $in: linkIds
            }
        })

        // Remove links from server cache
        const accountId = req.token.currentAccountId
        const countBeforeDeletion = kiss.global.links[accountId].length

        kiss.global.links[accountId] = kiss.global.links[accountId].filter(link => !linkIds.includes(link.id))

        const deleteLinks = countBeforeDeletion - kiss.global.links[accountId].length
        log.info(`kiss.data.relations - ${req.token.userId } deleted ${deleteLinks} link(s)`)
    },

    /**
     * Get all the links of multiple records
     * 
     * @param {object[]} records 
     * @returns {object[]} Array of links
     */
    getLinksFromRecords(records) {
        let linkIds = []
        records.forEach(record => {
            let links = kiss.data.relations.getLinks(record.sourceModelId, record.id)
            linkIds = linkIds.concat(links.map(link => link.linkId))
        })
        return linkIds
    },

    /**
     * Get the all foreign links of a record.
     * Look for all the linked records where the current record id match rX (left) or rY (right).
     * Each link is returned as:
     * 
     *  {
     *      linkId: "...",
     *      modelId: "...",
     *      recordId: "..."
     *  }
     * 
     * @param {string} modelId 
     * @param {string} recordId 
     * @returns {object[]} Array of link objects
     */
    getLinks(modelId, recordId) {
        const model = kiss.app.models[modelId]
        if (!model) return []

        // Get the dynamic links between records
        // They are kept in cache to improve lookup performances
        let links
        if (kiss.isClient) {
            const linkModel = kiss.app.models.link
            links = linkModel.collection.records
        } else {
            const accountId = model.accountId
            links = kiss.global.links[accountId] || []
        }

        // Get the links where the id of the record is in the **left** column of the join table
        const left = links
            .filter(link => link.mX == modelId && link.rX == recordId)
            .map(link => {
                return {
                    linkId: link.id,
                    modelId: link.mY,
                    recordId: link.rY
                }
            })

        // Get the links where the id of the record is in the **right** column of the join table
        const right = links
            .filter(link => link.mY == modelId && link.rY == recordId)
            .map(link => {
                return {
                    linkId: link.id,
                    modelId: link.mX,
                    recordId: link.rX
                }
            })

        // Lookup records from their ids
        const join = [].concat(left.concat(right))
        return join
    },

    /**
     * Get the foreign records informations associated to a specific link field:
     * - filters out links that point to deleted records
     * - default sort by creation date
     * 
     * @private
     * @ignore
     * @async
     * @param {string} modelId
     * @param {string} recordId
     * @param {string} fieldId - The link field id
     * @param {object[]|object} [sort] - Optional sort options
     * @param {object} [sortSyntax] - "normalized" | "mongo". Sort syntax. Default to "normalized"
     * @returns {object[]} Array of objects containing the links informations
     */
    async getLinksAndRecords(modelId, recordId, fieldId, sort, sortSyntax = "normalized") {
        try {
            const model = kiss.app.models[modelId]
            const field = model.getField(fieldId)
            const foreignModel = kiss.app.models[field.link.modelId]
            let links = kiss.data.relations.getLinksFromField(modelId, recordId, fieldId)
            const ids = links.map(link => link.recordId)
            const records = await kiss.db.findById(foreignModel.id, ids, sort, sortSyntax)

            return records.map(record => {
                const link = links.find(link => link.recordId == record.id)
                return Object.assign(link, {
                    record
                })
            })

        } catch (err) {
            // console.log("kiss.data.relations - getLinksAndRecords - Could not retrieve links")
            // console.log(err)
            return []
        }
    },

    /**
     * Patch the records with previous mutations which are already in the transaction's stack of operations
     * 
     * @private
     * @ignore
     * @param {string} modelId
     * @param {object} records - records to patch in memory
     * @param {object} transaction - transaction that holds the current state mutations
     * @returns {object} 
     */
    _patchRecordsFromTransactionCache(modelId, records, transaction) {
        records.forEach(record => {
            transaction.operations.every(operation => {
                if (operation.modelId == modelId && operation.recordId == record.id) {
                    Object.assign(record, operation.updates)
                    return false
                }
                return true
            })
        })
        return records
    }
}/**
 * 
 * kiss.data.Transaction
 * 
 * By default, KissJS is built to work with MongoDb, which is a NoSQL databases.
 * NoSQL are often denormalized.
 * What does it mean?
 * 
 * It means that when there are relationships between Models, some data is voluntarily duplicated accross documents to avoid joints.
 * For example, imagine a **Project** document which is connected to many **Tasks** documents.
 * 
 * In that situation, a common practice is to duplicate the **project name** within all its connected tasks.
 * But then, what happens if you change the project name afterwards? That's exactly where the complex stuff begins!
 * 
 * You will have to update all the connected documents by yourself.
 * But instead of requesting the server for each update, you can batch your updates into a single **Transaction**.
 * 
 * This is the purpose of this class.
 * 
 * @param {object} [config]
 * @param {object} [config.id] - Optional transaction id
 * @param {object} [config.operations] - List of operations to perform in the transaction (can be added later with addOperation method)
 * @param {object} [config.userId] - User who triggered the transaction, in case we need to timestamp the updated records
 * @returns {object} this
 * 
 * @example
 * // A transaction looks like this.
 * // Each operation contains the target model, target record, and updates to perform on the record
 * {
 *	"id": "98650fb1-9288-4be9-a611-394211e9fff9",
 *	"operations": [{
 *      "action": "update",
 *		"modelId": "d620b995-89a1-4f1b-a4c6-a4a11949de94",
 *		"recordId": "6ab2f4fd-e6f3-4fc3-998f-96629e7ef109",
 *		"updates": {
 *			"SJg2oX@w": "New project name"
 *		}
 *	}, {
 *      "action": "update",
 *		"modelId": "01f6c940-e247-4d85-9f35-e3d59ea49289",
 *		"recordId": "5eb85fe3-2634-466c-839f-08423fc1cac1",
 *		"updates": {
 *			"yUbNrXw9": "New project name"
 *		}
 *	}, {
 *      "action": "update",
 *		"modelId": "01f6c940-e247-4d85-9f35-e3d59ea49289",
 *		"recordId": "5ae68056-f099-473b-8f5f-af9eeec9ddff",
 *		"updates": {
 *			"yUbNrXw9": "New project name"
 *		}
 *	}, {
 *      "action": "update",
 *		"modelId": "01f6c940-e247-4d85-9f35-e3d59ea49289",
 *		"recordId": "1f7f9d6a-2cbc-42f1-80c4-8ad795141493",
 *		"updates": {
 *			"yUbNrXw9": "New project name"
 *		}
 *	}]
 * }
 */
kiss.data.Transaction = class {
    constructor(config = {}) {
        this.id = config.id || kiss.tools.uid()
        this.operations = config.operations || []
        this.dbMode = config.dbMode
        this.userId = config.userId
        return this
    }

    /**
     * Add an operation to the Transaction.
     * A single operation can contain multiple field updates.
     * 
     * @param {object} operation
     * @param {string} operation.action - Only "update" at the moment. Will support "insert" and "delete" in the future.
     * @param {string} operation.modelId -  The target model (allow to batch the operations by database table)
     * @param {string} operation.recordId - The record to update
     * @param {object} operation.updates - The update to apply to the record
     * @returns {object} The transaction itself (makes the method chainable)
     * 
     * @example
     * myTransaction.add({
     *  action: "update",
     *  modelId: "project",
     *  recordId: "5eb85fe3-2634-466c-839f-08423fc1cac1",
     *  updates: {
     *      name: "New project name",
     *      status: "pending"
     *  }
     * })
     */
    addOperation(operation) {
        this.operations.push(operation)
        return this
    }

    /**
     * Process a transaction
     * 
     * @async
     * @returns {object[]} Array of operations in case of success, empty Array otherwise
     */
    async process() {
        // Exit if no operations to process        
        if (this.operations.length == 0) {
            return []
        }

        // Merge operations by model and record
        let groupedOperations = {}

        this.operations.forEach(operation => {
            const modelId = operation.modelId
            const recordId = operation.recordId
            groupedOperations[modelId] = groupedOperations[modelId] || {}
            groupedOperations[modelId][recordId] = groupedOperations[modelId][recordId] || {}
            Object.assign(groupedOperations[modelId][recordId], operation.updates)
        })

        // Flatten the list of operations
        let flatOperations = []
        Object.keys(groupedOperations).forEach(modelId => {
            const modelOperations = groupedOperations[modelId]

            Object.keys(modelOperations).forEach(recordId => {
                const recordOperations = modelOperations[recordId]
                if (Object.keys(recordOperations).length == 0) return // Skip objects without any mutations

                // If a userId is provided, we timestamp the record
                if (this.userId) {
                    recordOperations.updatedAt = new Date().toISOString()
                    recordOperations.updatedBy = this.userId
                }

                flatOperations.push({
                    modelId,
                    recordId,
                    updates: recordOperations
                })
            })
        })

        // Process all the operations in bulk.
        // If the transaction only contains a single operation, then we downgrade it to a simple updateOne operation
        let success

        if (flatOperations.length == 1) {

            // Single operation: the transaction is downgraded to an updateOne
            // log(`kiss.data.Transaction - Processed as updateOne`)
            const operation = flatOperations[0]

            if (kiss.isClient) {
                success = await kiss.db.updateOne(operation.modelId, operation.recordId, operation.updates)

            } else {
                success = await kiss.db.updateOne(operation.modelId, {
                    _id: operation.recordId
                }, operation.updates)
            }
        } else {

            // Multiple operations: the transaction is processed with an updateBulk
            // log(`kiss.data.Transaction - Processed as updateBulk`)
            success = await kiss.db.updateBulk(flatOperations)
        }

        if (!success) {
            log(`kiss.data.Transaction - Could not process the operations`)
            this._rollback()
            return []
        } else {
            log(`kiss.data.Transaction - Processed ${flatOperations.length} operation(s)`)
            this._commit()
            return flatOperations
        }
    }

    /**
     * Commit a transaction
     * 
     * @private
     * @ignore
     */
    _commit() {
        // TODO
    }

    /**
     * Rollback a transaction
     * 
     * @private
     * @ignore
     */
    _rollback() {
        // TODO
    }
}

;/**
 * 
 * ## Formula module
 * 
 * **Handle specific formulae that can be used inside computed fields.**
 * 
 * @namespace
 */
kiss.formula = {
    //--------------------
    //
    // WORKING WITH TEXT
    //
    //--------------------

    /**
     * Returns the length of a string or an array
     * 
     * @param {string} text
     * @returns {number}
     * 
     * @example
     * LENGTH("San Francisco") // 13
     * LENGTH("") // 0
     * LENGTH(null) // 0
     * LENGTH(123) // 0
     * LENGTH([1, 2, 3]) // 3
     * LENGTH([]) // 0
     */
    LEN: (text) => {
        if (!text) return 0
        if (Array.isArray(text)) return text.length
        return text.length
    },
    LEN_HELP:
        `LEN( {{field}} )
        The length of a TEXT field, or the number of elements in a MULTI-VALUE field`,

    /**
     * Returns the left part of a string
     * 
     * @param {string} text
     * @param {number} n
     * @returns {text}
     * 
     * @example
     * LEFT("San Francisco", 3) // San
     */         
    LEFT: (text, n) => (n > 0) ? text.slice(0, n) : "",
    LEFT_HELP:
        `LEFT( {{field}}, 3)
        The left part of a TEXT field`,

    /**
     * Returns the right part of a string
     * 
     * @param {string} text
     * @param {number} n
     * @returns {text}
     * 
     * @example
     * RIGHT("San Francisco", 9) // Francisco
     */        
    RIGHT: (text, n) => (n > 0) ? text.slice(-n) : "",
    RIGHT_HELP:
        `RIGHT( {{field}}, 3)
        The right part of a TEXT field`,

    /**
     * Returns the middle part of a string
     * 
     * @param {string} text
     * @param {number} n
     * @returns {text}
     * 
     * @example
     * MIDDLE("San Francisco", 4, 8) // Fran
     */      
    MIDDLE: (text, from, to) => text.slice(from, to),
    MIDDLE_HELP:
        `MIDDLE( {{field}}, 4, 8)
        The middle part of a TEXT field`,

    /**
     * Returns the left part of a string, given a separator
     * 
     * @param {string} text
     * @param {string} separator
     * @returns {text}
     * 
     * @example
     * STRLEFT("San Francisco", " ") // San
     */
    STRLEFT: (text, separator) => text.split(separator)[0],
    STRLEFT_HELP:
        `STRLEFT( {{field}}, "@")
        The part of a TEXT field at the left of a given string`,

    /**
     * Returns the right part of a string, given a separator
     * 
     * @param {string} text
     * @param {string} separator
     * @returns {text}
     * 
     * @example
     * STRRIGHT("San Francisco", " ") // Francisco
     */       
    STRRIGHT: (text, separator) => text.split(separator).pop(),
    STRRIGHT_HELP:
        `STRRIGHT( {{field}}, "@")
        The part of a TEXT field at the right of a given string`,

    /**
     * Convert a string to uppercase
     * 
     * @param {string} text
     * @returns {text}
     * 
     * @example
     * UPPERCASE("San Francisco") // SAN FRANCISCO
     */    
    UPPERCASE: (text) => text.toUpperCase(),
    UPPERCASE_HELP:
        `UPPERCASE( {{field}})
        Returns a TEXT field in uppercase`,

    /**
     * Convert a string to lowercase
     * 
     * @param {string} text
     * @returns {text}
     * 
     * @example
     * LOWERCASE("San Francisco") // san francisco
     */     
    LOWERCASE: (text) => text.toLowerCase(),
    LOWERCASE_HELP:
        `LOWERCASE( {{field}} )
        Returns a TEXT field in lowercase`,

    /**
     * Convert a string to titlecase
     * 
     * @param {string} text
     * @returns {text}
     * 
     * @example
     * TITLECASE("paris") // Paris
     */      
    TITLECASE: (text) => text.toTitleCase(),
    TITLECASE_HELP:
        `TITLECASE( {{field}} )
        Returns a TEXT field in titlecase`,

    /**
     * Replace a string inside another string
     * 
     * @param {string} text
     * @param {string} oldText
     * @param {string} newText
     * @returns {text}
     * 
     * @example
     * REPLACE("New York is great", "New York", "Paris") // Paris is great
     */    
    REPLACE: (text, oldText, newText) => text.replaceAll(oldText, newText),
    REPLACE_HELP:
        `REPLACE( {{field}}, "New York", "Paris")
        Replaces one string with another inside a TEXT field`,

    /**
     * Generates a slug from a plain title
     * 
     * @param {string} title 
     * @returns {string} The generated slug
     * 
     * @example
     * SLUG("My article about dogs") // Returns "my-article-about-dogs"
     */
    SLUG: (text) => kiss.tools.generateSlug(text),
    SLUG_HELP:
        `SLUG( {{field}} )
        Transforms a TEXT field into a slug. Ex: "my-article-about-this"`,

    /**
     * Concatenate any number of strings
     * 
     * @param  {...any} strings 
     * @returns {string}
     * 
     * @example
     * CONCATENATE("Bob", " ", "Wilson") // "Bob Wilson"
     */
    CONCATENATE: (...strings) => strings.filter(string => string).join(""),
    CONCATENATE_HELP:
        `CONCATENATE( {{field1}}, " - ", {{field2}} )
        Concatenate multiple TEXT fields or texts together`,

    /**
     * Check if a string contains a value
     * 
     * @param {string} string 
     * @param {string} value 
     * @returns {boolean}
     * 
     * @example
     * CONTAINS("San Francisco", "San") // true
     * CONTAINS("Paris", "San") // false
     */
    CONTAINS: (string, value) => string.includes(value),
    CONTAINS_HELP:
        `CONTAINS( {{field}}, "San")
        Returns true if a TEXT field contains the given string`,

    /**
     * Removes whitespace at the beginning and end of a string
     * 
     * @param {string} string 
     * @returns {boolean}
     * 
     * @example
     * TRIM("  Hello   !  ") // "Hello !"
     */
    TRIM: (string) => string.trim(),
    TRIM_HELP:
        `TRIM( {{field}} )
        Returns "Hello !" if a TEXT field contains "  Hello   !  "`,

    //--------------------
    //
    // WORKING WITH NUMBERS
    //
    //--------------------

    /**
     * MIN
     * @param  {...any} numbers 
     * @returns {number}
     * 
     * @example
     * MIN(42, 666, 1515, 7) // 7
     */
    MIN: (...numbers) => {
        // console.log("MIN PARAMS: ", numbers)
        return Math.min(...numbers)
    },
    MIN_HELP:
        `MIN( {{field1}}, {{field2}}, ... )
        The min value of multiple NUMBER fields`,

    /**
     * MAX
     * 
     * @param  {...any} numbers 
     * @returns {number}
     * 
     * @example
     * MAX(42, 666, 1515, 7) // 1515
     */
    MAX: (...numbers) => Math.max(...numbers),
    MAX_HELP:
        `MAX( {{field1}}, {{field2}}, ... )
        The max value of multiple NUMBER fields`,

    /**
     * AVERAGE
     * 
     * @param  {...any} numbers 
     * @returns {number}
     * 
     * @example
     * AVERAGE(10, 20, 30) // 20
     */
    AVERAGE: (...numbers) => kiss.formula.SUM(...numbers) / numbers.length,
    AVERAGE_HELP:
        `AVERAGE( {{field1}}, {{field2}}, ... )
        The average value of multiple NUMBER fields`,

    /**
     * ROUND
     * 
     * @param {number} number 
     * @param {number} precision 
     * @returns {number}
     * 
     * @example
     * ROUND(12.367891, 3) // 12.378
     */
    ROUND: (number, precision) => number.round(precision),
    ROUND_HELP:
        `ROUND( {{field}}, 3)
        The rounded value of a NUMBER field`,

    /**
     * Returns the absolute value of a number
     * 
     * @param {number} number
     * @returns {number}
     * 
     * @example
     * ABS(-42) // 42
     */
    ABS: (number) => Math.abs(number),
    ABS_HELP:
        `ABS( {{field}} )
        The absolute value of a NUMBER field`,

    /**
     * Returns the nearest integer multiple of significance that is greater than or equal to the value.
     * If no significance is provided, a significance of 1 is assumed.
     * 
     * @param {number} number
     * @param {number} [significance]
     * @returns {number}
     * 
     * @example
     * CEILING(1.01, 0.1) // 1.1
     * CEILING(1.01) // 2
     */
    CEILING: (number, significance = 1) => Math.ceil(number / significance) * significance,
    CEILING_HELP:
        `CEILING( {{field}}, 0.1)
        The nearest integer multiple of significance that is greater than or equal to the value`,

    /**
     * Returns the nearest integer multiple of significance that is less than or equal to the value.
     * If no significance is provided, a significance of 1 is assumed.
     * 
     * @param {number} number 
     * @param {number} [significance]
     * @returns {number}
     * 
     * @example
     * FLOOR(1.01, 0.1) // 1
     * FLOOR(1.01) // 1
     */
    FLOOR: (number, significance = 1) => Math.floor(number / significance) * significance,
    FLOOR_HELP:
        `FLOOR( {{field}}, 0.1)
        The nearest integer multiple of significance that is less than or equal to the value`,

    /**
     * Returns the square root of a number
     * 
     * @param {number} number 
     * @returns {number}
     * 
     * @example
     * SQRT(16) // 4
     */
    SQRT: (number) => Math.sqrt(number),
    SQRT_HELP:
        `SQRT( {{field}} )
        The square root of a NUMBER field`,

    /**
     * POW
     * 
     * @param  {number} number
     * @param  {number} power
     * @returns {number}
     * 
     * @example
     * POW(4, 2) // 16
     */
    POWER: (number, power) => Math.pow(number ?? 0, power ?? 1),
    POWER_HELP:
        `POW( {{field}}, 2)
        Raise a NUMBER field to the specified power`,

    /**
     * Computes the logarithm of the value in provided base. The base defaults to 10 if not specified.
     * 
     * @param {number} number
     * @param {number} [base]
     * @returns {number}
     * 
     * @example
     * LOG(1024, 2) // 10
     * LOG(1000) // 3
     */
    LOG: (number, base = 10) => Math.log(number) / Math.log(base),
    LOG_HELP:
        `LOG( {{field}}, 2)
        The logarithm of a NUMBER field in the specified base`,

    /**
     * Returns the modulus operation.
     * 
     * @param {number} number
     * @param {number} divisor
     * @returns {number}
     * 
     * @example
     * MOD(10, 3) // 1
     * MOD(10, 5) // 0
     * MOD(10, 7) // 3
     */
    MOD: (number, divisor) => number % divisor,
    MOD_HELP:
        `MOD( {{field}}, 2)
        The modulus operation of a NUMBER field`,

    /**
     * PI
     * 
     * @returns {number}
     * 
     * @example
     * PI() // 3.1415927...
     */    
    PI: () => Math.PI,
    PI_HELP:
        `PI()
        PI number: 3.1415927...`,

    /**
     * Returns the COSINUS of a number
     * 
     * @param {number} number 
     * @returns {number}
     * 
     * @example
     * COS(2 * PI()) // 1
     */    
    COS: (number) => Math.cos(number),
    COS_HELP:
        `COS( {{field}} )
        The cosinus of a NUMBER field`,

    /**
     * Returns the SINUS of a number
     * 
     * @param {number} number 
     * @returns {number}
     * 
     * @example
     * SIN(PI() / 2) // 1
     */      
    SIN: (number) => Math.sin(number),
    SIN_HELP:
        `SIN( {{field}} )
        The sinus of a NUMBER field`,

    /**
     * Returns the TANGENT of a number
     * 
     * @param {number} number 
     * @returns {number}
     * 
     * @example
     * TAN(PI() / 4) // 1
     */    
    TAN: (number) => Math.tan(number),
    TAN_HELP:
        `TAN( {{field}} )
        The tangent of a NUMBER field`,

    //--------------------
    //
    // WORKING WITH DATES
    //
    //--------------------

    /**
     * Get the YEAR of an ISO date
     * 
     * @param {string} strDateISO 
     * @returns {string}
     * 
     * @example
     * YEAR("2022-12-24") // "2022"
     */
    YEAR: (strDateISO) => strDateISO.substring(0, 4),
    YEAR_HELP:
        `YEAR( {{field}} )
        The year of a DATE field`,

    /**
     * Get the MONTH of an ISO date
     * 
     * @param {string} strDateISO 
     * @returns {string}
     * 
     * @example
     * MONTH("2022-12-24") // "12"
     */    
    MONTH: (strDateISO) => strDateISO.substring(5, 7),
    MONTH_HELP:
        `MONTH( {{field}} )
        The month of a DATE field`,

    /**
     * Get the WEEK number of an ISO date.
     * Follow the ISO-8601 standard, where the first week of the year is the one that contains the first Thursday.
     * 
     * @param {string} strDateISO
     * @returns {number}
     * 
     * @example
     * WEEK("2022-12-24") // "51"
     * WEEK("2022-01-04") // "1"
     */
    WEEK: (strDateISO) => new Date(strDateISO).getWeek(),
    WEEK_HELP:
        `WEEK( {{field}} )
        The week number of a DATE field (according to ISO-8601)`,

    /**
     * Get the DAY of an ISO date
     * 
     * @param {string} strDateISO 
     * @returns {string}
     * 
     * @example
     * DAY("2022-12-24") // "24"
     */    
    DAY: (strDateISO) => strDateISO.substring(8, 10),
    DAY_HELP:
        `DAY( {{field}} )
        The day of a DATE field`,

    /**
     * Get the YEAR and MONTH of an ISO date
     * 
     * @param {string} strDateISO 
     * @returns {string} The year
     * 
     * @example
     * YEAR_MONTH("2022-12-24") // "2022-12"
     */    
    YEAR_MONTH: (strDateISO) => strDateISO.substring(0, 7),
    YEAR_MONTH_HELP:
        `YEAR_MONTH( {{field}} )
        The year and month of a DATE field, like "2020-07"`,

    /**
     * Compute the time difference between 2 dates
     * 
     * @param {string} fromISODate - As an ISO date string like "2023-02-14T15:44:05.886Z" or "2023-02-14"
     * @param {string} toISODate - As an ISO date string like "2023-02-14T15:44:05.886Z" or "2023-02-14"
     * @param {string} unit - "d" for days, "h" for hours... "mn", "s", "ms"
     * @returns {integer} Time diffence in the required unit of time
     * 
     * @example
     * TIME_DIFFERENCE("2023-02-14T15:44:05.886Z", "2023-02-14T18:44:26.316Z", "h") // 3
     * TIME_DIFFERENCE("2023-02-10", "2023-02-20", "d") // 10
     */
    TIME_DIFFERENCE: (fromISODate, toISODate, unit = "d") => {
        try {
            const fromDate = new Date(fromISODate)
            const toDate = new Date(toISODate)

            let coef
            switch(unit) {
                case "d":
                    coef = 1000 * 60 * 60 * 24
                    break
                case "h":
                    coef = 1000 * 60 * 60
                    break
                case "mn":
                    coef = 1000 * 60
                    break
                case "s":
                    coef = 1000
                case "ms":
                    coef = 1
            }
            return Math.round((toDate.getTime() - fromDate.getTime()) / coef)
        } catch (err) {
            return 0
        }
    },
    TIME_DIFFERENCE_HELP:
        `TIME_DIFFERENCE( {{field1}}, {{field2}}, "h")
        The time difference between 2 DATE fields, using the given unit (d, h, mn, s, or ms)`,

    /**
     * Compute the number of days between 2 dates
     * 
     * @param {string} fromISODate - As an ISO date string like "2023-02-14T15:44:05.886Z" or "2023-02-14"
     * @param {string} toISODate - As an ISO date string like "2023-02-14T15:44:05.886Z" or "2023-02-14" 
     * @returns {integer} Number of days
     * 
     * @example
     * DAYS_DIFFERENCE("2023-01-01T15:44:05.886Z", "2023-01-15T18:44:26.316Z") // 14
     * DAYS_DIFFERENCE("2023-01-01", "2023-01-10") // 9
     */
    DAYS_DIFFERENCE: (fromISODate, toISODate) => {
        return kiss.formula.TIME_DIFFERENCE(fromISODate, toISODate, "d")
    },
    DAYS_DIFFERENCE_HELP:
        `DAYS_DIFFERENCE( {{field1}}, {{field2}} )
        The number of days between 2 DATE fields`,

    /**
     * Compute the number of hours between 2 dates
     * 
     * @param {string} fromISODate 
     * @param {string} toISODate 
     * @returns {integer} Number of hours
     * 
     * @example
     * HOURS_DIFFERENCE("2023-01-01T15:00:00.000Z", "2023-01-02T16:00:00.000Z") // 25
     */
    HOURS_DIFFERENCE: (fromISODate, toISODate) => {
        return kiss.formula.TIME_DIFFERENCE(fromISODate, toISODate, "h")
    },
    HOURS_DIFFERENCE_HELP:
        `HOURS_DIFFERENCE( {{field1}}, {{field2}} )
        The number of hours between 2 DATE fields`,

    /**
     * Adjust a date to a new date, passing the number of years, months, days, hours, minutes and seconds to add or subtract.
     * If the hours, minutes and seconds are not specified, they are set to 0.
     * 
     * @param {date|string} date - Date or ISO date string like "2023-12-01"
     * @param {number} [years]
     * @param {number} [months]
     * @param {number} [days]
     * @param {number} [hours]
     * @param {number} [minutes]
     * @param {number} [seconds]
     * @param {string} [format] - "ISO" to return an ISO date string (default). Anything else to return a standard date object.
     * @returns {string} The adjusted date, as an ISO string like "2023-01-01"
     * 
     * @example
     * ADJUST_DATE("2023-01-01", 0, 1, 0) // "2023-02-01"
     * ADJUST_DATE("2023-01-01", 0, 0, 0, 48, 0, 0) // "2023-01-03"
     */
    ADJUST_DATE(date, years=0, months=0, days=0, hours=0, minutes=0, seconds=0, format = "ISO") {
        // Create a new date object by cloning the original date
        let newDate = (date) ? new Date(date) : new Date()
            
        // Add or subtract seconds, minutes, hours first using UTC methods
        newDate.setUTCSeconds(newDate.getUTCSeconds() + seconds)
        newDate.setUTCMinutes(newDate.getUTCMinutes() + minutes)
        newDate.setUTCHours(newDate.getUTCHours() + hours)
        
        // Then adjust days, months, years using UTC methods
        newDate.setUTCDate(newDate.getUTCDate() + days)
        newDate.setUTCMonth(newDate.getUTCMonth() + months)
        newDate.setUTCFullYear(newDate.getUTCFullYear() + years)
        
        // Return the adjusted date
        if (format == "ISO") return newDate.toISO()
        return newDate
    },
    ADJUST_DATE_HELP:
        `ADJUST_DATE( {{field}}, 0, 1, 0, 0, 0, 0)
        Adjust a DATE field by the number of given years, months, days, hours, minutes and seconds, and output the result like "2023-01-01"`,

    /**
     * Adjust a date to a new date and time, passing the number of years, months, days, hours, minutes and seconds to add or subtract.
     * If the hours, minutes and seconds are not specified, they are set to 0.
     * 
     * @param {date|string} date - Date or ISO date string like "2023-12-01"
     * @param {number} [years]
     * @param {number} [months]
     * @param {number} [days]
     * @param {number} [hours]
     * @param {number} [minutes]
     * @param {number} [seconds]
     * @param {string} [format] - "string" (default) or "date" to return a date object
     * @returns {string|date} The adjusted date and time, as an ISO string like "2023-01-01 12:34:56" or a date object
     * 
     * @example
     * ADJUST_DATE_AND_TIME("2023-01-01", 0, 1, 0) // "2023-02-01 00:00:00"
     * ADJUST_DATE_AND_TIME("2023-01-01", 0, 1, 0, 3, 0, 0) // "2023-02-01 03:00:00"
     * ADJUST_DATE_AND_TIME("2023-01-01 03:45:00", 0, 1, 0, 3, 0, 0) // "2023-02-01 06:45:00"
     * ADJUST_DATE_AND_TIME(new Date(), 0, 1, 0, 3, 0, 0) // "2023-01-01 06:45:00"
     */
    ADJUST_DATE_AND_TIME(date, years=0, months=0, days=0, hours=0, minutes=0, seconds=0, format = "ISO") {
        // Create a new date object by cloning the original date
        let newDate = (date) ? new Date(date) : new Date()
        
        // Add or subtract the specified number of years, months, and days
        newDate.setFullYear(newDate.getFullYear() + years)
        newDate.setMonth(newDate.getMonth() + months)
        newDate.setDate(newDate.getDate() + days)
        newDate.setHours(newDate.getHours() + hours)
        newDate.setMinutes(newDate.getMinutes() + minutes)
        newDate.setSeconds(newDate.getSeconds() + seconds)
        
        // Return the adjusted date and time
        if (format == "ISO") return newDate.toISODateTime()
        return newDate
    },
    ADJUST_DATE_AND_TIME_HELP:
        `ADJUST_DATE_AND_TIME( {{field}}, 0, 0, 1, 12, 30, 0)
        Adjust a DATE field by the number of given years, months, days, hours, minutes and seconds, and output the result like "2023-01-01 12:30:00"`,

    /**
     * Convert a date to a formatted string
     * 
     * @param {date|string} date - Date or ISO date string like "2023-12-01"
     * @param {string} format - Ex: "yyyy-mm-dd", "yyyy-mm-dd hh:MM:ss", "yyyy-mm-dd hh:MM", "yy-mm-dd hh:MM"
     * @returns {string}
     * 
     * @example
     * FORMAT_DATE(new Date(), "yyyy-mm-dd") // "2023-01-01"
     * FORMAT_DATE(new Date(), "yyyy-mm-dd hh:MM:ss") // "2023-01-01 00:00:00"
     * FORMAT_DATE("2023-12-31", "yy-mm-dd") // "23-12-31"
     */
    FORMAT_DATE: (date, format) => {
        try {
            if (!date) return ""
            if (typeof date == "string") date = new Date(date)

            const pad = (n) => n < 10 ? "0" + n : n

            let year = date.getFullYear()
            let month = pad(date.getMonth() + 1)
            let day = pad(date.getDate())
            let hour = pad(date.getHours())
            let minute = pad(date.getMinutes())
            let second = pad(date.getSeconds())
        
            return format.replace(/yyyy/g, year)
                .replace(/yy/g, year.toString().substring(2, 4))
                .replace(/mm/g, month)
                .replace(/dd/g, day)
                .replace(/hh/g, hour)
                .replace(/MM/g, minute)
                .replace(/ss/g, second)
        } catch (err) {
            return ""
        }
    },
    FORMAT_DATE_HELP:
        `FORMAT_DATE( DATE, "yyyy-mm-dd"), or FORMAT_DATE( DATE, "yyyy-mm-dd hh:MM")
        Convert a date to a formatted string. Usefull to display dates in a specific format, or to set another date field using ISO, like "2023-01-01"`,

    //--------------------
    //
    // WORKING WITH MULTI-VALUE FIELDS
    //
    //--------------------

    /**
     * SUM
     * 
     * @param  {...any} numbers 
     * @returns {number}
     * 
     * @example
     * SUM(1, 2, 3) // 6
     */
    SUM: (...numbers) => numbers.reduce((a, b) => Number(a||0) + Number(b||0), 0),
    SUM_HELP:
        `SUM( {{field1}}, {{field2}}, ... )
        The sum of multiple NUMBER fields`,

    /**
     * Returns the LENGTH of an array or a string
     * 
     * @param  {array|string} array
     * @returns {number}
     * 
     * @example
     * LENGTH([0, 1, 2, 3]) // 4
     * LENGTH("Satori") // 6
     */
    LENGTH: (array) => {
        if (!array) return 0
        if (!Array.isArray(array)) {
            if (typeof array == "string") return array.length
            else return 0
        }
        return array.length
    },
    LENGTH_HELP:
        `LENGTH( {{field}} )
        The length of a TEXT, or the number of elements in a MULTI-VALUE field`,

    /**
     * Returns the NTH element of an array or a string
     * 
     * @param  {array|string} array
     * @param  {number} index
     * @returns {*}
     * 
     * @example
     * NTH(["low", "medium", "high"], 1) // "medium"
     */
    NTH: (array, index) => {
        if (!array) return ""
        if (Array.isArray(array) || typeof array == "string") return array[index]
        return ""
    },
    NTH_HELP:
        `NTH( {{field}} )
        The nth element of a MULTI-VALUE field`,

    /**
     * Join an array of strings into a single string, given a separator
     * 
     * @param {string[]} array
     * @param {string} separator
     * @returns {string} The resulting string
     * 
     * @example
     * JOIN(["Paris", "San Diego", "Ajaccio"], " & ") // "Paris & San Diego & Ajaccio"
     */
    JOIN: (array, separator) => array.join(separator),
    JOIN_HELP:
        `JOIN( {{field}}, " & ")
        Transform a MULTI-VALUE field into a text with separators`,

    /**
     * Converts a list of values into an array, to feed MULTI-VALUE fields.
     * 
     * @param {*} values
     * @returns {string[]|number[]|date[]} The resulting array
     * 
     * @example
     * ARRAY( "a", "b", "c" ) // [ "a", "b", "c" ]
     */
    ARRAY: (...values) => values,
    ARRAY_HELP:
        `ARRAY( "a", "b", "c" )
        Transform a list of values into an array, to feed MULTI-VALUE fields`,

    /**
     * Get the nth element of an array
     * 
     * @param {array} array
     * @param {number} index
     * @returns {*} The nth element, or false if the index is out of range or the array is not an array
     * 
     * @example
     * ELEMENT( ARRAY( "a", "b", "c" ), 1 ) // "b"
     * ELEMENT( ARRAY( "a", "b", "c" ), 5 ) // false
     * ELEMENT( "a", 1 ) // false
     */        
    ELEMENT: (array, index) => {
        if (Array.isArray(array) == false) return false
        if (index < 0 || index >= array.length) return false
        return array[index]
    },
    ELEMENT_HELP:
        `ELEMENT( ARRAY( "a", "b", "c" ), 1 )
        Get the nth element of an array, or false if not found. Index starts at zero`,

    /**
     * Get the index of an item in an array
     * 
     * @param {array} array
     * @param {*} item
     * @returns {number} The index of the item in the array. Returns -1 if not found.
     * 
     * @example
     * INDEX_OF( ARRAY( "a", "b", "c" ), "c" ) // 2
     */        
    INDEX_OF: (array, item) => array.indexOf(item),
    INDEX_OF_HELP:
        `INDEX_OF( ARRAY( "a", "b", "c" ), "c" )
        Get the index of an item in an array. Returns -1 if not found`,
    
    //--------------------
    //
    // TESTING FIELD VALUE
    //
    //--------------------

    /**
     * Check if a field value is empty
     * 
     * @param  {*} value
     * @returns {boolean}
     * 
     * @example
     * IS_EMPTY([0, 1, 2, 3]) // false
     * IS_EMPTY([]) // true
     * IS_EMPTY("abc") // false
     * IS_EMPTY("") // true
     * IS_EMPTY(123) // false
     * IS_EMPTY(0) // false
     */
    IS_EMPTY: (value) => {
        if (value === 0) return false
        if (typeof value === "string" && value.trim() === "") return true
        if (!value) return true
        if (Array.isArray(value) && value.length == 0) return true
        return false
    },
    IS_EMPTY_HELP:
        `IS_EMPTY( {{field}} )
        Returns true if the field is empty`,

    /**
     * Check if a field value is not empty
     * 
     * @param  {*} value
     * @returns {boolean}
     * 
     * @example
     * IS_NOT_EMPTY([0, 1, 2, 3]) // true
     * IS_NOT_EMPTY([]) // false
     * IS_NOT_EMPTY("abc") // true
     * IS_NOT_EMPTY("") // false
     * IS_NOT_EMPTY(123) // true
     * IS_NOT_EMPTY(0) // true
     */
    IS_NOT_EMPTY: (value) => {
        return !kiss.formula.IS_EMPTY(value)
    },
    IS_NOT_EMPTY_HELP:
        `IS_NOT_EMPTY( {{field}} )
        Returns true if the field is not empty`,

    /**
     * Check if a value is empty, and returns a default value if it is.
     * An empty value can be an empty string, an empty array, an empty object, or a falsy value.
     * 
     * @param  {*} value - The value to check
     * @param  {*} valueIfEmpty - The default value to return if the value is empty
     * @returns {*} The value or the default value
     * 
     * @example
     * IF_EMPTY_USE("", "No value") // "No value"
     * IF_EMPTY_USE("Paris", "No value") // "Paris"
     * IF_EMPTY_USE([], "No value") // "No value"
     * IF_EMPTY_USE([1, 2, 3], "No value") // [1, 2, 3]
     * IF_EMPTY_USE(0, "No value") // 0
     * IF_EMPTY_USE({ name: "Paris" }, "No value") // { name: "Paris" }
     * IF_EMPTY_USE({}, "No value") // "No value"
     */
    IF_EMPTY_USE: (value, valueIfEmpty) => {
        if (Array.isArray(value)) {
            return value.length > 0 ? value : valueIfEmpty
        }
        
        if (value && typeof value === "object") {
            return Object.keys(value).length > 0 ? value : valueIfEmpty
        }
        
        return Boolean(value) ? value : valueIfEmpty
    },
    IF_EMPTY_USE_HELP:
        `IF_EMPTY_USE( {{field}}, valueIfEmpty )
        Returns the field value if the field is not empty, or the valueIfEmpty if the field is empty`,

    /**
     * Test a set of conditions, and returns the value of the first expression that matches the test.
     * If no condition matches, returns the value of the last (default) expression.
     * Always has an odd number of parameters:
     * 
     * ```
     *  IF(<condition 1>, <expression 1>, ..., ..., <condition N>, <expression N>, <expression Else>)
     * ```
     * 
     * @param  {...any} params 
     * @returns {any} Value of the first expression that matches the condition, or the last expression if none matches, or false if the syntax is incorrect
     * 
     * @example
     * // Returns "Good" if the field "amount" = 65, or "Poor" if the field "amount" = 20
     * IF({{amount}} > 80, "Great", {{amount}} > 60, "Good", {{amount}} > 40, "Not bad", "Poor")
     */
    IF: (...params) => {
        // console.log("IF PARAMS: ", params)
        try {
            if (params.length < 3 || params.length % 2 == 0) return false
            for (let i = 0; i <= params.length - 2; i = i + 2) {
                if (params[i] == true) return params[i + 1]
            }
            return params[params.length - 1]
        } catch (err) {
            // log(err)
            return false
        }
    },
    IF_HELP:
        `IF( {{field}} == 100, "Good", {{field}} > 50, "OK", "Poor" )
        Returns the value where the test is true, or defaults to the last value`,
    
    //--------------------
    //
    // TESTING WORKFLOW STATE
    //
    //--------------------

    /**
     * Check the current workflow step
     * 
     * IMPORTANT: only valid on the client, for "hideWhen" formulae
     * 
     * @param {string} stepName
     * @returns {boolean} true if the given step name is the current step
     */
    IS_WORKFLOW_STEP: (stepName) => {
        const stepId = kiss.context.record["workflow-stepId"]
        if (!stepId) return false
        const step = kiss.global.workflowSteps[stepId]
        if (!step) return false
        return step.name == stepName
    },
    IS_WORKFLOW_STEP_HELP:
        `IS_WORKFLOW_STEP("Analysis")
        Returns true if the given workflow step name is the active one. Useful to show/hide form fields or sections depending on the workflow step.`,
    
    /**
     * Check if a workflow has started
     * 
     * IMPORTANT: only valid on the client, for "hideWhen" formulae
     * 
     * @param {string} stepName
     * @returns {boolean} true if the given step name is the current step
     */
    IS_WORKFLOW_STARTED: () => {
        const stepId = kiss.context.record["workflow-stepId"]
        return !!stepId
    },
    IS_WORKFLOW_STARTED_HELP:
        `IS_WORKFLOW_STARTED()
        Returns true if a workflow has started. Useful to show/hide form fields or sections depending on the workflow status.`,
    
    //--------------------
    //
    // MISC TOOLS
    //
    //--------------------

    /**
     * Generates a unique id
     * 
     * @returns {string}
     * 
     * @example
     * UID() // "01844399-988f-7974-a68f-92d35fc702cc"
     */    
    UID: () => kiss.tools.uid(),
    UID_HELP:
        `UID()
        A unique ID like "01844399-988f-7974-a68f-92d35fc702cc"`,

    /**
     * Generates a short id
     * 
     * @returns {string}
     * 
     * @example
     * SHORT_ID() // "A84F007X"
     */    
    SHORT_ID: () => kiss.tools.shortUid().toUpperCase(),
    SHORT_ID_HELP:
        `SHORT_ID()
        A short ID like "A84F007X"`,
        
    /**
     * List of formulae which are not available for the user
     * 
     * @ignore
     */
    system: [
        "system",
        "hideWhen",
        "execute",
        "_parser",
        "COUNT",
        "COUNT_EMPTY",
        "COUNT_NON_EMPTY",
        "LIST",
        "LIST_NAMES",
        "SPLIT",
        "TODAY",
        "TIME",
        "NOW"
    ],

    /**
     * List of formulae which are only valid for "hideWhen" context
     * 
     * @ignore
     */
    hideWhen: [
        "IS_WORKFLOW_STEP",
        "IS_WORKFLOW_STARTED"
    ],

    /**
     * COUNT the number of items passed as parameters
     * 
     * @param  {...any} items
     * @returns {number}
     * 
     * @example
     * COUNT(1, "B", "C", 7) // 4
     */
    COUNT: (...items) => {
        return items.length
    },

    /**
     * COUNT the number of empty items passed as parameters
     * 
     * @param  {...any} items
     * @returns {number}
     * 
     * @example
     * COUNT_EMPTY(1, "B", "C", 7, "", []) // 2
     */
    COUNT_EMPTY: (...items) => {
        const empty = items.filter(item => {
            return (item === undefined) || (item === "") || (Array.isArray(item) && item.length == 0)
        })
        return empty.length
    },
    
    /**
     * COUNT the number of non-empty items passed as parameters
     * 
     * @param  {...any} items
     * @returns {number}
     * 
     * @example
     * COUNT_NON_EMPTY(1, "B", "C", 7, "", []) // 4
     */
    COUNT_NON_EMPTY: (...items) => {
        const nonEmpty = items.filter(item => {
            return (item !== undefined) && (item !== "") || (Array.isArray(item) && item.length != 0)
        })
        return nonEmpty.length
    },

    /**
     * Concatenate any number of strings as a comma separated text
     * 
     * @param  {...any} strings 
     * @returns {string}
     * 
     * @example
     * LIST("A", "B", "C") // "A, B, C"
     */    
    LIST: (...strings) => strings.filter(string => string !== undefined && string != "").unique().join(", "),

    /**
     * Merge a list of names into an array of names
     * 
     * @param  {...string} names
     * @returns {string[]}
     * 
     * @example
     * LIST_NAMES("John", "Bob", "Steve") // ["John, Bob, Steve"]
     */    
    LIST_NAMES: (...names) => {
        return names.filter(name => name !== undefined && name != "").flat().unique()
    },

    /**
     * Split a string into an array of strings, given a separator
     * 
     * @param {string} text 
     * @param {string} separator
     * @returns {string[]} The resulting array of strings
     * 
     * @example
     * SPLIT("Paris,San Diego,Ajaccio", ",") // ["Paris", "San Diego", "Ajaccio"]
     */
    SPLIT: (text, separator) => text.split(separator),

    /**
     * Get the current date as an ISO date string
     * 
     * @param {string} strDateISO 
     * @returns {string}
     * 
     * @example
     * TODAY() // "2022-12-24"
     */    
    TODAY: () => (new Date()).toISO(),

    /**
     * Get the current time as an ISO string (without time shift)
     * 
     * @returns {string}
     * 
     * @example
     * TIME() // "14:53:28"
     */    
    TIME: () => (new Date()).toISOString().substring(11,16),

    /**
     * Get the current date and time as a simple readable string (without time shift)
     * 
     * @returns {string}
     * 
     * @example
     * NOW() // "2022-12-24 14:53:28"
     */    
    NOW: () => (new Date()).toISOString().substring(0,19).replace("T", " "),

    /**
     * Execute a formula that is an arithmetic expression mixed or not with functions calls and return the result
     *
     * @param {string} formula - The formula to parse and execute
     * @param {Object} record - A record object. Each object property will be available in the formula with the following syntax: "{{property_name}}" if the corresponding entry is listed in fields.
     * @param {Array<{label: string, id: string}>} fields - A list of record properties sorted in a way such as {{index}} will be resolved as a record property.
     * @param {Object} field - The field being processed
     * @returns {*} - The formula result
     * 
     * @example
     * kiss.formula.execute("SUM(4, 6)") // returns 10
     * kiss.formula.execute("'Test: ' + (2 * SUM(3, 4))") // returns "Test: 14"
     * kiss.formula.execute("true && !false") // returns true
     * kiss.formula.execute("{{amount}} + {{vat}}") // returns 12 with record `{ amount: 10, vat: 2 }`
     */
    execute(formula, record, fields = undefined, field) {
        try {
            // if (field) console.log("kiss.formula - field:", field.label, "--------------------------------")
            // console.log("kiss.formula - execute:\n", formula)
            
            if (!this._parser) {
                // We must create the parser here (doing it in the upper scope, it would lose the reference to kiss.formula for somewhat reason)
                this._parser = new kiss.lib.formula.Parser({ availableFunctions: this })
            }
    
            const normalizedRecord = {}
            const propertiesList = fields.map(({ id, label }) => {
    
                // Field value can accessed either by its label or its id
                normalizedRecord[label] = record[id]
                normalizedRecord[id] = record[id]
    
                return label
            })
    
            return this._parser.parse(formula, normalizedRecord, propertiesList)
        }
        catch(err) {
            console.error("kiss.formula.execute - error: ", err)
            // return false
        }
    }
}

;// region Constants to make the parser more readable.
const CHAR_OPEN_PARENTHESIS = '('
const CHAR_CLOSING_PARENTHESIS = ')'
const CHAR_OPEN_CURLY_BRACKET = '{'
const CHAR_CLOSE_CURLY_BRACKET = '}'
const CHAR_NEWLINE = '\n'
const CHAR_CARRIAGE_RETURN = '\r'
const CHAR_TAB = '\t'
const CHAR_SPACE = ' '
const CHAR_BACKSLASH = '\\'
const CHAR_COMMA = ','
const CHAR_SINGLE_QUOTE = "'"
const CHAR_DOUBLE_QUOTE = '"'

const PARENTHESIS_TYPE = {
  CUSTOM_FUNCTION: 'customFunction',
  EXPRESSION: 'expression'
}
// endregion

// region Types

/**
 * @ignore
 * @callback isUnary
 * @param {string} symbol - The symbol to test
 * @returns {boolean} - True if the given symbol is a valid unary.postModifier operator in the current expression context.
 */

/**
 * @ignore
 * @callback isPreModifier
 * @param {string} symbol - The symbol to test
 * @returns {boolean} - True if the given symbol is a valid unary.preModifier operator in the current expression context.
 */

/**
 * @typedef CallStackStep
 * @description A CallStack step is an object that is modeling a function to call with its arguments.
 *      Since we're parsing a string expression, we want to be able to populate the current function with the arguments we find later
 *      (delimited by comas) and eventually we want to store the current expression and some results.
 *
 * @ignore
 * @property {Function} functionToCall - The function to execute.
 * @property {Array} arguments - Arguments passed to the function when invoked.
 * @property {boolean} [customFunction] - If the current stack element is an external function to call (functions plugged to the parser to add new features).
 * @property {number} [maxArguments] - Optional. Max arguments supported by the function.
 * @property {boolean} [postModifier] - Optional. True if the current step is a postModifier.
 * @property {boolean} [operand] - Optional. True if the current step is an operand.
 * @property {boolean} [expression] - Optional. True if the current step is an expression.
 * @property {Object} [operators] - Optional. If the step is an expression, contains helpers to transform expression arguments with unary operators.
 * @property {Function|null} [operators.unaryToApply = null] - If set to a function, the function to apply when the next expression operand will be found (used for unary.postModifier operators).
 * @property {isUnary} [operators.isUnary] - An helper to know if we will have to deal with a postModifier operator on the next expression operand given the current expression state.
 * @property {isPreModifier} [operators.isPreModifier] - AN helper to know if we have to apply a preModifier operator on the last operand of the current expression given its state.
 */

// endregion

/**
 * The purpose of this class is to be used to parse arithmetic and functional expressions that can be contextualized
 * with a record (so, given some variables, it is able to execute functions and computations).
 *
 * Note: this class is a continuous parser. Before returning its result, it will reset itself.
 * 
 * @ignore
 */
kiss.lib.formula.Parser = class Parser {

    /** @type {ParserOperators} */
    _operators

    /** @type {Object<string, Function>} */
    _functions

    /** @type {Array<CallStackStep>} **/
    _callStack

    /** @type {string} */
    _lastChar

    /** @type {string} */
    _currentChar

    /** @type {string} */
    _currentSymbol

    /** @type {string} */
    _currentPosition

    /** @type {string} */
    _currentOperator

    /** @type {Object} */
    _currentRecord

    /** @type {Array<string>} */
    _currentRecordPropertiesList

    /** @type {number} */
    _chainedBackslashes

    _openString = {
        singleQuote: false,
        doubleQuote: false
    }

    /** @type {number} */
    _openCurlyBracket = 0

    /** @type {Array<'customFunction' | 'expression'>} */
    _parenthesisStack = [];

    /** @type {any} */
    _finalResult

    /**
     * @param {Object} [opts = {}] - Parser options
     * @param {Object<string, Function>} [opts.availableFunctions = {}] - Available functions in formulas.
     * @param {ParserOperators} [opts.operators = {}] - Operators used by the parser to compute the result.
     */
    constructor(
        {
            availableFunctions = {},
            operators = null,
        } = {}
    ) {
        this._functions = availableFunctions ?? {}
        this._operators = operators || new kiss.lib.formula.ParserOperators()
        this._reset()
    }

    /**
     * Throw a parse error, printing the currentPosition in the formula to display a meaningful error message after a full parser reset.
     *
     * @param {string} message - Message to display
     * @private
     */
    _parseError(message) {
        const currentPosition = this._currentPosition
        this._reset()
        throw new Error(`Formula parsing error: ${currentPosition}<- ${message}`)
    }

    /**
     * Return the last element in the callStack
     *
     * @returns {CallStackStep}
     */
    _peekCallStack() {
        return this._callStack[this._callStack.length - 1]
    }

    /**
     * Parse a symbol to its real type.
     *
     * @param {string} symbol - THe symbol to parse
     * @returns {*}
     */
    _parseSymbol(symbol) {
        const record = this._currentRecord
        const propertiesList = this._currentRecordPropertiesList ?? Object.keys(record)

        // We start by the most straightforward tests first.
        switch(symbol.toLowerCase()) {
            case 'null':
                return null
            case 'true':
                return true
            case 'false':
                return false
            case 'undefined':
                return undefined
            case 'nan':
                return NaN
            case 'positive_infinity':
                return Number.POSITIVE_INFINITY
            case 'negative_infinity':
                return Number.NEGATIVE_INFINITY
        }

        // Then we check for tags
        if (symbol.startsWith('{{') && symbol.endsWith('}}')) {
            // We have a tag. A tag is reference to a record property.
            const tag = symbol.slice(2, -2)
            
            if (tag in record) {
                return record[tag]
            } else {
                const tagToInt = Number.parseInt(tag)

                if (!Number.isNaN(tagToInt) && propertiesList[tagToInt] in record) {
                    return record[propertiesList[tagToInt]]
                } else {
                    this._reset()
                    throw new Error(`Field '${tag}' not found in the provided record.`)
                }
            }
        }

        // Since strings are handled by the parser, and all other primitive types & tags have been handled, the only remaining type is Numbers.
        if(symbol.match(/\./)) {
            return Number.parseFloat(symbol)
        } else if(symbol.match(/,/)) {
            return Number.parseFloat(symbol.replaceAll(',', '.'))
        } else if(symbol.match(/[0-9.]+n$/)) {
            return BigInt(symbol.slice(0, -1))
        } else if(symbol.startsWith('\\x')) {
            return Number.parseInt(symbol.slice(2), 16)
        } else if(symbol.startsWith('\\b')) {
            return Number.parseInt(symbol.slice(2), 2)
        } else if(symbol.startsWith('\\o')) {
            return Number.parseInt(symbol.slice(2), 8)
        } return Number(symbol)
    }

    /**
     * Push a new value to the current stack:
     * - If the last element in the stack is an expression, add the value to the expression members (can be an operand or an operator)
     * - If the current step is a function, push the value to the function's arguments.
     * - Otherwise, add a new operand to the stack that will be used later as a function argument.
     *
     * @param {*} value - the value to push.
     */
    _pushValueToStack(value) {
        const lastStep = this._peekCallStack()

        if (lastStep && lastStep.expression) {
            if (typeof lastStep.operators.unaryToApply === 'function') {
                lastStep.arguments.push(lastStep.operators.unaryToApply(value))
                lastStep.operators.unaryToApply = null
            } else {
                lastStep.arguments.push(value)
            }
        } else if(lastStep && lastStep.maxArguments < lastStep.arguments.length && !lastStep.closed) {
            lastStep.arguments.push(value)
        } else {
            this._callStack.push({
                operand: true,
                functionToCall: this._operators.identity,
                maxArguments: 1,
                arguments: [value]
            })
        }
    }

    /**
     * If a currentSymbol have been collected in the current formula, we add it to the stack (after conversion by _parseSymbol)
     */
    _addCurrentSymbolToStack() {
        if (!this._currentSymbol) {
            return
        }

        this._pushValueToStack(this._parseSymbol(this._currentSymbol))
        this._currentSymbol = ''
    }

    /**
     * If a currentOperator have been collected in the current formula, we try to add it to the existing expression it belongs to.
     * If no expression is found, or if no currentOperator have been collected, will just silently fail.
     */
    _addCurrentOperatorToExpression() {
        if (!this._currentOperator) {
            return
        }

        const lastStep = this._peekCallStack()
        if (lastStep?.expression) {
            // We must apply unary operators before pushing them into the expression
            if (lastStep.operators.isPreModifier(this._currentOperator)) {
                const operator = this._operators.parseOperator(
                    'unary.preModifier',
                    this._currentOperator
                )

                // Since preModifiers applies to the previous operand, we can compute it now
                const lastOperand = lastStep.arguments.pop()

                lastStep.arguments.push(this._operators.unary.preModifier[operator](lastOperand))
                this._currentOperator = ''
                return
            } else if (lastStep.operators.isUnary(this._currentOperator)) {
                const operator = this._operators.parseOperator(
                    'unary.postModifier',
                    this._currentOperator
                )

                // Will be applied to the next operand
                lastStep.operators.unaryToApply = this._operators.unary.postModifier[operator]
                this._currentOperator = ''
                return
            }

            lastStep.arguments.push(
                this._operators.parseOperator(
                    'binary',
                    this._currentOperator
                )
            )

            this._currentOperator = ''
        }
    }

    /**
     * Execute the current expression by popping the stack if the last element on the callStack is an expression.
     *
     * @returns {boolean} - True if the stack have been popped.
     */
    _closeCurrentExpression() {
        const lastStep = this._peekCallStack()

        if (lastStep?.expression) {
            this._popStack()
            return true
        }
    }

    /**
     * Apply a postModifier (if any) at the end of the stack.
     */
    _applyPostModifier() {
        const lastStep = this._peekCallStack()

        if (lastStep?.postModifier) {
            this._popStack()
        }
    }

    /**
     * Pop the current stack until encountering a step to stop to. If, for example, the stack is:
     * function(no argument) - operand - operand - expression
     * 
     * After popStack you'll function(no argument) operand, operand, expressionResult
     *
     * Pop again and you'll get _finalResult = function(operand, operand, expressionResult)
     */
    _popStack() {
        /** @type {CallStackStep | undefined} */
        let step
        let argumentsToInject = []

        // No need to check maxArguments here, because it would have been spotted when an eventual comma would have been found.
        this._addCurrentSymbolToStack()

        // We remove all waiting operands.
        while ((step = this._callStack.pop())?.operand) {
            argumentsToInject.push(step.functionToCall(...step.arguments))
        }

        if (this._callStack.length === 0) {
            if (argumentsToInject.length === 1) {
                this._finalResult = argumentsToInject.pop()
                return
            } else if(step?.expression) {
                this._finalResult = step.functionToCall(...step.arguments)
                return
            }
        }

        if (!step) {
            return
        }

        const {
          functionToCall,
          arguments: functionArguments,
          closed,
          maxArguments,
        } = step

        const intermediateResult = functionToCall(
          ...functionArguments,
          ...(closed ? [] : argumentsToInject.reverse())
        )

        step = this._peekCallStack()

        if (this._callStack.length === 0) {
            this._finalResult = intermediateResult
        } else if(step) {
            if (step.expression) {
                this._pushValueToStack(intermediateResult)
            } else if (
              // Sorry :(
              // If the last function was an identity function without argument, and the current step is
              // a closed function, obviously, we have a problem: the value the identity function was waiting
              // for was not yet computed. So We ignore it when it happens.
              !(maxArguments === 1 && step.closed && functionArguments.length === 0)
            ) {
                this._callStack.push({
                    operand: true,
                    functionToCall: this._operators.identity,
                    maxArguments: 1,
                    arguments: [intermediateResult]
                })
            }
        } else {
            // Unmatching parenthesis number found.
            this._parseError('Unexpected closing parenthesis (have it been properly opened?)')
        }

        // Re-inject unused arguments
        if (closed) {
            this._callStack.push(...argumentsToInject.map(argument => ({
                operand: true,
                functionToCall: this._operators.identity,
                maxArguments: 1,
                arguments: [argument]
            })))
        }
    }

    /**
     * Loop over the callStack to find the first not-closed function (if any) to execute,
     * ignoring operands and expressions
     *
     * @returns {CallStackStep|null}
     */
    _getLastFunctionStep() {
        let i = this._callStack.length - 1

        while (
          this._callStack[i]?.operand
          || this._callStack[i]?.expression
        ) {
            i--
        }

        if (i < 0) {
            return null
        }

        return this._callStack[i]
    }

    _getLastCustomFunctionStep() {
        let i = this._callStack.length - 1

        while (!this._callStack[i]?.customFunction && i >= 0) {
          i--
        }

        if (i < 0) {
            return null
        }

        return this._callStack[i]
    }

    /**
     * Create an expression object used to represent an arithmetic expression to parse.
     *
     * @param {...*} startingExpressionMembers - Will be used as expression members at the beginning of the expression.
     * @returns {CallStackStep} - The expression.
     */
    _createExpression(...startingExpressionMembers) {
        const expression = {
            expression: true,
            functionToCall: this._operators.expression.bind(this._operators),
            arguments: startingExpressionMembers,
            operators: {
                unaryToApply: null,

                /** @type {isUnary} */
                isUnary: (symbol) => {
                    const lastElement = expression.arguments[expression.arguments.length - 1]

                    return this._operators.isAnOperatorString(symbol)
                        && (
                            expression.arguments.length === 0
                            || this._operators.isAnOperator(lastElement)
                        )
                },

                /** @type {isPreModifier} */
                isPreModifier: (symbol) => {
                    const lastExpressionMember = expression.arguments[expression.arguments.length -1]

                    return expression.arguments.length > 0
                        && symbol in this._operators.symbols.unary.preModifier
                        && !this._operators.isAnOperator(lastExpressionMember)
                }
            }
        }

        return expression
    }

    /**
     * Apply the current operator if any by adding it to the current expression
     *
     * @param {string|null} char - Optional. If provided, will try to find a valid operator by combining it with the currentOperator. If found, will add this character to the currentOperator.
     */
    _applyCurrentOperator(char = null) {
        if (!this._currentOperator) {
            return
        }

        if (char && this._operators.isAnOperatorCandidate(this._currentOperator + char)) {
            this._currentOperator += char
        }

        const lastStep = this._peekCallStack()
        if (!lastStep?.expression) {

            // If the previousStep is an identity function, add it to the current expression?
            if (lastStep?.operand) {
                this._callStack.splice(this._callStack.length - 1, 1)
                this._callStack.push(this._createExpression(...lastStep.arguments))
            } else {
                this._callStack.push(this._createExpression())
            }
        }

        this._addCurrentSymbolToStack()
        this._addCurrentOperatorToExpression()
    }

    _getAllOperandsUntilLastCustomFunction() {
        const operands = [];
        const lastFunction = this._getLastCustomFunctionStep();

        if (!lastFunction) {
            return operands;
        }

        for (let i = this._callStack.length - 1; i >= 0; i--) {
            const step = this._callStack[i];

            if (step.operand) {
                operands.push(step);
            } else break;
        }

        return operands;
    }

    _closeLastCustomFunction() {
        if (this._peekCallStack()?.expression) {
            return
        }

        if (this._parenthesisStack[this._parenthesisStack.length - 1] === PARENTHESIS_TYPE.EXPRESSION) {
            return
        }

        const lastFunction = this._getLastCustomFunctionStep();

        if (!lastFunction) {
            return
        }

        if (lastFunction.customFunction && !lastFunction.closed) {
            const operands = this._getAllOperandsUntilLastCustomFunction();
            lastFunction.arguments.push(...operands.map(operand => operand.functionToCall(...operand.arguments)));

            operands.forEach(() => this._callStack.pop());

            lastFunction.closed = true;

            this._popStack();
        }
    }

    /**
     * Parse and execute the formula, then return the result.
     *
     * @param {string} formula - An arithmetic formula. For supported operators and functions, see the constructor.
     * @param {Object | undefined} record - A record. Required if any {{token}} can be found in the formula
     * @param {Array<string> | undefined} propertiesList - A list of record properties sorted in a way such as {{index}} will be resolved as a record property.
     * @returns {*} - The result
     */
    _parse(formula, record, propertiesList) {
        formula = `(${formula})`

        this._currentRecord = record
        this._currentRecordPropertiesList = propertiesList

        for(const char of formula){
            this._currentChar = char
            this._currentPosition += char

            if (char !== CHAR_BACKSLASH) {
                if (this._lastChar === CHAR_BACKSLASH && this._chainedBackslashes %2 !== 0){
                    if (char === CHAR_DOUBLE_QUOTE || char === CHAR_SINGLE_QUOTE) {
                        this._currentSymbol += char
                        this._lastChar = char
                        this._chainedBackslashes = 0
                        continue
                    }
                }

                this._chainedBackslashes = 0
            }

            if ((this._openString.singleQuote || this._openString.doubleQuote) && char !== CHAR_BACKSLASH) {
                // Strings just swallows all chars (excepted backslashes) until closed.
                if (
                    (this._openString.singleQuote && char !== CHAR_SINGLE_QUOTE)
                    ||
                    (this._openString.doubleQuote && char !== CHAR_DOUBLE_QUOTE)
                ) {
                    this._currentSymbol += char
                    this._lastChar = char
                    continue
                }
            }

            if ((this._openCurlyBracket === 2) && char !== CHAR_CLOSE_CURLY_BRACKET) {
                this._currentSymbol += char
                this._lastChar = char
                continue
            } else if (this._openCurlyBracket === 1 && char !== CHAR_OPEN_CURLY_BRACKET && char !== CHAR_CLOSE_CURLY_BRACKET) {
                this._parseError(
                    'Invalid character here. An opened curly bracket must be immediately'
                    + ' followed by another one to get a valid tag !'
                )
            }

            switch(char){
                case CHAR_OPEN_PARENTHESIS:
                    this._applyCurrentOperator()

                    if (this._currentSymbol){
                        let funcName = this._currentSymbol.toUpperCase()

                        if (funcName in this._functions) {
                            this._callStack.push({
                                functionToCall: this._functions[funcName],
                                arguments: [],
                                customFunction: true,
                            })
                        } else {
                            this._parseError(`Unknown function ${funcName}`)
                        }

                        this._parenthesisStack.push(PARENTHESIS_TYPE.CUSTOM_FUNCTION)
                        this._currentSymbol = ''
                    } else {
                        // A parenthesis used for priority in computation is nothing else than
                        // a function that returns its only parameter (the result of the expression
                        // the parenthesis contains)

                        const lastStep = this._peekCallStack()
                        if (lastStep?.expression) {
                            const previousStep = this._callStack[this._callStack.length - 2]

                            // If the previousStep is an identity function, add it to the current expression?
                            if (previousStep && previousStep.maxArguments === 1) {
                                this._callStack.splice(this._callStack.length - 2, 1)
                                this._callStack.push(this._createExpression(...previousStep.arguments))
                            } else {
                                this._callStack.push(this._createExpression())
                            }
                        } else {
                            this._callStack.push({
                                maxArguments: 1,
                                functionToCall: this._operators.identity,
                                arguments: [],
                            })
                        }

                        this._parenthesisStack.push(PARENTHESIS_TYPE.EXPRESSION)
                    }

                    break

                case CHAR_CLOSING_PARENTHESIS:
                    this._applyPostModifier()
                    this._applyCurrentOperator()
                    this._addCurrentSymbolToStack()

                    if (!this._closeCurrentExpression()) { //TODO: error detection with + and - parenthesis.
                        this._popStack()
                    } else {
                        this._closeLastCustomFunction();
                    }

                    this._parenthesisStack.pop()

                    break

                case CHAR_COMMA:
                    this._applyPostModifier()

                    // We start by checking if a coma is allowed where we are.
                    // We determine that with the actual last element in the callstack, since it's
                    // this one that would receive the argument after the comma (or not)
                    const callStackStep = this._getLastFunctionStep()

                    if (
                        'maxArguments' in callStackStep
                        && callStackStep.arguments.length + 1 > callStackStep.maxArguments
                    ) {
                        this._parseError(`Expected ')' but found ','`)
                    }

                    this._applyCurrentOperator(null, true)
                    this._addCurrentSymbolToStack()
                    this._closeCurrentExpression()

                    // When we have to compute several arguments for a given function, we need to ensure the next
                    // created expression will not use the last operand on the stack. To do this consistently,
                    // we add the last operand to the last function arguments if the lastStep is an operand, and the lastFunction a custom function.
                    const lastStep = this._peekCallStack()
                    if (lastStep?.operand) {
                        const lastFunction = this._getLastFunctionStep();

                        if (lastFunction?.customFunction || lastFunction.maxArguments === 1) {
                            lastFunction.arguments.push(...lastStep.arguments);
                            this._callStack.pop();

                            // This one is tricky: sometimes we just computed a serie of expressions for a
                            // function argument. It must be then integrated to the last custom function argument
                            // list when it happens, or the identity function that is the last element on the stack
                            // will receive more than one argument.
                            const lastStackStep = this._peekCallStack();
                            const penultimateStackStep = this._callStack[this._callStack.length - 2];

                            if (lastStackStep.maxArguments === 1 && penultimateStackStep.customFunction) {
                                penultimateStackStep.arguments.push(lastFunction.arguments[0]);
                                this._callStack.pop();
                            }
                        }
                    }

                    break

                case CHAR_TAB:
                case CHAR_NEWLINE:
                case CHAR_CARRIAGE_RETURN:
                case CHAR_SPACE:
                    // white spaces have no computation meaning, but when we encounter them, we may have an operator to add to an expression
                    this._applyCurrentOperator()
                    break

                case CHAR_BACKSLASH:
                    this._applyCurrentOperator()

                    this._chainedBackslashes++

                    if (this._openString.singleQuote || this._openString.doubleQuote) {
                        if (this._lastChar === CHAR_BACKSLASH) {
                            if (this._chainedBackslashes % 2 === 0) {
                                this._currentSymbol += char
                            }
                        }
                    } else {
                        if (this._lastChar !== CHAR_BACKSLASH) {
                            this._currentSymbol += char
                        } else {
                            this._parseError(
                                'Unexpected character \\: outside strings, double backslashes are forbidden.'
                            )
                        }
                    }

                    break

                case CHAR_SINGLE_QUOTE:
                case CHAR_DOUBLE_QUOTE:
                    let stringClosed = false

                    if (char === CHAR_DOUBLE_QUOTE) {
                        if (this._openString.doubleQuote) {
                            if (this._lastChar !== CHAR_BACKSLASH) {
                                this._openString.doubleQuote = false
                            } else {
                                if (this._chainedBackslashes % 2 === 0) {
                                    this._openString.doubleQuote = false
                                } else {
                                    this._currentSymbol += char
                                }
                            }

                            stringClosed = !this._openString.doubleQuote
                        } else {
                            this._openString.doubleQuote = true
                        }
                    } else {
                        if (this._openString.singleQuote) {
                            if (this._lastChar !== CHAR_BACKSLASH) {
                                this._openString.singleQuote = false
                            } else {
                                if (this._chainedBackslashes % 2 === 0) {
                                    this._openString.singleQuote = false
                                } else {
                                    this._currentSymbol += char
                                }
                            }

                            stringClosed = !this._openString.singleQuote
                        } else {
                            this._openString.singleQuote = true
                        }
                    }

                    if (stringClosed) {
                        this._pushValueToStack(this._currentSymbol)
                        this._currentSymbol = ''
                    }
                    
                    break

                case CHAR_OPEN_CURLY_BRACKET:
                    if (this._openCurlyBracket === 0) {
                        this._addCurrentSymbolToStack()
                    }

                    this._currentSymbol += char
                    this._openCurlyBracket++
                    
                    break

                case CHAR_CLOSE_CURLY_BRACKET:
                    this._currentSymbol += char

                    if (this._openCurlyBracket === 0) {
                        this._parseError('Unexpected closing bracket !')
                    }

                    this._openCurlyBracket--

                    if (this._openCurlyBracket % 2 === 0) {
                        this._applyCurrentOperator()
                    }
                    
                    break

                default:
                    this._applyPostModifier()

                    if (this._currentOperator) {
                        if (this._operators.isAnOperatorCandidate(this._currentOperator + char)) {
                            this._currentOperator += char
                            break

                        } else if(this._operators.isAnOperatorCandidate(char)) {
                            this._addCurrentOperatorToExpression()
                            this._currentOperator = char
                            break
                        }
                    } else if(this._operators.isAnOperatorCandidate(char)) {
                        this._currentOperator = char
                        break
                    }

                    this._applyCurrentOperator()
                    this._currentSymbol += char

                    break
            }

            this._lastChar = char
        }

        this._applyCurrentOperator()

        if (this._currentSymbol) {
            this._addCurrentSymbolToStack()
            this._popStack()
        }

        while (this._callStack.length > 0) {
            this._popStack()
        }

        const finalResult = this._finalResult
        this._reset()

        return finalResult
    }

    /**
     * Parse and execute the formula, then return the result.
     * 
     * @param {string} formula - An arithmetic formula. For supported operators and functions, see the constructor.
     * @param {Object | undefined} record - A record. Required if any {{token}} can be found in the formula
     * @param {Array<string> | undefined} propertiesList - A list of record properties sorted in a way such as {{index}} will be resolved as a record property.
     * @returns {*} - The result
     */
    parse(formula, record, propertiesList = undefined) {
        try {
            return this._parse(formula, record, propertiesList)
        } catch(err) {
            this._reset()

            throw err
        }
    }

    /**
     * Completely resets the parser state
     */
    _reset() {
        this._callStack = []
        this._lastChar = ''
        this._currentChar = ''
        this._currentRecord = {}
        this._currentSymbol = ''
        this._currentPosition = ''
        this._currentOperator = ''
        this._openCurlyBracket = 0
        this._currentRecordPropertiesList = []
        this._chainedBackslashes = 0
        this._parenthesisStack = []
        this._openString = {
            singleQuote: false,
            doubleQuote: false
        }
        this._finalResult = undefined
    }
}

;/**
 * @typedef {'binary' | 'unary.preModifier' | 'unary.postModifier'} ParserOperatorType
 * @description
 * - **binary**: takes two operands as argument in this order: left, right
 * - **unary.preModifier**: modifies what comes before the operator (ex: 4! is factorial 4 -> 24)
 * - **unary.postModifier**: modifies what comes after the operator (ex: !true is negate true -> false)
 * @ignore
 */

/**
 * @typedef ParserOperatorDefinition
 * @property {number} precedence - The higher, the most priority the operator will get over the others.
 * @property {Function} operation - The function to execute when the operator is being used.
 * @property {ParserOperatorType} type - The type of operator.
 * @ignore
 */

/**
 * List of operators available to a parser. Can be enriched by modifying this file, or just with constructor arguments at runtime.
 * 
 * @ignore
 */
kiss.lib.formula.ParserOperators = class ParserOperators{
    // region Default operators

    /**
     * Symbols are used for the parser to be able to make the difference between an operator and its string representation.
     *
     * Ex: Without symbol, the expression "'test' + '+'" would throw an error instead of printing 'test+',
     * because the last '+' char would have been interpreted as an operator.
     */
    symbols = {
        unary: {
            preModifier: {
                '!': Symbol('!')
            },
            postModifier: {
                '~': Symbol('~'),
                '!': Symbol('!'),
                '-': Symbol('-')
            }
        },
        binary: {
            '+': Symbol('+'),
            '-': Symbol('-'),
            '/': Symbol('/'),
            '%': Symbol('%'),
            '*': Symbol('*'),
            '|': Symbol('|'),
            '&': Symbol('&'),
            '^': Symbol('^'),
            '&&': Symbol('&&'),
            '||': Symbol('||'),
            '<': Symbol('<'),
            '<=': Symbol('<='),
            '>': Symbol('>'),
            '>=': Symbol('>='),
            '??': Symbol('??'),
            '==': Symbol('=='),
            '!=': Symbol('!='),
            '!==': Symbol('!=='),
            '===': Symbol('===')
        }
    }

    unary = {
        preModifier: {
            // Factorial
            [this.symbols.unary.preModifier['!']]: (operand) => {
                let isPositive = operand >= 0

                operand = Math.abs(operand)

                let result = operand

                if (operand === 0 || operand === 1){
                    return 1
                }

                while (operand > 1) {
                    operand--;
                    result *= operand;
                }

                return isPositive ? result : -result;
            }
        },

        // Modify what follows (as opposed to preModifiers that would modify what was before.
        postModifier: {
            [this.symbols.unary.postModifier['~']]: (operand) => {
                return ~operand
            },
            [this.symbols.unary.postModifier['!']]: (operand) => {
                return !operand
            },
            [this.symbols.unary.postModifier['-']]: (operand) => {
                return -operand
            }
        },
    }

    binary = {
        [this.symbols.binary['+']]: (leftOperand, rightOperand) => {
            return leftOperand + rightOperand
        },
        [this.symbols.binary['-']]: (leftOperand, rightOperand) => {
            return leftOperand - rightOperand
        },
        [this.symbols.binary['/']]: (leftOperand, rightOperand) => {
            return leftOperand / rightOperand
        },
        [this.symbols.binary['%']]: (leftOperand, rightOperand) => {
            return leftOperand % rightOperand
        },
        [this.symbols.binary['*']]: (leftOperand, rightOperand) => {
            return leftOperand * rightOperand
        },
        [this.symbols.binary['|']]: (leftOperand, rightOperand) => {
            return leftOperand | rightOperand
        },
        [this.symbols.binary['&']]: (leftOperand, rightOperand) => {
            return leftOperand & rightOperand
        },
        [this.symbols.binary['^']]: (leftOperand, rightOperand) => {
            return leftOperand ^ rightOperand
        },
        [this.symbols.binary['&&']]: (leftOperand, rightOperand) => {
            return leftOperand && rightOperand
        },
        [this.symbols.binary['||']]: (leftOperand, rightOperand) => {
            return leftOperand || rightOperand
        },
        [this.symbols.binary['<']]: (leftOperand, rightOperand) => {
            return leftOperand < rightOperand
        },
        [this.symbols.binary['<=']]: (leftOperand, rightOperand) => {
            return leftOperand <= rightOperand
        },
        [this.symbols.binary['>']]: (leftOperand, rightOperand) => {
            return leftOperand > rightOperand
        },
        [this.symbols.binary['>=']]: (leftOperand, rightOperand) => {
            return leftOperand >= rightOperand
        },
        [this.symbols.binary['??']]: (leftOperand, rightOperand) => {
            return leftOperand ?? rightOperand
        },
        [this.symbols.binary['==']]: (leftOperand, rightOperand) => {
            return leftOperand == rightOperand
        },
        [this.symbols.binary['!=']]: (leftOperand, rightOperand) => {
            return leftOperand != rightOperand
        },
        [this.symbols.binary['===']]: (leftOperand, rightOperand) => {
            return leftOperand === rightOperand
        },
        [this.symbols.binary['!==']]: (leftOperand, rightOperand) => {
            return leftOperand !== rightOperand
        }
    }

    precedence = {
        // Todo: [this.symbols.binary['**']]: 160,
        [this.symbols.binary['*']]: 150,
        [this.symbols.binary['/']]: 150,
        [this.symbols.binary['%']]: 150,
        [this.symbols.binary['+']]: 140,
        [this.symbols.binary['-']]: 140,
        // Todo: [this.symbols.binary['<<']]: 130,
        // Todo: [this.symbols.binary['>>']]: 130,
        // Todo: [this.symbols.binary['>>>']]: 130,        
        [this.symbols.binary['<']]: 120,
        [this.symbols.binary['<=']]: 120,
        [this.symbols.binary['>']]: 120,
        [this.symbols.binary['>=']]: 120,
        [this.symbols.binary['==']]: 110,
        [this.symbols.binary['!=']]: 110,
        [this.symbols.binary['===']]: 110,
        [this.symbols.binary['!==']]: 110,
        [this.symbols.binary['&']]: 100,
        [this.symbols.binary['^']]: 90,
        [this.symbols.binary['|']]: 80,
        [this.symbols.binary['&&']]: 70,
        [this.symbols.binary['||']]: 60,
        [this.symbols.binary['??']]: 50
    }

    // precedence = {
    //     [this.symbols.binary['&&']]: 100, // Always applied in priority
    //     [this.symbols.binary['||']]: 50,
    //     [this.symbols.binary['/']]: 50,
    //     [this.symbols.binary['%']]: 50,
    //     [this.symbols.binary['*']]: 50,
    //     [this.symbols.binary['|']]: 20,
    //     [this.symbols.binary['+']]: 25,
    //     [this.symbols.binary['-']]: 25,
    //     [this.symbols.binary['&']]: 20,
    //     [this.symbols.binary['^']]: 20,

    //     // Comparison operators must have the lowest value
    //     [this.symbols.binary['<']]: 10,
    //     [this.symbols.binary['<=']]: 10,
    //     [this.symbols.binary['>']]: 10,
    //     [this.symbols.binary['>=']]: 10,
    //     [this.symbols.binary['??']]: 10,
    //     [this.symbols.binary['==']]: 10,
    //     [this.symbols.binary['!=']]: 10,
    //     [this.symbols.binary['===']]: 10,
    //     [this.symbols.binary['!==']]: 10,
    // }

    /**
     * Will contain a list of all available operators and all their composition.
     *
     * @ignore
     * @example
     * '===', '>=', '>', '&&', operatorCandidates will contain keys '=', '==', '===', '>', '>=', '&', '&&'
     */
    operatorCandidates = {}

    // endregion

    /**
     * @ignore
     * @param {Object} [opts = {}] - Operators options
     * @param {Object<string, ParserOperatorDefinition>} [opts.operators = {}] - List of operators to add. The key is the operator name.
     */
    constructor(
        {
            operators = {}
        } = {}
    ) {
        Object.entries(operators).forEach(
            /**
             * @ignore
             * @param {string} operatorName - The key is the operator name
             * @param {ParserOperatorDefinition} operatorDefinition - The operator definition
             */
            ([operatorName, operatorDefinition]) => {
                const {
                    precedence = 10,
                    type = 'binary',
                    operation
                } = operatorDefinition

                const errorHeader = `Operator "${operatorName}" definition error: `

                if (!operatorName) {
                    throw new TypeError(`${errorHeader}An empty string is not a valid operator name`)
                }

                if (!Number.isInteger(precedence)) {
                    throw new TypeError(
                        `${errorHeader}Invalid preference for operator "${operatorName}". Expecting integer, got ${typeof precedence}`
                    )
                }

                if (!(typeof operation !== 'function')) {
                    throw new TypeError(
                        `${errorHeader}Operation must be a function`
                    )
                }

                const operatorSymbol = Symbol(operatorName)

                switch(type) {
                    case 'binary':
                        this.symbols.binary[operatorName] = operatorSymbol
                        this.binary[operatorSymbol] = operation
                        this.precedence[operatorSymbol] = precedence
                        break
                    case 'unary.postModifier':
                        this.symbols.unary.postModifier[operatorName] = operatorSymbol
                        this.unary.postModifier[operatorSymbol] = operation
                        this.precedence[operatorSymbol] = precedence
                        break
                    case 'unary.preModifier':
                        this.symbols.unary.preModifier[operatorName] = operatorSymbol
                        this.unary.preModifier[operatorSymbol] = operation
                        this.precedence[operatorSymbol] = precedence
                        break
                    default: throw new TypeError(
                        `Unsupported operator type ${type}. Allowed: 'binary', 'unary.preModifier', 'unary.postModifier'`
                    )
                }
            }
        )

        const operatorKeys = new Set([
            ...Object.keys(this.symbols.unary.preModifier),
            ...Object.keys(this.symbols.unary.postModifier),
            ...Object.keys(this.symbols.binary)
        ])

        for (const operatorKey of operatorKeys) {
            this.operatorCandidates[operatorKey] = true

            const split = operatorKey.split('')

            let derived = ''
            while (split.length) {
                derived += split.shift()

                this.operatorCandidates[derived] = true
            }
        }
    }

    /**
     * Transform an infix expression into a postfix expression.
     *
     * @ignore
     * @param {number[]|Symbol[]} infix - An infix expression as an array of operators and numbers
     * @returns {(number[]|Symbol[])}
     */
    _infixToPostfix(infix){
        const output = [];
        const operators = [];

        for (let token of infix) {
            if (this.isAnOperator(token)) {
                while (
                    operators.length
                    && this.precedence[operators[operators.length - 1]] >= this.precedence[token]
                ) {
                    output.push(operators.pop())
                }

                operators.push(token)
            } else {
                output.push(token)
            }
        }

        while (operators.length) {
            output.push(operators.pop())
        }

        return output;
    }

    /**
     * An identity operator is modeling a computation priorisation by parenthesis. It only returns its argument.
     * The computation inside it have already been done at this stage.
     *
     * @ignore
     * @param res - The result to return.
     * @param rest - Used to detect a possible defect in the parser. This should never happen.
     * @returns {*} - The provided first parameter as is.
     */
    identity(res, ...rest) {
        if (rest.length > 0) {
            // This should never happen.
            throw new Error(
                'Formula execution error: an identity operator can`t accept more than one argument.'
            )
        }

        return res;
    }

    /**
     * Take an infix expression under the form of an array of operand and operators (note that
     * parenthesis must have already been resolved at this point).
     *
     * @ignore
     * @param {...(Symbol|number)} args
     * @returns {number}
     */
    expression(...args) {
        if (args.length === 1) {
            return args[0]
        }

        const postfix = this._infixToPostfix(args)
        const stack = []

        for (let token of postfix) {
            // Any operator from this point is a binary operator
            if (token in this.binary) {
                const b = stack.pop()
                const a = stack.pop()

                stack.push(this.binary[token](a, b))
            } else {
                stack.push(token)
            }
        }

        return stack[0]
    }

    /**
     * Return true if the given string is an operator
     *
     * @ignore
     * @param {Symbol} symbol - The symbol we're testing
     * @returns {boolean}
     */
    isAnOperator(symbol) {
        return symbol in this.unary.postModifier
            || symbol in this.unary.preModifier
            || symbol in this.binary
    }

    /**
     * Return true if the provided string is a potential operator. For multichars operators,
     * this method will return true even if the candidate is only a "partial" operator and
     * no complete operator is matching it.
     *
     * @ignore
     * @param {string} candidate - A string candidate for an operator
     * @returns {boolean}
     * 
     * @example
     * For operator "===", the following candidates will return true: "=", "==", "==="
     */
    isAnOperatorCandidate(candidate) {
        return candidate in this.operatorCandidates
    }

    /**
     * Return true if the given operator is a real operator. Only matches exact operators.
     *
     * @ignore
     * @param {string} operator - String representation of an operator
     * @returns {boolean} - True if this operator exists
     */
    isAnOperatorString(operator) {
        return operator in this.symbols.unary.postModifier
            || operator in this.symbols.unary.preModifier
            || operator in this.symbols.binary
    }

    /**
     * Parse an operator string representation into an operator symbol.
     *
     * @ignore
     * @param {ParserOperatorType} type - Operator type.
     * @param {string} candidate - The candidate to parse into an operator Symbol
     * @throws {TypeError} - If the candidate is not an operator candidate or if the operator type is not supported.
     * @returns {Symbol}
     */
    parseOperator(type, candidate) {
        if(!this.isAnOperatorCandidate(candidate)) {
            throw new TypeError(`${candidate} is not a valid operator!`)
        }

        switch(type) {
            case 'binary':
                return this.symbols.binary[candidate]
            case 'unary.preModifier':
                return this.symbols.unary.preModifier[candidate]
            case 'unary.postModifier':
                return this.symbols.unary.postModifier[candidate]
            default:
                throw new TypeError(
                    `Unsupported operator type ${
                        type
                    }. Allowed: 'binary', 'unary.preModifier', 'unary.postModifier`
                )
        }
    }
}

;/**
 * 
 * ## Namespace for misc global variables
 * 
 * @namespace
 * 
 */
kiss.addToModule("global", {

    // Authentication
    tokens: {},
    refreshTokens: {},

    // Ajax max retries
    // Prevents refreshToken loops for invalid tokens
    ajaxRetries: 0,
    ajaxMaxRetries: 3,

    // Models cache
    models: [],

    // Exiting view types
    viewTypes: [{
            name: "datatable",
            icon: "fas fa-table",
            description: "datatable view"
        }, {
            name: "calendar",
            icon: "far fa-calendar",
            description: "calendar view"
        },
        {
            name: "kanban",
            icon: "fab fa-trello",
            description: "kanban view"
        },
        {
            name: "timeline",
            icon: "fas fa-align-left",
            description: "timeline view"
        },
        {
            name: "chart",
            icon: "fas fa-chart-line",
            description: "chart view"
        },
        {
            name: "dashboard",
            icon: "fas fa-tachometer-alt",
            description: "dashboard view"
        }
        // {
        //     name: "gallery",
        //     icon: "fas fa-th",
        //     description: "gallery view"
        // }
    ],

    /**
     * Get the icon for a view type
     * 
     * @param {string} type 
     * @returns {string} icon
     */
    getViewIcon(type) {
        const view = this.viewTypes.find(v => v.name == type)
        if (view) return view.icon
        return "fas fa-table"
    },

    // Existing chart types
    chartTypes: [{
            name: "bar",
            icon: "fas fa-chart-bar",
        }, {
            name: "line",
            icon: "fas fa-chart-line",
        },
        {
            name: "pie",
            icon: "fas fa-chart-pie",
        },
        {
            name: "doughnut",
            icon: "fab fa-osi",
        },
        {
            name: "number",
            icon: "fas fa-hashtag",
        }
    ],

    /**
     * Get the icon for a chart type
     * 
     * @param {string} type 
     * @returns {string} icon
     */
    getChartIcon(type) {
        const chart = this.chartTypes.find(c => c.name == type)
        if (chart) return chart.icon
        return "fas fa-chart-line"
    },

    // Existing field types
    fieldTypes: [{
            value: "text",
            label: "text",
            icon: "fas fa-font",
            dataType: "text"
        },
        {
            value: "textarea",
            label: "paragraph",
            icon: "fas fa-comment-dots",
            dataType: "text"
        },
        {
            value: "richTextField",
            label: "rich text",
            icon: "fas fa-align-left",
            dataType: "text"
        },
        {
            value: "aiTextarea",
            label: "AI paragraph",
            icon: "far fa-lightbulb",
            dataType: "text"
        },
        {
            value: "number",
            label: "number",
            icon: "fas fa-hashtag",
            dataType: "number"
        },
        {
            value: "date",
            label: "date",
            icon: "fas fa-calendar",
            dataType: "date"
        },
        {
            value: "time",
            label: "time",
            icon: "fas fa-clock",
            dataType: "text"
        },
        {
            value: "select",
            label: "#select",
            icon: "fas fa-mouse-pointer",
            dataType: "text"
        },
        {
            value: "selectViewColumn",
            label: "#select view column",
            icon: "fas fa-th-list",
            dataType: "text"
        },
        {
            value: "selectViewColumns",
            label: "#select view columns",
            icon: "fas fa-table",
            dataType: "text"
        },
        {
            value: "checkbox",
            label: "checkbox",
            icon: "fas fa-check-square",
            dataType: "boolean"
        },
        {
            value: "attachment",
            label: "attachment",
            icon: "fas fa-paperclip"
        },
        {
            value: "aiImage",
            label: "AI image",
            icon: "fas fa-images"
        },
        {
            value: "directory",
            label: "collaborators",
            icon: "fas fa-users"
        },
        {
            value: "slider",
            label: "slider",
            icon: "fas fa-sliders-h"
        },
        {
            value: "rating",
            label: "rating",
            icon: "fas fa-star"
        },
        {
            value: "color",
            label: "color",
            icon: "fas fa-palette"
        },
        {
            value: "colorPicker",
            label: "color picker",
            icon: "fas fa-palette"
        },
        {
            value: "icon",
            label: "icon",
            icon: "far fa-heart"
        },
        {
            value: "iconPicker",
            label: "icon picker",
            icon: "far fa-heart"
        },
        {
            value: "password",
            label: "password",
            icon: "fas fa-key"
        },
        {
            value: "codeEditor",
            label: "code editor",
            icon: "fas fa-code"
        },
        {
            value: "mapField",
            label: "map field",
            icon: "fas fa-map"
        },
        // Fields for linked records (relationships)
        {
            value: "link",
            label: "link to another table",
            icon: "fas fa-link"
        },
        {
            value: "lookup",
            label: "lookup a value on linked records",
            icon: "fas fa-eye"
        },
        {
            value: "summary",
            label: "summarize data from linked records",
            icon: "fas fa-calculator"
        }
    ],

    // Existing element types
    elementTypes: [{
            value: "html",
            label: "HTML",
            icon: "fas fa-bars"
        },
        {
            value: "image",
            label: "image",
            icon: "fas fa-image"
        },
        {
            value: "button",
            label: "button",
            icon: "fas fa-mouse-pointer"
        }
    ],

    // Used to auto-increment component ids
    componentCount: 0,

    palette: [
        // Palette 1
        "00CCEE", "00AAEE", "0075FF", "0088CC", "004499", "007766", "008833", "00AA99", "55CC00", "88CC00", "FFD139", "FFAA00", "F77D05", "B22222", "CC0055", "ED3757", "EE00AA", "CC0088", "8833EE", "772288",
        // Palette 2
        "77DDEE", "77CCEE", "429AFF", "66AACC", "447799", "537772", "528866", "6FAAA4", "91CC66", "C3E673", "EACD64", "FFD480", "CCA266", "B25959", "CC6690", "FF8080", "EE77CC", "AD77EE", "7B68EE", "815F88",
        // Palette 3
        "BEDBE0", "B4DDED", "87BFFF", "A1BDCC", "6B8699", "6E8777", "899E91", "8AA8A4", "BACCAD", "D0D8BC", "E2D7A1", "CCBB99", "AFA495", "B28C8C", "FFFFFF", "BBBBBB", "999999", "777777", "555555", "000000"
    ]
})

;/**
 * 
 * #Prototypes extensions
 * (aka brute force monkey patching)
 * 
 * Careful with this: for some cases, I found it more convenient to extend the prototypes directly,
 * but it could break compatibility with other frameworks / libraries.
 * 
 */

/**
 * Check if a string contains HTML
 * 
 * @returns {boolean}
 */
String.prototype.containsHTML = function () {
    if (this.valueOf() === "<>") return false
    const regex = /<(?:.|\n)*?>/gm;
    return regex.test(this)
}

/**
 * Escape html chars to prevent display problems when inserting dynamic page content
 * 
 * @returns {string} Escaped string
 */
String.prototype.escapeHtml = function () {
    return this.replace(/&/g, "&#38;")
        .replace(/"/g, "&#34;")
        .replace(/'/g, "&#39;")
        .replace(/</g, "&#60;")
}

/**
 * Check is a string contains only safe caracters
 * 
 * @returns {boolean}
 */
String.prototype.isSafe = function () {
    return /^[^<>]*$/.test(this) || /[\w\d]|[^\>\<]/.test(this);
}

/**
 * Reduce every extra spaces to a single space character
 * 
 * @returns {string} The string without extra space
 */
String.prototype.removeExtraSpaces = function () {
    return this.replace(/\s+/g, ' ')
}

/**
 * Capitilize the first letter
 * 
 * @returns {string} The string
 * 
 * @example
 * "employee".toTitleCase() // "Employee"
 */
String.prototype.toTitleCase = function () {
    return this.charAt(0).toUpperCase() + this.substring(1)
}

/**
 * Check if the string can be converted to a number
 * 
 * @returns {boolean}
 */
String.prototype.isNumeric = function () {
    return !isNaN(parseFloat(this)) && isFinite(this)
}

/**
 * Return a hash code of the string
 * 
 * @returns {integer} 32bits signed integer
 * 
 * @example
 * "hello".hashCode() // 99162322
 * "seriously?".hashCode() // -188581074
 */
String.prototype.hashCode = function () {
    let hash = 0
    let chr
    if (this.length === 0) return hash

    for (let i = 0; i < this.length; i++) {
        chr = this.charCodeAt(i)
        hash = hash * 31 + chr
        hash |= 0 // Convert to 32bit integer
    }
    return hash
}

/**
 * Return the right part of a string, given a substring within the string
 * 
 * @param {string} substring 
 * @returns {string} The right part of the string
 */
String.prototype.rightString = function (substring) {
    let index = this.indexOf(substring)
    return index === -1 ? "" : this.slice(index + substring.length)
}

/**
 * Return the left part of a string, given a substring within the string
 * 
 * @param {string} substring 
 * @returns {string} The left part of the string
 */
String.prototype.leftString = function (substring) {
    let index = this.indexOf(substring)
    return index === -1 ? "" : this.slice(0, index)
}

/**
 * Return a Date in ISO format: YYYY-MM-DD
 * 
 * @returns {string} Date in ISO string format
 */
Date.prototype.toISO = function () {
    //return this.getFullYear().toString() + "-" + (this.getMonth() + 1).toString().padStart(2, 0) + "-" + this.getDate().toString().padStart(2, 0)
    return this.toISOString().split("T")[0]
}

/**
 * Return a Date/Time in ISO format: YYYY-MM-DD HH:MM:SS
 * 
 * @returns {string} Date and time in ISO string format
 */
Date.prototype.toISODateTime = function () {
    return this.toISO() + " " + this.toLocaleTimeString()
}

/**
 * Add N days to a date
 * 
 * @param {number} days 
 * @returns {date} The new date
 */
Date.prototype.addDays = function (days) {
    let date = new Date(this.valueOf())
    date.setDate(date.getDate() + days)
    return date
}

/**
 * Get time as hh:mm
 * 
 * @returns {string} Time as hh:mm
 */
Date.prototype.toTime = function () {
    let hours = this.getHours().toString().padStart(2, "0")
    let minutes = this.getMinutes().toString().padStart(2, "0")
    return `${hours}:${minutes}`
}

/**
 * Returns the week number for this date.
 * 
 * dowOffset is the day of week the week "starts" on for your locale - it can be from 0 to 6.
 * If dowOffset is 1 (Monday), the week returned is the ISO 8601 week number.
 * 
 * @param {number} [dowOffset] - Day of week the week "starts" on for your locale (default to 1 = Monday)
 * @return {number}
 */
Date.prototype.getWeek = function (dowOffset = 1) {
    let newYear = new Date(this.getFullYear(), 0, 1)
    let day = newYear.getDay() - dowOffset
    day = (day >= 0 ? day : day + 7)
    
    let dayNum = Math.floor((this.getTime() - newYear.getTime() - (this.getTimezoneOffset()-newYear.getTimezoneOffset())*60000)/86400000) + 1
    let weekNum

    // If the year starts before the middle of a week
    if(day < 4) {
        weekNum = Math.floor((dayNum+day-1)/7) + 1
        if(weekNum > 52) {
            nYear = new Date(this.getFullYear() + 1, 0, 1)
            nDay = nYear.getDay() - dowOffset
            nDay = nDay >= 0 ? nDay : nDay + 7

            // If the next year starts before the middle of the week, it is week #1 of that year
            weekNum = nDay < 4 ? 1 : 53
        }
    }
    else {
        weekNum = Math.floor((dayNum + day - 1) / 7)
    }
    return weekNum
}

/**
 * Returns a rounded number
 * 
 * @param {number} precision
 * @returns The rounded number
 * 
 * @example
 * const floatingNumber = 123.456789
 * console.log(floatingNumber.round(2)) // => 123.46
 */
Number.prototype.round = function (precision) {
    return +(Math.round(this + "e+" + precision) + "e-" + precision)
}

/**
 * Return a formatted file size
 * 
 * @returns {string} File size
 * 
 * @example
 * (63).toFileSize() // => 63 B
 * (1024).toFileSize() // => 1 kB
 * (1048576).toFileSize() // => 1 MB
 */
Number.prototype.toFileSize = function () {
    // MB
    let fileSizeMb = Math.round(this / 1024 / 1024)
    if (fileSizeMb > 0) return fileSizeMb + " MB"

    // kB
    let fileSizeKb = Math.round(this / 1024)
    if (fileSizeKb > 0) return fileSizeKb + " kB"

    // B
    return this + " B"
}

/**
 * Formats a number as a string with a fixed number of digits.
 * Use it for display purpose only (not for calculations)
 * 
 * @param {number} precision
 * @returns {string}
 * 
 * @example
 * const floatingNumber = 123.4
 * console.log(floatingNumber.format(3)) // => "123.400"
 */
Number.prototype.format = function (precision) {
    return this.toLocaleString(undefined, {
        minimumFractionDigits: precision,
        maximumFractionDigits: precision
    })
}

/**
 * Formats a number as a string with a fixed number of characters, leading zeros.
 * Use it for display purpose only (not for calculations)
 * 
 * @param {number} width
 * @returns {string}
 * 
 * @example
 * const myNumber = 9
 * console.log(myNumber.pad(4)) // => "0009"
 */
Number.prototype.pad = function (width) {
    if (typeof width !== "number") return this
    return String(this).padStart(width, "0")
}

/**
 * Swap 2 elements of an array
 * 
 * @param {number} idx1 
 * @param {number} idx2 
 * @returns {array} The array with swapped items
 * 
 * @example
 * const myArray = [1, 2, 3, 4]
 * myArray.swap(1, 2) // => [1, 3, 2, 4]
 */
Array.prototype.swap = function (idx1, idx2) {
    const tmp = this[idx1]
    this[idx1] = this[idx2]
    this[idx2] = tmp
    return this
}

/**
 * Array.unique
 * 
 * Remove all the duplicate elements.
 * Note it only works for primitives types: undefined, null, boolean, string and number
 * 
 * @returns {array} The array without duplicates
 */
Array.prototype.unique = function () {
    // Most elegant solution which unfortunately only works with primitive types:
    //return [...new Set[this]]

    // Brute force implementation
    let arr = []
    for (let i = 0; i < this.length; i++) {
        if (!arr.includes(this[i])) arr.push(this[i])
    }
    return arr
}

/**
 * Array.uniqueObjectId
 * 
 * In an array of objects, remove all the objects with a duplicate id.
 * 
 * @returns {object[]} The array without duplicates
 */
Array.prototype.uniqueObjectId = function () {
    const ids = this.map(o => o.id)
    return this.filter(({
        id
    }, index) => !ids.includes(id, index + 1))
}

/**
 * Array.uniqueObject
 * 
 * In an array of objects, remove all the objects with a duplicate property.
 * 
 * @param {string} propertyName - Name of the property used as reference to check if the object is a duplicate entry
 * @returns {object[]} The array without duplicates
 */
Array.prototype.uniqueObject = function (propertyName) {
    return this.filter((item, index, self) =>
        index === self.findIndex((element) => (
            element[propertyName] === item[propertyName]
        ))
    )
}

/**
 * Return the intersection of 2 arrays
 * 
 * @param {Array} otherArray 
 * @returns {Array} The items in common with the 2 arrays
 */
Array.prototype.intersect = function (otherArray) {
    return this.filter(item => otherArray.includes(item))
}

/**
 * Array.remove
 * 
 * Remove a specific item
 * @returns {array} The new array
 */
Array.prototype.remove = function (item) {
    let index = this.indexOf(item)
    if (index != -1) this.splice(index, 1)
    return this
}

/**
 * Array.get
 * 
 * In an array of objects that have an id, return the object with the resquested id
 * 
 * @param {string} itemId - Id of the item to retrieve
 * @returns {*} - The found object, or undefined if not found
 */
Array.prototype.get = function (itemId) {
    return this.find(item => item.id === itemId)
}

/**
 * Array.sortBy
 * 
 * In an array of objects, return the array sorted by property name
 * 
 * @param {string} propertyName - Id of the item to retrieve
 * @returns {object[]} - The sorted array
 */
Array.prototype.sortBy = function (propertyName) {
    return this.sort(function (a, b) {
        if (a[propertyName] <= b[propertyName]) return -1
        return 1
    })
}

/**
 * Array.sortAlpha
 * 
 * In an array of strings, return the array sorted alphabetically
 * 
 * @returns {string[]} - The sorted array of strings
 */
Array.prototype.sortAlpha = function () {
    return this.sort((a, b) => a.localeCompare(b))
}

/**
 * Array.removeById
 * 
 * In an array of objects that have ids, remove the object with the resquested id
 * 
 * @param {string} itemId - Id of the item to remove
 * @returns this - The resulting array
 */
Array.prototype.removeById = function (itemId) {
    const index = this.findIndex(item => item.id == itemId)
    if (index > -1) this.splice(index, 1)
    return this
}

/**
 * Array.includesObject
 * 
 * - Check if an array of objects contains a specific object
 * - Does a shallow comparison (not deep)
 * 
 * @param {object} object - The object to search inside the array of objects
 */
Array.prototype.includesObject = function (object) {
    return (JSON.stringify(this).indexOf(JSON.stringify(object)) != -1)
}

/**
 * Event.stop
 * 
 * Shorthand to stop both the propagation of an event, and also prevent its default behavior
 */
Event.prototype.stop = function () {
    this.stopPropagation()
    this.preventDefault()
}

/**
 * Element.deepDelete
 * 
 * - delete an Element and all its children
 * - unsubscribe the elements from the PubSub event bus
 * - remove (unobserve) the container elements from the resizeObserver
 * 
 * This prevents memory leaks from detached DOM nodes which are still referenced in the PubSub.
 * 
 * @param {boolean} deleteRoot - Delete or preserve the root node (default to true). If preserved, it only deletes the children
 * 
 * @example:
 * node.deepDelete(): delete the node and its children
 * node.deepDelete(false): only delete the node's children
 */
if (kiss.isClient) {
    Element.prototype.deepDelete = function (deleteRoot) {
        while (this.firstElementChild) this.lastElementChild.deepDelete()

        if (deleteRoot !== false) {
            // Unsubscribe from PubSub
            if ((this.subscriptions) && (this.subscriptions.length != 0)) this.subscriptions.forEach(subscriptionId => kiss.pubsub.unsubscribe(subscriptionId))

            // Unobserve resize events if it's a container
            if (this.isContainer) kiss.screen.getResizeObserver().unobserve(this)

            // Remove masks if any
            if (this.mask) this.mask.deepDelete()

            // Trigger the _beforeDelete method of the component
            if (this._beforeDelete) this._beforeDelete()

            // Delete node
            if (this.parentNode) this.parentNode.removeChild(this)
        }
    }
}

;/**
 * 
 * ## Simple tools shared between client and server
 * 
 */
kiss.addToModule("tools", {
    /**
     * Short ID generator
     * 
     * Use carefully: because of the use of Math.random, the collision risk is high compared to uid().
     * It should be used only on small set of independant objects (for example: field names in a form)
     * 
     * @ignore
     * @param {integer} [size] - Desired size for the uid. Default to 8.
     * @returns {string}
     */
    shortUid(size = 8) {
        size--
        const alphabet = "aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ0123456789"
        let id = alphabet[(Math.random() * 52) | 0] // Can't start with a number
        while (size--) id += alphabet[(Math.random() * 62) | 0]
        return id
    },

    /**
     * Shorter non-RFC4122 GUID generator
     * 
     * @ignore
     * @param {number} t - Id length. Defaults to 21 to have a collision risk similar to uid()
     * @returns {string}
     */
    nanoId(t = 21) {
        return crypto.getRandomValues(new Uint8Array(t)).reduce(((t, e) => t += (e &= 63) < 36 ? e.toString(36) : e < 62 ? (e - 26).toString(36).toUpperCase() : e < 63 ? "_" : "-"), "")
    },

    /**
     * Check if a string matches RFC4122 format
     * 
     * @ignore
     * @param {string} str
     * @returns {boolean}
     */
    isUid(str) {
        const RFC4122 = /\b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b/;
        if (str.match(RFC4122)) return true
        return false
    },

    /**
     * Check if a model is a pre-defined static model or a custom model generated from the free api.
     * Custom models have their name starting with "plugin" or following the RFC4122 id format.
     * 
     * @ignore
     * @param {string} modelId 
     * @returns {bollean}
     */
    isCustomModel(modelId) {
        if (kiss.tools.isUid(modelId)) return true
        return false
    },

    /**
     * Check if a model has "Audit trail" feature enabled.
     * 
     * @ignore
     * @param {string} modelId 
     * @returns {boolean}
     */
    hasAuditTrail(modelId) {
        const model = kiss.app.models[modelId]
        
        if (!model.features) return false
        if (!model.features["form-feature-audit"]) return false
        if (model.features["form-feature-audit"].active == true) return true
        return false
    },

    /**
     * Check if a model's field is numeric.
     * A field is numeric if:
     * - its type is numeric
     * - it's a lookup or summary field that points to a numeric field
     * 
     * @ignore
     * @param {object} field - Model's field
     * @returns {boolean}
     */
    isNumericField(field) {
        const fieldType = field.type
        return  ["number", "rating", "slider"].includes(fieldType)
        || (fieldType == "lookup" && ["number", "rating", "slider"].includes(field.lookup.type))
        || (fieldType == "summary" && ["number", "rating", "slider"].includes(field.summary.type))
    },

    /**
     * Check if a variable is a number
     * 
     * @ignore
     * @param {number} n 
     * @returns {boolean} true if the variable is a number
     */
    isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n)
    },

    /**
     * Check if a text is an ISO date, like "2014-12-20T21:17:50.309000Z"
     * 
     * @ignore
     * @param {string} text
     * @param {boolean} [dateOnly] - If true, check only the date part
     * @returns {boolean} true if the text is an ISO date
     */
    isISODate(text, dateOnly = false) {
        const isoRegex = (dateOnly) ? /^\d{4}-\d{2}-\d{2}$/ : /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/;
        return isoRegex.test(text)
    },

    /**
     * Check if 2 arrays intersect
     * 
     * @ignore
     * @param {array} array1 
     * @param {array} array2 
     * @returns {boolean}
     */
    intersects(array1, array2) {
        const intersection = kiss.tools.intersection(array1, array2)
        return (intersection.length > 0)
    },

    /**
     * Returns the intersection of 2 arrays
     * 
     * @ignore
     * @param {array} array1 
     * @param {array} array2 
     * @returns {array}
     */
    intersection(array1, array2) {
        if (!array1 || !array2) return []
        return array1.filter(item => array2.includes(item))
    },

    /**
     * Calculate the number of days between 2 dates
     * 
     * @ignore
     * @param {date} dateA
     * @param {date} dateB
     */
    daysBetweenDates(dateA, dateB) {
        const timeDifference = Math.abs(dateA.getTime() - dateB.getTime())
        return Math.floor(timeDifference / (3600 * 24 * 1000))
    },

    /**
     * Parse a text and find all the tags within double curly brackets
     * 
     * @ignore
     * @param {string} sourceText - The text to parse
     * @returns {string[]} - Array of tags found in the source text
     * 
     * @example
     * kiss.tools.findTags(" {{A}} * 2 + {{B}} * 3 + {{C}} * 4 ") // ["A", "B", "C"]
     */
    findTags(sourceText) {
        let regex = new RegExp("{{(.*?)}}", "g")
        let text, tags = []
        while (text = regex.exec(sourceText)) tags.push(text[0].substring(2, text[0].length - 2))
        return tags.unique()
    },

    /**
     * Get the current time
     * 
     * @ignore
     * @param {boolean} displaySseconds - true to display the seconds
     * @returns {string} ISO time
     * 
     * @example
     * kiss.tools.getTime() // 15:28
     * kiss.tools.getTime(true) // 15:28:33
     */
    getTime(displaySseconds) {
        const now = new Date()
        const hours = now.getHours().pad(2)
        const minutes = now.getMinutes().pad(2)
        const seconds = now.getSeconds().pad(2)
        return hours + ":" + minutes + ((displaySseconds) ? ":" + seconds : "")
    },

    /**
     * Wrap the setTimout function into a Promise
     * 
     * @ignore
     * @param {integer} [ms] - The number of milliseconds to wait before resolving
     * @returns {function} The promise to execute a function after a given delay
     * 
     * @example
     * kiss.tools.wait(2 * 1000).then(() => console.log("Hello!"))
     */
    wait(ms = 500) {
        return new Promise(resolve => setTimeout(resolve, ms))
    },

    /**
     * Throttle a function so that it can't be executed too many times per second
     * 
     * @ignore
     * @param {number} delay - In milliseconds
     * @param {function} fn - The function to throttle
     * @returns The throttled function
     */
    throttle(delay, fn) {
        let lastCall = 0
        return function (...args) {
            const now = (new Date).getTime()
            if (now - lastCall < delay) return
            lastCall = now
            return fn(...args)
        }
    },

    /**
     * Memoization helper to cache the result of expensive functions that are called multiple times
     * 
     * Return the value if it exists in the cache
     * otherwise, compute the input with the passed in function,
     * update the collection object with the input as the key,
     * and compute result as the value to that key
     * End result will be key-value pairs stored inside cache
     * 
     * @ignore
     * @param (function) func - Function to memoize
     * @returns {*} The result of the passed function, whatever it is
     * 
     * @example
     * kiss.tools.memoize((a) => 2 * a)
     */
    memoize(func) {
        const cache = {}
        return (input) => {
            log("MEMOIZED:" + input)
            if (cache[input]) log("!MEMOIZED: sent cached result!")
            return cache[input] || (cache[input] = func(input))
        }
    },

    /**
     * Compute the distance in km between 2 geolocation points using Haversine formula
     * 
     * @ignore
     * @param {number} lat1 
     * @param {number} lon1 
     * @param {number} lat2 
     * @param {number} lon2 
     * @returns {number} Distance in km
     */
    distanceInKm(lat1, lon1, lat2, lon2) {
        const earthRadius = 6371
        const dLat = kiss.tools.degToRad(lat2 - lat1)
        const dLon = kiss.tools.degToRad(lon2 - lon1)

        const a =
            Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(kiss.tools.degToRad(lat1)) * Math.cos(kiss.tools.degToRad(lat2)) *
            Math.sin(dLon / 2) * Math.sin(dLon / 2)

        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
        const distance = earthRadius * c
        return distance
    },

    /**
     * Convert degrees to radians
     * 
     * @ignore
     * @param {number} degrees 
     * @returns {number} radians
     */
    degToRad(degrees) {
        return degrees * Math.PI / 180
    },

    /**
     * Check if 2 geolocation points are in a given range of kilometers
     * 
     * @ignore
     * @param {object} geolocationA - Example {latitude: X, longitude: Y}
     * @param {object} geolocationB 
     * @param {number} rangeInKm
     * @returns {boolean} true if the 2 geolocations are in the given range of kilometers
     */
    isInRange(geolocationA, geolocationB, rangeInKm) {
        const distance = kiss.tools.distanceInKm(geolocationA.latitude, geolocationA.longitude, geolocationB.latitude, geolocationB.longitude)
        return distance <= rangeInKm
    },

    /**
     * Valie a field value against validation rules
     * 
     * @ignore
     * @param {object} config 
     * @param {*} value 
     * @returns {boolean}
     */
    validateValue(dataType, config, value) {
        // Skip validation if field is readOnly
        if (config.readOnly) return true

        // Required
        if (config.required && (value == "" || value == undefined)) return false
        if (dataType == "rating" && config.required && value === 0) return false

        // Don't try to validate empty fields if they are not required
        if (value == "") return true

        switch (dataType) {
            case "text":
            case "textarea":
            case "aiTextarea":
            case "password":
                return kiss.tools.validateText(config, value)

            case "number":
                return kiss.tools.validateNumber(config, value)
        }

        // All validation rules passed
        return true
    },

    /**
     * Validate a number field value against validation rules
     * 
     * @ignore
     * @param {object} config
     * @param {number} [config.min]
     * @param {number} [config.max]
     * @param {number} [config.precision]
     * @param {*} value 
     * @returns {boolean}
     */
    validateNumber(config, value) {
        value = Number(value)
        if (
            (
                config.hasOwnProperty("min") &&
                (config.min !== undefined) &&
                (config.min !== 0) &&
                (value < config.min)
            ) ||
            (
                config.hasOwnProperty("max") &&
                (config.max !== undefined) &&
                (config.max !== 0) &&
                (value > config.max)
            )
        ) {
            return false
        }

        if (config.precision == 0 && !Number.isInteger(value)) {
            return false
        }

        return true
    },

    /**
     * Valite a text field value against validation rules
     * 
     * @ignore
     * @param {object} config 
     * @param {number} [config.minLength]
     * @param {number} [config.maxLength]
     * @param {string} [config.validationType] - alpha|alphanumeric|email|url|ip|regex
     * @param {string} [config.validationRegex] - if validation type = "regex"
     * @param {*} value
     * @returns {boolean}
     */
    validateText(config, value) {
        // Text length
        if (kiss.tools.validateTextLength(config, value) == false) return false

        // Regex
        switch (config.validationType) {
            case "alpha":
                if (!value.match(kiss.tools.regex.alpha)) return false
                break
            case "alphanumeric":
                if (!value.match(kiss.tools.regex.alphanumeric)) return false
                break
            case "email":
                if (!value.match(kiss.tools.regex.email)) return false
                break
            case "url":
                if (!value.match(kiss.tools.regex.url)) return false
                break
            case "ip":
                if (!value.match(kiss.tools.regex.ip)) return false
                break
            case "regex":
                if (!config.validationRegex) return true
                
                // console.log("The field has to pass the regex: " + config.validationRegex)
                const regex = kiss.tools.createRegexFromString(config.validationRegex)
                if (!value.match(regex)) return false
        }

        // Excludes HTML
        if (value.containsHTML()) return false

        // All validation rules passed
        return true
    },

    /**
     * Converts a string to a regex object.
     * 
     * Manage the case where the regex is defined with the /regex/flags syntax
     * 
     * @param {string} input 
     * @returns {RegExp} The regex object
     */
    createRegexFromString(input) {
        let regexBody
        let regexFlags
        const regexDelimiterPattern = /^\/(.+)\/([gimsuy]*)$/;
        
        if (regexDelimiterPattern.test(input)) {
            const parts = input.match(regexDelimiterPattern)

            // Body
            regexBody = parts[1]

            // Flags (ex : 'g', 'i', etc.)
            regexFlags = parts[2]

        } else {
            regexBody = input
            regexFlags = ""
        }
        
        return new RegExp(regexBody, regexFlags)
    },

    /**
     * Convert HTML to plain text
     * 
     * @param {string} html 
     * @returns {string} The plain text
     */
    convertHtmlToPlainText(html) {
        html = html.replace(/<br\s*\/?>/gi, '\n')
        html = html.replace(/<\/p>/gi, '\n')
        
        var tempDiv = document.createElement("div")
        tempDiv.innerHTML = html
        return tempDiv.textContent || tempDiv.innerText || ""
    },

    /**
     * Valite text field length against validation rules
     * 
     * @ignore
     * @param {object} config 
     * @param {number} [config.minLength]
     * @param {number} [config.maxLength]
     * @param {*} value
     * @returns {boolean}
     */
    validateTextLength(config, value) {
        if (
            (
                config.hasOwnProperty("minLength") &&
                (value.length < config.minLength)
            ) ||
            (
                config.hasOwnProperty("maxLength") &&
                (config.maxLength > 0) &&
                (value.length > config.maxLength)
            )
        ) {
            return false
        }

        return true
    },

    /**
     * Define regex for common fields validation
     * 
     * @ignore
     */
    regex: {
        alpha: new RegExp(`^[a-zA-Z_]+$`),
        alphanumeric: new RegExp(`^[a-zA-Z0-9]([a-zA-Z0-9_])+$`),
        email: new RegExp(`^\\s*([\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,})(\\s*,\\s*[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,})*\\s*$`),
        url: new RegExp(`^(http(s?):\\/)?\\/(.)+$`),
        ip: new RegExp(`^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$`)
    },

    /**
     * Generates a slug from a plain title
     * 
     * @ignore
     * @param {string} text 
     * @returns {string} The generated slug
     * 
     * @example
     * kiss.tools.generateSlug("My article about dogs") // Returns "my-article-about-dogs"
     */
    generateSlug(text) {
        return text.toString().toLowerCase()
            .normalize("NFD")
            .replace(/[\u0300-\u036f]/g, "")
            .replace(/\s+/g, "-")
            .replace(/[^a-z0-9\-]/g, "")
            .replace(/\-\-+/g, "-")
            .replace(/^-+/, "")
            .replace(/-+$/, "");
    },

    /**
     * Generates an SEO friendly breadcrumb from a list of links
     * 
     * @ignore
     * @param {object[]} items - Each breadcrumb item should be a object like: {label: "Home", url: "https://domain/home"}
     */
    generateBreadcrumb(items) {
        let breadcrumb = '<nav aria-label="breadcrumb"><div itemscope="itemscope" itemtype="http://schema.org/BreadcrumbList" class="breadcrumb"><div class="container">'
        for (let i = 0; i < items.length; i++) {
            let item = items[i]
            let li = `<span itemprop="itemListElement" itemscope="itemscope" itemtype="http://schema.org/ListItem" class="breadcrumb-item${i === items.length - 1 ? ' active' : ''}">`
            if (item.url) {
                li += `<a href="${item.url}" itemprop="item"><span itemprop="name">${item.label}</span> <meta itemprop="position" content="${i + 1}"></a>`
            } else {
                li += `<span itemprop="name">${item.label}</span> <meta itemprop="position" content="${i + 1}">`
            }
            li += '</span>'
            breadcrumb += li
        }
        breadcrumb += '</div></div></nav>'
    }
})


;kiss.app.defineModel({
    id: "account",
    name: "Account",
    namePlural: "Accounts",
    icon: "fas fa-home",
    color: "#00aaee",

    items: [{
            primary: true,
            id: "owner",
            dataType: String
        },
        {
            isACL: true,
            id: "managers",
            dataType: Array
        },
        {
            id: "planId",
            dataType: String
        },
        {
            id: "planUsers",
            dataType: String
        },
        {
            id: "planApps",
            dataType: String
        },
        {
            id: "stripeCustomerId",
            dataType: String
        },
        {
            id: "stripeSubscriptionId",
            dataType: String
        },
        {
            id: "periodStart",
            dataType: String
        },
        {
            id: "periodEnd",
            dataType: String
        },
        {
            id: "status",
            dataType: String
        },
        {
            id: "createdAt",
            dataType: String
        },
        {
            id: "collaborators",
            dataType: Array
        },
        {
            id: "invited",
            dataType: Array
        },
        {
            id: "smtp",
            dataType: Object
        }
    ],

    acl: {
        permissions: {
            create: [{
                isCreator: true
            }],
            update: [{
                isSupportTeam: true
            }],
            delete: [{
                isDeleter: true
            }]
        },

        validators: {
            async isCreator() {
                return false
            },
            
            async isSupportTeam({req}) {
                const userId = (kiss.isServer) ? req.token.userId : kiss.session.getUserId()
                if (userId.split("@")[1] === "pickaform.com") return true
                return false
            },

            async isDeleter() {
                return false
            }
        }
    }
})

;/**
 * An "API client" record stores informations about clients which can connect to the API
 */
kiss.app.defineModel({
    id: "apiClient",
    name: "API client",
    namePlural: "API clients",
    icon: "fas fa-plug",
    color: "#ffaa00",

    items: [{
            id: "accountId",
            dataType: String
        },
        {
            id: "name",
            label: "#name",
            dataType: String
        },
        {
            id: "token",
            label: "token",
            readOnly: true,
            dataType: String
        },
        {
            id: "expiration",
            label: "expiration",
            readOnly: true,
            dataType: Date
        }
    ],

    acl: {
        permissions: {
            create: [{
                    isOwner: true
                },
                {
                    isManager: true
                }
            ],
            read: [{
                    isOwner: true
                },
                {
                    isManager: true
                }
            ],
            update: [{
                    isOwner: true
                },
                {
                    isManager: true
                }
            ],
            delete: [{
                    isOwner: true
                },
                {
                    isManager: true
                }
            ]
        },

        validators: {
            async isOwner({
                req
            }) {
                return (kiss.isServer) ? req.token.isOwner : kiss.session.isAccountOwner()
            },

            async isManager({
                req
            }) {
                return (kiss.isServer) ? req.token.isManager : kiss.session.isAccountManager()
            }
        }
    }
})

;/**
 * A "file" record stores informations about file attachments
 */
kiss.app.defineModel({
    id: "file",
    splitBy: "account",
    
    name: "File",
    namePlural: "Files",
    icon: "fas fa-file",
    color: "#00aaee",

    items: [
        {
            id: "accountId",
            dataType: String
        },
        {
            id: "userId",
            dataType: String
        },
        {
            id: "type", // local, amazon_s3
            dataType: String
        },
        {
            id: "path",
            dataType: String
        },
        {
            id: "downloadPath",
            dataType: String
        },
        {
            id: "name",
            dataType: String
        },
        {
            id: "size",
            dataType: Boolean
        },
        {
            id: "fieldname",
            dataType: String
        },
        {
            id: "originalname",
            dataType: String
        },
        {
            id: "encoding",
            dataType: String
        },
        {
            id: "mimeType",
            dataType: String
        },
	    {
			id: 'accessReaders',
		    dataType: Array
	    },
        {
            id: "destination",
            dataType: String
        }
    ]    
})

;kiss.app.defineModel({
    id: "group",
    name: "Group",
    namePlural: "Groups",
    icon: "fas fa-users",
    color: "#00aaee",

    items: [{
            id: "name",
            dataType: String
        },
        {
            id: "description",
            dataType: String
        },
        {
            id: "icon",
            dataType: String
        },
        {
            id: "color",
            dataType: String
        },
        {
            id: "users",
            dataType: [String],
            isACL: true
        }
    ],

    acl: {
        permissions: {
            create: [{
                    isOwner: true
                },
                {
                    isManager: true
                }
            ],
            update: [{
                    isOwner: true
                },
                {
                    isManager: true
                }
            ],
            delete: [{
                    isOwner: true
                },
                {
                    isManager: true
                }
            ]
        },

        validators: {
            async isOwner({
                req
            }) {
                return (kiss.isServer) ? req.token.isOwner : kiss.session.isAccountOwner()
            },

            async isManager({
                req
            }) {
                return (kiss.isServer) ? req.token.isManager : kiss.session.isAccountManager()
            }
        }
    }
})

;/**
 * A "link" record connects 2 records X and Y together, and they are structured like:
 * {
 *      mX: ..., // m: model id of record X
 *      rX: ..., // r: record id of record X
 *      fX: ..., // f: field id for record X
 *      mY: ...,
 *      rY: ...,
 *      fY: ...
 * }
 */
kiss.app.defineModel({
    id: "link",
    splitBy: "account",

    name: "Link",
    namePlural: "Links",
    icon: "fas fa-link",
    color: "#00aaee",

    items: [
        {
            id: "mX",
            dataType: String
        },
        {
            id: "rX",
            dataType: String
        },
        {
            id: "fX",
            dataType: String
        },
        {
            id: "mY",
            dataType: String
        },
        {
            id: "rY",
            dataType: String
        },
        {
            id: "fY",
            dataType: String
        },
        {
            id: "auto",
            dataType: Boolean
        }
    ],

    acl: {
        permissions: {
            create: [
                {isCreator: true}
            ],
            update: [
                {isUpdater: true}
            ],
            delete: [
                {isDeleter: true}
            ]
        },

        /**
         * Note: creating or deleting a link is like performing an update on the linked record.
         * So, to allow the creation or deletion of a link, we check if the user is allowed to update the linked record.
         * We only check the record which is on the left side (mX / rX) of the link, because we assume the rights should be symetrical.
         */
        validators: {
            async isCreator({req, record}) {
                if (kiss.isServer) {
                    if (Array.isArray(req.body)) {
                        // insertMany links
                        req.path_0 = req.body[0].mX
                        req.path_1 = req.body[0].rX
                    }
                    else {
                        // insertOne link
                        req.path_0 = req.body.mX
                        req.path_1 = req.body.rX
                    }
                    return await kiss.acl.check({action: "update", req})
                }
                else {
                    const modelId = record.mX
                    const recordId = record.rX
                    const linkedRecord = await kiss.app.collections[modelId].findOne(recordId)
                    return await kiss.acl.check({action: "update", record: linkedRecord})
                }
            },

            async isUpdater() {
                // A link can't be modified
                return false
            },

            async isDeleter({req, record}) {
                if (kiss.isServer) {
                    req.path_0 = record.mX
                    req.path_1 = record.rX
                    return await kiss.acl.check({action: "update", req})
                }
                else {
                    const modelId = record.mX
                    const recordId = record.rX
                    const linkedRecord = await kiss.app.collections[modelId].findOne(recordId)
                    return await kiss.acl.check({action: "update", record: linkedRecord})
                }
            }
        }
    }
})

;kiss.app.defineModel({
    id: "trash",
    splitBy: "account",
    
    name: "Trash",
    namePlural: "Trashes",
    icon: "fas fa-trash",
    color: "#8833ee",

    items: [
        {
            id: "sourceModelId",
            label: "model",
            dataType: String
        },
        {
            id: "name",
            label: "name",
            dataType: String
        },
        {
            id: "icon",
            label: "icon",
            type: "icon",
            dataType: String
        },
        {
            id: "color",
            label: "color",
            type: "color",
            dataType: String
        },
        {
            id: "deletedAt",
            label: "#deletedAt",
            type: "data",
            dataType: Date
        },
        {
            id: "deletedBy",
            label: "#deletedBy",
            type: "directory",
            dataType: [String]
        }        
    ],

    acl: {
        permissions: {
            update: [
                {isUpdater: true},
            ],
            delete: [
                {isOwner: true},
                {isManager: true},
                {isRestorer: true}
            ]
        },

        validators: {
            async isOwner({
                req
            }) {
                return (kiss.isServer) ? req.token.isOwner : kiss.session.isAccountOwner()
            },

            async isManager({
                req
            }) {
                return (kiss.isServer) ? req.token.isManager : kiss.session.isAccountManager()
            },            

            // A deleted record can't be modified
            async isUpdater() {
                return false
            },

            // Anyone who deleted a record can restore it
            async isRestorer({req, record}) {
                const userId = (kiss.isClient) ? kiss.session.getUserId() : req.token.userId
                return record.deletedBy == userId
            }
        }
    }    
})

;kiss.app.defineModel({
    id: "user",
    name: "User",
    namePlural: "Users",
    icon: "fas fa-user",
    color: "#00aaee",

    items: [{
            id: "accountId",
            dataType: String
        },
        {
            id: "email",
            primary: true,
            dataType: String
        },
        {
            id: "firstName",
            dataType: String
        },
        {
            id: "lastName",
            dataType: String
        },
        {
            id: "name", // firstName + " " + lastName
            dataType: String
        },
        {
            id: "active",
            dataType: Boolean
        },
        {
            id: "loginType", // google, facebook...
            dataType: String
        },
        {
            id: "socialId", // internal id for social auth
            dataType: String
        },
        {
            id: "sessionToken", // token for external auth
            dataType: String
        },
        {
            id: "password",
            dataType: String
        },
        {
            id: "language",
            dataType: String
        },
        {
            id: "isCollaboratorOf",
            dataType: Array
        },
        {
            id: "invitedBy",
            dataType: Array
        },
        {
            id: "currentAccountId",
            dataType: String
        }
    ],

    acl: {
        permissions: {
            create: [{
                    isOwner: true,
                    quotaNotExceeded: true
                },
                {
                    isManager: true,
                    quotaNotExceeded: true
                }
            ],
            update: [{
                    isOwner: true
                },
                {
                    isManager: true
                },
                {
                    isConnectedUser: true
                }
            ],
            delete: [{
                    isOwner: true
                },
                {
                    isManager: true
                }
            ]
        },

        validators: {
            async isOwner({
                req
            }) {
                return (kiss.isServer) ? req.token.isOwner : kiss.session.isAccountOwner()
            },

            async isManager({
                req
            }) {
                return (kiss.isServer) ? req.token.isManager : kiss.session.isAccountManager()
            },

            async quotaNotExceeded() {
                if (kiss.isClient) {
                    const currentNumberOfUsers = kiss.app.collections.user.records.length
                    const allowedNumberOfUsers = Number(kiss.session.account.planUsers)
                    if (currentNumberOfUsers >= allowedNumberOfUsers) return false
                    return true
                }
            },

            async isConnectedUser({
                req,
                record
            }) {
                const userId = (kiss.isServer) ? req.token.userId : kiss.session.getUserId()
                if (userId == record.email) return true
                return false
            }
        }
    }
})

;kiss.app.defineModel({
    id: "view",
    name: "View",
    namePlural: "Views",
    icon: "fas fa-table",
    color: "#ed3757",

    items: [
        {
            id: "createdAt",
            label: "#createdAt",
            type: "date",
            dataType: Date,
            acl: {
                update: false
            }
        },
        {
            primary: true,
            id: "name",
            label: "#name",
            type: "text",
            dataType: String
        },
        {
            id: "description",
            dataType: String
        },
        {
            id: "applicationIds",
            dataType: [String]
        },
        {
            id: "modelId",
            label: "#form",
            dataType: String,
            acl: {
                update: false
            }
        },
        {
            id: "fieldId",
            dataType: String,
            acl: {
                update: false
            }
        },        
        {
            id: "type",
            dataType: String
        },
        {
            id: "filter",
            dataType: Object,
            value: {}
        },
        {
            id: "sort",
            dataType: [Object],
            value: []
        },
        {
            id: "projection",
            dataType: Object,
            value: {}
        },
        {
            id: "group",
            dataType: [String]
        },
        {
            id: "config",
            dataType: Object
        },
        {
            id: "authenticatedCanRead",
            label: "#authenticatedCanRead",
            type: "checkbox",
            shape: "switch",
            iconColorOn: "#20c933",
            dataType: Boolean
        },
        {
            id: "accessRead",
            label: "#accessRead",
            type: "directory",
            multiple: true,
            dataType: [String],
            isACL: true
        },
        {
            id: "ownerCanUpdate",
            label: "#ownerCanUpdate",
            type: "checkbox",
            shape: "switch",
            iconColorOn: "#20c933",
            dataType: Boolean
        },      
        {
            id: "accessUpdate",
            label: "#accessUpdate",
            type: "directory",
            multiple: true,
            dataType: [String],
            isACL: true
        },
        {
            id: "canCreateRecord",
            label: "#show create button",
            type: "checkbox",
            shape: "switch",
            iconColorOn: "#20c933",
            dataType: Boolean
        }
    ],

    acl: {
        permissions: {
            create: [
                { isOwner: true },
                { isManager: true },
                { isModelDesigner: true },
                { isPrivateView: true }
            ],
            read: [
                { isViewOwner: true },
                { authenticatedCanRead: true },
                { isViewReader: true },
            ],
            update: [
                { isOwner: true },
                { isManager: true },
                { isViewOwner: true },
                { isViewDesigner: true },
                { isModelDesigner: true }
            ],
            delete: [
                { isOwner: true },
                { isManager: true },
                { isViewOwner: true },
                { isViewDesigner: true },
                { isModelDesigner: true }
            ]
        },
    
        validators: {
            /**
             * ACL validator that checks if the active user is the account owner
             */
             async isOwner({
                req
            }) {
                return (kiss.isServer) ? req.token.isOwner : kiss.session.isAccountOwner()
            },

            /**
             * ACL validator that checks if the active user is an account manager
             */
            async isManager({
                req
            }) {
                return (kiss.isServer) ? req.token.isManager : kiss.session.isAccountManager()
            },            

            /**
             * Check if it's a private view that's being created
             */
            async isPrivateView({req, record}) {
                const userId = (kiss.isServer) ? req.token.userId : kiss.session.getUserId()
                if (record.accessUpdate.includes(userId)) return true
                return false
            },

            /**
             * ACL validator that checks if the active user is the view owner
             */
            async isViewOwner({req, record}) {
                const userId = (kiss.isServer) ? req.token.userId : kiss.session.getUserId()
                if (record.createdBy == userId) return true
                return false
            },

            /**
             * ACL validator that checks if the active user can update the view
             */
            async isViewDesigner({userACL, record}) {
                // Only the owner can update
                if (record.ownerCanUpdate == true) return false
    
                // Access is not defined
                if (record.accessUpdate == undefined) return false
    
                // Other people can update
                if (kiss.tools.intersects(userACL, record.accessUpdate)) return true
    
                return false
            },            

            /**
             * Check if the active user can manage the view's model
             */
            async isModelDesigner({userACL, req, record}) {
                let model
                const modelId = record.modelId

                if (kiss.isServer) {
                    model = await kiss.db.findOne("model", {_id: modelId})
                }
                else {
                    model = await kiss.app.collections.model.findOne(modelId)
                }
                if (!model) return false

                // Only the owner can manage the model
                if (model.ownerCanManage == true) return false

                // Access is not defined
                if (model.accessManage == undefined) return false

                // Other people can manage the model
                if (kiss.tools.intersects(userACL, model.accessManage)) return true

                return false
            },

            /**
             * ACL validator that checks if all authenticated users can read the record
             */
            async authenticatedCanRead({record}) {
                return !!record.authenticatedCanRead
            },
    
            /**
             * ACL validator that checks if the active user can read the view
             */
            async isViewReader({userACL, record}) {
                if (record.accessRead && kiss.tools.intersects(userACL, record.accessRead)) return true
            }            
        }
    },    

    methods: {

        /**
         * Get the collection of records associated to this view
         */
        getCollection() {
            let collection = kiss.app.collections[this.id]
            if (!collection) {
                collection = new kiss.data.Collection({
                    id: this.id,
                    model: kiss.app.models[this.modelId],
                    sort: this.sort,
                    filter: this.filter,
                    group: this.group,
                    projection: this.projection
                })
            }
            return collection
        },

        /**
         * Synchronize the view parameters with the model fields:
         * - clean up filters
         * - clean up sorts
         * - clean up groups
         * - add/update/remove datatable columns
         */
        async syncWithModelFields() {
            const model = kiss.app.models[this.modelId]

            // Filter out the fields used in the filters, sorts, and groups, if they are not anymore in the model
            if (this.filter) this.filter = this._sanitizeFilters(this.filter)
            
            if (this.sort) this.sort = this.sort.filter(sortOption => {
                const field = model.getField(Object.keys(sortOption)[0])
                if (!field) return false
                if (field.deleted) return false
                return true
            })

            if (this.group) this.group = this.group.filter(groupFieldId => {
                const field = model.getField(groupFieldId)
                if (!field) return false
                if (field.deleted) return false
                return true
            })

            // Update <datatable> views
            if (this.type == "datatable") {

                // For each model's field, update the corresponding column
                model.getFields().forEach(field => {
                    let column = this.config.columns.get(field.id)
                    
                    if (column) {
                        // The column exists: we udpate it
                        column.type = model.getFieldType(field)
                        column.title = field.label
                        if (column.title.startsWith("#")) column.title = txtTitleCase(column.title)
                        column.title = column.title.toTitleCase()
                        column.deleted = !!field.deleted
                    }
                    else {
                        // The column doesn't exist: we add it
                        if (field.label && field.type && !field.deleted) {
                            this.config.columns.push({
                                id: field.id,
                                type: model.getFieldType(field),
                                title: field.label.toTitleCase(),
                                hidden: (field.type == "link") ? true : false
                            })
                        }
                    }
                })

                await this.update({
                    config: this.config
                }, true)
            }

            // Update <calendar> views
            if (this.type == "calendar") {}

            // Update <kanban> views
            if (this.type == "kanban") {}

            // Update <gallery> views
            if (this.type == "gallery") {}
        },

        /**
         * Remove all the view filters which use a field that doesn't exist anymore in the model
         * 
         * @param {object} filter
         * @returns {object} The fixed filter
         */
        _sanitizeFilters(filter) {
            if (!filter) return
            
            if (filter.type == "filter") {
                const model = kiss.app.models[this.modelId]
                let filterField = model.getField(filter.fieldId)
                if (filterField && filterField.deleted != true) return filter
                return null
            } else if (filter.type == "group") {
                let newFilters = []
                filter.filters.forEach(filterConfig => {
                    let cleanedFilter = this._sanitizeFilters(filterConfig)
                    if (cleanedFilter) newFilters.push(cleanedFilter)
                })
                filter.filters = newFilters
                return filter
            }
        },

        /**
         * Rename the view
         * 
         * - display a dialog to enter the name
         * - prevent from updating if the name is empty
         */
        async rename() {
            let model = kiss.app.models[this.modelId]

            createDialog({
                type: "input",
                title: txtTitleCase("rename this view"),
                icon: model.icon,
                headerBackgroundColor: model.color,
                width: 600,
                message: txtUpperCase("enter the view name"),
                defaultValue: this.name,
                buttonOKText: txtTitleCase("validate the new name"),
                autoClose: false,

                action: async (viewName) => {
                    if (viewName == "") {
                        createNotification(txtTitleCase("a view must have a name"))
                        return false
                    }

                    await this.update({
                        name: viewName
                    })
                    return true
                }
            })
        },

        /**
         * Duplicate the view
         * 
         * @param {boolean} isPrivate - Duplicate the view as private. Default is false
         */
        async duplicate(isPrivate = false) {
            let model = kiss.app.models[this.modelId]

            createDialog({
                type: "input",
                title: txtTitleCase("duplicate this view"),
                icon: "fas fa-copy",
                headerBackgroundColor: model.color,
                width: 600,
                message: txtUpperCase("enter the view name"),
                buttonOKText: txtTitleCase("create the new view"),
                autoClose: false,
    
                action: async (viewName) => {
                    if (viewName == "") {
                        createNotification(txtTitleCase("a view must have a name"))
                        return false
                    }

                    const newView = kiss.app.models.view.create(this)
                    newView.id = uid()
                    newView.name = (viewName) ? viewName : newView.name + " " + txt("(copy)")

                    // View access
                    newView.authenticatedCanRead = (isPrivate) ? false : true
                    newView.accessRead = (isPrivate) ? [kiss.session.getUserId()] : []
                    newView.ownerCanUpdate = (isPrivate) ? false : true
                    newView.accessUpdate = (isPrivate) ? [kiss.session.getUserId()] : []

                    await newView.save()
        
                    kiss.router.navigateTo({
                        viewId: newView.id
                    })
                    return true
                }
            })
        },

        /**
         * Delete the view
         */
        async remove() {
            // Check if it's the last view for this model in the application
            let application = await kiss.app.collections.application.findOne(kiss.context.applicationId)
            let model = kiss.app.models[this.modelId]

            // Get the application and view
            let message =
                `<center>
                ${txtTitleCase("#delete view message")}
                <br><br>
                <b>${model.namePlural.toTitleCase()} / ${this.name.toTitleCase()}</b>
                </center>`

            createDialog({
                type: "danger",
                title: txtTitleCase("delete the view"),
                message: message,
                width: 600,
                buttonOKText: txtTitleCase("delete the view"),
                buttonOKPosition: "left",
                closable: false,
                autoClose: false,

                action: async () => {
                    await this.delete()

                    // The view doesn't exist anymore: we open the 1st view instead
                    let firstView = await application.getFirstView(this.modelId)
                    if (!firstView) return true

                    kiss.router.navigateTo({
                        viewId: firstView.id,
                        viewType: firstView.type
                    })

                    // Store the last opened view for this model
                    kiss.app.models[this.modelId].lastOpenedView = {
                        type: firstView.type,
                        id: firstView.id
                    }

                    return true
                }
            })
        }
    }
})

;